----End fileIn of C:\Users\pcomi\Downloads\ISW1-2021-1C-2doParcial.st----!

Object subclass: #PartidaDETruco
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial'!

!classDefinition: #PartidaDETruco category: 'ISW1-2021-1C-2doParcial' stamp: 'pc 7/5/2021 17:19:41'!
Object subclass: #PartidaDETruco
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial'!

!classRenamed: #PartidaDETruco as: #PartidaDeTruco stamp: 'pc 7/5/2021 17:19:51'!
Smalltalk renameClassNamed: #PartidaDETruco as: #PartidaDeTruco!

!classRenamed: #PartidaDeTruco as: #PartidaDeTrucoTest stamp: 'pc 7/5/2021 17:21:43'!
Smalltalk renameClassNamed: #PartidaDeTruco as: #PartidaDeTrucoTest!

!classRenamed: #PartidaDeTrucoTest as: #RondaDeTrucoTest stamp: 'pc 7/5/2021 17:22:51'!
Smalltalk renameClassNamed: #PartidaDeTrucoTest as: #RondaDeTrucoTest!

!classDefinition: #RondaDeTruco category: 'ISW1-2021-1C-2doParcial' stamp: 'pc 7/5/2021 17:43:02'!
Object subclass: #RondaDeTruco
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial'!
!RondaDeTrucoTest methodsFor: 'no messages' stamp: 'pc 7/5/2021 17:43:32'!
test01
	|rondaDeTruco cartasJugadorA cartasJugadorB jugadorA jugadorB |
	
	cartasJugadorA := OrderedCollection new.
	cartasJugadorA add: (CartaDeTruco anchoDeEspada ) .
	cartasJugadorA add: (CartaDeTruco oroCon: 2).
	cartasJugadorA add: (CartaDeTruco copaCon: 3).
	cartasJugadorB := OrderedCollection new.
	cartasJugadorB add: (CartaDeTruco anchoDeBasto ) .
	cartasJugadorB add: (CartaDeTruco oroCon: 3).
	cartasJugadorB add: (CartaDeTruco copaCon: 4).
	rondaDeTruco := RondaDeTruco entreJugador: jugadorA con: cartasJugadorA vs: jugadorB con: cartasJugadorB

	! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 17:44:52' prior: 0!
test01
	| rondaDeTruco temp2 temp3 temp4 temp5 |
	temp2 _ OrderedCollection new.
	temp2 add: CartaDeTruco anchoDeEspada.
	temp2 add: (CartaDeTruco oroCon: 2).
	temp2 add: (CartaDeTruco copaCon: 3).
	temp3 _ OrderedCollection new.
	temp3 add: CartaDeTruco anchoDeBasto.
	temp3 add: (CartaDeTruco oroCon: 3).
	temp3 add: (CartaDeTruco copaCon: 4).
	rondaDeTruco _ RondaDeTruco
		entreJugador: temp4
		con: temp2
		vs: temp5
		con: temp3.! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 17:45:13' prior: 0!
test01
	| rondaDeTruco temp2 temp3 temp4 temp5 |
	temp2 _ OrderedCollection new.
	temp2 add: CartaDeTruco anchoDeEspada.
	temp2 add: (CartaDeTruco oroCon: 2).
	temp2 add: (CartaDeTruco copaCon: 3).
	temp3 _ OrderedCollection new.
	temp3 add: CartaDeTruco anchoDeBasto.
	temp3 add: (CartaDeTruco oroCon: 3).
	temp3 add: (CartaDeTruco copaCon: 4).
	rondaDeTruco _ RondaDeTruco
		entreJugador: temp4
		con: temp2
		vs: temp5
		con: temp3.! !

----STARTUP---- (5 July 2021 17:46:21) as C:\Users\pcomi\Documents\programs\cuis\CuisUniversity-4532.image!


!classDefinition: #CashierTest category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'pc 7/5/2021 17:46:33'!
TestCase subclass: #CashierTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #CashierTest category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'pc 7/5/2021 17:46:33'!
TestCase subclass: #CashierTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!
!CashierTest methodsFor: 'receiving from empty trailer' stamp: 'F 5/21/2020 21:50:00'!
test01ShouldNotAcceptEmptyTrailerFromNormalWorkingRobot

	| aRobot aTrailer aCashier |
	
	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot with: aTrailer.
	
	aCashier := Cashier new.

	self
		should: [ 
			aCashier receiveOrder: aRobot 
		]
		raise: Error
		withMessageText: Cashier trailerIsEmptyErrorDescription.
! !
!CashierTest methodsFor: 'receiving from empty trailer' stamp: 'F 5/21/2020 21:50:32'!
test02ShouldNotAcceptEmptyTrailerFromMechanicalFailureRobot

	| aRobot aTrailer aCashier |
	
	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot with: aTrailer.
	
	aCashier := Cashier new.

	self
		should: [ 
			aRobot withMechanicalFailure.
			aCashier receiveOrder: aRobot 
		]
		raise: Error
		withMessageText: Cashier trailerIsEmptyErrorDescription.
! !
!CashierTest methodsFor: 'receiving from sensors failure robot' stamp: 'F 5/20/2020 23:18:54'!
test03ShouldNotAcceptSensorsFailureRobot

	| aRobot aTrailer aCashier |
	
	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot with: aTrailer.
	
	aCashier := Cashier new.

	self
		should: [ 
			aRobot withSensorsFailure.
			aCashier receiveOrder: aRobot ]
		raise: Error
		withMessageText: Cashier robotSensorsFailureErrorDescription.
! !
!CashierTest methodsFor: 'receiving from mechanical failure robot' stamp: 'F 5/20/2020 23:47:15'!
test04ShouldChangeRobotStatusToOutOfOrderWhenMechanicalFailureRobot

	| aRobot aTrailer aCashier |
	
	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot with: aTrailer.
	
	aCashier := Cashier new.

	self
		should: [ 
			aRobot take: (ProductA with: 1  and: 1).
			aRobot withMechanicalFailure.
			
			aCashier receiveOrder: aRobot.
			
			aRobot take: (ProductA with: 1 and: 1) ]
		raise: Error
		withMessageText: Robot outOfOrderErrorDescription.

! !

!classDefinition: #ProductTest category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'pc 7/5/2021 17:46:33'!
TestCase subclass: #ProductTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #ProductTest category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'pc 7/5/2021 17:46:33'!
TestCase subclass: #ProductTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!
!ProductTest methodsFor: 'instance creation' stamp: 'FRT 5/4/2020 19:37:46'!
test01CanNotCreateProductWithCeroOrLessWeight

	self
		should: [ Product with: 0  and: 100 ]
		raise: Error
		withMessageText: Product invalidWeightErrorDescription 
! !
!ProductTest methodsFor: 'instance creation' stamp: 'FRT 5/4/2020 19:37:51'!
test02CanNotCreateProductWithCeroOrLessHeight

	self
		should: [ Product with: 100  and: 0 ]
		raise: Error
		withMessageText: Product invalidHeightErrorDescription 
! !
!ProductTest methodsFor: 'instance creation' stamp: 'FRT 5/4/2020 17:54:48'!
test03CanNotCreateProductWithNoIntegerWeight

	self
		should: [ Product with: 1.5  and: 100 ]
		raise: Error
		withMessageText: Product weightMustBeIntegerErrorDescription 

! !
!ProductTest methodsFor: 'instance creation' stamp: 'FRT 5/4/2020 17:55:14'!
test04CanNotCreateProductWithNoIntegerHeight

	self
		should: [ Product with: 100  and: 1.5 ]
		raise: Error
		withMessageText: Product heightMustBeIntegerErrorDescription 

! !

!classDefinition: #RobotTest category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'pc 7/5/2021 17:46:33'!
TestCase subclass: #RobotTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #RobotTest category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'pc 7/5/2021 17:46:33'!
TestCase subclass: #RobotTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!
!RobotTest methodsFor: 'instance creation' stamp: 'FRT 5/4/2020 11:29:44'!
test01ShouldReceiveAnEmptyTrailer

	| aTrailer |

	aTrailer := Trailer with: 20 and: 100.
	aTrailer carry: (ProductA with: 1  and: 1).
	
	self
		should: [ Robot with: aTrailer ]
		raise: Error
		withMessageText: Robot notEmptyTrailerErrorDescription! !
!RobotTest methodsFor: 'taking products' stamp: 'FRT 5/4/2020 11:04:57'!
test02ShouldTakeProductsWhenWorkingNormal

	| aTrailer aRobot |

	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot with: aTrailer.
	
	aRobot take: (ProductA with: 1  and: 1).
	
	self assert: 1 equals: aTrailer totalProductsAmount! !
!RobotTest methodsFor: 'taking products' stamp: 'FRT 5/4/2020 11:07:49'!
test03ShouldTakeProductsWhenWorkingWithSensorsFailures

	| aTrailer aRobot |

	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot with: aTrailer.
	aRobot withSensorsFailure.
	
	aRobot take: (ProductA with: 1  and: 1).
	
	self assert: 1 equals: aTrailer totalProductsAmount! !
!RobotTest methodsFor: 'taking products' stamp: 'FRT 5/4/2020 11:08:34'!
test04ShouldTakeProductsWhenWorkingWithMechanicalFailures

	| aTrailer aRobot |

	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot with: aTrailer.
	aRobot withMechanicalFailure.
	
	aRobot take: (ProductA with: 1  and: 1).
	
	self assert: 1 equals: aTrailer totalProductsAmount! !
!RobotTest methodsFor: 'taking products' stamp: 'FRT 5/4/2020 18:26:53'!
test05ShouldNotTakeProductsWhenOutOfOrder

	| aTrailer aRobot |

	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot with: aTrailer.
	aRobot outOfOrder.
	
	self
		should: [ aRobot take: (ProductA with: 1  and: 1) ]
		raise: Error
		withMessageText: Robot outOfOrderErrorDescription.
	
	self assert: 0 equals: aTrailer totalProductsAmount! !
!RobotTest methodsFor: 'closing order' stamp: 'FRT 5/4/2020 12:46:40'!
test06CanCloseOrderWhenWorkingNormal

	| aTrailer aRobot |

	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot with: aTrailer.
	aRobot take: (ProductA with: 1  and: 1).
	
	self assert: (aRobot closeOrderUsing: Cashier new)! !
!RobotTest methodsFor: 'closing order' stamp: 'FRT 5/4/2020 11:28:16'!
test07CanNotCloseOrderWhenWorkingWithSensorsFailures

	| aTrailer aRobot |

	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot with: aTrailer.
	aRobot take: (ProductA with: 1  and: 1).
	
	aRobot withSensorsFailure.

	self
		should: [ aRobot closeOrderUsing: Cashier new ]
		raise: Error
		withMessageText: Cashier robotSensorsFailureErrorDescription.
 
! !
!RobotTest methodsFor: 'closing order' stamp: 'FRT 5/4/2020 12:47:10'!
test08CanCloseOrderWhenWorkingWithMechanicalFailures

	| aTrailer aRobot |

	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot with: aTrailer.
	aRobot take: (ProductA with: 1  and: 1).

	aRobot withMechanicalFailure.	
		
	self assert: (aRobot closeOrderUsing: Cashier new).! !
!RobotTest methodsFor: 'closing order' stamp: 'FRT 5/4/2020 18:48:41'!
test09CanNotCloseOrderWhenOutOfOrder

	| aTrailer aRobot |

	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot with: aTrailer.
	aRobot take: (ProductA with: 1  and: 1).
	
	aRobot outOfOrder.

	self
		should: [ aRobot closeOrderUsing: Cashier new ]
		raise: Error
		withMessageText: Robot outOfOrderErrorDescription.
 
! !

!classDefinition: #TrailerTest category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'pc 7/5/2021 17:46:34'!
TestCase subclass: #TrailerTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #TrailerTest category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'pc 7/5/2021 17:46:34'!
TestCase subclass: #TrailerTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!
!TrailerTest methodsFor: 'weight capacity' stamp: 'FRT 5/4/2020 17:29:39'!
test01CanNotCreateTrailerWithCeroOrLessMaxWeight

	self
		should: [ Trailer with: 0  and: 100 ]
		raise: Error
		withMessageText: Trailer invalidWeightCapacityErrorDescription 
! !
!TrailerTest methodsFor: 'weight capacity' stamp: 'FRT 5/4/2020 17:30:47'!
test02CanNotCreateTrailerWithCeroOrLessMaxHeight

	self
		should: [ Trailer with: 1  and: 0 ]
		raise: Error
		withMessageText: Trailer invalidHeightCapacityErrorDescription 
! !
!TrailerTest methodsFor: 'weight capacity' stamp: 'FRT 5/4/2020 17:41:04'!
test03CanNotCreateTrailerWithNoIntegerMaxWeight

	self
		should: [ Trailer with: 1.5  and: 100 ]
		raise: Error
		withMessageText: Trailer weightCapacityMustBeIntegerErrorDescription 
! !
!TrailerTest methodsFor: 'weight capacity' stamp: 'FRT 5/4/2020 17:41:29'!
test04CanNotCreateTrailerWithNoIntegerMaxHeight

	self
		should: [ Trailer with: 100  and: 1.5 ]
		raise: Error
		withMessageText: Trailer heightCapacityMustBeIntegerErrorDescription 
! !
!TrailerTest methodsFor: 'weight capacity' stamp: 'FRT 5/4/2020 17:43:36'!
test05ShouldRejectProductAIfWeightExceeded

	| aTrailer |
	aTrailer := Trailer with: 20  and: 100.
	
	self
		should: [ aTrailer carry: (ProductA with: 21 and: 1) ]
		raise: Error
		withMessageText: Trailer maxWeightExceededErrorDescription.
		
	self assert: aTrailer isEmpty.! !
!TrailerTest methodsFor: 'weight capacity' stamp: 'FRT 5/4/2020 17:43:28'!
test06ShouldRejectProductBIfWeightExceeded

	| aTrailer |
	aTrailer := Trailer with: 20  and: 100.
	
	self
		should: [ aTrailer carry: (ProductB with: 21 and: 1) ]
		raise: Error
		withMessageText: Trailer maxWeightExceededErrorDescription.
		
	self assert: aTrailer isEmpty.! !
!TrailerTest methodsFor: 'weight capacity' stamp: 'FRT 5/5/2020 11:27:50'!
test07ShouldAcceptProductsIfWeightUnderMaxWeightCapacity

	| aTrailer |
	aTrailer := Trailer with: 11  and: 100.
	
	aTrailer carry: (ProductA with: 1 and: 1).
	aTrailer carry: (ProductA with: 2 and: 1).
	aTrailer carry: (ProductB with: 3 and: 1).
	aTrailer carry: (ProductB with: 4 and: 1).
		
	self assert: aTrailer totalProductsAmount equals: 4.
	self assert: aTrailer totalProductsWeight equals: 10.! !
!TrailerTest methodsFor: 'weight capacity' stamp: 'FRT 5/5/2020 11:27:57'!
test08ShouldAcceptProductsIfWeightEqualsMaxWeightCapacity

	| aTrailer |
	aTrailer := Trailer with: 11  and: 100.
	
	aTrailer carry: (ProductA with: 1 and: 1).
	aTrailer carry: (ProductA with: 2 and: 1).
	aTrailer carry: (ProductB with: 3 and: 1).
	aTrailer carry: (ProductB with: 4 and: 1).
	aTrailer carry: (ProductB with: 1 and: 1).
	
	self assert: aTrailer totalProductsAmount equals: 5.
	self assert: aTrailer totalProductsWeight equals: 11.! !
!TrailerTest methodsFor: 'height capacity' stamp: 'FRT 5/5/2020 11:28:03'!
test09ShouldAcceptProductAIgnoringMaxTotalHeightOfBProducts

	| aTrailer heightCapacity exceededHeightCapacity halfExceededHeightCapacity |

	heightCapacity := 100.
	aTrailer := Trailer with: 20  and: heightCapacity.
	
	exceededHeightCapacity := heightCapacity + 2.
	halfExceededHeightCapacity := exceededHeightCapacity / 2.
	
	aTrailer carry: (ProductA with: 10 and: halfExceededHeightCapacity).
	aTrailer carry: (ProductA with: 10 and: halfExceededHeightCapacity).
	
	self assert: aTrailer totalProductsAmount equals: 2.
	self assert: aTrailer totalProductsHeight equals: 0.
	! !
!TrailerTest methodsFor: 'height capacity' stamp: 'FRT 5/5/2020 11:28:07'!
test10ShouldIgnoreAProductsInMaxTotalHeightOfBProducts

	| aTrailer heightCapacity exceededHeightCapacity halfExceededHeightCapacity |

	heightCapacity := 100.
	aTrailer := Trailer with: 20  and: heightCapacity.
	
	exceededHeightCapacity := heightCapacity + 2.
	halfExceededHeightCapacity := exceededHeightCapacity / 2.
	
	aTrailer carry: (ProductA with: 10 and: halfExceededHeightCapacity).
	aTrailer carry: (ProductB with: 10 and: halfExceededHeightCapacity).
	
	self assert: aTrailer totalProductsAmount equals: 2.
	self assert: aTrailer totalProductsHeight equals: halfExceededHeightCapacity.
	! !
!TrailerTest methodsFor: 'height capacity' stamp: 'FRT 5/5/2020 11:28:16'!
test11ShouldRejectProductBExceedingMaxTotalHeightOfBProducts

	| aTrailer heightCapacity exceededHeightCapacity halfExceededHeightCapacity |

	heightCapacity := 100.
	aTrailer := Trailer with: 20  and: heightCapacity.
	
	exceededHeightCapacity := heightCapacity + 2.
	halfExceededHeightCapacity := exceededHeightCapacity / 2.
	
	aTrailer carry: (ProductB with: 10 and: halfExceededHeightCapacity).

	self 
		should: [aTrailer carry: (ProductB with: 10 and: halfExceededHeightCapacity)] 
		raise: Error
		withMessageText: Trailer maxHeightExceededErrorDescription.
	
	self assert: aTrailer totalProductsAmount equals: 1.
	self assert: aTrailer totalProductsHeight equals: halfExceededHeightCapacity.
	! !

!classDefinition: #Cashier category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'pc 7/5/2021 17:46:34'!
Object subclass: #Cashier
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #Cashier category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'pc 7/5/2021 17:46:34'!
Object subclass: #Cashier
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!
!Cashier methodsFor: 'closing buy order' stamp: 'F 5/20/2020 23:33:11'!
receiveOrder: aRobot
	
	aRobot status = #WorkingNormal ifTrue: [ | aTrailer | 
		aTrailer := aRobot trailer.	
		self assertTrailerNotEmpty: aTrailer.
		
		"Comentario: en este punto el cashier realizar�a el checkout de los productos."
		
		^ true
	].

	aRobot status = #SensorsFailure ifTrue: [ 	
		aRobot outOfOrder.
		self signalRobotSensorsFailure
	].
	
	aRobot status = #MechanicalFailure ifTrue: [ | aTrailer |
		aRobot outOfOrder.
		
		aTrailer := aRobot trailer.	
		self assertTrailerNotEmpty: aTrailer.
		
		"Comentario: en este punto el cashier realizar�a el checkout de los productos."

		^ true
	].
! !
!Cashier methodsFor: 'assertions' stamp: 'FRT 5/4/2020 11:17:52'!
assertTrailerNotEmpty: aTrailer
	
	aTrailer isEmpty ifTrue: [self signalTrailerIsEmpty]! !
!Cashier methodsFor: 'assertions' stamp: 'FRT 5/4/2020 11:28:31'!
signalTrailerIsEmpty
	
	self error: self class trailerIsEmptyErrorDescription! !
!Cashier methodsFor: 'exceptions' stamp: 'FRT 5/4/2020 11:28:03'!
signalRobotSensorsFailure
	
	self error: self class robotSensorsFailureErrorDescription! !

!classDefinition: 'Cashier class' category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'pc 7/5/2021 17:46:34'!
Cashier class
	instanceVariableNames: ''!

!classDefinition: 'Cashier class' category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'pc 7/5/2021 17:46:34'!
Cashier class
	instanceVariableNames: ''!
!Cashier class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 11:28:03'!
robotSensorsFailureErrorDescription
	
	^ 'This robot presents sensors failures!!'! !
!Cashier class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 11:28:31'!
trailerIsEmptyErrorDescription
	
	^ 'This robots trailer is empty!!'! !

!classDefinition: #Product category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'pc 7/5/2021 17:46:34'!
Object subclass: #Product
	instanceVariableNames: 'weight height'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #Product category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'pc 7/5/2021 17:46:34'!
Object subclass: #Product
	instanceVariableNames: 'weight height'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!
!Product methodsFor: 'instance creation' stamp: 'FRT 5/4/2020 10:39:55'!
initializeWith: aWeight and: aHeight
	
	weight := aWeight.
	height := aHeight.! !
!Product methodsFor: 'action' stamp: 'FRT 5/4/2020 10:38:22'!
carryBy: aTrailer	
	
	self subclassResponsibility! !
!Product methodsFor: 'testing' stamp: 'FRT 5/4/2020 10:39:06'!
isStackable
	
	self subclassResponsibility! !
!Product methodsFor: 'accessing' stamp: 'FRT 5/4/2020 10:43:30'!
height
	
	^ height! !
!Product methodsFor: 'accessing' stamp: 'FRT 5/4/2020 10:43:24'!
weight
	
	^ weight! !

!classDefinition: 'Product class' category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'pc 7/5/2021 17:46:34'!
Product class
	instanceVariableNames: ''!

!classDefinition: 'Product class' category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'pc 7/5/2021 17:46:34'!
Product class
	instanceVariableNames: ''!
!Product class methodsFor: 'instance creation' stamp: 'FRT 5/4/2020 17:47:40'!
with: aWeight and: aHeight
	
	aWeight strictlyPositive ifFalse: [ self signalInvalidWeight ].
	aHeight strictlyPositive ifFalse: [ self signalInvalidHeight ].

	aWeight isInteger ifFalse: [ self signalWeightMustBeInteger ].
	aHeight isInteger ifFalse: [ self signalHeightMustBeInteger ].
	
	^ self new initializeWith: aWeight and: aHeight! !
!Product class methodsFor: 'exceptions' stamp: 'FRT 5/4/2020 17:48:22'!
signalHeightMustBeInteger

	self error: self heightMustBeIntegerErrorDescription! !
!Product class methodsFor: 'exceptions' stamp: 'FRT 5/4/2020 11:29:08'!
signalInvalidHeight

	self error: self invalidHeightErrorDescription! !
!Product class methodsFor: 'exceptions' stamp: 'FRT 5/4/2020 11:29:18'!
signalInvalidWeight

	self error: self invalidWeightErrorDescription! !
!Product class methodsFor: 'exceptions' stamp: 'FRT 5/4/2020 17:48:12'!
signalWeightMustBeInteger

	self error: self weightMustBeIntegerErrorDescription! !
!Product class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 17:49:16'!
heightMustBeIntegerErrorDescription

	^ 'Height must be integer'! !
!Product class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 11:29:08'!
invalidHeightErrorDescription

	^ 'Height must be positive'! !
!Product class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 11:29:18'!
invalidWeightErrorDescription

	^ 'Weight must be positive'! !
!Product class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 17:49:08'!
weightMustBeIntegerErrorDescription

	^ 'Weight must be integer'! !

!classDefinition: #ProductA category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'pc 7/5/2021 17:46:35'!
Product subclass: #ProductA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #ProductA category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'pc 7/5/2021 17:46:35'!
Product subclass: #ProductA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!
!ProductA methodsFor: 'testing' stamp: 'FRT 5/4/2020 10:41:29' overrides: 50903758!
isStackable

	^ false! !
!ProductA methodsFor: 'action' stamp: 'FRT 5/4/2020 10:41:12' overrides: 50903754!
carryBy: aTrailer

	aTrailer carryProductA: self! !

!classDefinition: #ProductB category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'pc 7/5/2021 17:46:35'!
Product subclass: #ProductB
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #ProductB category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'pc 7/5/2021 17:46:35'!
Product subclass: #ProductB
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!
!ProductB methodsFor: 'testing' stamp: 'FRT 5/4/2020 10:42:28' overrides: 50903758!
isStackable

	^ true! !
!ProductB methodsFor: 'action' stamp: 'FRT 5/4/2020 10:42:16' overrides: 50903754!
carryBy: aTrailer

	aTrailer carryProductB: self! !

!classDefinition: #Robot category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'pc 7/5/2021 17:46:35'!
Object subclass: #Robot
	instanceVariableNames: 'status trailer'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #Robot category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'pc 7/5/2021 17:46:35'!
Object subclass: #Robot
	instanceVariableNames: 'status trailer'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!
!Robot methodsFor: 'actions' stamp: 'FRT 5/4/2020 18:41:25'!
closeOrderUsing: aCashier
	
	status = #WorkingNormal ifTrue: [ ^ aCashier receiveOrder: self ].
	status = #SensorsFailure ifTrue: [ ^ aCashier receiveOrder: self ].
	status = #MechanicalFailure ifTrue: [ ^ aCashier receiveOrder: self ].
	status = #OutOfOrder ifTrue: [ ^ self class signalOutOfOrder ].
! !
!Robot methodsFor: 'actions' stamp: 'FRT 5/4/2020 18:30:39'!
take: aProduct

	status = #WorkingNormal ifTrue: [ ^ trailer carry: aProduct ].
	status = #SensorsFailure ifTrue: [ ^ trailer carry: aProduct ].
	status = #MechanicalFailure ifTrue: [ ^ trailer carry: aProduct ].
	status = #OutOfOrder ifTrue: [ ^ self class signalOutOfOrder ].
! !
!Robot methodsFor: 'status' stamp: 'FRT 5/4/2020 18:29:54'!
outOfOrder

	status := #OutOfOrder
! !
!Robot methodsFor: 'status' stamp: 'FRT 5/4/2020 18:29:48'!
withMechanicalFailure

	status := #MechanicalFailure
! !
!Robot methodsFor: 'status' stamp: 'FRT 5/4/2020 18:29:39'!
withSensorsFailure

	status := #SensorsFailure
! !
!Robot methodsFor: 'accessing' stamp: 'FRT 5/4/2020 18:35:21'!
status

	^ status
! !
!Robot methodsFor: 'accessing' stamp: 'FRT 5/3/2020 21:27:04'!
trailer

	^ trailer
! !
!Robot methodsFor: 'initialization' stamp: 'FRT 5/4/2020 18:21:29'!
initializeWith: aTrailer

	trailer := aTrailer.
	status := #WorkingNormal.
! !

!classDefinition: 'Robot class' category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'pc 7/5/2021 17:46:36'!
Robot class
	instanceVariableNames: ''!

!classDefinition: 'Robot class' category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'pc 7/5/2021 17:46:36'!
Robot class
	instanceVariableNames: ''!
!Robot class methodsFor: 'instance creation' stamp: 'FRT 5/3/2020 22:36:52'!
with: aTrailer

	self assertIsEmpty: aTrailer.

	^ self new initializeWith: aTrailer! !
!Robot class methodsFor: 'assertions' stamp: 'FRT 5/3/2020 22:35:35'!
assertIsEmpty: aTrailer

	^ aTrailer isEmpty ifFalse: [ self signalNotEmptyTrailer ]! !
!Robot class methodsFor: 'assertions' stamp: 'FRT 5/4/2020 11:29:32'!
signalNotEmptyTrailer

	self error: self notEmptyTrailerErrorDescription! !
!Robot class methodsFor: 'assertions' stamp: 'FRT 5/4/2020 18:26:04'!
signalOutOfOrder
	
	self error: self outOfOrderErrorDescription! !
!Robot class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 11:29:32'!
notEmptyTrailerErrorDescription

	^ 'The robot was assigned a non empty trailer'! !
!Robot class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 18:26:32'!
outOfOrderErrorDescription
	
	^ 'Robot out of order :('! !

!classDefinition: #Trailer category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'pc 7/5/2021 17:46:36'!
Object subclass: #Trailer
	instanceVariableNames: 'weightCapacity heightCapacity container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #Trailer category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'pc 7/5/2021 17:46:36'!
Object subclass: #Trailer
	instanceVariableNames: 'weightCapacity heightCapacity container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!
!Trailer methodsFor: 'initialization' stamp: 'FRT 5/3/2020 23:27:42'!
initializeWith: aWeightCapacity and: aHeightCapacity

	weightCapacity := aWeightCapacity.
	heightCapacity := aHeightCapacity.
	
	container := OrderedCollection new.! !
!Trailer methodsFor: 'accessing' stamp: 'FRT 5/3/2020 23:34:36'!
totalProductsAmount
	
	^ container size.! !
!Trailer methodsFor: 'accessing' stamp: 'F 5/14/2020 10:35:03'!
totalProductsHeight
	"Solo importa la altura de los productos apilables"

	| total index |

	total := 0.
	index := 1.
	
	[index <= container size] whileTrue: [ | product |
		product := (container at: index).
		(product isStackable) ifTrue: [ total := total +  product height ].
		index := index + 1.	
	].

	^ total.! !
!Trailer methodsFor: 'accessing' stamp: 'F 5/14/2020 10:34:38'!
totalProductsWeight
	
	| total index |

	total := 0.
	index := 1.
	
	[index <= container size] whileTrue: [
		total := total + (container at: index) weight.
		index := index + 1.	
	].

	^ total.! !
!Trailer methodsFor: 'testing' stamp: 'FRT 5/3/2020 23:33:33'!
isEmpty
	
	^ container isEmpty! !
!Trailer methodsFor: 'action' stamp: 'FRT 5/3/2020 23:35:19'!
carry: aProduct
	
	^ aProduct carryBy: self.! !
!Trailer methodsFor: 'action' stamp: 'FRT 5/4/2020 19:08:17'!
carryProductA: aProduct
	
	self assertWeightAdding: aProduct.
	container add: aProduct.! !
!Trailer methodsFor: 'action' stamp: 'FRT 5/4/2020 19:08:09'!
carryProductB: aProduct

	self assertWeightAdding: aProduct.
	self assertHeightAdding: aProduct.
	
	container add: aProduct.! !
!Trailer methodsFor: 'assertions' stamp: 'FRT 5/5/2020 11:27:29'!
assertHeightAdding: aProduct
	
	(self totalProductsHeight + aProduct height) > heightCapacity ifTrue: [ self signalMaxHeightCapacityExceeded ]! !
!Trailer methodsFor: 'assertions' stamp: 'FRT 5/5/2020 11:27:41'!
assertWeightAdding: aProduct
	
	(self totalProductsWeight + aProduct weight) > weightCapacity ifTrue: [ self signalMaxWeightCapacityExceeded ]! !
!Trailer methodsFor: 'exceptions' stamp: 'FRT 5/4/2020 11:30:31'!
signalMaxHeightCapacityExceeded

	self error: self class maxHeightExceededErrorDescription
! !
!Trailer methodsFor: 'exceptions' stamp: 'FRT 5/4/2020 11:30:38'!
signalMaxWeightCapacityExceeded

	self error: self class maxWeightExceededErrorDescription
! !

!classDefinition: 'Trailer class' category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'pc 7/5/2021 17:46:36'!
Trailer class
	instanceVariableNames: ''!

!classDefinition: 'Trailer class' category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'pc 7/5/2021 17:46:36'!
Trailer class
	instanceVariableNames: ''!
!Trailer class methodsFor: 'instance creation' stamp: 'FRT 5/4/2020 17:33:58'!
with: aWeightCapacity and: aHeightCapacity

	aWeightCapacity strictlyPositive ifFalse: [ self signalInvalidWeightCapacity ].
	aHeightCapacity strictlyPositive ifFalse: [ self signalInvalidHeightCapacity ].
	
	aWeightCapacity isInteger ifFalse: [ self signalWeightCapacityMustBeInteger ].
	aHeightCapacity isInteger ifFalse: [ self signalHeightCapacityMustBeInteger ].
		
	^ self new initializeWith: aWeightCapacity and: aHeightCapacity.

! !
!Trailer class methodsFor: 'exceptions' stamp: 'FRT 5/4/2020 17:37:41'!
signalHeightCapacityMustBeInteger

	self error: self heightCapacityMustBeIntegerErrorDescription
! !
!Trailer class methodsFor: 'exceptions' stamp: 'FRT 5/4/2020 11:30:12'!
signalInvalidHeightCapacity

	self error: self invalidHeightCapacityErrorDescription
! !
!Trailer class methodsFor: 'exceptions' stamp: 'FRT 5/4/2020 11:30:21'!
signalInvalidWeightCapacity

	self error: self invalidWeightCapacityErrorDescription
! !
!Trailer class methodsFor: 'exceptions' stamp: 'FRT 5/4/2020 17:37:29'!
signalWeightCapacityMustBeInteger

	self error: self weightCapacityMustBeIntegerErrorDescription
! !
!Trailer class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 17:49:38'!
heightCapacityMustBeIntegerErrorDescription

	^ 'Height capacity must be integer'! !
!Trailer class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 11:30:12'!
invalidHeightCapacityErrorDescription

	^ 'The trailers height capacity must be positive.'
! !
!Trailer class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 11:30:21'!
invalidWeightCapacityErrorDescription

	^ 'The trailers weight capacity must be positive.'
! !
!Trailer class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 11:30:31'!
maxHeightExceededErrorDescription

	^ 'Maximum height has been exceeded'
! !
!Trailer class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 11:30:38'!
maxWeightExceededErrorDescription

	^ 'Maximum weight has been exceeded'
! !
!Trailer class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 17:49:32'!
weightCapacityMustBeIntegerErrorDescription

	^ 'Weight capacity must be integer'! !

!classDefinition: #CoffeeShopTest category: 'IngSof1-2019-2C-1Parcial' stamp: 'pc 7/5/2021 17:46:37'!
TestCase subclass: #CoffeeShopTest
	instanceVariableNames: 'billGates adaLovelace alanKay salesSystem'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #CoffeeShopTest category: 'IngSof1-2019-2C-1Parcial' stamp: 'pc 7/5/2021 17:46:37'!
TestCase subclass: #CoffeeShopTest
	instanceVariableNames: 'billGates adaLovelace alanKay salesSystem'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!CoffeeShopTest methodsFor: 'setUp/tearDown' stamp: 'HAW 9/22/2019 21:41:38' overrides: 16927572!
setUp

	adaLovelace := CoffeeShopCustomer named: 'Ada Lovelace' ofType: #Gold.
	alanKay := CoffeeShopCustomer named: 'Alan Kay' ofType: #Silver.
	billGates := CoffeeShopCustomer named: 'Bill Gates' ofType: #Normal! !
!CoffeeShopTest methodsFor: 'test objects' stamp: 'HAW 9/20/2019 17:15:53'!
combo1

	^#Combo1! !
!CoffeeShopTest methodsFor: 'test objects' stamp: 'HAW 9/20/2019 17:21:01'!
combo2

	^#Combo2! !
!CoffeeShopTest methodsFor: 'tests - sales' stamp: 'HAW 9/22/2019 21:41:51'!
test01ThereAreNoSalesWhenSalesSystemIsCreated

	salesSystem := CoffeeShopSalesSystem new.

	self assert: (salesSystem salesMadeTo: adaLovelace) isEmpty! !
!CoffeeShopTest methodsFor: 'tests - sales' stamp: 'HAW 9/22/2019 21:41:51'!
test02CanQuerySalesByCustomer

	| salesToAdaLovelace |

	salesSystem := CoffeeShopSalesSystem new.

	salesSystem registerSaleTo: adaLovelace of: self combo1.
	
	salesToAdaLovelace := salesSystem salesMadeTo: adaLovelace.
	self assert: 1 equals: salesToAdaLovelace size.
	self assert: 1 equals: (salesToAdaLovelace count: [ :aProduct | aProduct = self combo1 ])! !
!CoffeeShopTest methodsFor: 'tests - sales' stamp: 'HAW 9/22/2019 21:41:51'!
test03SalesAreDistinguishedByCustomer

	| salesToAdaLovelace salesToAlanKay |

	salesSystem := CoffeeShopSalesSystem new.

	salesSystem registerSaleTo: adaLovelace of: self combo1.
	salesSystem registerSaleTo: alanKay of: self combo2.

	salesToAdaLovelace := salesSystem salesMadeTo: adaLovelace.
	self assert: 1 equals: salesToAdaLovelace size.
	self assert: 1 equals: (salesToAdaLovelace count: [ :aProduct | aProduct = self combo1 ]).

	salesToAlanKay := salesSystem salesMadeTo: alanKay.
	self assert: 1 equals: salesToAlanKay size.
	self assert: 1 equals: (salesToAlanKay  count: [ :aProduct | aProduct = self combo2 ])! !
!CoffeeShopTest methodsFor: 'tests - volume sold' stamp: 'HAW 9/22/2019 21:41:51'!
test04VolumeSoldToCustomerIsZeroWhenCustomerHasNoSaleRegistered

	| volumeSoldToCustomer |

	salesSystem := CoffeeShopSalesSystem new.

	volumeSoldToCustomer := salesSystem volumeSoldTo: adaLovelace.

	self assert: 0*milliliter equals: volumeSoldToCustomer! !
!CoffeeShopTest methodsFor: 'tests - volume sold' stamp: 'HAW 9/22/2019 21:46:19'!
test05VolumeIs_250_WhenOnlyCombo1WasSoldToCustomer

	| volumeSoldToCustomer |

	salesSystem := CoffeeShopSalesSystem new.

	salesSystem registerSaleTo: adaLovelace of: self combo1.

	volumeSoldToCustomer := salesSystem volumeSoldTo: adaLovelace.

	self assert: 250*milliliter equals: volumeSoldToCustomer ! !
!CoffeeShopTest methodsFor: 'tests - volume sold' stamp: 'HAW 9/22/2019 21:46:07'!
test06VolumeIs_100_WhenOnlyCombo2WasSoldToCustomer

	| volumeSoldToCustomer |

	salesSystem := CoffeeShopSalesSystem new.

	salesSystem registerSaleTo: adaLovelace of: self combo2.

	volumeSoldToCustomer := salesSystem volumeSoldTo: adaLovelace.

	self assert: 100*milliliter equals: volumeSoldToCustomer ! !
!CoffeeShopTest methodsFor: 'tests - volume sold' stamp: 'HAW 9/22/2019 21:46:41'!
test07VolumeSoldToCustomerIsTheSumOfAllSoldProducts

	| volumeSoldToCustomer |

	salesSystem := CoffeeShopSalesSystem new.

	salesSystem registerSaleTo: adaLovelace of: self combo1.
	salesSystem registerSaleTo: adaLovelace of: self combo2.

	volumeSoldToCustomer := salesSystem volumeSoldTo: adaLovelace.

	self assert: (250*milliliter)+(100*milliliter) equals: volumeSoldToCustomer ! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 21:48:39'!
test08NoRewardExpectedWhenCustomerHasNotBuyAnything

	salesSystem := CoffeeShopSalesSystem new.

	salesSystem rewardOf: adaLovelace ifNone: [ ^self ].
	
	self failWith: 'No reward expected when customer has not buy anything'! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 21:41:51'!
test09GoldCustomerGetsRewardedWithOneCombo2With50PercentItsPriceWhenRule1Holds

	| adaLovelaceReward |

	salesSystem := CoffeeShopSalesSystem new.

	salesSystem registerSaleTo: adaLovelace of: self combo1.
	salesSystem registerSaleTo: adaLovelace of: self combo2.

	adaLovelaceReward := salesSystem rewardOf: adaLovelace ifNone: [ self fail ].

	self assert: 1 equals: adaLovelaceReward quantity.
	self assert: adaLovelaceReward isForCombo2.
	self assert: 60*peso equals: adaLovelaceReward price.
! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 21:41:51'!
test10SilverCustomerGetsRewardedWithOneCombo2With75PercentItsPriceWhenRule1Holds

	| alaKayReward |

	salesSystem := CoffeeShopSalesSystem new.

	salesSystem registerSaleTo: alanKay of: self combo1.
	salesSystem registerSaleTo: alanKay of: self combo2.

	alaKayReward := salesSystem rewardOf: alanKay ifNone: [ self fail ].

	self assert: 1 equals: alaKayReward quantity.
	self assert: alaKayReward isForCombo2.
	self assert: 120*3/4*peso equals: alaKayReward price.
! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 21:41:51'!
test11NormalCustomerGetsRewardedWithOneCombo2With90PercentItsPriceWhenRule1Holds

	| billGatesReward |

	salesSystem := CoffeeShopSalesSystem new.

	salesSystem registerSaleTo: billGates of: self combo1.
	salesSystem registerSaleTo: billGates of: self combo2.

	billGatesReward := salesSystem rewardOf: billGates ifNone: [ self fail ].

	self assert: 1 equals: billGatesReward quantity.
	self assert: billGatesReward isForCombo2.
	self assert: 120*9/10*peso equals: billGatesReward price.
! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 21:41:51'!
test12GoldCustomerGetsRewardedWithOneCombo1At75PesosWhenRule2Holds

	| adaLovelaceReward |

	salesSystem := CoffeeShopSalesSystem new.

	salesSystem registerSaleTo: adaLovelace of: self combo1.
	salesSystem registerSaleTo: adaLovelace of: self combo1.
	salesSystem registerSaleTo: adaLovelace of: self combo2.

	adaLovelaceReward := salesSystem rewardOf: adaLovelace ifNone: [ self fail ].

	self assert: 2 equals: adaLovelaceReward quantity.
	self assert: adaLovelaceReward isForCombo1.
	self assert: 75*peso equals: adaLovelaceReward price.
! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 21:41:51'!
test13SilverCustomerGetsRewardedWithOneCombo1At83PesosWhenRule2Holds

	| alanKayReward |

	salesSystem := CoffeeShopSalesSystem new.

	salesSystem registerSaleTo: alanKay of: self combo1.
	salesSystem registerSaleTo: alanKay of: self combo1.
	salesSystem registerSaleTo: alanKay of: self combo2.

	alanKayReward := salesSystem rewardOf: alanKay ifNone: [ self fail ].

	self assert: 2 equals: alanKayReward quantity.
	self assert: alanKayReward isForCombo1.
	self assert: 83*peso equals: alanKayReward price.
! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 21:41:51'!
test14NormalCustomerGetsRewardedWithOneCombo1At97PesosWhenRule2Holds

	| billGatesReward |

	salesSystem := CoffeeShopSalesSystem new.

	salesSystem registerSaleTo: billGates of: self combo1.
	salesSystem registerSaleTo: billGates of: self combo1.
	salesSystem registerSaleTo: billGates of: self combo2.

	billGatesReward := salesSystem rewardOf: billGates ifNone: [ self fail ].

	self assert: 2 equals: billGatesReward quantity.
	self assert: billGatesReward isForCombo1.
	self assert: 97*peso equals: billGatesReward price.
! !

!classDefinition: #CoffeeShopCustomer category: 'IngSof1-2019-2C-1Parcial' stamp: 'pc 7/5/2021 17:46:37'!
Object subclass: #CoffeeShopCustomer
	instanceVariableNames: 'name type'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #CoffeeShopCustomer category: 'IngSof1-2019-2C-1Parcial' stamp: 'pc 7/5/2021 17:46:37'!
Object subclass: #CoffeeShopCustomer
	instanceVariableNames: 'name type'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!CoffeeShopCustomer methodsFor: 'type' stamp: 'HAW 9/21/2019 13:05:10'!
type

	^type! !
!CoffeeShopCustomer methodsFor: 'initialization' stamp: 'HAW 9/21/2019 13:00:45'!
initializeNamed: aName ofType: aType

	name := aName.
	type := aType ! !
!CoffeeShopCustomer methodsFor: 'printing' stamp: 'HAW 9/22/2019 18:57:07' overrides: 50683280!
printOn: aStream

	aStream
		nextPutAll: 'Customer named ';
		nextPutAll: name! !

!classDefinition: 'CoffeeShopCustomer class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'pc 7/5/2021 17:46:37'!
CoffeeShopCustomer class
	instanceVariableNames: ''!

!classDefinition: 'CoffeeShopCustomer class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'pc 7/5/2021 17:46:37'!
CoffeeShopCustomer class
	instanceVariableNames: ''!
!CoffeeShopCustomer class methodsFor: 'instance creation' stamp: 'HAW 9/21/2019 13:00:21'!
named: aName ofType: aType

	^self new initializeNamed: aName ofType: aType! !

!classDefinition: #CoffeeShopReward category: 'IngSof1-2019-2C-1Parcial' stamp: 'pc 7/5/2021 17:46:37'!
Object subclass: #CoffeeShopReward
	instanceVariableNames: 'price quantity product'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #CoffeeShopReward category: 'IngSof1-2019-2C-1Parcial' stamp: 'pc 7/5/2021 17:46:37'!
Object subclass: #CoffeeShopReward
	instanceVariableNames: 'price quantity product'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!CoffeeShopReward methodsFor: 'accessing' stamp: 'HAW 9/20/2019 17:54:42'!
price

	^price! !
!CoffeeShopReward methodsFor: 'accessing' stamp: 'HAW 9/21/2019 16:31:13'!
quantity

	^quantity ! !
!CoffeeShopReward methodsFor: 'initialization' stamp: 'HAW 9/22/2019 19:08:08'!
initializeOf: aProduct at: aPrice quantity: aQuantity

	product := aProduct.
	price := aPrice.
	quantity := aQuantity
	! !
!CoffeeShopReward methodsFor: 'testing' stamp: 'HAW 9/22/2019 19:07:57'!
isForCombo1
	
	^product = #Combo1! !
!CoffeeShopReward methodsFor: 'testing' stamp: 'HAW 9/22/2019 19:07:57'!
isForCombo2
	
	^product = #Combo2! !

!classDefinition: 'CoffeeShopReward class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'pc 7/5/2021 17:46:38'!
CoffeeShopReward class
	instanceVariableNames: ''!

!classDefinition: 'CoffeeShopReward class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'pc 7/5/2021 17:46:38'!
CoffeeShopReward class
	instanceVariableNames: ''!
!CoffeeShopReward class methodsFor: 'instance creation' stamp: 'HAW 9/20/2019 17:53:14'!
of: aComboType at: aPrice quantity: aQuantity

	^self new initializeOf: aComboType at: aPrice quantity: aQuantity
! !

!classDefinition: #CoffeeShopSalesSystem category: 'IngSof1-2019-2C-1Parcial' stamp: 'pc 7/5/2021 17:46:38'!
Object subclass: #CoffeeShopSalesSystem
	instanceVariableNames: 'sales'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #CoffeeShopSalesSystem category: 'IngSof1-2019-2C-1Parcial' stamp: 'pc 7/5/2021 17:46:38'!
Object subclass: #CoffeeShopSalesSystem
	instanceVariableNames: 'sales'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!CoffeeShopSalesSystem methodsFor: 'product volume' stamp: 'HAW 9/22/2019 19:51:19'!
volumeOf: aProduct

	aProduct = #Combo1 ifTrue: [ ^250*milliliter ].
	aProduct = #Combo2 ifTrue: [ ^100*milliliter ].

	self error: 'Invalid product'
	! !
!CoffeeShopSalesSystem methodsFor: 'initialization' stamp: 'HAW 9/20/2019 17:17:34' overrides: 16896425!
initialize

	sales := Dictionary new! !
!CoffeeShopSalesSystem methodsFor: 'selling' stamp: 'HAW 9/22/2019 19:06:50'!
registerSaleTo: aCustomer of: aProduct

	| salesToCustomer |

	salesToCustomer := sales at: aCustomer ifAbsentPut: [ OrderedCollection new ].
	salesToCustomer add: aProduct ! !
!CoffeeShopSalesSystem methodsFor: 'selling' stamp: 'HAW 9/20/2019 17:24:49'!
salesMadeTo: aCustomer

	^sales at: aCustomer ifAbsent: [ #() ]! !
!CoffeeShopSalesSystem methodsFor: 'selling' stamp: 'HAW 9/22/2019 19:51:19'!
volumeSoldTo: aCustomer

	 ^(self salesMadeTo: aCustomer) sum: [ :aProduct | self volumeOf: aProduct ] ifEmpty: [ 0*milliliter ]! !
!CoffeeShopSalesSystem methodsFor: 'rewarding' stamp: 'HAW 9/22/2019 19:53:42'!
rewardOf: aCustomer ifNone: noneBlock 

	| salesToCustomer volumeSoldToCustomer rewardRule |

	salesToCustomer := self salesMadeTo: aCustomer.
	volumeSoldToCustomer := self volumeSoldTo: aCustomer.
	
	rewardRule := RewardRule for: volumeSoldToCustomer ifNone: [^noneBlock value].
	^rewardRule createRewardFor: aCustomer.
	! !

!classDefinition: 'CoffeeShopSalesSystem class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'pc 7/5/2021 17:46:38'!
CoffeeShopSalesSystem class
	instanceVariableNames: ''!

!classDefinition: 'CoffeeShopSalesSystem class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'pc 7/5/2021 17:46:38'!
CoffeeShopSalesSystem class
	instanceVariableNames: ''!
!CoffeeShopSalesSystem class methodsFor: 'initialization' stamp: 'HAW 9/23/2019 08:50:03' overrides: 16883149!
initialize

	Smalltalk at: #milliliter put: (BaseUnit named: 'milliliter')! !

!classDefinition: #RewardRule category: 'IngSof1-2019-2C-1Parcial' stamp: 'pc 7/5/2021 17:46:38'!
Object subclass: #RewardRule
	instanceVariableNames: 'product'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #RewardRule category: 'IngSof1-2019-2C-1Parcial' stamp: 'pc 7/5/2021 17:46:38'!
Object subclass: #RewardRule
	instanceVariableNames: 'product'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!RewardRule methodsFor: 'reward creation' stamp: 'HAW 9/22/2019 19:03:50'!
createRewardFor: aCustomer 
	
	self subclassResponsibility ! !
!RewardRule methodsFor: 'reward creation' stamp: 'HAW 9/22/2019 10:51:26'!
productQuantity

	self subclassResponsibility ! !
!RewardRule methodsFor: 'reward creation' stamp: 'HAW 9/22/2019 10:51:33'!
rewardedProduct

	self subclassResponsibility ! !
!RewardRule methodsFor: 'product price' stamp: 'HAW 9/22/2019 21:43:12'!
priceOf: aProduct

	aProduct = #Combo1 ifTrue: [ ^150*peso ].
	aProduct = #Combo2 ifTrue: [ ^120*peso ].

	self error: 'Invalid combo type'! !

!classDefinition: 'RewardRule class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'pc 7/5/2021 17:46:38'!
RewardRule class
	instanceVariableNames: ''!

!classDefinition: 'RewardRule class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'pc 7/5/2021 17:46:38'!
RewardRule class
	instanceVariableNames: ''!
!RewardRule class methodsFor: 'testing' stamp: 'HAW 9/22/2019 19:53:22'!
isFor: volumeSoldToCustomer 
		
	self subclassResponsibility ! !
!RewardRule class methodsFor: 'instance creation' stamp: 'HAW 9/22/2019 19:53:42'!
for: volumeSoldToCustomer ifNone: aNoneBlock

	^self subclasses 
		detect: [ :aRuleClass | aRuleClass isFor: volumeSoldToCustomer ] 
		ifFound: [ :aRuleClass | aRuleClass new ]
		ifNone: aNoneBlock ! !

!classDefinition: #Combo1RewardRule category: 'IngSof1-2019-2C-1Parcial' stamp: 'pc 7/5/2021 17:46:38'!
RewardRule subclass: #Combo1RewardRule
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #Combo1RewardRule category: 'IngSof1-2019-2C-1Parcial' stamp: 'pc 7/5/2021 17:46:38'!
RewardRule subclass: #Combo1RewardRule
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!Combo1RewardRule methodsFor: 'reward creation' stamp: 'HAW 9/22/2019 21:41:45' overrides: 50904617!
createRewardFor: aCustomer 
	
	| price |
	
	product := self rewardedProduct.
	
	aCustomer type = #Gold ifTrue: [ price := 75*peso ].
	aCustomer type = #Silver ifTrue: [ price := 83*peso ].
	aCustomer type = #Normal ifTrue: [ price := 97*peso ].
	
	^CoffeeShopReward of: product at: price quantity: self productQuantity! !
!Combo1RewardRule methodsFor: 'reward creation' stamp: 'HAW 9/22/2019 19:54:35' overrides: 50904622!
productQuantity
	
	^2! !
!Combo1RewardRule methodsFor: 'reward creation' stamp: 'HAW 9/22/2019 19:01:41' overrides: 50904626!
rewardedProduct
	
	^#Combo1! !

!classDefinition: 'Combo1RewardRule class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'pc 7/5/2021 17:46:38'!
Combo1RewardRule class
	instanceVariableNames: ''!

!classDefinition: 'Combo1RewardRule class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'pc 7/5/2021 17:46:38'!
Combo1RewardRule class
	instanceVariableNames: ''!
!Combo1RewardRule class methodsFor: 'testing' stamp: 'HAW 9/22/2019 19:53:22' overrides: 50904647!
isFor: volumeSoldToCustomer 

	^volumeSoldToCustomer > (500*milliliter)! !

!classDefinition: #Combo2RewardRule category: 'IngSof1-2019-2C-1Parcial' stamp: 'pc 7/5/2021 17:46:38'!
RewardRule subclass: #Combo2RewardRule
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #Combo2RewardRule category: 'IngSof1-2019-2C-1Parcial' stamp: 'pc 7/5/2021 17:46:38'!
RewardRule subclass: #Combo2RewardRule
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!Combo2RewardRule methodsFor: 'reward creation' stamp: 'HAW 9/22/2019 21:41:45' overrides: 50904617!
createRewardFor: aCustomer 
	
	| price |
	
	product := self rewardedProduct.
	
	aCustomer type = #Gold ifTrue: [ price := (self priceOf: product)/2 ].
	aCustomer type = #Silver ifTrue: [ price := (self priceOf: product)*3/4 ].
	aCustomer type = #Normal ifTrue: [ price := (self priceOf: product)*9/10 ].
	
	^CoffeeShopReward of: product at: price quantity: self productQuantity! !
!Combo2RewardRule methodsFor: 'reward creation' stamp: 'HAW 9/22/2019 10:23:07' overrides: 50904622!
productQuantity

	^1! !
!Combo2RewardRule methodsFor: 'reward creation' stamp: 'HAW 9/22/2019 19:00:28' overrides: 50904626!
rewardedProduct
	
	^#Combo2! !

!classDefinition: 'Combo2RewardRule class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'pc 7/5/2021 17:46:38'!
Combo2RewardRule class
	instanceVariableNames: ''!

!classDefinition: 'Combo2RewardRule class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'pc 7/5/2021 17:46:38'!
Combo2RewardRule class
	instanceVariableNames: ''!
!Combo2RewardRule class methodsFor: 'testing' stamp: 'HAW 9/22/2019 19:53:22' overrides: 50904647!
isFor: volumeSoldToCustomer 

	^volumeSoldToCustomer between: 300*milliliter and: 500*milliliter
	! !

!classRemoval: #Combo2RewardRule stamp: 'pc 7/5/2021 17:46:39'!
RewardRule subclass: #Combo2RewardRule
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #Combo1RewardRule stamp: 'pc 7/5/2021 17:46:39'!
RewardRule subclass: #Combo1RewardRule
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #RewardRule stamp: 'pc 7/5/2021 17:46:40'!
Object subclass: #RewardRule
	instanceVariableNames: 'product'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopSalesSystem stamp: 'pc 7/5/2021 17:46:40'!
Object subclass: #CoffeeShopSalesSystem
	instanceVariableNames: 'sales'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopReward stamp: 'pc 7/5/2021 17:46:40'!
Object subclass: #CoffeeShopReward
	instanceVariableNames: 'price quantity product'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopCustomer stamp: 'pc 7/5/2021 17:46:41'!
Object subclass: #CoffeeShopCustomer
	instanceVariableNames: 'name type'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopTest stamp: 'pc 7/5/2021 17:46:41'!
TestCase subclass: #CoffeeShopTest
	instanceVariableNames: 'billGates adaLovelace alanKay salesSystem'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #CoffeeShopTest category: 'IngSof1-2019-2C-1Parcial' stamp: 'pc 7/5/2021 17:46:41'!
TestCase subclass: #CoffeeShopTest
	instanceVariableNames: 'billGates adaLovelace alanKay salesSystem'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #CoffeeShopTest category: 'IngSof1-2019-2C-1Parcial' stamp: 'pc 7/5/2021 17:46:41'!
TestCase subclass: #CoffeeShopTest
	instanceVariableNames: 'billGates adaLovelace alanKay salesSystem'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!CoffeeShopTest methodsFor: 'setUp/tearDown' stamp: 'HAW 9/23/2019 08:55:28' overrides: 16927572!
setUp

	adaLovelace := CoffeeShopCustomer goldNamed: 'Ada Lovelace'.
	alanKay := CoffeeShopCustomer silverNamed: 'Alan Kay'.
	billGates := CoffeeShopCustomer normalNamed: 'Bill Gates'! !
!CoffeeShopTest methodsFor: 'test objects' stamp: 'HAW 9/23/2019 08:59:18'!
combo1

	^CoffeeShopProduct combo1! !
!CoffeeShopTest methodsFor: 'test objects' stamp: 'HAW 9/23/2019 08:59:25'!
combo2

	^CoffeeShopProduct combo2 ! !
!CoffeeShopTest methodsFor: 'tests - sales' stamp: 'HAW 9/22/2019 20:22:35'!
assertSalesMadeTo: aCustomer are: aQuantity ofType: aProductTypeBlock

	| salesToCustomer |
	
	salesToCustomer := salesSystem salesMadeTo: aCustomer.
	self assert: aQuantity equals: salesToCustomer size.
	self assert: aQuantity equals: (salesToCustomer count: aProductTypeBlock)! !
!CoffeeShopTest methodsFor: 'tests - sales' stamp: 'HAW 9/22/2019 21:18:36'!
test01ThereAreNoSalesWhenSalesSystemIsCreated

	salesSystem := CoffeeShopSalesSystem new.

	self assert: (salesSystem salesMadeTo: adaLovelace) isEmpty! !
!CoffeeShopTest methodsFor: 'tests - sales' stamp: 'HAW 9/22/2019 21:18:36'!
test02CanQuerySalesByCustomer

	salesSystem := CoffeeShopSalesSystem new.

	salesSystem registerSaleTo: adaLovelace of: self combo1.
	self assertSalesMadeTo: adaLovelace are: 1 ofType: [ :aProduct | aProduct = self combo1 ]
	! !
!CoffeeShopTest methodsFor: 'tests - sales' stamp: 'HAW 9/22/2019 21:18:36'!
test03SalesAreDistinguishedByCustomer

	salesSystem := CoffeeShopSalesSystem new.

	salesSystem registerSaleTo: adaLovelace of: self combo1.
	salesSystem registerSaleTo: adaLovelace of: self combo1.
	salesSystem registerSaleTo: alanKay of: self combo2.

	self assertSalesMadeTo: adaLovelace are: 2 ofType: [ :aProduct | aProduct = self combo1 ].
	self assertSalesMadeTo: alanKay are: 1 ofType: [ :aProduct | aProduct = self combo2 ]! !
!CoffeeShopTest methodsFor: 'tests - volume sold' stamp: 'HAW 9/22/2019 21:18:36'!
test04VolumeSoldToCustomerIsZeroWhenCustomerHasNoSaleRegistered

	| volumeSoldToCustomer |

	salesSystem := CoffeeShopSalesSystem new.

	volumeSoldToCustomer := salesSystem volumeSoldTo: adaLovelace.

	self assert: 0*milliliter equals: volumeSoldToCustomer! !
!CoffeeShopTest methodsFor: 'tests - volume sold' stamp: 'HAW 9/22/2019 21:18:36'!
test05VolumesSoldToCustomerIs_250_WhenOnlyCombo1WasBought

	| volumeSoldToCustomer |

	salesSystem := CoffeeShopSalesSystem new.

	salesSystem registerSaleTo: adaLovelace of: self combo1.

	volumeSoldToCustomer := salesSystem volumeSoldTo: adaLovelace.

	self assert: 250*milliliter equals: volumeSoldToCustomer ! !
!CoffeeShopTest methodsFor: 'tests - volume sold' stamp: 'HAW 9/22/2019 21:18:36'!
test06VolumesSoldToCustomerIs_100_WhenOnlyCombo2WasBought

	| volumeSoldToCustomer |

	salesSystem := CoffeeShopSalesSystem new.

	salesSystem registerSaleTo: adaLovelace of: self combo2.

	volumeSoldToCustomer := salesSystem volumeSoldTo: adaLovelace.

	self assert: 100*milliliter equals: volumeSoldToCustomer ! !
!CoffeeShopTest methodsFor: 'tests - volume sold' stamp: 'HAW 9/22/2019 21:18:36'!
test07VolumesSoldToCustomerIsTheSumOfAllSales

	| volumeSoldToCustomer |

	salesSystem := CoffeeShopSalesSystem new.

	salesSystem registerSaleTo: adaLovelace of: self combo1.
	salesSystem registerSaleTo: adaLovelace of: self combo2.

	volumeSoldToCustomer := salesSystem volumeSoldTo: adaLovelace.

	self assert: (250*milliliter)+(100*milliliter) equals: volumeSoldToCustomer ! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 20:25:09'!
assertRewardOf: aCustomer is: aQuantity of: aRewardTypeBlock at: aPrice

	| customerReward |
	
	customerReward := salesSystem rewardOf: aCustomer ifNone: [ self fail ].

	self assert: aQuantity equals: customerReward quantity.
	self assert: (aRewardTypeBlock value: customerReward).
	self assert: aPrice equals: customerReward price.
! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 20:29:19'!
registerSalesForCombo1RewardTo: aCustomer

	salesSystem registerSaleTo: aCustomer of: self combo1.
	salesSystem registerSaleTo: aCustomer of: self combo1.
	salesSystem registerSaleTo: aCustomer of: self combo2.! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 21:17:22'!
registerSalesForCombo1RewardTo: aCustomer andAssertPriceIs: aPrice

	self registerSalesForCombo1RewardTo: aCustomer.
	self assertRewardOf: aCustomer is: 2 of: [ :aReward | aReward isForCombo1 ] at: aPrice ! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 20:27:16'!
registerSalesForCombo2RewardTo: aCustomer

	salesSystem registerSaleTo: aCustomer of: self combo1.
	salesSystem registerSaleTo: aCustomer of: self combo2.
! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 21:15:55'!
registerSalesForCombo2RewardTo: aCustomer andAssertPriceIs: aPrice

	self registerSalesForCombo2RewardTo: aCustomer.
	self assertRewardOf: aCustomer is: 1 of: [ :aReward | aReward isForCombo2 ] at: aPrice! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 21:18:36'!
test08WhenNothingHasBeenSoldToCustomerThereIsNoRewardForHer

	salesSystem := CoffeeShopSalesSystem new.

	salesSystem rewardOf: adaLovelace ifNone: [ ^self ].
	
	self fail.! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 21:18:36'!
test09GoldCustomerGetsRewardedWithOneCombo2With50PercentItsPriceWhenRule1Holds

	salesSystem := CoffeeShopSalesSystem new.
	self registerSalesForCombo2RewardTo: adaLovelace andAssertPriceIs: 60*peso! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 21:18:36'!
test10SilverCustomerGetsRewardedWithOneCombo2With75PercentItsPriceWhenRule1Holds

	salesSystem := CoffeeShopSalesSystem new.
	self registerSalesForCombo2RewardTo: alanKay andAssertPriceIs: 120*3/4*peso ! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 21:18:36'!
test11NormalCustomerGetsRewardedWithOneCombo2With90PercentItsPriceWhenRule1Holds

	salesSystem := CoffeeShopSalesSystem new.
	self registerSalesForCombo2RewardTo: billGates andAssertPriceIs: 120*9/10*peso ! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 21:18:36'!
test12GoldCustomerGetsRewardedWithOneCombo1At75PesosWhenRule2Holds

	salesSystem := CoffeeShopSalesSystem new.
	self registerSalesForCombo1RewardTo: adaLovelace andAssertPriceIs: 75*peso 
! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 21:18:36'!
test13SilverCustomerGetsRewardedWithOneCombo1At83PesosWhenRule2Holds

	salesSystem := CoffeeShopSalesSystem new.
	self registerSalesForCombo1RewardTo: alanKay andAssertPriceIs: 83*peso
! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 21:18:36'!
test14NormalCustomerGetsRewardedWithOneCombo1At97PesosWhenRule2Holds

	salesSystem := CoffeeShopSalesSystem new.
	self registerSalesForCombo1RewardTo: billGates andAssertPriceIs: 97*peso
! !

!classDefinition: #CoffeeShopCustomer category: 'IngSof1-2019-2C-1Parcial' stamp: 'pc 7/5/2021 17:46:42'!
Object subclass: #CoffeeShopCustomer
	instanceVariableNames: 'name type'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #CoffeeShopCustomer category: 'IngSof1-2019-2C-1Parcial' stamp: 'pc 7/5/2021 17:46:42'!
Object subclass: #CoffeeShopCustomer
	instanceVariableNames: 'name type'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!CoffeeShopCustomer methodsFor: 'initialization' stamp: 'HAW 9/23/2019 08:54:02'!
initializeNamed: aName ofType: aType

	name := aName.
	type := aType.
	! !
!CoffeeShopCustomer methodsFor: 'printing' stamp: 'HAW 9/22/2019 18:57:07' overrides: 50683280!
printOn: aStream

	aStream
		nextPutAll: 'Customer named ';
		nextPutAll: name! !
!CoffeeShopCustomer methodsFor: 'reward price' stamp: 'HAW 9/23/2019 08:54:17'!
rewardPriceFor: aReward

	^type rewardPriceFor: aReward ! !

!classDefinition: 'CoffeeShopCustomer class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'pc 7/5/2021 17:46:42'!
CoffeeShopCustomer class
	instanceVariableNames: ''!

!classDefinition: 'CoffeeShopCustomer class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'pc 7/5/2021 17:46:42'!
CoffeeShopCustomer class
	instanceVariableNames: ''!
!CoffeeShopCustomer class methodsFor: 'instance creation' stamp: 'HAW 9/23/2019 08:53:09'!
goldNamed: aName 

	^self named: aName ofType: CoffeeShopGoldCustomer new! !
!CoffeeShopCustomer class methodsFor: 'instance creation' stamp: 'HAW 9/23/2019 08:53:44'!
named: aName ofType: aType

	^self new initializeNamed: aName ofType: aType! !
!CoffeeShopCustomer class methodsFor: 'instance creation' stamp: 'HAW 9/23/2019 08:53:28'!
normalNamed: aName 

	^self named: aName ofType: CoffeeShopNormalCustomer new! !
!CoffeeShopCustomer class methodsFor: 'instance creation' stamp: 'HAW 9/23/2019 08:53:18'!
silverNamed: aName 

	^self named: aName ofType: CoffeeShopSilverCustomer new! !

!classDefinition: #CoffeeShopCustomerType category: 'IngSof1-2019-2C-1Parcial' stamp: 'pc 7/5/2021 17:46:42'!
Object subclass: #CoffeeShopCustomerType
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #CoffeeShopCustomerType category: 'IngSof1-2019-2C-1Parcial' stamp: 'pc 7/5/2021 17:46:42'!
Object subclass: #CoffeeShopCustomerType
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!CoffeeShopCustomerType methodsFor: 'reward price' stamp: 'HAW 9/23/2019 08:54:32'!
rewardPriceFor: aCustomer

	self subclassResponsibility ! !

!classDefinition: #CoffeeShopGoldCustomer category: 'IngSof1-2019-2C-1Parcial' stamp: 'pc 7/5/2021 17:46:42'!
CoffeeShopCustomerType subclass: #CoffeeShopGoldCustomer
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #CoffeeShopGoldCustomer category: 'IngSof1-2019-2C-1Parcial' stamp: 'pc 7/5/2021 17:46:42'!
CoffeeShopCustomerType subclass: #CoffeeShopGoldCustomer
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!CoffeeShopGoldCustomer methodsFor: 'reward price' stamp: 'HAW 9/22/2019 21:32:02' overrides: 50905155!
rewardPriceFor: aReward

	^aReward rewardPriceForGoldCustomer! !

!classDefinition: #CoffeeShopNormalCustomer category: 'IngSof1-2019-2C-1Parcial' stamp: 'pc 7/5/2021 17:46:42'!
CoffeeShopCustomerType subclass: #CoffeeShopNormalCustomer
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #CoffeeShopNormalCustomer category: 'IngSof1-2019-2C-1Parcial' stamp: 'pc 7/5/2021 17:46:42'!
CoffeeShopCustomerType subclass: #CoffeeShopNormalCustomer
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!CoffeeShopNormalCustomer methodsFor: 'reward price' stamp: 'HAW 9/22/2019 21:33:38' overrides: 50905155!
rewardPriceFor: aReward

	^aReward rewardPriceForNormalCustomer! !

!classDefinition: #CoffeeShopSilverCustomer category: 'IngSof1-2019-2C-1Parcial' stamp: 'pc 7/5/2021 17:46:42'!
CoffeeShopCustomerType subclass: #CoffeeShopSilverCustomer
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #CoffeeShopSilverCustomer category: 'IngSof1-2019-2C-1Parcial' stamp: 'pc 7/5/2021 17:46:42'!
CoffeeShopCustomerType subclass: #CoffeeShopSilverCustomer
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!CoffeeShopSilverCustomer methodsFor: 'reward price' stamp: 'HAW 9/22/2019 21:32:57' overrides: 50905155!
rewardPriceFor: aReward

	^aReward rewardPriceForSilverCustomer! !

!classDefinition: #CoffeeShopProduct category: 'IngSof1-2019-2C-1Parcial' stamp: 'pc 7/5/2021 17:46:42'!
Object subclass: #CoffeeShopProduct
	instanceVariableNames: 'price volume'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #CoffeeShopProduct category: 'IngSof1-2019-2C-1Parcial' stamp: 'pc 7/5/2021 17:46:42'!
Object subclass: #CoffeeShopProduct
	instanceVariableNames: 'price volume'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!CoffeeShopProduct methodsFor: 'price/volume' stamp: 'HAW 9/23/2019 08:57:19'!
price

	^price! !
!CoffeeShopProduct methodsFor: 'price/volume' stamp: 'HAW 9/23/2019 08:57:27'!
volume

	^volume ! !
!CoffeeShopProduct methodsFor: 'initialization' stamp: 'HAW 9/23/2019 09:02:56'!
initializeOf: aVolume at: aPrice

	volume := aVolume.
	price := aPrice.
! !

!classDefinition: 'CoffeeShopProduct class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'pc 7/5/2021 17:46:43'!
CoffeeShopProduct class
	instanceVariableNames: 'combo1 combo2'!

!classDefinition: 'CoffeeShopProduct class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'pc 7/5/2021 17:46:43'!
CoffeeShopProduct class
	instanceVariableNames: 'combo1 combo2'!
!CoffeeShopProduct class methodsFor: 'instance creation' stamp: 'HAW 9/23/2019 09:02:40'!
combo1

	^combo1! !
!CoffeeShopProduct class methodsFor: 'instance creation' stamp: 'HAW 9/23/2019 09:02:46'!
combo2

	^combo2 ! !
!CoffeeShopProduct class methodsFor: 'instance creation' stamp: 'HAW 9/23/2019 09:02:29'!
of: aVolume at: aPrice 

	^self new initializeOf: aVolume at: aPrice 
! !
!CoffeeShopProduct class methodsFor: 'initialization' stamp: 'HAW 9/23/2019 09:03:14' overrides: 16883149!
initialize

	combo1 := self of: 250*milliliter at: 150*peso.
	combo2 := self of: 100*milliliter at: 120*peso! !

!classDefinition: #CoffeeShopReward category: 'IngSof1-2019-2C-1Parcial' stamp: 'pc 7/5/2021 17:46:43'!
Object subclass: #CoffeeShopReward
	instanceVariableNames: 'price quantity product'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #CoffeeShopReward category: 'IngSof1-2019-2C-1Parcial' stamp: 'pc 7/5/2021 17:46:43'!
Object subclass: #CoffeeShopReward
	instanceVariableNames: 'price quantity product'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!CoffeeShopReward methodsFor: 'accessing' stamp: 'HAW 9/20/2019 17:54:42'!
price

	^price! !
!CoffeeShopReward methodsFor: 'accessing' stamp: 'HAW 9/21/2019 16:31:13'!
quantity

	^quantity ! !
!CoffeeShopReward methodsFor: 'initialization' stamp: 'HAW 9/22/2019 19:08:08'!
initializeOf: aProduct at: aPrice quantity: aQuantity

	product := aProduct.
	price := aPrice.
	quantity := aQuantity
	! !
!CoffeeShopReward methodsFor: 'testing' stamp: 'HAW 9/23/2019 09:00:41'!
isForCombo1
	
	^product = CoffeeShopProduct combo1 ! !
!CoffeeShopReward methodsFor: 'testing' stamp: 'HAW 9/23/2019 09:01:02'!
isForCombo2
	
	^product = CoffeeShopProduct combo2 ! !

!classDefinition: 'CoffeeShopReward class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'pc 7/5/2021 17:46:43'!
CoffeeShopReward class
	instanceVariableNames: ''!

!classDefinition: 'CoffeeShopReward class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'pc 7/5/2021 17:46:43'!
CoffeeShopReward class
	instanceVariableNames: ''!
!CoffeeShopReward class methodsFor: 'instance creation' stamp: 'HAW 9/20/2019 17:53:14'!
of: aComboType at: aPrice quantity: aQuantity

	^self new initializeOf: aComboType at: aPrice quantity: aQuantity
! !

!classDefinition: #CoffeeShopSalesSystem category: 'IngSof1-2019-2C-1Parcial' stamp: 'pc 7/5/2021 17:46:43'!
Object subclass: #CoffeeShopSalesSystem
	instanceVariableNames: 'sales'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #CoffeeShopSalesSystem category: 'IngSof1-2019-2C-1Parcial' stamp: 'pc 7/5/2021 17:46:43'!
Object subclass: #CoffeeShopSalesSystem
	instanceVariableNames: 'sales'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!CoffeeShopSalesSystem methodsFor: 'initialization' stamp: 'HAW 9/20/2019 17:17:34' overrides: 16896425!
initialize

	sales := Dictionary new! !
!CoffeeShopSalesSystem methodsFor: 'selling' stamp: 'HAW 9/22/2019 19:06:50'!
registerSaleTo: aCustomer of: aProduct

	| salesToCustomer |

	salesToCustomer := sales at: aCustomer ifAbsentPut: [ OrderedCollection new ].
	salesToCustomer add: aProduct ! !
!CoffeeShopSalesSystem methodsFor: 'selling' stamp: 'HAW 9/20/2019 17:24:49'!
salesMadeTo: aCustomer

	^sales at: aCustomer ifAbsent: [ #() ]! !
!CoffeeShopSalesSystem methodsFor: 'selling' stamp: 'HAW 9/22/2019 21:26:40'!
volumeSoldTo: aCustomer

	 ^(self salesMadeTo: aCustomer) sum: [ :aProduct | aProduct volume ] ifEmpty: [ 0*milliliter ]! !
!CoffeeShopSalesSystem methodsFor: 'rewarding' stamp: 'HAW 9/22/2019 19:53:42'!
rewardOf: aCustomer ifNone: noneBlock 

	| salesToCustomer volumeSoldToCustomer rewardRule |

	salesToCustomer := self salesMadeTo: aCustomer.
	volumeSoldToCustomer := self volumeSoldTo: aCustomer.
	
	rewardRule := RewardRule for: volumeSoldToCustomer ifNone: [^noneBlock value].
	^rewardRule createRewardFor: aCustomer.
	! !

!classDefinition: 'CoffeeShopSalesSystem class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'pc 7/5/2021 17:46:43'!
CoffeeShopSalesSystem class
	instanceVariableNames: ''!

!classDefinition: 'CoffeeShopSalesSystem class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'pc 7/5/2021 17:46:43'!
CoffeeShopSalesSystem class
	instanceVariableNames: ''!
!CoffeeShopSalesSystem class methodsFor: 'initialization' stamp: 'HAW 9/20/2019 17:32:54' overrides: 16883149!
initialize

	liter := BaseUnit named: 'liter'.
	milliliter := ProportionalDerivedUnit baseUnit: liter conversionFactor: 1/100 named: 'milliliter'.! !

!classDefinition: #RewardRule category: 'IngSof1-2019-2C-1Parcial' stamp: 'pc 7/5/2021 17:46:43'!
Object subclass: #RewardRule
	instanceVariableNames: 'product'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #RewardRule category: 'IngSof1-2019-2C-1Parcial' stamp: 'pc 7/5/2021 17:46:43'!
Object subclass: #RewardRule
	instanceVariableNames: 'product'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!RewardRule methodsFor: 'reward creation' stamp: 'HAW 9/22/2019 21:35:14'!
createRewardFor: aCustomer 
	
	| price |
	
	product := self rewardedProduct.
	price := aCustomer rewardPriceFor: self.
	
	^CoffeeShopReward of: product at: price quantity: self productQuantity! !
!RewardRule methodsFor: 'reward creation' stamp: 'HAW 9/22/2019 10:51:26'!
productQuantity

	self subclassResponsibility ! !
!RewardRule methodsFor: 'reward creation' stamp: 'HAW 9/22/2019 10:51:33'!
rewardedProduct

	self subclassResponsibility ! !
!RewardRule methodsFor: 'price' stamp: 'HAW 9/22/2019 21:36:18'!
rewardPriceForGoldCustomer

	self subclassResponsibility ! !
!RewardRule methodsFor: 'price' stamp: 'HAW 9/22/2019 21:36:31'!
rewardPriceForNormalCustomer

	self subclassResponsibility ! !
!RewardRule methodsFor: 'price' stamp: 'HAW 9/22/2019 21:36:26'!
rewardPriceForSilverCustomer

	self subclassResponsibility ! !

!classDefinition: 'RewardRule class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'pc 7/5/2021 17:46:43'!
RewardRule class
	instanceVariableNames: ''!

!classDefinition: 'RewardRule class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'pc 7/5/2021 17:46:43'!
RewardRule class
	instanceVariableNames: ''!
!RewardRule class methodsFor: 'testing' stamp: 'HAW 9/22/2019 19:53:22'!
isFor: volumeSoldToCustomer 
		
	self subclassResponsibility ! !
!RewardRule class methodsFor: 'instance creation' stamp: 'HAW 9/22/2019 19:53:42'!
for: volumeSoldToCustomer ifNone: aNoneBlock

	^self subclasses 
		detect: [ :aRuleClass | aRuleClass isFor: volumeSoldToCustomer ] 
		ifFound: [ :aRuleClass | aRuleClass new ]
		ifNone: aNoneBlock ! !

!classDefinition: #Combo1RewardRule category: 'IngSof1-2019-2C-1Parcial' stamp: 'pc 7/5/2021 17:46:43'!
RewardRule subclass: #Combo1RewardRule
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #Combo1RewardRule category: 'IngSof1-2019-2C-1Parcial' stamp: 'pc 7/5/2021 17:46:43'!
RewardRule subclass: #Combo1RewardRule
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!Combo1RewardRule methodsFor: 'reward creation' stamp: 'HAW 9/22/2019 19:54:35' overrides: 50905448!
productQuantity
	
	^2! !
!Combo1RewardRule methodsFor: 'reward creation' stamp: 'HAW 9/23/2019 09:00:06' overrides: 50905452!
rewardedProduct
	
	^CoffeeShopProduct combo1 ! !
!Combo1RewardRule methodsFor: 'price' stamp: 'HAW 9/22/2019 21:32:17' overrides: 50905456!
rewardPriceForGoldCustomer
	
	^ 75*peso
	! !
!Combo1RewardRule methodsFor: 'price' stamp: 'HAW 9/22/2019 21:33:50' overrides: 50905460!
rewardPriceForNormalCustomer
	
	^ 97*peso ! !
!Combo1RewardRule methodsFor: 'price' stamp: 'HAW 9/22/2019 21:33:10' overrides: 50905464!
rewardPriceForSilverCustomer

	^ 83*peso ! !

!classDefinition: 'Combo1RewardRule class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'pc 7/5/2021 17:46:43'!
Combo1RewardRule class
	instanceVariableNames: ''!

!classDefinition: 'Combo1RewardRule class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'pc 7/5/2021 17:46:43'!
Combo1RewardRule class
	instanceVariableNames: ''!
!Combo1RewardRule class methodsFor: 'testing' stamp: 'HAW 9/22/2019 19:53:22' overrides: 50905478!
isFor: volumeSoldToCustomer 

	^volumeSoldToCustomer > (500*milliliter)! !

!classDefinition: #Combo2RewardRule category: 'IngSof1-2019-2C-1Parcial' stamp: 'pc 7/5/2021 17:46:44'!
RewardRule subclass: #Combo2RewardRule
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #Combo2RewardRule category: 'IngSof1-2019-2C-1Parcial' stamp: 'pc 7/5/2021 17:46:44'!
RewardRule subclass: #Combo2RewardRule
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!Combo2RewardRule methodsFor: 'reward creation' stamp: 'HAW 9/22/2019 10:23:07' overrides: 50905448!
productQuantity

	^1! !
!Combo2RewardRule methodsFor: 'reward creation' stamp: 'HAW 9/23/2019 09:01:14' overrides: 50905452!
rewardedProduct
	
	^CoffeeShopProduct combo2 ! !
!Combo2RewardRule methodsFor: 'price' stamp: 'HAW 9/22/2019 21:34:38' overrides: 50905456!
rewardPriceForGoldCustomer
	
	^product price/2 
	! !
!Combo2RewardRule methodsFor: 'price' stamp: 'HAW 9/22/2019 21:35:06' overrides: 50905460!
rewardPriceForNormalCustomer
	
	^product price *9/10! !
!Combo2RewardRule methodsFor: 'price' stamp: 'HAW 9/22/2019 21:34:53' overrides: 50905464!
rewardPriceForSilverCustomer
	
	^product price*3/4
	! !

!classDefinition: 'Combo2RewardRule class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'pc 7/5/2021 17:46:44'!
Combo2RewardRule class
	instanceVariableNames: ''!

!classDefinition: 'Combo2RewardRule class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'pc 7/5/2021 17:46:44'!
Combo2RewardRule class
	instanceVariableNames: ''!
!Combo2RewardRule class methodsFor: 'testing' stamp: 'HAW 9/22/2019 19:53:22' overrides: 50905478!
isFor: volumeSoldToCustomer 

	^volumeSoldToCustomer between: 300*milliliter and: 500*milliliter
	! !

!classRemoval: #Trailer stamp: 'pc 7/5/2021 17:46:44'!
Object subclass: #Trailer
	instanceVariableNames: 'weightCapacity heightCapacity container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classRemoval: #Robot stamp: 'pc 7/5/2021 17:46:45'!
Object subclass: #Robot
	instanceVariableNames: 'status trailer'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classRemoval: #ProductB stamp: 'pc 7/5/2021 17:46:45'!
Product subclass: #ProductB
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classRemoval: #ProductA stamp: 'pc 7/5/2021 17:46:45'!
Product subclass: #ProductA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classRemoval: #Product stamp: 'pc 7/5/2021 17:46:46'!
Object subclass: #Product
	instanceVariableNames: 'weight height'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classRemoval: #Cashier stamp: 'pc 7/5/2021 17:46:46'!
Object subclass: #Cashier
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classRemoval: #TrailerTest stamp: 'pc 7/5/2021 17:46:47'!
TestCase subclass: #TrailerTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classRemoval: #RobotTest stamp: 'pc 7/5/2021 17:46:47'!
TestCase subclass: #RobotTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classRemoval: #ProductTest stamp: 'pc 7/5/2021 17:46:48'!
TestCase subclass: #ProductTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classRemoval: #CashierTest stamp: 'pc 7/5/2021 17:46:48'!
TestCase subclass: #CashierTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #CashierTest category: 'ISW1-2020-1C-Parcial-Solucion' stamp: 'pc 7/5/2021 17:46:48'!
TestCase subclass: #CashierTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Solucion'!

!classDefinition: #CashierTest category: 'ISW1-2020-1C-Parcial-Solucion' stamp: 'pc 7/5/2021 17:46:48'!
TestCase subclass: #CashierTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Solucion'!
!CashierTest methodsFor: 'receiving from empty trailer' stamp: 'FRT 5/4/2020 11:45:58'!
shouldRaise: errorMessage when: aBlock

	| aRobot aTrailer aCashier |
	
	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot with: aTrailer.
	
	aCashier := Cashier new.

	self
		should: [ aBlock value: aRobot value: aCashier ]
		raise: Error
		withMessageText: errorMessage.
! !
!CashierTest methodsFor: 'receiving from empty trailer' stamp: 'FRT 5/4/2020 11:47:39'!
test01ShouldNotAcceptEmptyTrailerFromNormalWorkingRobot

	self 
		shouldRaise: Cashier trailerIsEmptyErrorDescription 
		when: [ :aRobot :aCashier | aCashier receiveOrderFromNormal: aRobot ]
! !
!CashierTest methodsFor: 'receiving from empty trailer' stamp: 'FRT 6/11/2020 17:02:13'!
test02ShouldNotAcceptEmptyTrailerFromMechanicalFailureRobot

	self 
		shouldRaise: Cashier trailerIsEmptyErrorDescription 
		when: [ :aRobot :aCashier | 
			aRobot withMechanicalFailure.
			aCashier receiveOrderFromMechanicalFailure: aRobot 
		]
! !
!CashierTest methodsFor: 'receiving from sensors failure robot' stamp: 'F 5/5/2020 11:22:18'!
test03ShouldNotAcceptSensorsFailureRobot

	self 
		shouldRaise: Cashier robotSensorsFailureErrorDescription 
		when: [ :aRobot :aCashier | 
			aRobot withSensorsFailure.
			aCashier receiveOrderFromSensorsFailure: aRobot 
		]
! !
!CashierTest methodsFor: 'receiving from mechanical failure robot' stamp: 'F 5/20/2020 23:55:01'!
test04ShouldChangeRobotStatusToOutOfOrderWhenMechanicalFailureRobot

	self 
		shouldRaise: Robot outOfOrderErrorDescription
		when: [ :aRobot :aCashier |
			aRobot take: (ProductA with: 1  and: 1).
			aRobot withMechanicalFailure.
			
			aCashier receiveOrderFromMechanicalFailure: aRobot.			
			
			aRobot take: (ProductA with: 1 and: 1).
		]
! !

!classDefinition: #ProductTest category: 'ISW1-2020-1C-Parcial-Solucion' stamp: 'pc 7/5/2021 17:46:48'!
TestCase subclass: #ProductTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Solucion'!

!classDefinition: #ProductTest category: 'ISW1-2020-1C-Parcial-Solucion' stamp: 'pc 7/5/2021 17:46:48'!
TestCase subclass: #ProductTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Solucion'!
!ProductTest methodsFor: 'instance creation' stamp: 'FRT 5/4/2020 17:51:50'!
test01CanNotCreateProductWithCeroOrLessWeight

	self
		should: [ ProductA with: 0  and: 100 ]
		raise: Error
		withMessageText: Product invalidWeightErrorDescription 
! !
!ProductTest methodsFor: 'instance creation' stamp: 'FRT 5/4/2020 17:53:22'!
test02CanNotCreateProductWithCeroOrLessHeight

	self
		should: [ ProductA with: 100  and: 0 ]
		raise: Error
		withMessageText: Product invalidHeightErrorDescription 
! !
!ProductTest methodsFor: 'instance creation' stamp: 'FRT 5/4/2020 17:54:48'!
test03CanNotCreateProductWithNoIntegerWeight

	self
		should: [ Product with: 1.5  and: 100 ]
		raise: Error
		withMessageText: Product weightMustBeIntegerErrorDescription 

! !
!ProductTest methodsFor: 'instance creation' stamp: 'FRT 5/4/2020 17:55:14'!
test04CanNotCreateProductWithNoIntegerHeight

	self
		should: [ Product with: 100  and: 1.5 ]
		raise: Error
		withMessageText: Product heightMustBeIntegerErrorDescription 

! !

!classDefinition: #RobotTest category: 'ISW1-2020-1C-Parcial-Solucion' stamp: 'pc 7/5/2021 17:46:48'!
TestCase subclass: #RobotTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Solucion'!

!classDefinition: #RobotTest category: 'ISW1-2020-1C-Parcial-Solucion' stamp: 'pc 7/5/2021 17:46:48'!
TestCase subclass: #RobotTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Solucion'!
!RobotTest methodsFor: 'instance creation' stamp: 'FRT 5/4/2020 11:29:44'!
test01ShouldReceiveAnEmptyTrailer

	| aTrailer |

	aTrailer := Trailer with: 20 and: 100.
	aTrailer carry: (ProductA with: 1  and: 1).
	
	self
		should: [ Robot with: aTrailer ]
		raise: Error
		withMessageText: Robot notEmptyTrailerErrorDescription! !
!RobotTest methodsFor: 'taking products' stamp: 'FRT 5/4/2020 11:04:57'!
test02ShouldTakeProductsWhenWorkingNormal

	| aTrailer aRobot |

	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot with: aTrailer.
	
	aRobot take: (ProductA with: 1  and: 1).
	
	self assert: 1 equals: aTrailer totalProductsAmount! !
!RobotTest methodsFor: 'taking products' stamp: 'FRT 5/4/2020 11:07:49'!
test03ShouldTakeProductsWhenWorkingWithSensorsFailures

	| aTrailer aRobot |

	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot with: aTrailer.
	aRobot withSensorsFailure.
	
	aRobot take: (ProductA with: 1  and: 1).
	
	self assert: 1 equals: aTrailer totalProductsAmount! !
!RobotTest methodsFor: 'taking products' stamp: 'FRT 5/4/2020 11:08:34'!
test04ShouldTakeProductsWhenWorkingWithMechanicalFailures

	| aTrailer aRobot |

	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot with: aTrailer.
	aRobot withMechanicalFailure.
	
	aRobot take: (ProductA with: 1  and: 1).
	
	self assert: 1 equals: aTrailer totalProductsAmount! !
!RobotTest methodsFor: 'taking products' stamp: 'F 5/5/2020 11:19:12'!
test05ShouldNotTakeProductsWhenOutOfOrder

	| aTrailer aRobot |

	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot with: aTrailer.
	aRobot outOfOrder.
	
	self
		should: [ aRobot take: (ProductA with: 1  and: 1) ]
		raise: Error
		withMessageText: Robot outOfOrderErrorDescription.
	
	self assert: 0 equals: aTrailer totalProductsAmount! !
!RobotTest methodsFor: 'closing order' stamp: 'FRT 5/4/2020 12:46:40'!
test06CanCloseOrderWhenWorkingNormal

	| aTrailer aRobot |

	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot with: aTrailer.
	aRobot take: (ProductA with: 1  and: 1).
	
	self assert: (aRobot closeOrderUsing: Cashier new)! !
!RobotTest methodsFor: 'closing order' stamp: 'FRT 5/4/2020 11:28:16'!
test07CanNotCloseOrderWhenWorkingWithSensorsFailures

	| aTrailer aRobot |

	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot with: aTrailer.
	aRobot take: (ProductA with: 1  and: 1).
	
	aRobot withSensorsFailure.

	self
		should: [ aRobot closeOrderUsing: Cashier new ]
		raise: Error
		withMessageText: Cashier robotSensorsFailureErrorDescription.
 
! !
!RobotTest methodsFor: 'closing order' stamp: 'FRT 5/4/2020 12:47:10'!
test08CanCloseOrderWhenWorkingWithMechanicalFailures

	| aTrailer aRobot |

	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot with: aTrailer.
	aRobot take: (ProductA with: 1  and: 1).

	aRobot withMechanicalFailure.	
		
	self assert: (aRobot closeOrderUsing: Cashier new).! !
!RobotTest methodsFor: 'closing order' stamp: 'F 5/5/2020 11:19:17'!
test09CanNotCloseOrderWhenOutOfOrder

	| aTrailer aRobot |

	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot with: aTrailer.
	aRobot take: (ProductA with: 1  and: 1).
	
	aRobot outOfOrder.

	self
		should: [ aRobot closeOrderUsing: Cashier new ]
		raise: Error
		withMessageText: Robot outOfOrderErrorDescription.
 
! !

!classDefinition: #TrailerTest category: 'ISW1-2020-1C-Parcial-Solucion' stamp: 'pc 7/5/2021 17:46:49'!
TestCase subclass: #TrailerTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Solucion'!

!classDefinition: #TrailerTest category: 'ISW1-2020-1C-Parcial-Solucion' stamp: 'pc 7/5/2021 17:46:49'!
TestCase subclass: #TrailerTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Solucion'!
!TrailerTest methodsFor: 'weight capacity' stamp: 'HAW 6/7/2020 15:14:57'!
shouldAcceptProducts: aTrailerBlock withAmount: anExpectedAmount andWeight: anExpectedWeight  

	| aTrailer |
	aTrailer := Trailer with: 11  and: 100.
	
	aTrailer carry: (ProductA with: 1 and: 1).
	aTrailer carry: (ProductA with: 2 and: 1).
	aTrailer carry: (ProductB with: 3 and: 1).
	aTrailer carry: (ProductB with: 4 and: 1).
	aTrailerBlock value: aTrailer.
		
	self assert: aTrailer totalProductsAmount equals: anExpectedAmount.
	self assert: aTrailer totalProductsWeight equals: anExpectedWeight ! !
!TrailerTest methodsFor: 'weight capacity' stamp: 'HAW 6/7/2020 16:47:37'!
shouldSignalMaxWeightExceededErrorDescriptionWhenAdding: aProductType

	| aTrailer |
	aTrailer := Trailer with: 20  and: 100.
	
	self
		should: [ aTrailer carry: (aProductType with: 21 and: 1)]
		raise: Error
		withMessageText: Trailer maxWeightExceededErrorDescription.
		
	self assert: aTrailer isEmpty! !
!TrailerTest methodsFor: 'weight capacity' stamp: 'FRT 5/4/2020 17:29:39'!
test01CanNotCreateTrailerWithCeroOrLessMaxWeight

	self
		should: [ Trailer with: 0  and: 100 ]
		raise: Error
		withMessageText: Trailer invalidWeightCapacityErrorDescription 
! !
!TrailerTest methodsFor: 'weight capacity' stamp: 'FRT 5/4/2020 17:30:47'!
test02CanNotCreateTrailerWithCeroOrLessMaxHeight

	self
		should: [ Trailer with: 1  and: 0 ]
		raise: Error
		withMessageText: Trailer invalidHeightCapacityErrorDescription 
! !
!TrailerTest methodsFor: 'weight capacity' stamp: 'FRT 5/4/2020 17:41:04'!
test03CanNotCreateTrailerWithNoIntegerMaxWeight

	self
		should: [ Trailer with: 1.5  and: 100 ]
		raise: Error
		withMessageText: Trailer weightCapacityMustBeIntegerErrorDescription 
! !
!TrailerTest methodsFor: 'weight capacity' stamp: 'FRT 5/4/2020 17:41:29'!
test04CanNotCreateTrailerWithNoIntegerMaxHeight

	self
		should: [ Trailer with: 100  and: 1.5 ]
		raise: Error
		withMessageText: Trailer heightCapacityMustBeIntegerErrorDescription 
! !
!TrailerTest methodsFor: 'weight capacity' stamp: 'HAW 6/7/2020 16:46:28'!
test05ShouldRejectProductAIfWeightExceeded

	self shouldSignalMaxWeightExceededErrorDescriptionWhenAdding: ProductA ! !
!TrailerTest methodsFor: 'weight capacity' stamp: 'HAW 6/7/2020 16:45:53'!
test06ShouldRejectProductBIfWeightExceeded

	self shouldSignalMaxWeightExceededErrorDescriptionWhenAdding: ProductB
	! !
!TrailerTest methodsFor: 'weight capacity' stamp: 'HAW 6/7/2020 15:14:15'!
test07ShouldAcceptProductsIfWeightUnderMaxWeightCapacity

	self shouldAcceptProducts: [ :trailer | ] withAmount: 4 andWeight: 10.! !
!TrailerTest methodsFor: 'weight capacity' stamp: 'HAW 6/7/2020 15:15:27'!
test08ShouldAcceptProductsIfWeightEqualsMaxWeightCapacity

	self shouldAcceptProducts: [ :trailer | trailer carry: (ProductB with: 1 and: 1).] withAmount: 5 andWeight: 11.
! !
!TrailerTest methodsFor: 'height capacity' stamp: 'HAW 6/7/2020 15:25:07'!
assertHeightShouldBe: anExpectedHeightBlock whenAdding: aProductTypeToAdd 

	| aTrailer heightCapacity exceededHeightCapacity halfExceededHeightCapacity |

	heightCapacity := 100.
	aTrailer := Trailer with: 20  and: heightCapacity.
	
	exceededHeightCapacity := heightCapacity + 2.
	halfExceededHeightCapacity := exceededHeightCapacity / 2.
	
	aTrailer carry: (ProductA with: 10 and: halfExceededHeightCapacity).
	aTrailer carry: (aProductTypeToAdd with: 10 and: halfExceededHeightCapacity).
	
	self assert: aTrailer totalProductsAmount equals: 2.
	self assert: aTrailer totalProductsHeight equals: (anExpectedHeightBlock value: halfExceededHeightCapacity)! !
!TrailerTest methodsFor: 'height capacity' stamp: 'FRT 6/11/2020 16:54:16'!
test09ShouldAcceptNonStackableProductsIgnoringHeightCapacity

	self assertHeightShouldBe: [ :aHeight | 0 ] whenAdding: ProductA! !
!TrailerTest methodsFor: 'height capacity' stamp: 'FRT 6/11/2020 17:00:21'!
test10ShouldIgnoreNonStackableProductsWhenAddingStackableProduct

	self assertHeightShouldBe: [ :aHeight | aHeight ] whenAdding: ProductB! !
!TrailerTest methodsFor: 'height capacity' stamp: 'FRT 6/11/2020 16:58:06'!
test11ShouldRejectStackableProductExceedingHeightCapacity

	| aTrailer heightCapacity exceededHeightCapacity halfExceededHeightCapacity |

	heightCapacity := 100.
	aTrailer := Trailer with: 20  and: heightCapacity.
	
	exceededHeightCapacity := heightCapacity + 2.
	halfExceededHeightCapacity := exceededHeightCapacity / 2.
	
	aTrailer carry: (ProductB with: 10 and: halfExceededHeightCapacity).

	self 
		should: [aTrailer carry: (ProductB with: 10 and: halfExceededHeightCapacity)] 
		raise: Error
		withMessageText: Trailer maxHeightExceededErrorDescription.
	
	self assert: aTrailer totalProductsAmount equals: 1.
	self assert: aTrailer totalProductsHeight equals: halfExceededHeightCapacity.
	! !

!classDefinition: #Cashier category: 'ISW1-2020-1C-Parcial-Solucion' stamp: 'pc 7/5/2021 17:46:49'!
Object subclass: #Cashier
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Solucion'!

!classDefinition: #Cashier category: 'ISW1-2020-1C-Parcial-Solucion' stamp: 'pc 7/5/2021 17:46:49'!
Object subclass: #Cashier
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Solucion'!
!Cashier methodsFor: 'accept buy order' stamp: 'F 5/14/2020 11:01:58'!
acceptProductsFrom: aRobot

	| aTrailer |

	aTrailer := aRobot trailer.	
	self assertTrailerNotEmpty: aTrailer.
		
	"Comentario: en este punto el cashier realizar�a el checkout de los productos."

	^ true! !
!Cashier methodsFor: 'receiving buy order' stamp: 'FRT 5/4/2020 11:19:10'!
receiveOrderFromMechanicalFailure: aRobot
	
	aRobot outOfOrder.
	^ self acceptProductsFrom: aRobot.! !
!Cashier methodsFor: 'receiving buy order' stamp: 'FRT 5/4/2020 11:19:01'!
receiveOrderFromNormal: aRobot
	
	^ self acceptProductsFrom: aRobot! !
!Cashier methodsFor: 'receiving buy order' stamp: 'FRT 5/3/2020 23:01:39'!
receiveOrderFromSensorsFailure: aRobot
	
	aRobot outOfOrder.
	self signalRobotSensorsFailure! !
!Cashier methodsFor: 'assertions' stamp: 'FRT 5/4/2020 11:17:52'!
assertTrailerNotEmpty: aTrailer
	
	aTrailer isEmpty ifTrue: [self signalTrailerIsEmpty]! !
!Cashier methodsFor: 'exceptions' stamp: 'FRT 5/4/2020 11:28:03'!
signalRobotSensorsFailure
	
	self error: self class robotSensorsFailureErrorDescription! !
!Cashier methodsFor: 'exceptions' stamp: 'FRT 5/4/2020 11:28:31'!
signalTrailerIsEmpty
	
	self error: self class trailerIsEmptyErrorDescription! !

!classDefinition: 'Cashier class' category: 'ISW1-2020-1C-Parcial-Solucion' stamp: 'pc 7/5/2021 17:46:50'!
Cashier class
	instanceVariableNames: ''!

!classDefinition: 'Cashier class' category: 'ISW1-2020-1C-Parcial-Solucion' stamp: 'pc 7/5/2021 17:46:50'!
Cashier class
	instanceVariableNames: ''!
!Cashier class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 11:28:03'!
robotSensorsFailureErrorDescription
	
	^ 'This robot presents sensors failures!!'! !
!Cashier class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 11:28:31'!
trailerIsEmptyErrorDescription
	
	^ 'This robots trailer is empty!!'! !

!classDefinition: #Product category: 'ISW1-2020-1C-Parcial-Solucion' stamp: 'pc 7/5/2021 17:46:50'!
Object subclass: #Product
	instanceVariableNames: 'weight height'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Solucion'!

!classDefinition: #Product category: 'ISW1-2020-1C-Parcial-Solucion' stamp: 'pc 7/5/2021 17:46:50'!
Object subclass: #Product
	instanceVariableNames: 'weight height'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Solucion'!
!Product methodsFor: 'instance creation' stamp: 'FRT 5/4/2020 10:39:55'!
initializeWith: aWeight and: aHeight
	
	weight := aWeight.
	height := aHeight.! !
!Product methodsFor: 'action' stamp: 'FRT 5/4/2020 10:38:22'!
carryBy: aTrailer	
	
	self subclassResponsibility! !
!Product methodsFor: 'testing' stamp: 'FRT 5/4/2020 10:39:06'!
isStackable
	
	self subclassResponsibility! !
!Product methodsFor: 'accessing' stamp: 'FRT 5/4/2020 10:43:30'!
height
	
	^ height! !
!Product methodsFor: 'accessing' stamp: 'FRT 5/4/2020 10:43:24'!
weight
	
	^ weight! !

!classDefinition: 'Product class' category: 'ISW1-2020-1C-Parcial-Solucion' stamp: 'pc 7/5/2021 17:46:50'!
Product class
	instanceVariableNames: ''!

!classDefinition: 'Product class' category: 'ISW1-2020-1C-Parcial-Solucion' stamp: 'pc 7/5/2021 17:46:50'!
Product class
	instanceVariableNames: ''!
!Product class methodsFor: 'instance creation' stamp: 'FRT 5/4/2020 17:47:40'!
with: aWeight and: aHeight
	
	aWeight strictlyPositive ifFalse: [ self signalInvalidWeight ].
	aHeight strictlyPositive ifFalse: [ self signalInvalidHeight ].

	aWeight isInteger ifFalse: [ self signalWeightMustBeInteger ].
	aHeight isInteger ifFalse: [ self signalHeightMustBeInteger ].
	
	^ self new initializeWith: aWeight and: aHeight! !
!Product class methodsFor: 'exceptions' stamp: 'FRT 5/4/2020 17:48:22'!
signalHeightMustBeInteger

	self error: self heightMustBeIntegerErrorDescription! !
!Product class methodsFor: 'exceptions' stamp: 'FRT 5/4/2020 11:29:08'!
signalInvalidHeight

	self error: self invalidHeightErrorDescription! !
!Product class methodsFor: 'exceptions' stamp: 'FRT 5/4/2020 11:29:18'!
signalInvalidWeight

	self error: self invalidWeightErrorDescription! !
!Product class methodsFor: 'exceptions' stamp: 'FRT 5/4/2020 17:48:12'!
signalWeightMustBeInteger

	self error: self weightMustBeIntegerErrorDescription! !
!Product class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 17:49:16'!
heightMustBeIntegerErrorDescription

	^ 'Height must be integer'! !
!Product class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 11:29:08'!
invalidHeightErrorDescription

	^ 'Height must be positive'! !
!Product class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 11:29:18'!
invalidWeightErrorDescription

	^ 'Weight must be positive'! !
!Product class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 17:49:08'!
weightMustBeIntegerErrorDescription

	^ 'Weight must be integer'! !

!classDefinition: #ProductA category: 'ISW1-2020-1C-Parcial-Solucion' stamp: 'pc 7/5/2021 17:46:50'!
Product subclass: #ProductA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Solucion'!

!classDefinition: #ProductA category: 'ISW1-2020-1C-Parcial-Solucion' stamp: 'pc 7/5/2021 17:46:50'!
Product subclass: #ProductA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Solucion'!
!ProductA methodsFor: 'testing' stamp: 'FRT 5/4/2020 10:41:29' overrides: 50906190!
isStackable

	^ false! !
!ProductA methodsFor: 'action' stamp: 'FRT 5/4/2020 10:41:12' overrides: 50906186!
carryBy: aTrailer

	aTrailer carryProductA: self! !

!classDefinition: #ProductB category: 'ISW1-2020-1C-Parcial-Solucion' stamp: 'pc 7/5/2021 17:46:50'!
Product subclass: #ProductB
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Solucion'!

!classDefinition: #ProductB category: 'ISW1-2020-1C-Parcial-Solucion' stamp: 'pc 7/5/2021 17:46:50'!
Product subclass: #ProductB
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Solucion'!
!ProductB methodsFor: 'testing' stamp: 'FRT 5/4/2020 10:42:28' overrides: 50906190!
isStackable

	^ true! !
!ProductB methodsFor: 'action' stamp: 'FRT 5/4/2020 10:42:16' overrides: 50906186!
carryBy: aTrailer

	aTrailer carryProductB: self! !

!classDefinition: #Robot category: 'ISW1-2020-1C-Parcial-Solucion' stamp: 'pc 7/5/2021 17:46:50'!
Object subclass: #Robot
	instanceVariableNames: 'status trailer'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Solucion'!

!classDefinition: #Robot category: 'ISW1-2020-1C-Parcial-Solucion' stamp: 'pc 7/5/2021 17:46:50'!
Object subclass: #Robot
	instanceVariableNames: 'status trailer'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Solucion'!
!Robot methodsFor: 'actions' stamp: 'HAW 6/7/2020 15:33:01'!
closeOrderUsing: aCashier

	^ status closeOrderUsing: aCashier! !
!Robot methodsFor: 'actions' stamp: 'FRT 5/3/2020 22:40:35'!
take: aProduct

	status take: aProduct! !
!Robot methodsFor: 'status' stamp: 'FRT 5/3/2020 22:42:57'!
outOfOrder

	status := OutOfOrder for: self
! !
!Robot methodsFor: 'status' stamp: 'FRT 5/3/2020 22:50:41'!
withMechanicalFailure

	status := MechanicalFailure for: self
! !
!Robot methodsFor: 'status' stamp: 'FRT 5/3/2020 22:50:45'!
withSensorsFailure

	status := SensorsFailure for: self
! !
!Robot methodsFor: 'accessing' stamp: 'FRT 5/3/2020 21:27:04'!
trailer

	^ trailer
! !
!Robot methodsFor: 'initialization' stamp: 'FRT 5/4/2020 11:05:43'!
initializeWith: aTrailer

	trailer := aTrailer.
	status := WorkingNormal for: self.
! !
!Robot methodsFor: 'status related' stamp: 'FRT 5/3/2020 22:41:23'!
carry: aProduct

	trailer carry: aProduct! !

!classDefinition: 'Robot class' category: 'ISW1-2020-1C-Parcial-Solucion' stamp: 'pc 7/5/2021 17:46:51'!
Robot class
	instanceVariableNames: ''!

!classDefinition: 'Robot class' category: 'ISW1-2020-1C-Parcial-Solucion' stamp: 'pc 7/5/2021 17:46:51'!
Robot class
	instanceVariableNames: ''!
!Robot class methodsFor: 'instance creation' stamp: 'FRT 5/3/2020 22:36:52'!
with: aTrailer

	self assertIsEmpty: aTrailer.

	^ self new initializeWith: aTrailer! !
!Robot class methodsFor: 'assertions' stamp: 'FRT 5/3/2020 22:35:35'!
assertIsEmpty: aTrailer

	^ aTrailer isEmpty ifFalse: [ self signalNotEmptyTrailer ]! !
!Robot class methodsFor: 'assertions' stamp: 'FRT 5/4/2020 11:29:32'!
signalNotEmptyTrailer

	self error: self notEmptyTrailerErrorDescription! !
!Robot class methodsFor: 'assertions' stamp: 'F 5/5/2020 11:17:36'!
signalOutOfOrder
	
	self error: self outOfOrderErrorDescription! !
!Robot class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 11:29:32'!
notEmptyTrailerErrorDescription

	^ 'The robot was assigned a non empty trailer'! !
!Robot class methodsFor: 'error messages' stamp: 'F 5/5/2020 11:18:28'!
outOfOrderErrorDescription
	
	^ 'Robot out of order :('! !

!classDefinition: #RobotStatus category: 'ISW1-2020-1C-Parcial-Solucion' stamp: 'pc 7/5/2021 17:46:51'!
Object subclass: #RobotStatus
	instanceVariableNames: 'robot'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Solucion'!

!classDefinition: #RobotStatus category: 'ISW1-2020-1C-Parcial-Solucion' stamp: 'pc 7/5/2021 17:46:51'!
Object subclass: #RobotStatus
	instanceVariableNames: 'robot'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Solucion'!
!RobotStatus methodsFor: 'initialization' stamp: 'FRT 5/3/2020 21:32:00'!
initializeWith: aRobot

	robot := aRobot! !
!RobotStatus methodsFor: 'robot actions' stamp: 'FRT 6/12/2020 10:35:01'!
closeOrderUsing: aCashier

	self subclassResponsibility! !
!RobotStatus methodsFor: 'robot actions' stamp: 'FRT 5/3/2020 21:38:22'!
take: aProduct

	self subclassResponsibility! !

!classDefinition: 'RobotStatus class' category: 'ISW1-2020-1C-Parcial-Solucion' stamp: 'pc 7/5/2021 17:46:51'!
RobotStatus class
	instanceVariableNames: ''!

!classDefinition: 'RobotStatus class' category: 'ISW1-2020-1C-Parcial-Solucion' stamp: 'pc 7/5/2021 17:46:51'!
RobotStatus class
	instanceVariableNames: ''!
!RobotStatus class methodsFor: 'instance creation' stamp: 'FRT 5/3/2020 21:30:55'!
for: aRobot
	
	^ self new initializeWith: aRobot! !

!classDefinition: #MechanicalFailure category: 'ISW1-2020-1C-Parcial-Solucion' stamp: 'pc 7/5/2021 17:46:51'!
RobotStatus subclass: #MechanicalFailure
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Solucion'!

!classDefinition: #MechanicalFailure category: 'ISW1-2020-1C-Parcial-Solucion' stamp: 'pc 7/5/2021 17:46:51'!
RobotStatus subclass: #MechanicalFailure
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Solucion'!
!MechanicalFailure methodsFor: 'robot actions' stamp: 'FRT 5/3/2020 22:46:51' overrides: 50906418!
closeOrderUsing: aCashier
	
	^ aCashier receiveOrderFromMechanicalFailure: robot
	! !
!MechanicalFailure methodsFor: 'robot actions' stamp: 'FRT 5/3/2020 21:44:39' overrides: 50906423!
take: aProduct
	
	robot carry: aProduct! !

!classDefinition: #OutOfOrder category: 'ISW1-2020-1C-Parcial-Solucion' stamp: 'pc 7/5/2021 17:46:51'!
RobotStatus subclass: #OutOfOrder
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Solucion'!

!classDefinition: #OutOfOrder category: 'ISW1-2020-1C-Parcial-Solucion' stamp: 'pc 7/5/2021 17:46:51'!
RobotStatus subclass: #OutOfOrder
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Solucion'!
!OutOfOrder methodsFor: 'as yet unclassified' stamp: 'F 5/5/2020 11:20:34' overrides: 50906418!
closeOrderUsing: aCashier
	
	Robot signalOutOfOrder! !
!OutOfOrder methodsFor: 'as yet unclassified' stamp: 'HAW 6/7/2020 15:32:51' overrides: 50906423!
take: aProduct
	
	Robot signalOutOfOrder! !

!classDefinition: #SensorsFailure category: 'ISW1-2020-1C-Parcial-Solucion' stamp: 'pc 7/5/2021 17:46:51'!
RobotStatus subclass: #SensorsFailure
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Solucion'!

!classDefinition: #SensorsFailure category: 'ISW1-2020-1C-Parcial-Solucion' stamp: 'pc 7/5/2021 17:46:51'!
RobotStatus subclass: #SensorsFailure
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Solucion'!
!SensorsFailure methodsFor: 'robot actions' stamp: 'FRT 5/3/2020 22:45:54' overrides: 50906418!
closeOrderUsing: aCashier
	
	^ aCashier receiveOrderFromSensorsFailure: robot! !
!SensorsFailure methodsFor: 'robot actions' stamp: 'FRT 5/3/2020 21:43:35' overrides: 50906423!
take: aProduct
	
	robot carry: aProduct! !

!classDefinition: #WorkingNormal category: 'ISW1-2020-1C-Parcial-Solucion' stamp: 'pc 7/5/2021 17:46:51'!
RobotStatus subclass: #WorkingNormal
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Solucion'!

!classDefinition: #WorkingNormal category: 'ISW1-2020-1C-Parcial-Solucion' stamp: 'pc 7/5/2021 17:46:51'!
RobotStatus subclass: #WorkingNormal
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Solucion'!
!WorkingNormal methodsFor: 'robot actions' stamp: 'FRT 5/3/2020 22:45:19' overrides: 50906418!
closeOrderUsing: aCashier
	
	^ aCashier receiveOrderFromNormal: robot! !
!WorkingNormal methodsFor: 'robot actions' stamp: 'FRT 5/3/2020 21:41:15' overrides: 50906423!
take: aProduct
	
	robot carry: aProduct! !

!classDefinition: #Trailer category: 'ISW1-2020-1C-Parcial-Solucion' stamp: 'pc 7/5/2021 17:46:51'!
Object subclass: #Trailer
	instanceVariableNames: 'weightCapacity heightCapacity container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Solucion'!

!classDefinition: #Trailer category: 'ISW1-2020-1C-Parcial-Solucion' stamp: 'pc 7/5/2021 17:46:51'!
Object subclass: #Trailer
	instanceVariableNames: 'weightCapacity heightCapacity container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Solucion'!
!Trailer methodsFor: 'initialization' stamp: 'FRT 5/3/2020 23:27:42'!
initializeWith: aWeightCapacity and: aHeightCapacity

	weightCapacity := aWeightCapacity.
	heightCapacity := aHeightCapacity.
	
	container := OrderedCollection new.! !
!Trailer methodsFor: 'accesing totals' stamp: 'HAW 6/7/2020 13:34:29'!
total: aContainer using: aBlock
	
	^ aContainer sum: [ :aProduct |  (aBlock value: aProduct) ] ifEmpty: [ 0 ]! !
!Trailer methodsFor: 'accesing totals' stamp: 'FRT 5/4/2020 10:28:36'!
totalHeight: aContainer

	^ self total: aContainer using: [ :aProduct | aProduct height ]! !
!Trailer methodsFor: 'accesing totals' stamp: 'FRT 5/4/2020 10:28:15'!
totalWeight: aContainer

	^ self total: aContainer using: [ :aProduct | aProduct weight ]! !
!Trailer methodsFor: 'accessing' stamp: 'FRT 5/3/2020 23:34:36'!
totalProductsAmount
	
	^ container size.! !
!Trailer methodsFor: 'accessing' stamp: 'F 5/5/2020 11:14:31'!
totalProductsHeight
	"Solo importa la altura de los productos apilables"
	
	^ self totalHeight: (container select: [ :aProduct | aProduct isStackable])! !
!Trailer methodsFor: 'accessing' stamp: 'F 5/5/2020 11:14:17'!
totalProductsWeight
	
	^ self totalWeight: container.! !
!Trailer methodsFor: 'testing' stamp: 'FRT 5/3/2020 23:33:33'!
isEmpty
	
	^ container isEmpty! !
!Trailer methodsFor: 'action' stamp: 'FRT 5/4/2020 10:17:59'!
add: aProduct asserting: aBlock

	aBlock value.
	container add: aProduct.! !
!Trailer methodsFor: 'action' stamp: 'FRT 5/3/2020 23:35:19'!
carry: aProduct
	
	^ aProduct carryBy: self.! !
!Trailer methodsFor: 'action' stamp: 'FRT 5/4/2020 10:19:42'!
carryProductA: aProduct
	
	self add: aProduct 
		 asserting: [ 
			self assertWeightAdding: aProduct.
	 	 ]
	! !
!Trailer methodsFor: 'action' stamp: 'FRT 5/4/2020 10:50:33'!
carryProductB: aProduct

	self add: aProduct 
		 asserting: [ 
			self assertWeightAdding: aProduct.
			self assertHeightAdding: aProduct.
	 	 ]
! !
!Trailer methodsFor: 'assertions' stamp: 'F 5/5/2020 11:14:31'!
assertHeightAdding: aProduct
	
	(self totalProductsHeight + aProduct height) > heightCapacity ifTrue: [ self signalMaxHeightCapacityExceeded ]! !
!Trailer methodsFor: 'assertions' stamp: 'F 5/5/2020 11:14:17'!
assertWeightAdding: aProduct
	
	(self totalProductsWeight + aProduct weight) > weightCapacity ifTrue: [ self signalMaxWeightCapacityExceeded ]! !
!Trailer methodsFor: 'exceptions' stamp: 'FRT 5/4/2020 11:30:31'!
signalMaxHeightCapacityExceeded

	self error: self class maxHeightExceededErrorDescription
! !
!Trailer methodsFor: 'exceptions' stamp: 'FRT 5/4/2020 11:30:38'!
signalMaxWeightCapacityExceeded

	self error: self class maxWeightExceededErrorDescription
! !

!classDefinition: 'Trailer class' category: 'ISW1-2020-1C-Parcial-Solucion' stamp: 'pc 7/5/2021 17:46:52'!
Trailer class
	instanceVariableNames: ''!

!classDefinition: 'Trailer class' category: 'ISW1-2020-1C-Parcial-Solucion' stamp: 'pc 7/5/2021 17:46:52'!
Trailer class
	instanceVariableNames: ''!
!Trailer class methodsFor: 'instance creation' stamp: 'FRT 5/4/2020 17:33:58'!
with: aWeightCapacity and: aHeightCapacity

	aWeightCapacity strictlyPositive ifFalse: [ self signalInvalidWeightCapacity ].
	aHeightCapacity strictlyPositive ifFalse: [ self signalInvalidHeightCapacity ].
	
	aWeightCapacity isInteger ifFalse: [ self signalWeightCapacityMustBeInteger ].
	aHeightCapacity isInteger ifFalse: [ self signalHeightCapacityMustBeInteger ].
		
	^ self new initializeWith: aWeightCapacity and: aHeightCapacity.

! !
!Trailer class methodsFor: 'exceptions' stamp: 'FRT 5/4/2020 17:37:41'!
signalHeightCapacityMustBeInteger

	self error: self heightCapacityMustBeIntegerErrorDescription
! !
!Trailer class methodsFor: 'exceptions' stamp: 'FRT 5/4/2020 11:30:12'!
signalInvalidHeightCapacity

	self error: self invalidHeightCapacityErrorDescription
! !
!Trailer class methodsFor: 'exceptions' stamp: 'FRT 5/4/2020 11:30:21'!
signalInvalidWeightCapacity

	self error: self invalidWeightCapacityErrorDescription
! !
!Trailer class methodsFor: 'exceptions' stamp: 'FRT 5/4/2020 17:37:29'!
signalWeightCapacityMustBeInteger

	self error: self weightCapacityMustBeIntegerErrorDescription
! !
!Trailer class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 17:49:38'!
heightCapacityMustBeIntegerErrorDescription

	^ 'Height capacity must be integer'! !
!Trailer class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 11:30:12'!
invalidHeightCapacityErrorDescription

	^ 'The trailers height capacity must be positive.'
! !
!Trailer class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 11:30:21'!
invalidWeightCapacityErrorDescription

	^ 'The trailers weight capacity must be positive.'
! !
!Trailer class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 11:30:31'!
maxHeightExceededErrorDescription

	^ 'Maximum height has been exceeded'
! !
!Trailer class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 11:30:38'!
maxWeightExceededErrorDescription

	^ 'Maximum weight has been exceeded'
! !
!Trailer class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 17:49:32'!
weightCapacityMustBeIntegerErrorDescription

	^ 'Weight capacity must be integer'! !

!classDefinition: #ParkingLotTest category: 'ISW1-2019-1C-Parcial' stamp: 'pc 7/5/2021 17:46:52'!
TestCase subclass: #ParkingLotTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2019-1C-Parcial'!

!classDefinition: #ParkingLotTest category: 'ISW1-2019-1C-Parcial' stamp: 'pc 7/5/2021 17:46:52'!
TestCase subclass: #ParkingLotTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2019-1C-Parcial'!
!ParkingLotTest methodsFor: 'tests' stamp: 'HAW 4/24/2019 16:32:35'!
test01CanNotCreateAParkingLotWithCeroOrLessLots

	self
		should: [ ParkingLot with: 0 and: self defaultPriceList ]
		raise: Error
		withMessageText: ParkingLot invalidNumberOfLotsErrorDescription ! !
!ParkingLotTest methodsFor: 'tests' stamp: 'HAW 4/24/2019 16:32:41'!
test02CanNotCreateAParkingLotWithNoIntegerNumberOfLots

	self
		should: [ ParkingLot with: 1.5 and: self defaultPriceList ]
		raise: Error
		withMessageText: ParkingLot numberOfLotsMustBeIntegerErrorDescription ! !
!ParkingLotTest methodsFor: 'tests' stamp: 'HAW 4/24/2019 16:33:00'!
test03WhenAParkingLotIsCreatedWithEvenSlotsAllSlotsEmpty

	| parkingLotSize parkingLot |
	
	parkingLotSize := 10.
	parkingLot := ParkingLot with: parkingLotSize and: self defaultPriceList.
	
	self assert: parkingLotSize equals: parkingLot freeSlots size ! !
!ParkingLotTest methodsFor: 'tests' stamp: 'HAW 4/24/2019 16:33:23'!
test04WhenAParkingLotIsCreatedWithOddSlotsOneIsReservedAndTheRestAreEmpty

	| parkingLotSize parkingLot |
	
	parkingLotSize := 11.

	parkingLot := ParkingLot with: parkingLotSize and: self defaultPriceList.
	
	self assert: parkingLotSize -1 equals: parkingLot freeSlots size.
	self assert: 1 equals: parkingLot reservedSlots size! !
!ParkingLotTest methodsFor: 'tests' stamp: 'HAW 4/24/2019 16:40:15'!
test05ParkingAVehicleReducesFreeSlotsByOne

	| parkingLotSize parkingLot |
	
	parkingLotSize := 10.
	parkingLot := ParkingLot with: parkingLotSize and: self defaultPriceList.
	
	parkingLot receive: #car.
	
	self assert: parkingLotSize - 1 equals: parkingLot freeSlots size.
	self assert: 1 equals: parkingLot occupiedSlots size
! !
!ParkingLotTest methodsFor: 'tests' stamp: 'HAW 4/24/2019 16:40:56'!
test06WhenAVehicleLeavesTheEmptySlotsIsAugmentedByOne

	| parkingLotSize parkingLot parkedSlot |
	
	parkingLotSize := 10.
	parkingLot := ParkingLot with: parkingLotSize and: self defaultPriceList.
	
	parkedSlot := parkingLot receive: #bike.
	parkingLot release: parkedSlot.

	self assert: parkingLotSize equals: parkingLot freeSlots size.
	self assert: parkingLot occupiedSlots isEmpty! !
!ParkingLotTest methodsFor: 'tests' stamp: 'HAW 4/24/2019 22:30:01'!
test07CanNotReleaseASlotNotIncludedInParkingLot

	| parkingLotSize parkingLot |
	
	parkingLotSize := 10.
	parkingLot := ParkingLot with: parkingLotSize and: self defaultPriceList.
	
	self 
		should: [ parkingLot release: Slot new ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: ParkingLot slotNotInParkingLotErrorDescription equals: anError messageText.
			self assert: parkingLotSize equals: parkingLot freeSlots size ]! !
!ParkingLotTest methodsFor: 'tests' stamp: 'HAW 4/24/2019 22:29:55'!
test08CanNotParkAVehicleInTheBoosSlot

	| parkingLotSize parkingLot |
	
	parkingLotSize := 11.

	parkingLot := ParkingLot with: parkingLotSize and: self defaultPriceList.
	
	self 
		should: [ (parkingLot bossSlotIfNone: [ self fail ]) receive: #car ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: Slot canNotParkInSlotWhenReservedErrorDescription equals: anError messageText.
			self assert: parkingLot occupiedSlots isEmpty ]! !
!ParkingLotTest methodsFor: 'tests' stamp: 'HAW 4/24/2019 22:29:50'!
test09ThereIsNoBoosSlotWhenNumberOfLotsIsEven

	| parkingLotSize parkingLot |
	
	parkingLotSize := 10.

	parkingLot := ParkingLot with: parkingLotSize and: self defaultPriceList.
	
	parkingLot bossSlotIfNone: [ ^self ].
	self failWith: 'There should not be a boos slot'! !
!ParkingLotTest methodsFor: 'tests' stamp: 'HAW 4/24/2019 22:29:45'!
test10CanNotParkIfFull

	| parkingLotSize parkingLot |
	
	parkingLotSize := 2.
	parkingLot := ParkingLot with: parkingLotSize and: self defaultPriceList.
	
	parkingLot receive: #car.
	parkingLot receive: #bike.
	
	self 
		should: [ parkingLot receive: #car ]
		raise: Error
		withMessageText: ParkingLot canNotParkIsFullErrorDescription 
! !
!ParkingLotTest methodsFor: 'tests' stamp: 'HAW 4/24/2019 22:29:40'!
test11CanNotRealeaseAnEmptyLot

	| parkingLotSize parkingLot |
	
	parkingLotSize := 2.
	parkingLot := ParkingLot with: parkingLotSize and: self defaultPriceList.
	
	self 
		should: [ parkingLot release: parkingLot freeSlots anyOne ]
		raise: Error
		withExceptionDo: [ :anError | 
			self assert: ParkingLot canNotReleaseAnEmptySlotErrorDescription equals: anError messageText.
			self assert: parkingLotSize equals: parkingLot freeSlots size ].
! !
!ParkingLotTest methodsFor: 'tests' stamp: 'HAW 4/24/2019 22:30:51'!
test12CanGetTheTotalParked

	| parkingLot priceList |

	priceList := self defaultPriceList.
	parkingLot := ParkingLot with: 10 and: priceList.
	
	parkingLot receive: #car.
	parkingLot receive: #car.
	parkingLot receive: #bike.

	self assert: ( (priceList at: #car) * 2) + (priceList at: #bike) equals: parkingLot totalParked! !
!ParkingLotTest methodsFor: 'tests' stamp: 'HAW 4/24/2019 22:31:14'!
test13ReservedSlotDoesNotAddToTalParked

	| parkingLot priceList |

	priceList := self defaultPriceList.
	parkingLot := ParkingLot with: 11 and: priceList.

	parkingLot receive: #car.
	parkingLot receive: #car.
	parkingLot receive: #bike.

	self assert: ((priceList at: #car) * 2) + (priceList at: #bike) equals: parkingLot totalParked! !
!ParkingLotTest methodsFor: 'tests' stamp: 'HAW 4/24/2019 22:32:16'!
test14CanNotCalculateTotalParkedWithUnknowVehicleType

	| parkingLot priceList |

	priceList := self defaultPriceList.
	parkingLot := ParkingLot with: 10 and: priceList.

	parkingLot receive: #unknowVehicleType.
	
	self
		should: [ parkingLot totalParked ]
		raise: Error
		withMessageText: ParkingLot unknowVehicleTypeErrorDescription ! !
!ParkingLotTest methodsFor: 'tests' stamp: 'HAW 4/24/2019 22:32:24'!
test15CanGetTheTotalCarsParked

	| parkingLot priceList |

	priceList := self defaultPriceList.
	parkingLot := ParkingLot with: 10 and: priceList.

	parkingLot receive: #car.
	parkingLot receive: #car.
	parkingLot receive: #bike.
	
	self assert: (priceList at: #car)*2 equals: parkingLot totalCarsParked ! !
!ParkingLotTest methodsFor: 'tests' stamp: 'HAW 4/24/2019 22:32:31'!
test16CanGetTheTotalBikeParked

	| parkingLot priceList |

	priceList := self defaultPriceList.
	parkingLot := ParkingLot with: 10 and: priceList.

	parkingLot receive: #bike.
	parkingLot receive: #bike.
	parkingLot receive: #car.
	
	self assert: (priceList at: #bike)*2 equals: parkingLot totalBikesParked ! !
!ParkingLotTest methodsFor: 'price list' stamp: 'HAW 4/24/2019 11:13:24'!
defaultPriceList
	
	^Dictionary new
		at: #car put: 100*peso;
		at: #bike put: 50*peso;
		yourself ! !

!classDefinition: #SlotTest category: 'ISW1-2019-1C-Parcial' stamp: 'pc 7/5/2021 17:46:53'!
TestCase subclass: #SlotTest
	instanceVariableNames: 'number state'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2019-1C-Parcial'!

!classDefinition: #SlotTest category: 'ISW1-2019-1C-Parcial' stamp: 'pc 7/5/2021 17:46:53'!
TestCase subclass: #SlotTest
	instanceVariableNames: 'number state'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2019-1C-Parcial'!
!SlotTest methodsFor: 'tests' stamp: 'HAW 4/24/2019 19:36:47'!
test01NewSlotsAreEmpty

	self assert: Slot new isEmpty
	
! !
!SlotTest methodsFor: 'tests' stamp: 'HAW 4/24/2019 19:38:09'!
test02ParkingAVehicleMakesTheSlotOccupied

	| slot |
	
	slot := Slot new.
	slot receive: #car.
	
	self assert: slot isOccupied.
	self deny: slot isEmpty! !
!SlotTest methodsFor: 'tests' stamp: 'HAW 4/24/2019 23:30:53'!
test03CanReserveASlot

	| slot |
	
	slot := Slot new.
	slot reserve.
	
	self assert: slot isReserved.
	self deny: slot isOccupied.
	self deny: slot isEmpty! !
!SlotTest methodsFor: 'tests' stamp: 'HAW 4/24/2019 23:30:48'!
test04CanNotParkInAnOccupiedSlot

	| slot |
	
	slot := Slot new.
	slot receive: #car.
	
	self 
		should: [ slot receive: #car ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Slot canNotParkInSlotWhenOccupiedErrorDescription! !
!SlotTest methodsFor: 'tests' stamp: 'HAW 4/24/2019 23:30:42'!
test05CanNotParkInAReservedSlot

	| slot |
	
	slot := Slot new.
	slot reserve.
	
	self 
		should: [ slot receive: #car ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [:anError |
			self assert:  Slot canNotParkInSlotWhenReservedErrorDescription equals: anError messageText.
			self assert: slot isReserved ]! !
!SlotTest methodsFor: 'tests' stamp: 'HAW 4/24/2019 23:30:29'!
test06CanNotReleaseAnEmptySlot

	| slot |
	
	slot := Slot new.
	
	self 
		should: [ slot release ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [:anError |
			self assert:  Slot canNotLeaveFromEmptySlotErrorDescription equals: anError messageText.
			self assert: slot isEmpty ]! !
!SlotTest methodsFor: 'tests' stamp: 'HAW 4/24/2019 23:30:24'!
test07CanNotReleaseAReservedSlot

	| slot |
	
	slot := Slot new.
	slot reserve.
	
	self 
		should: [ slot release ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [:anError |
			self assert: Slot canNotLeaveFromReservedSlotErrorDescription equals: anError messageText.
			self assert: slot isReserved ]! !
!SlotTest methodsFor: 'tests' stamp: 'HAW 4/24/2019 23:30:18'!
test08CanNotReserveAnOccupiedSlot

	| slot |
	
	slot := Slot new.
	slot receive: #car.
	
	self 
		should: [ slot reserve ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [:anError |
			self assert: Slot canNotReserveAnOccupiedSlotErrorDescription equals: anError messageText.
			self assert: slot isOccupied ]! !
!SlotTest methodsFor: 'tests' stamp: 'HAW 4/24/2019 23:30:12'!
test09CanNotReserveAReserveSlot

	| slot |
	
	slot := Slot new.
	slot reserve.
	
	self 
		should: [ slot reserve ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [:anError |
			self assert: Slot canNotReserveAReservedSlotErrorDescription equals: anError messageText.
			self assert: slot isReserved ]! !
!SlotTest methodsFor: 'tests' stamp: 'HAW 4/24/2019 23:30:08'!
test10SlotIsEmptyAfterReleasingIt

	| slot |

	slot := Slot new.
	slot receive: #car.
	slot release.
	
	self assert: slot isEmpty.
	self deny: slot isOccupied! !
!SlotTest methodsFor: 'tests' stamp: 'HAW 4/24/2019 23:30:03'!
test11CostOfAnEmptySlotIsCeroPesos

	| slot |

	slot := Slot new.
	
	self assert: 0*peso equals: (slot costUsing: self defaultPriceList ifUnknowVehicleType: [ self fail ])! !
!SlotTest methodsFor: 'tests' stamp: 'HAW 4/24/2019 23:29:59'!
test12CostOfAReservedSlotIsCeroPesos

	| slot |

	slot := Slot new.
	slot reserve.
	
	self assert: 0*peso equals: (slot costUsing: self defaultPriceList ifUnknowVehicleType: [ self fail ])! !
!SlotTest methodsFor: 'tests' stamp: 'HAW 4/24/2019 23:29:54'!
test13CostOfAnOcuppiedSlotDependsOnVehicleType

	| slotWithACar slotWithABike priceList |

	slotWithACar := Slot new.
	slotWithACar receive: #car.
	
	slotWithABike := Slot new.
	slotWithABike receive: #bike.
	
	priceList := self defaultPriceList.
	
	self assert: (priceList at: #car) equals: (slotWithACar costUsing: priceList ifUnknowVehicleType: [ self fail ]).
	self assert: (priceList at: #bike) equals: (slotWithABike costUsing: priceList ifUnknowVehicleType: [ self fail ]).
	! !
!SlotTest methodsFor: 'tests' stamp: 'HAW 4/24/2019 23:29:50'!
test14ThereIsNoCostOfInvalidVehicleType

	| slotWithACar priceList |

	slotWithACar := Slot new.
	slotWithACar receive: #unknowVehicle.
	
	priceList := self defaultPriceList.
	
	slotWithACar costUsing: priceList ifUnknowVehicleType: [ ^self ].
	self failWith: 'should not get cost of invalid vehicle type'
	! !
!SlotTest methodsFor: 'price list' stamp: 'HAW 4/24/2019 19:56:51'!
defaultPriceList
	
	^Dictionary new
		at: #car put: 100*peso;
		at: #bike put: 50*peso;
		yourself ! !

!classDefinition: #ParkingLot category: 'ISW1-2019-1C-Parcial' stamp: 'pc 7/5/2021 17:46:54'!
Object subclass: #ParkingLot
	instanceVariableNames: 'slots prices'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2019-1C-Parcial'!

!classDefinition: #ParkingLot category: 'ISW1-2019-1C-Parcial' stamp: 'pc 7/5/2021 17:46:54'!
Object subclass: #ParkingLot
	instanceVariableNames: 'slots prices'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2019-1C-Parcial'!
!ParkingLot methodsFor: 'parking' stamp: 'HAW 4/24/2019 22:18:34'!
receive: aVehicleType
		
	| freeSlots slotToPark |
	
	freeSlots := self freeSlots.
	freeSlots isEmpty ifTrue: [ self signalFullParkingLot ].
	
	slotToPark := freeSlots atRandom.
	slotToPark receive: aVehicleType.
	
	^slotToPark! !
!ParkingLot methodsFor: 'parking' stamp: 'HAW 4/24/2019 22:18:17'!
release: aSlot

	(slots includes: aSlot) ifFalse: [ self signalSlotNotInParkingLot ].
	aSlot isEmpty ifTrue: [ self signalCanNotReleaseAnEmptySlot ].
	
	aSlot release! !
!ParkingLot methodsFor: 'initialization' stamp: 'HAW 4/24/2019 20:10:45'!
initializeWith: anAmountOfSlots and: aPriceList
	
	anAmountOfSlots odd 
		ifTrue: [ slots := (((1 to: anAmountOfSlots - 1) collect: [:id | Slot new]) asOrderedCollection) add: Slot new reserve; yourself ]
		ifFalse: [ slots := ((1 to: anAmountOfSlots) collect: [:id | Slot new]) asOrderedCollection ].
	
	prices := aPriceList ! !
!ParkingLot methodsFor: 'filtering' stamp: 'HAW 4/24/2019 22:20:26'!
freeSlots

	| freeSlots |
	
	freeSlots := OrderedCollection new.
	slots do: [ :aSlot | aSlot isEmpty ifTrue: [ freeSlots add: aSlot ]]. 
	
	^ freeSlots! !
!ParkingLot methodsFor: 'filtering' stamp: 'HAW 4/24/2019 22:20:54'!
occupiedSlots

	| occupiedSlots |
	
	occupiedSlots := OrderedCollection new.
	slots do: [ :aSlot | aSlot isOccupied ifTrue: [ occupiedSlots add: aSlot ]]. 
	
	^ occupiedSlots! !
!ParkingLot methodsFor: 'filtering' stamp: 'HAW 4/24/2019 22:21:08'!
reservedSlots

	| reservedSlots |
	
	reservedSlots := OrderedCollection new.
	slots do: [ :aSlot | aSlot isReserved ifTrue: [ reservedSlots add: aSlot ]]. 
	
	^ reservedSlots! !
!ParkingLot methodsFor: 'exceptions' stamp: 'HAW 4/24/2019 20:48:43'!
signalCanNotReleaseAnEmptySlot

	self error: self class canNotReleaseAnEmptySlotErrorDescription.! !
!ParkingLot methodsFor: 'exceptions' stamp: 'HAW 4/24/2019 10:16:10'!
signalFullParkingLot

	self error: self class canNotParkIsFullErrorDescription.! !
!ParkingLot methodsFor: 'exceptions' stamp: 'HAW 4/24/2019 22:13:27'!
signalSlotNotInParkingLot
	
	self error: self class slotNotInParkingLotErrorDescription ! !
!ParkingLot methodsFor: 'exceptions' stamp: 'HAW 4/24/2019 22:15:18'!
signalUnknowVehicleType

	self error: self class unknowVehicleTypeErrorDescription! !
!ParkingLot methodsFor: 'cost' stamp: 'HAW 4/24/2019 22:14:44'!
costOf: aSlot 
	
	^aSlot costUsing: prices ifUnknowVehicleType: [ self signalUnknowVehicleType ]! !
!ParkingLot methodsFor: 'cost' stamp: 'HAW 4/24/2019 22:26:19'!
totalBikesParked

	| totalBikesParked |
	
	totalBikesParked := 0*peso.
	slots do: [ :aSlot | (aSlot isOccupied and: [ aSlot vehicleType = #bike ]) ifTrue: [totalBikesParked := totalBikesParked + (self costOf: aSlot)]].
	
	^totalBikesParked
	! !
!ParkingLot methodsFor: 'cost' stamp: 'HAW 4/24/2019 22:25:59'!
totalCarsParked

	| totalCarsParked |
	
	totalCarsParked := 0*peso.
	slots do: [ :aSlot | (aSlot isOccupied and: [ aSlot vehicleType = #car ]) ifTrue: [totalCarsParked := totalCarsParked + (self costOf: aSlot)]].
	
	^totalCarsParked
	! !
!ParkingLot methodsFor: 'cost' stamp: 'HAW 4/24/2019 22:25:33'!
totalParked

	| totalParked |
	
	totalParked := 0*peso.
	slots do: [ :aSlot | totalParked := totalParked + (self costOf: aSlot) ].
	
	^totalParked
	! !
!ParkingLot methodsFor: 'boss slot' stamp: 'HAW 4/24/2019 20:21:14'!
bossSlotIfNone: noneBlock
	
	^self reservedSlots ifEmpty: noneBlock ifNotEmpty: [ :reservedSlots | reservedSlots anyOne ]! !

!classDefinition: 'ParkingLot class' category: 'ISW1-2019-1C-Parcial' stamp: 'pc 7/5/2021 17:46:54'!
ParkingLot class
	instanceVariableNames: ''!

!classDefinition: 'ParkingLot class' category: 'ISW1-2019-1C-Parcial' stamp: 'pc 7/5/2021 17:46:54'!
ParkingLot class
	instanceVariableNames: ''!
!ParkingLot class methodsFor: 'instance creation' stamp: 'HAW 4/24/2019 09:56:44'!
with: aNumberOfSlots and: aPriceList
	"creates a Parking Lot with a number of slots and a list of prices"
	
	self assertIsPositive: aNumberOfSlots.
	self assertIsInteger: aNumberOfSlots.
	
	^ self new initializeWith: aNumberOfSlots and: aPriceList.! !
!ParkingLot class methodsFor: 'error messages' stamp: 'HAW 4/24/2019 10:16:10'!
canNotParkIsFullErrorDescription

	^ 'Can not park because ParkingLot is full'.! !
!ParkingLot class methodsFor: 'error messages' stamp: 'HAW 4/24/2019 10:45:51'!
canNotReleaseAnEmptySlotErrorDescription

	^  'Your vehicle is not parked here'.! !
!ParkingLot class methodsFor: 'error messages' stamp: 'HAW 4/24/2019 09:55:14'!
invalidNumberOfLotsErrorDescription
	
	^'The number of lots must be positive'! !
!ParkingLot class methodsFor: 'error messages' stamp: 'HAW 4/24/2019 09:55:49'!
numberOfLotsMustBeIntegerErrorDescription
	
	^'Number of lots must be integer'! !
!ParkingLot class methodsFor: 'error messages' stamp: 'HAW 4/24/2019 22:11:40'!
slotNotInParkingLotErrorDescription
	
	^'Slot does not belong to this parking lot'! !
!ParkingLot class methodsFor: 'error messages' stamp: 'HAW 4/24/2019 22:15:43'!
unknowVehicleTypeErrorDescription

	^'Unknow vehicle type'! !
!ParkingLot class methodsFor: 'assertions' stamp: 'HAW 4/24/2019 09:57:32'!
assertIsInteger: aNumberOfLots

	aNumberOfLots isInteger ifFalse: [ self signalNumberOfLotsMustBeInteger ]! !
!ParkingLot class methodsFor: 'assertions' stamp: 'HAW 4/24/2019 09:53:50'!
assertIsPositive: aNumberOfLots

	aNumberOfLots strictlyPositive ifFalse: [ self signalInvalidNumberOfLots ]! !
!ParkingLot class methodsFor: 'exceptions' stamp: 'HAW 4/24/2019 09:55:14'!
signalInvalidNumberOfLots

	self error: self invalidNumberOfLotsErrorDescription ! !
!ParkingLot class methodsFor: 'exceptions' stamp: 'HAW 4/24/2019 09:57:43'!
signalNumberOfLotsMustBeInteger
	
	self error: self numberOfLotsMustBeIntegerErrorDescription ! !

!classDefinition: #Slot category: 'ISW1-2019-1C-Parcial' stamp: 'pc 7/5/2021 17:46:55'!
Object subclass: #Slot
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2019-1C-Parcial'!

!classDefinition: #Slot category: 'ISW1-2019-1C-Parcial' stamp: 'pc 7/5/2021 17:46:55'!
Object subclass: #Slot
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2019-1C-Parcial'!

!classDefinition: 'Slot class' category: 'ISW1-2019-1C-Parcial' stamp: 'pc 7/5/2021 17:46:55'!
Slot class
	instanceVariableNames: ''!

!classDefinition: 'Slot class' category: 'ISW1-2019-1C-Parcial' stamp: 'pc 7/5/2021 17:46:55'!
Slot class
	instanceVariableNames: ''!
!Slot class methodsFor: 'error messages' stamp: 'HAW 4/24/2019 19:50:27'!
canNotLeaveFromEmptySlotErrorDescription

	^ 'Can not leave from an already empty slot'! !
!Slot class methodsFor: 'error messages' stamp: 'HAW 4/24/2019 19:52:15'!
canNotLeaveFromReservedSlotErrorDescription
	
	^'Can not leave from a reserved slot (is only for owners!!)'! !
!Slot class methodsFor: 'error messages' stamp: 'HAW 4/24/2019 19:42:23'!
canNotParkInSlotWhenOccupiedErrorDescription
	
	^ 'Can not park in ocuppied slot'! !
!Slot class methodsFor: 'error messages' stamp: 'HAW 4/24/2019 19:43:16'!
canNotParkInSlotWhenReservedErrorDescription

	^ 'Can not park in a slot reserved for the owner'.! !
!Slot class methodsFor: 'error messages' stamp: 'HAW 4/24/2019 20:41:58'!
canNotReserveAReservedSlotErrorDescription
	
	^'Can not reserve a reserved slots'! !
!Slot class methodsFor: 'error messages' stamp: 'HAW 4/24/2019 20:40:34'!
canNotReserveAnOccupiedSlotErrorDescription
	
	^'Can not reserved an occupied slot'! !
!Slot methodsFor: 'nil' stamp: 'pc 5/2/2021 11:56:06'!
isEmpty
	^True! !
!Slot methodsFor: 'nil' stamp: 'pc 5/2/2021 11:59:06'!
recive: aCar
	! !

!classDefinition: #NameOfSubclass category: 'ISW1-2019-1C-Parcial' stamp: 'pc 7/5/2021 17:46:55'!
Object subclass: #NameOfSubclass
	instanceVariableNames: 'isEmpty'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2019-1C-Parcial'!

!classDefinition: #NameOfSubclass category: 'ISW1-2019-1C-Parcial' stamp: 'pc 7/5/2021 17:46:55'!
Object subclass: #NameOfSubclass
	instanceVariableNames: 'isEmpty'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2019-1C-Parcial'!

!classRemoval: #NameOfSubclass stamp: 'pc 7/5/2021 17:46:55'!
Object subclass: #NameOfSubclass
	instanceVariableNames: 'isEmpty'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2019-1C-Parcial'!

!classDefinition: #Slot category: 'ISW1-2019-1C-Parcial' stamp: 'pc 7/5/2021 17:46:55'!
Object subclass: #Slot
	instanceVariableNames: 'isEmpty'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2019-1C-Parcial'!

!classDefinition: #Slot category: 'ISW1-2019-1C-Parcial' stamp: 'pc 7/5/2021 17:46:55'!
Object subclass: #Slot
	instanceVariableNames: 'isEmpty'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2019-1C-Parcial'!
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 11:59:49' prior: 50907401!
isEmpty
	^isEmpty! !
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 12:00:07' prior: 50907404!
recive: aCar
	isEmpty := False. ! !
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 12:00:27' prior: 50907448!
recive: aCar
	isEmpty := false. ! !
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 12:01:34' overrides: 16896425!
initialize
	isEmpty := true. ! !
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 12:02:30' prior: 50907456 overrides: 16896425!
initialize
	isEmpty! !
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 12:02:40' prior: 50907444!
isEmpty
	^true! !

!classDefinition: #Slot category: 'ISW1-2019-1C-Parcial' stamp: 'pc 7/5/2021 17:46:55'!
Object subclass: #Slot
	instanceVariableNames: 'isEmpty isOcupied'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2019-1C-Parcial'!
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 12:05:52' prior: 50907452!
recive: aCar
	isOcupied := false. ! !
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 12:07:09' prior: 50907476!
recive: aCar
	isOcupied := true. ! !
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 12:08:12' prior: 50907461 overrides: 16896425!
initialize
	isEmpty := true.! !
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 12:08:25' prior: 50907465!
isEmpty
	^isEmpty ! !
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 12:08:42'!
isOcupied
	^isOcupied ! !
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 12:08:54' prior: 50907480!
recive: aCar
	isOcupied := true. 
	isEmpty := false.! !
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 12:09:26'!
receive: aCar
	isOcupied := true. 
	isEmpty := false.! !

!methodRemoval: Slot #recive: stamp: 'pc 7/5/2021 17:46:56'!
recive: aCar
	isOcupied := true. 
	isEmpty := false.!

!classDefinition: #Slot category: 'ISW1-2019-1C-Parcial' stamp: 'pc 7/5/2021 17:46:56'!
Object subclass: #Slot
	instanceVariableNames: 'isEmpty isOcupied isOccupied'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2019-1C-Parcial'!
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 12:09:56'!
isOccupied
	^isOccupied ! !
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 12:10:15' prior: 50907485 overrides: 16896425!
initialize
	isEmpty := true.
	isOccupied := false.! !

!classDefinition: #Slot category: 'ISW1-2019-1C-Parcial' stamp: 'pc 7/5/2021 17:46:56'!
Object subclass: #Slot
	instanceVariableNames: 'isEmpty isOccupied'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2019-1C-Parcial'!

!classDefinition: #Slot category: 'ISW1-2019-1C-Parcial' stamp: 'pc 7/5/2021 17:46:56'!
Object subclass: #Slot
	instanceVariableNames: 'isEmpty isOccupied'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2019-1C-Parcial'!
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 12:11:42' prior: 50907500!
receive: aCar
	isOccupied := true. 
	isEmpty := false.! !

!classDefinition: #Slot category: 'ISW1-2019-1C-Parcial' stamp: 'pc 7/5/2021 17:46:56'!
Object subclass: #Slot
	instanceVariableNames: 'isEmpty isOccupied reserved'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2019-1C-Parcial'!
!Slot methodsFor: 'nil' stamp: 'pc 5/2/2021 12:13:04'!
isReserved
	^reserved! !

!classDefinition: #Slot category: 'ISW1-2019-1C-Parcial' stamp: 'pc 7/5/2021 17:46:56'!
Object subclass: #Slot
	instanceVariableNames: 'isEmpty occupied reserved'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2019-1C-Parcial'!

!classDefinition: #Slot category: 'ISW1-2019-1C-Parcial' stamp: 'pc 7/5/2021 17:46:56'!
Object subclass: #Slot
	instanceVariableNames: 'isEmpty occupied reserved'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2019-1C-Parcial'!

!classDefinition: #Slot category: 'ISW1-2019-1C-Parcial' stamp: 'pc 7/5/2021 17:46:56'!
Object subclass: #Slot
	instanceVariableNames: 'empty occupied reserved'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2019-1C-Parcial'!

!classDefinition: #Slot category: 'ISW1-2019-1C-Parcial' stamp: 'pc 7/5/2021 17:46:56'!
Object subclass: #Slot
	instanceVariableNames: 'empty occupied reserved'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2019-1C-Parcial'!
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 12:13:34' prior: 50907521 overrides: 16896425!
initialize
	empty := true.
	occupied := false.! !
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 12:13:53' prior: 50907588 overrides: 16896425!
initialize
	empty := true.
	occupied := false.
	reserved := false.! !
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 12:14:02' prior: 50907492!
isOcupied
	^occupied ! !
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 12:14:11' prior: 50907489!
isEmpty
	^empty ! !
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 12:14:19' prior: 50907516!
isOccupied
	^occupied ! !

!methodRemoval: Slot #isOcupied stamp: 'pc 7/5/2021 17:46:56'!
isOcupied
	^occupied !
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 12:14:37' prior: 50907541!
receive: aCar
	occupied := true. 
	empty := false.! !
!Slot methodsFor: 'nil' stamp: 'pc 5/2/2021 12:15:28'!
reserve
	reserved := true.! !
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 12:16:55' prior: 50907617!
reserve
	reserved := true.
	empty := false.! !
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 12:22:33' prior: 50907613!
receive: aCar
	
	self isOccupied  ifTrue: [
		self class] ifFalse: [
		occupied = true. 
		empty := false.]! !
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 12:22:58' prior: 50907626!
receive: aCar
	
	self isOccupied  ifTrue: [
		self class canNotParkInSlotWhenOccupiedErrorDescription] ifFalse: [
		occupied = true. 
		empty := false.]! !
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 12:24:54' prior: 50907633!
receive: aCar
	
	self isOccupied  ifTrue: [
		^Error signal: self class canNotParkInSlotWhenOccupiedErrorDescription] ifFalse: [
		occupied = true. 
		empty := false.]! !
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 12:33:04' prior: 50907641!
receive: aCar
	
	self isOccupied  ifTrue: [
		^Error signal: self class canNotParkInSlotWhenOccupiedErrorDescription] ifFalse: [
		occupied = true. 
		empty := false.]! !
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 12:34:08' prior: 50907650!
receive: aCar
	
	self isOccupied  ifTrue: [
		Error signal: self class canNotParkInSlotWhenOccupiedErrorDescription] ifFalse: [
		occupied = true. 
		empty := false.]! !
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 12:35:13' prior: 50907659!
receive: aCar
	
	self isOccupied ifTrue: [
		Error signal: self class canNotParkInSlotWhenOccupiedErrorDescription] ifFalse: [
		occupied = true. 
		empty := false.]! !
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 12:36:16' prior: 50907668!
receive: aCar
	
	self isOccupied ifTrue: [
		Error signal: self class canNotParkInSlotWhenOccupiedErrorDescription] ifFalse: [
		occupied := true. 
		empty := false.]! !
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 12:37:38' prior: 50907621!
reserve
	self isReserved ifTrue:[
		Error signal: self class ]ifFalse:[
		reserved := true.
		empty := false.
		]! !
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 12:38:00' prior: 50907685!
reserve
	self isReserved ifTrue:[
		Error signal: self class canNotParkInSlotWhenReservedErrorDescription]ifFalse:[
		reserved := true.
		empty := false.
		]! !
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 12:39:00' prior: 50907692!
reserve

		reserved := true.
		empty := false.
		! !
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 12:39:34' prior: 50907676!
receive: aCar
	
	(self isOccupied or: self isReserved) ifTrue: [
		Error signal: self class canNotParkInSlotWhenOccupiedErrorDescription] ifFalse: [
		occupied := true. 
		empty := false.]! !

!classDefinition: #Slot category: 'ISW1-2019-1C-Parcial' stamp: 'pc 7/5/2021 17:46:56'!
Object subclass: #Slot
	instanceVariableNames: 'availability'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2019-1C-Parcial'!

!classDefinition: #Slot category: 'ISW1-2019-1C-Parcial' stamp: 'pc 7/5/2021 17:46:56'!
Object subclass: #Slot
	instanceVariableNames: 'availability'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2019-1C-Parcial'!
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 15:46:54' prior: 50907593 overrides: 16896425!
initialize
	availability  := #empty! !
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 15:47:20' prior: 50907602!
isEmpty
	^availability = #empty! !
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 15:47:36' prior: 50907606!
isOccupied
	^availability = #occupied ! !
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 15:47:42' prior: 50907553!
isReserved
	^availability = #reserved! !
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 15:48:04' prior: 50907700!
reserve

		availability = #reserved.
		! !
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 15:49:26' prior: 50907705!
receive: aCar
	
	self isOccupied ifTrue: [
		Error signal: self class canNotParkInSlotWhenOccupiedErrorDescription] .
	self isOccupied ifTrue: [
		Error signal: self class canNotParkInSlotWhenOccupiedErrorDescription]. 
	self isEmpty ifTrue: [
		availability := #occupied.]! !
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 15:49:50' prior: 50907751!
receive: aCar
	
	self isOccupied ifTrue: [
		Error signal: self class canNotParkInSlotWhenOccupiedErrorDescription] .
	self isOccupied ifTrue: [
		Error signal: self class canNotParkInSlotWhenReservedErrorDescription]. 
	self isEmpty ifTrue: [
		availability := #occupied.]! !
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 15:50:52' prior: 50907763!
receive: vehicle
	self isOccupied ifTrue: [
		Error signal: self class canNotParkInSlotWhenOccupiedErrorDescription] .
	self isOccupied ifTrue: [
		Error signal: self class canNotParkInSlotWhenReservedErrorDescription]. 
	self isEmpty ifTrue: [
		availability := #occupied.]! !
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 15:52:31' prior: 50907775!
receive: aVehicle
	self isReserved ifTrue: [
		Error signal: self class canNotParkInSlotWhenOccupiedErrorDescription] .
	self isOccupied ifTrue: [
		Error signal: self class canNotParkInSlotWhenReservedErrorDescription]. 
	self isEmpty ifTrue: [
		availability := #occupied.]! !
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 15:53:09' prior: 50907787!
receive: aVehicle
	self isReserved ifTrue: [
		Error signal: self class 
		canNotParkInSlotWhenReservedErrorDescription] .
	self isOccupied ifTrue: [
		Error signal: self class canNotParkInSlotWhenOccupiedErrorDescription]. 
	self isEmpty ifTrue: [
		availability := #occupied.]! !
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 15:56:35' prior: 50907742!
isReserved
	^availability = #reserved! !
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 15:57:54' prior: 50907746!
reserve

		availability := #reserved.
		! !
!Slot methodsFor: 'nil' stamp: 'pc 5/2/2021 15:59:08'!
release
	availability := #empty! !
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 16:00:20' prior: 50907819!
release
	self isEmpty ifTrue:[].
		
	availability = #empty! !
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 16:00:43' prior: 50907823!
release
	self isEmpty ifTrue:[
		Error signal: self class canNotLeaveFromEmptySlotErrorDescription].
		
	availability = #empty! !
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 16:01:38' prior: 50907828!
release
	self isEmpty ifTrue:[
		Error signal: self class canNotLeaveFromEmptySlotErrorDescription].
	self isReserved ifTrue:[
		Error signal: self class canNotLeaveFromEmptySlotErrorDescription].
		
	availability = #empty! !
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 16:01:48' prior: 50907835!
release
	self isEmpty ifTrue:[
		Error signal: self class canNotLeaveFromEmptySlotErrorDescription].
	self isReserved ifTrue:[
		Error signal: self class canNotLeaveFromReservedSlotErrorDescription].
		
	availability = #empty! !
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 16:02:20' prior: 50907845!
release
	self isEmpty ifTrue:[
		Error signal: self class canNotLeaveFromEmptySlotErrorDescription].
	self isReserved ifTrue:[
		Error signal: self class canNotLeaveFromReservedSlotErrorDescription].
	self isOccupied ifTrue: [ 	
	availability = #empty]! !
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 16:03:26' prior: 50907815!
reserve
	self isOccupied ifTrue:[
		].
	self isReserved ifTrue:[
		].
	self isEmpty ifTrue: [
	availability := #reserved].
		! !
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 16:03:52' prior: 50907866!
reserve
	self isOccupied ifTrue:[
		Error signal: self class canNotReserveAnOccupiedSlotErrorDescription].
	self isReserved ifTrue:[
		].
	self isEmpty ifTrue: [
	availability := #reserved].
		! !
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 16:04:20' prior: 50907873!
reserve
	self isOccupied ifTrue:[
		Error signal: self class canNotReserveAnOccupiedSlotErrorDescription].
	self isReserved ifTrue:[
		Error signal: self class canNotReserveAReservedSlotErrorDescription].
	self isEmpty ifTrue: [
	availability := #reserved].
		! !
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 16:05:35' prior: 50907855!
release
	self isEmpty ifTrue:[
		Error signal: self class canNotLeaveFromEmptySlotErrorDescription].
	self isReserved ifTrue:[
		Error signal: self class canNotLeaveFromReservedSlotErrorDescription].
	self isOccupied ifTrue: [ 	
		availability = #empty]! !
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 16:05:57' prior: 50907733!
isEmpty
	^availability = #empty! !

!classDefinition: #Slot category: 'ISW1-2019-1C-Parcial' stamp: 'pc 7/5/2021 17:46:56'!
Object subclass: #Slot
	instanceVariableNames: 'availability car bike'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2019-1C-Parcial'!

!classDefinition: #Slot category: 'ISW1-2019-1C-Parcial' stamp: 'pc 7/5/2021 17:46:56'!
Object subclass: #Slot
	instanceVariableNames: 'availability car bike'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2019-1C-Parcial'!

!classDefinition: #Slot category: 'ISW1-2019-1C-Parcial' stamp: 'pc 7/5/2021 17:46:56'!
Object subclass: #Slot
	instanceVariableNames: 'availability'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2019-1C-Parcial'!

!classDefinition: #Slot category: 'ISW1-2019-1C-Parcial' stamp: 'pc 7/5/2021 17:46:56'!
Object subclass: #Slot
	instanceVariableNames: 'availability'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2019-1C-Parcial'!
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 16:07:08' prior: 50907893!
release
	self isEmpty ifTrue:[
		Error signal: self class canNotLeaveFromEmptySlotErrorDescription].
	self isReserved ifTrue:[
		Error signal: self class canNotLeaveFromReservedSlotErrorDescription].
	self isOccupied ifTrue: [ 	
		availability := #empty]! !

!classDefinition: #Slot category: 'ISW1-2019-1C-Parcial' stamp: 'pc 7/5/2021 17:46:56'!
Object subclass: #Slot
	instanceVariableNames: 'availability vehicle'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2019-1C-Parcial'!

!classDefinition: #Slot category: 'ISW1-2019-1C-Parcial' stamp: 'pc 7/5/2021 17:46:57'!
Object subclass: #Slot
	instanceVariableNames: 'availability vehicle'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2019-1C-Parcial'!
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 16:11:30' prior: 50907799!
receive: aVehicle
	self isReserved ifTrue: [
		Error signal: self class 
		canNotParkInSlotWhenReservedErrorDescription] .
	self isOccupied ifTrue: [
		Error signal: self class canNotParkInSlotWhenOccupiedErrorDescription]. 
	self isEmpty ifTrue: [
		availability := #occupied.
		vehicle := aVehicle ]! !
!Slot methodsFor: 'nil' stamp: 'pc 5/2/2021 16:12:16'!
costUsing: aDicc
	! !
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 17:06:45'!
costUsing: aDicc	 ifUnknowVehicleType: aBlock
	! !
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 17:06:52' prior: 50907979!
costUsing: aDicc	 ifUnknowVehicleType: aBlock
	! !

!methodRemoval: Slot #costUsing: stamp: 'pc 7/5/2021 17:46:57'!
costUsing: aDicc
	!
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 17:08:46' prior: 50907984!
costUsing: aDicc	 ifUnknowVehicleType: aBlock
	vehicle = #car ifTrue:  [^aDicc at: #car ifAbsent: [aBlock ]]. 
	vehicle = #bike ifTrue:  [^aDicc at: #bike ifAbsent: [aBlock ]] ! !
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 17:09:14' prior: 50907991!
costUsing: aDicc	 ifUnknowVehicleType: aBlock
	vehicle = #car ifTrue:  [^aDicc at: #car ifAbsent: [aBlock ]]. 
	vehicle = #bike ifTrue:  [^aDicc at: #bike ifAbsent: [aBlock ]].
	^ aBlock ! !
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 17:10:12' prior: 50908000!
costUsing: aDicc	 ifUnknowVehicleType: aBlock
	(vehicle = #car) ifTrue:  [^aDicc at: #car ifAbsent: [aBlock ]]. 
	(vehicle = #bike) ifTrue:  [^aDicc at: #bike ifAbsent: [aBlock ]].
	^ aBlock ! !
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 17:10:45' prior: 50908009!
costUsing: aDicc	 ifUnknowVehicleType: aBlock
	(vehicle = #car) ifTrue:  [^aDicc at: #car ifAbsent: [aBlock ]]. 
	(vehicle = #bike) ifTrue:  [^aDicc at: #bike ifAbsent: [aBlock ]].
	^ [aBlock] ! !
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 17:14:05' prior: 50908018!
costUsing: aDicc	 ifUnknowVehicleType: aBlock
	self isOccupied ifTrue: [
	(vehicle = #car) ifTrue:  [^aDicc at: #car ifAbsent: [aBlock ]]. 
	(vehicle = #bike) ifTrue:  [^aDicc at: #bike ifAbsent: [aBlock ]].
	aBlock value].
	^0*peso! !

!classDefinition: #SlotState category: 'ISW1-2019-1C-Parcial' stamp: 'pc 7/5/2021 17:46:57'!
Object subclass: #SlotState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2019-1C-Parcial'!

!classDefinition: #SlotState category: 'ISW1-2019-1C-Parcial' stamp: 'pc 7/5/2021 17:46:57'!
Object subclass: #SlotState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2019-1C-Parcial'!

!classDefinition: #Empty category: 'ISW1-2019-1C-Parcial' stamp: 'pc 7/5/2021 17:46:57'!
SlotState subclass: #Empty
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2019-1C-Parcial'!

!classDefinition: #Empty category: 'ISW1-2019-1C-Parcial' stamp: 'pc 7/5/2021 17:46:57'!
SlotState subclass: #Empty
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2019-1C-Parcial'!

!classDefinition: #Occupied category: 'ISW1-2019-1C-Parcial' stamp: 'pc 7/5/2021 17:46:57'!
SlotState subclass: #Occupied
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2019-1C-Parcial'!

!classDefinition: #Occupied category: 'ISW1-2019-1C-Parcial' stamp: 'pc 7/5/2021 17:46:57'!
SlotState subclass: #Occupied
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2019-1C-Parcial'!

!classDefinition: #Reserved category: 'ISW1-2019-1C-Parcial' stamp: 'pc 7/5/2021 17:46:57'!
SlotState subclass: #Reserved
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2019-1C-Parcial'!

!classDefinition: #Reserved category: 'ISW1-2019-1C-Parcial' stamp: 'pc 7/5/2021 17:46:57'!
SlotState subclass: #Reserved
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2019-1C-Parcial'!
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 17:18:32' prior: 50907729 overrides: 16896425!
initialize
	availability  := #empty! !
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 17:19:36' prior: 50908096 overrides: 16896425!
initialize
	availability  := Empty new! !
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 17:20:05' prior: 50907904!
isEmpty
	^availability isEmpty! !
!SlotState methodsFor: 'nil' stamp: 'pc 5/2/2021 17:20:14'!
isEmpty
	! !
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 17:20:28' prior: 50907737!
isOccupied
	^availability isOccupied ! !
!SlotState methodsFor: 'nil' stamp: 'pc 5/2/2021 17:20:34'!
isOccupied! !
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 17:20:47' prior: 50907811!
isReserved
	^availability isReserved! !
!SlotState methodsFor: 'nil' stamp: 'pc 5/2/2021 17:20:54'!
isReserved! !
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 17:22:03' prior: 50907964!
receive: aVehicle
	availability receive: aVehicle 

	"self isReserved ifTrue: [
		Error signal: self class 
		canNotParkInSlotWhenReservedErrorDescription] .
	self isOccupied ifTrue: [
		Error signal: self class canNotParkInSlotWhenOccupiedErrorDescription]. 
	self isEmpty ifTrue: [
		availability := #occupied.
		vehicle := aVehicle ]"! !
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 17:24:14' prior: 50908129!
receive: aVehicle

	availability receive: aVehicle in: self

	"self isReserved ifTrue: [
		Error signal: self class 
		canNotParkInSlotWhenReservedErrorDescription] .
	self isOccupied ifTrue: [
		Error signal: self class canNotParkInSlotWhenOccupiedErrorDescription]. 
	self isEmpty ifTrue: [
		availability := #occupied.
		vehicle := aVehicle ]"! !
!Empty methodsFor: 'no messages' stamp: 'pc 5/2/2021 17:24:41'!
receive: aVehicle in: aSlot
	! !
!Slot methodsFor: 'nil' stamp: 'pc 5/2/2021 17:26:49'!
vehicle
	^vehicle ! !
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 17:27:10'!
availability 
	^availability ! !

!methodRemoval: Slot #vehicle stamp: 'pc 7/5/2021 17:46:57'!
vehicle
	^vehicle !

!methodRemoval: Slot #availability stamp: 'pc 7/5/2021 17:46:57'!
availability 
	^availability !
!SlotState methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 17:29:08' prior: 50908109!
isEmpty
	^false
	! !
!SlotState methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 17:29:15' prior: 50908117!
isOccupied
	^false! !
!SlotState methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 17:29:21' prior: 50908125!
isReserved
	^false! !
!Empty methodsFor: 'nil' stamp: 'pc 5/2/2021 17:29:34' overrides: 50908172!
isEmpty
	^true! !
!Occupied methodsFor: 'no messages' stamp: 'pc 5/2/2021 17:29:50' overrides: 50908176!
isOccupied
	^true! !
!Reserved methodsFor: 'no messages' stamp: 'pc 5/2/2021 17:30:02' overrides: 50908180!
isReserved
	^true! !
!Empty methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 17:31:20' prior: 50908156!
receive: aVehicle in: aSlot
	
	! !
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 17:31:33' prior: 50908143!
receive: aVehicle

	availability receive: aVehicle 

	"self isReserved ifTrue: [
		Error signal: self class 
		canNotParkInSlotWhenReservedErrorDescription] .
	self isOccupied ifTrue: [
		Error signal: self class canNotParkInSlotWhenOccupiedErrorDescription]. 
	self isEmpty ifTrue: [
		availability := #occupied.
		vehicle := aVehicle ]"! !
!Empty methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 17:32:28'!
receive: aVehicle 

	
	! !
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 17:39:02' prior: 50907938!
release
	self isEmpty ifTrue:[
		Error signal: self class canNotLeaveFromEmptySlotErrorDescription].
	self isReserved ifTrue:[
		Error signal: self class canNotLeaveFromReservedSlotErrorDescription].
	self isOccupied ifTrue: [ 	
		availability isEmpty]! !
!Empty methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 17:43:09' prior: 50908196!
receive: aVehicle in: aSlot
	
	aSlot asignVehicle: aVehicle.
	aSlot asignAvailabilit
	! !
!Empty methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 17:44:07' prior: 50908228!
receive: aVehicle in: aSlot
	
	aSlot asignVehicle: aVehicle.
	aSlot asignAvailability: Occupied 
	! !
!Slot methodsFor: 'nil' stamp: 'pc 5/2/2021 17:44:44'!
asignVehicle: aVehicle
	! !
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 17:45:04' prior: 50908239!
asignVehicle: aVehicle
	vehicle := aVehicle ! !
!Slot methodsFor: 'nil' stamp: 'pc 5/2/2021 17:45:56'!
asignAvailability: aStateClass
	availability := aStateClass new! !

!methodRemoval: Empty #receive: stamp: 'pc 7/5/2021 17:46:57'!
receive: aVehicle 

	
	!
!Occupied methodsFor: 'nil' stamp: 'pc 5/2/2021 17:46:39'!
receive: aVehicle in: aSlot
	! !
!Occupied methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 17:47:14' prior: 50908254!
receive: aVehicle in: aSlot
	Error signal: aSlot class canNotParkInSlotWhenOccupiedErrorDescription! !
!Reserved methodsFor: 'nil' stamp: 'pc 5/2/2021 17:47:30'!
receive: aVehicle in: aSlot
	Error signal: aSlot class canNotParkInSlotWhenOccupiedErrorDescription! !
!Reserved methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 17:47:44' prior: 50908264!
receive: aVehicle in: aSlot
	Error signal: aSlot class canNotParkInSlotWhenReservedErrorDescription! !
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 17:48:35' prior: 50908217!
release

	availability releaseFrom: self
	"self isEmpty ifTrue:[
		Error signal: self class canNotLeaveFromEmptySlotErrorDescription].
	self isReserved ifTrue:[
		Error signal: self class canNotLeaveFromReservedSlotErrorDescription].
	self isOccupied ifTrue: [ 	
		availability isEmpty]"! !
!Empty methodsFor: 'nil' stamp: 'pc 5/2/2021 17:48:54'!
releaseFrom: aSlot
! !
!Empty methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 17:49:25' prior: 50908288!
releaseFrom: aSlot
	Error signal: aSlot class canNotLeaveFromEmptySlotErrorDescription! !
!Reserved methodsFor: 'nil' stamp: 'pc 5/2/2021 17:49:41'!
releaseFrom: aSlot
	Error signal: aSlot class canNotLeaveFromEmptySlotErrorDescription! !
!Reserved methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 17:49:54' prior: 50908297!
releaseFrom: aSlot
	Error signal: aSlot class canNotLeaveFromReservedSlotErrorDescription! !
!Occupied methodsFor: 'nil' stamp: 'pc 5/2/2021 17:50:57'!
releaseFrom: aSlot
	aSlot asignAvailability: Empty! !
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 17:51:22' prior: 50908277!
release

	availability releaseFrom: self
	"self isEmpty ifTrue:[
		Error signal: self class canNotLeaveFromEmptySlotErrorDescription].
	self isReserved ifTrue:[
		Error signal: self class canNotLeaveFromReservedSlotErrorDescription].
	self isOccupied ifTrue: [ 	
		availability := #empty]"! !
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 17:52:44' prior: 50908101 overrides: 16896425!
initialize
	self asignAvailability: Empty ! !
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 17:53:31' prior: 50907882!
reserve
	availability reserveA: self
	"self isOccupied ifTrue:[
		Error signal: self class canNotReserveAnOccupiedSlotErrorDescription].
	self isReserved ifTrue:[
		Error signal: self class canNotReserveAReservedSlotErrorDescription].
	self isEmpty ifTrue: [
	availability := #reserved]."
		! !
!Empty methodsFor: 'nil' stamp: 'pc 5/2/2021 17:53:53'!
reserveA: aSlot
	! !
!Occupied methodsFor: 'nil' stamp: 'pc 5/2/2021 17:54:50'!
reserveA:aSlot
	Error signal: aSlot class canNotReserveAnOccupiedSlotErrorDescription! !
!Reserved methodsFor: 'nil' stamp: 'pc 5/2/2021 17:55:02'!
reserveA:aSlot
	Error signal: aSlot class canNotReserveAnOccupiedSlotErrorDescription! !
!Reserved methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 17:55:19' prior: 50908350!
reserveA:aSlot
	Error signal: aSlot class canNotReserveAReservedSlotErrorDescription! !
!Empty methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 17:56:14' prior: 50908342!
reserveA: aSlot
	aSlot asignAvailability: Reserved ! !
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 17:58:07' prior: 50908200!
receive: aVehicle

	availability receive: aVehicle in: self 

	"self isReserved ifTrue: [
		Error signal: self class 
		canNotParkInSlotWhenReservedErrorDescription] .
	self isOccupied ifTrue: [
		Error signal: self class canNotParkInSlotWhenOccupiedErrorDescription]. 
	self isEmpty ifTrue: [
		availability := #occupied.
		vehicle := aVehicle ]"! !
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 18:07:52' prior: 50908027!
costUsing: aDicc	 ifUnknowVehicleType: aBlock
	
	self isOccupied ifTrue: [
		[^aDicc at: vehicle ifAbsent: [aBlock ]]. 
	aBlock value].
	^0*peso
	
	"self isOccupied ifTrue: [
	(vehicle = #car) ifTrue:  [^aDicc at: #car ifAbsent: [aBlock ]]. 
	(vehicle = #bike) ifTrue:  [^aDicc at: #bike ifAbsent: [aBlock ]].
	aBlock value].
	^0*peso"! !
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 18:10:38' prior: 50908381!
costUsing: aDicc	 ifUnknowVehicleType: aBlock
	
	self isOccupied ifTrue: [
		[^aDicc at: vehicle ifAbsent: [aBlock ]]. 
		aBlock value].
	^0*peso
	
	"self isOccupied ifTrue: [
	(vehicle = #car) ifTrue:  [^aDicc at: #car ifAbsent: [aBlock ]]. 
	(vehicle = #bike) ifTrue:  [^aDicc at: #bike ifAbsent: [aBlock ]].
	aBlock value].
	^0*peso"! !
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 18:11:54' prior: 50908395!
costUsing: aDicc	 ifUnknowVehicleType: aBlock
	
	self isOccupied ifTrue: [
		^aDicc at: vehicle ifAbsent: [aBlock ]].
	^0*peso
	
	"self isOccupied ifTrue: [
	(vehicle = #car) ifTrue:  [^aDicc at: #car ifAbsent: [aBlock ]]. 
	(vehicle = #bike) ifTrue:  [^aDicc at: #bike ifAbsent: [aBlock ]].
	aBlock value].
	^0*peso"! !
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 18:12:47' prior: 50908409!
costUsing: aDicc	 ifUnknowVehicleType: aBlock
	
	self isOccupied ifTrue: [
		aDicc at: vehicle ifAbsent: [aBlock ].
		aBlock value].
	^0*peso
	
	"self isOccupied ifTrue: [
	(vehicle = #car) ifTrue:  [^aDicc at: #car ifAbsent: [aBlock ]]. 
	(vehicle = #bike) ifTrue:  [^aDicc at: #bike ifAbsent: [aBlock ]].
	aBlock value].
	^0*peso"! !
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 18:15:31' prior: 50908422!
costUsing: aDicc	 ifUnknowVehicleType: aBlock
	
	^aDicc at: vehicle ifAbsent: [aBlock].
	
	"self isOccupied ifTrue: [
	(vehicle = #car) ifTrue:  [^aDicc at: #car ifAbsent: [aBlock ]]. 
	(vehicle = #bike) ifTrue:  [^aDicc at: #bike ifAbsent: [aBlock ]].
	aBlock value].
	^0*peso"! !
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 18:17:50' prior: 50908436!
costUsing: aDicc	 ifUnknowVehicleType: aBlock
	
	availability costUsing: aDicc ifUnknowVehicleType: aBlock
	
	"self isOccupied ifTrue: [
	(vehicle = #car) ifTrue:  [^aDicc at: #car ifAbsent: [aBlock ]]. 
	(vehicle = #bike) ifTrue:  [^aDicc at: #bike ifAbsent: [aBlock ]].
	aBlock value].
	^0*peso"! !
!Empty methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 18:18:00'!
costUsing: aDicc ifUnknowVehicleType: aBlock! !
!Empty methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 18:19:07' prior: 50908460!
costUsing: aDicc ifUnknowVehicleType: aBlock
	^0*peso! !
!Reserved methodsFor: 'nil' stamp: 'pc 5/2/2021 18:19:21'!
costUsing: aDicc ifUnknowVehicleType: aBlock
	^0*peso! !
!Occupied methodsFor: 'nil' stamp: 'pc 5/2/2021 18:19:26'!
costUsing: aDicc ifUnknowVehicleType: aBlock
	^0*peso! !
!Occupied methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 18:20:14' prior: 50908473!
costUsing: aDicc ifUnknowVehicleType: aBlock
	^aDicc at: #car ifAbsent: [aBlock ]! !
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 18:21:02' prior: 50908448!
costUsing: aDicc	 ifUnknowVehicleType: aBlock
	
	availability costUsing: aDicc VehicleType: vehicle ifUnknowVehicleType: aBlock
	
	"self isOccupied ifTrue: [
	(vehicle = #car) ifTrue:  [^aDicc at: #car ifAbsent: [aBlock ]]. 
	(vehicle = #bike) ifTrue:  [^aDicc at: #bike ifAbsent: [aBlock ]].
	aBlock value].
	^0*peso"! !
!Empty methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 18:21:13'!
costUsing: aDicc VehicleType: vehicle ifUnknowVehicleType: aBlock
	^0*peso! !

!methodRemoval: Empty #costUsing:ifUnknowVehicleType: stamp: 'pc 7/5/2021 17:46:58'!
costUsing: aDicc ifUnknowVehicleType: aBlock
	^0*peso!
!Reserved methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 18:21:24'!
costUsing: aDicc VehicleType: vehicle ifUnknowVehicleType: aBlock
	^0*peso! !

!methodRemoval: Reserved #costUsing:ifUnknowVehicleType: stamp: 'pc 7/5/2021 17:46:58'!
costUsing: aDicc ifUnknowVehicleType: aBlock
	^0*peso!
!Occupied methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 18:22:00'!
costUsing: aDicc VehicleType: vehicle ifUnknowVehicleType: aBlock
	^aDicc at: vehicle ifAbsent: [aBlock ]! !

!methodRemoval: Occupied #costUsing:ifUnknowVehicleType: stamp: 'pc 7/5/2021 17:46:58'!
costUsing: aDicc ifUnknowVehicleType: aBlock
	^aDicc at: #car ifAbsent: [aBlock ]!
!Occupied methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 18:22:54' prior: 50908517!
costUsing: aDicc VehicleType: vehicle ifUnknowVehicleType: aBlock
	^aDicc at: vehicle ifAbsent: [aBlock value]! !
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 18:27:27' prior: 50908484!
costUsing: aDicc	 ifUnknowVehicleType: aBlock
	
	^availability costUsing: aDicc VehicleType: vehicle ifUnknowVehicleType: aBlock
	
	"self isOccupied ifTrue: [
	(vehicle = #car) ifTrue:  [^aDicc at: #car ifAbsent: [aBlock ]]. 
	(vehicle = #bike) ifTrue:  [^aDicc at: #bike ifAbsent: [aBlock ]].
	aBlock value].
	^0*peso"! !

!classDefinition: #SlotState category: 'ISW1-2019-1C-Parcial' stamp: 'pc 7/5/2021 17:46:58'!
Object subclass: #SlotState
	instanceVariableNames: 'slot'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2019-1C-Parcial'!

!classDefinition: #SlotState category: 'ISW1-2019-1C-Parcial' stamp: 'pc 7/5/2021 17:46:58'!
Object subclass: #SlotState
	instanceVariableNames: 'slot'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2019-1C-Parcial'!
!Empty methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 18:48:15'!
costUsing: aDicc ifUnknowVehicleType: aBlock
	^0*peso! !

!methodRemoval: Empty #costUsing:VehicleType:ifUnknowVehicleType: stamp: 'pc 7/5/2021 17:46:58'!
costUsing: aDicc VehicleType: vehicle ifUnknowVehicleType: aBlock
	^0*peso!
!Occupied methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 18:49:44'!
costUsing: aDicc ifUnknowVehicleType: aBlock
	^slot 	costFromOccupied: aDicc ifUnknowVehicleType: aBlock! !

!methodRemoval: Occupied #costUsing:VehicleType:ifUnknowVehicleType: stamp: 'pc 7/5/2021 17:46:58'!
costUsing: aDicc VehicleType: vehicle ifUnknowVehicleType: aBlock
	^aDicc at: vehicle ifAbsent: [aBlock value]!
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 18:51:35' prior: 50908326 overrides: 16896425!
initialize
	availability := Empty for: self ! !
!SlotState class methodsFor: 'nil' stamp: 'pc 5/2/2021 18:52:27'!
for: aSlot
	self new initializeWith: aSlot
	! !
!SlotState methodsFor: 'nil' stamp: 'pc 5/2/2021 18:52:48'!
initializeWith:aSlot
	slot := aSlot.! !
!Empty methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 18:53:04'!
receive: aVehicle 
	
	slot asignVehicle: aVehicle.
	slot asignAvailability: Occupied 
	! !

!methodRemoval: Empty #receive:in: stamp: 'pc 7/5/2021 17:46:58'!
receive: aVehicle in: aSlot
	
	aSlot asignVehicle: aVehicle.
	aSlot asignAvailability: Occupied 
	!
!Empty methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 18:53:23'!
releaseFrom
	Error signal: slot class canNotLeaveFromEmptySlotErrorDescription! !
!Empty methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 18:53:30'!
release
	Error signal: slot class canNotLeaveFromEmptySlotErrorDescription! !

!methodRemoval: Empty #releaseFrom stamp: 'pc 7/5/2021 17:46:58'!
releaseFrom
	Error signal: slot class canNotLeaveFromEmptySlotErrorDescription!

!methodRemoval: Empty #releaseFrom: stamp: 'pc 7/5/2021 17:46:58'!
releaseFrom: aSlot
	Error signal: aSlot class canNotLeaveFromEmptySlotErrorDescription!
!Empty methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 18:53:48'!
reserve
	slot asignAvailability: Reserved ! !
!Occupied methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 18:53:58'!
receive: aVehicle 
	Error signal: slot class canNotParkInSlotWhenOccupiedErrorDescription! !

!methodRemoval: Occupied #receive:in: stamp: 'pc 7/5/2021 17:46:58'!
receive: aVehicle in: aSlot
	Error signal: aSlot class canNotParkInSlotWhenOccupiedErrorDescription!
!Occupied methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 18:54:10'!
release
	slot asignAvailability: Empty! !

!methodRemoval: Occupied #releaseFrom: stamp: 'pc 7/5/2021 17:46:58'!
releaseFrom: aSlot
	aSlot asignAvailability: Empty!
!Occupied methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 18:54:32'!
reserve
	Error signal: slot class canNotReserveAnOccupiedSlotErrorDescription! !

!methodRemoval: Occupied #reserveA: stamp: 'pc 7/5/2021 17:46:58'!
reserveA:aSlot
	Error signal: aSlot class canNotReserveAnOccupiedSlotErrorDescription!

!methodRemoval: Empty #reserveA: stamp: 'pc 7/5/2021 17:46:58'!
reserveA: aSlot
	aSlot asignAvailability: Reserved !
!Reserved methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 18:54:51'!
receive: aVehicle 
	Error signal: slot class canNotParkInSlotWhenReservedErrorDescription! !

!methodRemoval: Reserved #receive:in: stamp: 'pc 7/5/2021 17:46:58'!
receive: aVehicle in: aSlot
	Error signal: aSlot class canNotParkInSlotWhenReservedErrorDescription!
!Reserved methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 18:55:09'!
release
	Error signal: slot class canNotLeaveFromReservedSlotErrorDescription! !

!methodRemoval: Reserved #releaseFrom: stamp: 'pc 7/5/2021 17:46:58'!
releaseFrom: aSlot
	Error signal: aSlot class canNotLeaveFromReservedSlotErrorDescription!
!Reserved methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 18:55:21'!
reserve
	Error signal: slot class canNotReserveAReservedSlotErrorDescription! !

!methodRemoval: Reserved #reserveA: stamp: 'pc 7/5/2021 17:46:58'!
reserveA:aSlot
	Error signal: aSlot class canNotReserveAReservedSlotErrorDescription!
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 18:55:44' prior: 50908367!
receive: aVehicle

	availability receive: aVehicle

	"self isReserved ifTrue: [
		Error signal: self class 
		canNotParkInSlotWhenReservedErrorDescription] .
	self isOccupied ifTrue: [
		Error signal: self class canNotParkInSlotWhenOccupiedErrorDescription]. 
	self isEmpty ifTrue: [
		availability := #occupied.
		vehicle := aVehicle ]"! !
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 18:55:49' prior: 50908313!
release

	availability release
	"self isEmpty ifTrue:[
		Error signal: self class canNotLeaveFromEmptySlotErrorDescription].
	self isReserved ifTrue:[
		Error signal: self class canNotLeaveFromReservedSlotErrorDescription].
	self isOccupied ifTrue: [ 	
		availability := #empty]"! !
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 18:55:54' prior: 50908331!
reserve
	availability reserve
	"self isOccupied ifTrue:[
		Error signal: self class canNotReserveAnOccupiedSlotErrorDescription].
	self isReserved ifTrue:[
		Error signal: self class canNotReserveAReservedSlotErrorDescription].
	self isEmpty ifTrue: [
	availability := #reserved]."
		! !
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 18:56:43' prior: 50908247!
asignAvailability: aStateClass
	availability := aStateClass new! !
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 19:17:43' prior: 50908699!
receive: aVehicle

	availability receive: aVehicle

	! !
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 19:17:49' prior: 50908713!
release

	availability release
	! !
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 19:17:53' prior: 50908725!
reserve
	availability reserve

		! !
!SlotState class methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 19:26:42' prior: 50908591!
for: aSlot
	^self new initializeWith: aSlot
	! !
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 19:31:41' prior: 50908737!
asignAvailability: aStateClass
	availability := aStateClass for: self! !
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 19:32:09' prior: 50908536!
costUsing: aDicc	 ifUnknowVehicleType: aBlock
	
	^availability costUsing: aDicc ifUnknowVehicleType: aBlock
	
	"self isOccupied ifTrue: [
	(vehicle = #car) ifTrue:  [^aDicc at: #car ifAbsent: [aBlock ]]. 
	(vehicle = #bike) ifTrue:  [^aDicc at: #bike ifAbsent: [aBlock ]].
	aBlock value].
	^0*peso"! !
!Slot methodsFor: 'nil' stamp: 'pc 5/2/2021 19:33:08'!
costFromOccupied: aDicc ifUnknowVehicleType: aBlock
	aDicc at: vehicle ifAbsent: [aBlock ]! !
!Reserved methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 19:33:15'!
costUsing: aDicc ifUnknowVehicleType: aBlock
	^0*peso! !

!methodRemoval: Reserved #costUsing:VehicleType:ifUnknowVehicleType: stamp: 'pc 7/5/2021 17:46:59'!
costUsing: aDicc VehicleType: vehicle ifUnknowVehicleType: aBlock
	^0*peso!
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 19:38:52' prior: 50908778!
costFromOccupied: aDicc ifUnknowVehicleType: aBlock
	^aDicc at: vehicle ifAbsent: [aBlock ]! !
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 19:39:16' prior: 50908795!
costFromOccupied: aDicc ifUnknowVehicleType: aBlock
	aDicc at: vehicle ifAbsent: [aBlock ]! !
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 19:44:17' prior: 50908766!
costUsing: aDicc	 ifUnknowVehicleType: aBlock
	
	^availability costUsing: aDicc ifUnknowVehicleType: aBlock
	
! !
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 19:45:07' prior: 50908801!
costFromOccupied: aDicc ifUnknowVehicleType: aBlock
	^aDicc at: vehicle ifAbsent: [aBlock ]! !
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 19:46:18' prior: 50908807!
costUsing: aDicc	 ifUnknowVehicleType: aBlock
	
	^availability costUsing: aDicc ifUnknowVehicleType: [aBlock]
	
! !
!Occupied methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 19:46:27' prior: 50908573!
costUsing: aDicc ifUnknowVehicleType: aBlock
	^slot 	costFromOccupied: aDicc ifUnknowVehicleType: [aBlock]! !
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 19:46:56' prior: 50908820!
costUsing: aDicc	 ifUnknowVehicleType: aBlock
	
	^availability costUsing: aDicc ifUnknowVehicleType: aBlock
	
! !
!Occupied methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 19:47:09' prior: 50908827!
costUsing: aDicc ifUnknowVehicleType: aBlock
	^slot 	costFromOccupied: aDicc ifUnknowVehicleType: aBlock! !
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 19:47:29' prior: 50908814!
costFromOccupied: aDicc ifUnknowVehicleType: aBlock
	^aDicc at: vehicle ifAbsent: [aBlock]! !
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 19:48:14' prior: 50908848!
costFromOccupied: aDicc ifUnknowVehicleType: aBlock
	^aDicc at: vehicle ifAbsent: [aBlock value]! !
!Slot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 19:48:33' prior: 50908854!
costFromOccupied: aDicc ifUnknowVehicleType: aBlock
	^aDicc at: vehicle ifAbsent: aBlock! !
!Slot methodsFor: 'nil' stamp: 'pc 5/2/2021 19:52:42'!
vehicleType
	^vehicle ! !
!ParkingLot methodsFor: 'cost' stamp: 'pc 5/2/2021 20:00:01' prior: 50907233!
totalBikesParked

	self totalVehiclesParked: #bike.
	
	"| totalBikesParked |
	
	totalBikesParked := 0*peso.
	slots do: [ :aSlot | (aSlot isOccupied and: [ aSlot vehicleType = #bike ]) ifTrue: [totalBikesParked := totalBikesParked + (self costOf: aSlot)]].
	
	^totalBikesParked"
	! !
!ParkingLot methodsFor: 'nil' stamp: 'pc 5/2/2021 20:00:20'!
totalVehiclesParked: aVehiecle
	! !
!ParkingLot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 20:02:51' prior: 50908880!
totalVehiclesParked: aVehiecle
	slots select: [:aSlot | (aSlot isOccupied and: [ aSlot vehicleType = aVehiecle ])].! !
!ParkingLot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 20:03:07' prior: 50908885!
totalVehiclesParked: aVehicle
	slots select: [:aSlot | (aSlot isOccupied and: [ aSlot vehicleType = aVehicle ])].! !
!ParkingLot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 20:04:28' prior: 50908892!
totalVehiclesParked: aVehicle
	(slots select: [:aSlot | (aSlot isOccupied and: [ aSlot vehicleType = aVehicle ])]) sum: [] ifEmpty: [^0*peso].! !
!ParkingLot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 20:08:33' prior: 50908899!
totalVehiclesParked: aVehicle
	(slots select: [:aSlot | (aSlot isOccupied and: [ aSlot vehicleType = aVehicle ])]) sum: [] ifEmpty: [^0*peso].! !
!ParkingLot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 20:11:31' prior: 50908907!
totalVehiclesParked: aVehicle
	(slots select: [:aSlot | (aSlot isOccupied and: [ aSlot vehicleType = aVehicle ])]) sum: [:sum | ] ifEmpty: [^0*peso].! !
!ParkingLot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 20:12:25' prior: 50908915!
totalVehiclesParked: aVehicle
	(slots select: [:aSlot | (aSlot isOccupied and: [ aSlot vehicleType = aVehicle ])]) sum: [:aSlot | self costOf: aSlot] ifEmpty: [^0*peso].! !
!ParkingLot methodsFor: 'cost' stamp: 'pc 5/2/2021 20:13:13' prior: 50907243!
totalCarsParked
	^self totalVehiclesParked: #car.
	"| totalCarsParked |
	
	totalCarsParked := 0*peso.
	slots do: [ :aSlot | (aSlot isOccupied and: [ aSlot vehicleType = #car ]) ifTrue: [totalCarsParked := totalCarsParked + (self costOf: aSlot)]].
	
	^totalCarsParked"
	! !
!ParkingLot methodsFor: 'cost' stamp: 'pc 5/2/2021 20:13:18' prior: 50908869!
totalBikesParked

	^self totalVehiclesParked: #bike.
	
	"| totalBikesParked |
	
	totalBikesParked := 0*peso.
	slots do: [ :aSlot | (aSlot isOccupied and: [ aSlot vehicleType = #bike ]) ifTrue: [totalBikesParked := totalBikesParked + (self costOf: aSlot)]].
	
	^totalBikesParked"
	! !
!ParkingLot methodsFor: 'cost' stamp: 'pc 5/2/2021 20:13:24' prior: 50908931!
totalCarsParked

	^self totalVehiclesParked: #car.
	
	"| totalCarsParked |
	
	totalCarsParked := 0*peso.
	slots do: [ :aSlot | (aSlot isOccupied and: [ aSlot vehicleType = #car ]) ifTrue: [totalCarsParked := totalCarsParked + (self costOf: aSlot)]].
	
	^totalCarsParked"
	! !
!ParkingLot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 20:15:13'!
totalParkedOf: aVehicle
	(slots select: [:aSlot | (aSlot isOccupied and: [ aSlot vehicleType = aVehicle ])]) sum: [:aSlot | self costOf: aSlot] ifEmpty: [^0*peso].! !

!methodRemoval: ParkingLot #totalVehiclesParked: stamp: 'pc 7/5/2021 17:46:59'!
totalVehiclesParked: aVehicle
	(slots select: [:aSlot | (aSlot isOccupied and: [ aSlot vehicleType = aVehicle ])]) sum: [:aSlot | self costOf: aSlot] ifEmpty: [^0*peso].!
!ParkingLot methodsFor: 'cost' stamp: 'pc 5/2/2021 20:15:29' prior: 50908942!
totalBikesParked

	^self totalParkedOf: #bike.
	
	"| totalBikesParked |
	
	totalBikesParked := 0*peso.
	slots do: [ :aSlot | (aSlot isOccupied and: [ aSlot vehicleType = #bike ]) ifTrue: [totalBikesParked := totalBikesParked + (self costOf: aSlot)]].
	
	^totalBikesParked"
	! !
!ParkingLot methodsFor: 'cost' stamp: 'pc 5/2/2021 20:15:38' prior: 50908954!
totalCarsParked

	^self totalParkedOf: #car.
	
	"| totalCarsParked |
	
	totalCarsParked := 0*peso.
	slots do: [ :aSlot | (aSlot isOccupied and: [ aSlot vehicleType = #car ]) ifTrue: [totalCarsParked := totalCarsParked + (self costOf: aSlot)]].
	
	^totalCarsParked"
	! !
!ParkingLot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 20:20:00' prior: 50908966!
totalParkedOf: aVehicle
	(slots select: [:aSlot | aSlot isOccupied and: [ aSlot vehicleType = aVehicle ]]) sum: [:aSlot | self costOf: aSlot] ifEmpty: [^0*peso].! !
!ParkingLot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 20:20:11' prior: 50909006!
totalParkedOf: aVehicle
	(slots select: [:aSlot | aSlot isOccupied and: [aSlot vehicleType = aVehicle ]]) sum: [:aSlot | self costOf: aSlot] ifEmpty: [^0*peso].! !
!ParkingLot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 20:21:18' prior: 50909015!
totalParkedOf: aVehicle
	^ (slots select: [:aSlot | aSlot isOccupied and: [aSlot vehicleType = aVehicle ]]) sum: [:aSlot | self costOf: aSlot] ifEmpty: [^0*peso].
	
	! !
!ParkingLot methodsFor: 'as yet unclassified' stamp: 'pc 5/2/2021 20:22:26' prior: 50909024!
totalParkedOf: aVehicle
	^(slots select: [:aSlot | aSlot isOccupied and: [aSlot vehicleType = aVehicle ]]) sum: [:aSlot | self costOf: aSlot] ifEmpty: [^0*peso].
	
	! !
!ParkingLot methodsFor: 'filtering' stamp: 'pc 5/2/2021 20:27:25' prior: 50907189!
occupiedSlots

	self select: [:aSlot | aSlot isOccupied]
	"| occupiedSlots |
	
	occupiedSlots := OrderedCollection new.
	slots do: [ :aSlot | aSlot isOccupied ifTrue: [ occupiedSlots add: aSlot ]]. 
	
	^ occupiedSlots"! !
!ParkingLot methodsFor: 'filtering' stamp: 'pc 5/2/2021 20:27:50' prior: 50909041!
occupiedSlots

	^self select: [:aSlot | aSlot isOccupied]
	"| occupiedSlots |
	
	occupiedSlots := OrderedCollection new.
	slots do: [ :aSlot | aSlot isOccupied ifTrue: [ occupiedSlots add: aSlot ]]. 
	
	^ occupiedSlots"! !
!ParkingLot methodsFor: 'filtering' stamp: 'pc 5/2/2021 20:29:14' prior: 50909051!
occupiedSlots

	^self select: [:aSlot | aSlot isOccupied]
	
	"| occupiedSlots |
	
	occupiedSlots := OrderedCollection new.
	slots do: [ :aSlot | aSlot isOccupied ifTrue: [ occupiedSlots add: aSlot ]]. 
	
	^ occupiedSlots"! !
!ParkingLot methodsFor: 'filtering' stamp: 'pc 5/2/2021 20:30:07' prior: 50909061!
occupiedSlots

	^self select: [:aSlot | aSlot isOccupied].
	
	"| occupiedSlots |
	
	occupiedSlots := OrderedCollection new.
	slots do: [ :aSlot | aSlot isOccupied ifTrue: [ occupiedSlots add: aSlot ]]. 
	
	^ occupiedSlots"! !
!ParkingLot methodsFor: 'filtering' stamp: 'pc 5/2/2021 20:31:51' prior: 50909071!
occupiedSlots

	^slots select: [:aSlot | aSlot isOccupied].
	
	"| occupiedSlots |
	
	occupiedSlots := OrderedCollection new.
	slots do: [ :aSlot | aSlot isOccupied ifTrue: [ occupiedSlots add: aSlot ]]. 
	
	^ occupiedSlots"! !
!ParkingLot methodsFor: 'filtering' stamp: 'pc 5/2/2021 20:34:46' prior: 50907197!
reservedSlots
	
	^slots select: [:aSlot | aSlot isReserved ].
	
	"| reservedSlots |
	
	reservedSlots := OrderedCollection new.
	slots do: [ :aSlot | aSlot isReserved ifTrue: [ reservedSlots add: aSlot ]]. 
	
	^ reservedSlots"! !
!ParkingLot methodsFor: 'filtering' stamp: 'pc 5/2/2021 20:35:04' prior: 50907182!
freeSlots

	^slots select: [:aSlot | aSlot isEmpty ].

	"| freeSlots |
	
	freeSlots := OrderedCollection new.
	slots do: [ :aSlot | aSlot isEmpty ifTrue: [ freeSlots add: aSlot ]]. 
	
	^ freeSlots"! !
!SlotState methodsFor: 'nil' stamp: 'pc 5/2/2021 20:37:09'!
reserve
	self subclassResponsibility ! !
!SlotState methodsFor: 'nil' stamp: 'pc 5/2/2021 20:37:28'!
release
	self subclassResponsibility ! !
!SlotState methodsFor: 'nil' stamp: 'pc 5/2/2021 20:37:46'!
receive: aVehicle 
	self subclassResponsibility ! !

!classDefinition: #CantSuspend category: 'CodigoRepetido-Ejercicio' stamp: 'pc 7/5/2021 17:46:59'!
Error subclass: #CantSuspend
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CodigoRepetido-Ejercicio'!

!classDefinition: #CantSuspend category: 'CodigoRepetido-Ejercicio' stamp: 'pc 7/5/2021 17:46:59'!
Error subclass: #CantSuspend
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CodigoRepetido-Ejercicio'!

!classDefinition: #NotFound category: 'CodigoRepetido-Ejercicio' stamp: 'pc 7/5/2021 17:46:59'!
Error subclass: #NotFound
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CodigoRepetido-Ejercicio'!

!classDefinition: #NotFound category: 'CodigoRepetido-Ejercicio' stamp: 'pc 7/5/2021 17:46:59'!
Error subclass: #NotFound
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CodigoRepetido-Ejercicio'!

!classDefinition: #CustomerBookTest category: 'CodigoRepetido-Ejercicio' stamp: 'pc 7/5/2021 17:46:59'!
TestCase subclass: #CustomerBookTest
	instanceVariableNames: 'customerBook paulMcCartney johnLennon'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CodigoRepetido-Ejercicio'!

!classDefinition: #CustomerBookTest category: 'CodigoRepetido-Ejercicio' stamp: 'pc 7/5/2021 17:46:59'!
TestCase subclass: #CustomerBookTest
	instanceVariableNames: 'customerBook paulMcCartney johnLennon'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CodigoRepetido-Ejercicio'!
!CustomerBookTest methodsFor: 'assertions' stamp: 'HAW 9/20/2018 09:33:40'!
assertNumberOfActiveCustomersIn: aCustomerBook is: aNumberOfActiveCustomers andSuspendedIs: aNumberOfSuspendedCustomers

	self assert: aNumberOfActiveCustomers equals: aCustomerBook numberOfActiveCustomers.
	self assert: aNumberOfSuspendedCustomers equals: aCustomerBook numberOfSuspendedCustomers.
	self assert: aNumberOfActiveCustomers + aNumberOfSuspendedCustomers equals: aCustomerBook numberOfCustomers.
! !
!CustomerBookTest methodsFor: 'assertions' stamp: 'NR 5/8/2020 19:01:57' overrides: 50634177!
should: aBlockToMeasure notTakeMoreThan: aTimeLimit
	
	| millisecondsBeforeRunning millisecondsAfterRunning|
	
	millisecondsBeforeRunning := Time millisecondClockValue * millisecond.
	aBlockToMeasure value.
	millisecondsAfterRunning := Time millisecondClockValue * millisecond.
	
	self assert: (millisecondsAfterRunning-millisecondsBeforeRunning) < aTimeLimit.
	
	
	"Solucion Alternativa: (tambien pueden reificarla ustedes mismos)"
	"
	|millisecondsRunning|
	
	millisecondsRunning := aBlockToMeasure timeToRun * millisecond.
	
	self assert: millisecondsRunning < aTimeLimit.
	"
	

! !
!CustomerBookTest methodsFor: 'assertions' stamp: 'NR 5/8/2020 18:59:55'!
should: aBlockThatShouldFail raise: anExceptionType asserting: aVerificationBlock

	[ aBlockThatShouldFail value.
	self fail ]
		on: anExceptionType 
		do: aVerificationBlock 
	
	"Ver should:raise:withExceptionDo: de TestCase..."
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'NR 9/24/2018 02:39:25'!
test01AddingCustomerShouldNotTakeMoreThan50Milliseconds

	self 
		should: [ customerBook addCustomerNamed: johnLennon ]
		notTakeMoreThan: 50 * millisecond
	

	
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'NR 9/24/2018 02:36:37'!
test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds
	
	customerBook addCustomerNamed: paulMcCartney.
	
	self 
		should: [ customerBook removeCustomerNamed: paulMcCartney ]
		notTakeMoreThan: 100 * millisecond

! !
!CustomerBookTest methodsFor: 'testing' stamp: 'NR 9/24/2018 02:36:43'!
test03CanNotAddACustomerWithEmptyName 

	self 
		should: [ customerBook addCustomerNamed: '' ]
		raise: Error
		asserting: [ :anError |  
			self assert: anError messageText = CustomerBook customerCanNotBeEmptyErrorMessage.
			self assert: customerBook isEmpty ]! !
!CustomerBookTest methodsFor: 'testing' stamp: 'NR 9/24/2018 02:39:39'!
test04CanNotRemoveAnInvalidCustomer
	
	customerBook addCustomerNamed: johnLennon.
	
	self 
		should: [ customerBook removeCustomerNamed: paulMcCartney]
		raise: NotFound 
		asserting: [ :anError | 
			self assert: customerBook numberOfCustomers = 1.
			self assert: (customerBook includesCustomerNamed: johnLennon) ]! !
!CustomerBookTest methodsFor: 'testing' stamp: 'NR 9/24/2018 02:38:26'!
test05SuspendingACustomerShouldNotRemoveItFromCustomerBook

	customerBook addCustomerNamed: paulMcCartney.
	customerBook suspendCustomerNamed: paulMcCartney.
	
	self assertNumberOfActiveCustomersIn: customerBook is: 0 andSuspendedIs: 1.
	self assert: (customerBook includesCustomerNamed: paulMcCartney).
	

	
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'NR 9/24/2018 02:38:33'!
test06RemovingASuspendedCustomerShouldRemoveItFromCustomerBook
	
	customerBook addCustomerNamed: paulMcCartney.
	customerBook suspendCustomerNamed: paulMcCartney.
	customerBook removeCustomerNamed: paulMcCartney.
	
	self assertNumberOfActiveCustomersIn: customerBook is: 0 andSuspendedIs: 0.
	self deny: (customerBook includesCustomerNamed: paulMcCartney).
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'NR 9/23/2020 20:00:49'!
test07CanNotSuspendAnInvalidCustomer

	customerBook addCustomerNamed: johnLennon.
	
	self
		should: [ customerBook suspendCustomerNamed: 'George Harrison']
		raise: CantSuspend 
		asserting: [ :anError | 
			self assert: customerBook numberOfCustomers = 1.
			self assert: (customerBook includesCustomerNamed: johnLennon) ]
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'NR 9/24/2018 02:39:06'!
test08CanNotSuspendAnAlreadySuspendedCustomer

	customerBook addCustomerNamed: johnLennon.
	customerBook suspendCustomerNamed: johnLennon.
	
	self
		should: [ customerBook suspendCustomerNamed: johnLennon ]
		raise: CantSuspend 
		asserting: [ :anError | 
			self assert: customerBook numberOfCustomers = 1.
			self assert: (customerBook includesCustomerNamed: johnLennon) ]
! !
!CustomerBookTest methodsFor: 'setUp' stamp: 'NR 5/7/2020 03:50:44' overrides: 16927572!
setUp
		
		"Atenci�n: Analizar pros y cons de utilizar este mensaje cuando los objetos son mutables. Probar hacer el debug de un test (por ej. el 06) y darle restart antes de que termine. �Qu� ocurre con las colecciones?"
		
		customerBook := CustomerBook  new.
		paulMcCartney := 'Paul McCartney'.
		johnLennon := 'John Lennon'! !

!classDefinition: #CustomerBook category: 'CodigoRepetido-Ejercicio' stamp: 'pc 7/5/2021 17:47:00'!
Object subclass: #CustomerBook
	instanceVariableNames: 'suspended active'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CodigoRepetido-Ejercicio'!

!classDefinition: #CustomerBook category: 'CodigoRepetido-Ejercicio' stamp: 'pc 7/5/2021 17:47:00'!
Object subclass: #CustomerBook
	instanceVariableNames: 'suspended active'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CodigoRepetido-Ejercicio'!
!CustomerBook methodsFor: 'testing' stamp: 'NR 9/24/2018 02:27:53'!
includesCustomerNamed: aName

	^(active includes: aName) or: [suspended includes: aName]! !
!CustomerBook methodsFor: 'testing' stamp: 'NR 9/24/2018 02:27:53'!
isEmpty
	
	^active isEmpty and: [suspended isEmpty]! !
!CustomerBook methodsFor: 'initialization' stamp: 'NR 9/23/2020 20:01:39' overrides: 16896425!
initialize

	active := OrderedCollection new.
	suspended:= OrderedCollection new! !
!CustomerBook methodsFor: 'customer management' stamp: 'NR 9/24/2018 02:27:53'!
addCustomerNamed: aName

	aName isEmpty ifTrue: [ self signalCustomerNameCannotBeEmpty ].
	(self includesCustomerNamed: aName) ifTrue: [ self signalCustomerAlreadyExists ].
	
	active add: aName ! !
!CustomerBook methodsFor: 'customer management' stamp: 'NR 9/24/2018 02:27:53'!
numberOfActiveCustomers
	
	^active size! !
!CustomerBook methodsFor: 'customer management' stamp: 'NR 4/3/2019 10:55:16'!
numberOfCustomers
	
	^self numberOfActiveCustomers + self numberOfSuspendedCustomers! !
!CustomerBook methodsFor: 'customer management' stamp: 'NR 9/19/2018 18:05:35'!
numberOfSuspendedCustomers
	
	^suspended size! !
!CustomerBook methodsFor: 'customer management' stamp: 'NR 4/17/2021 17:59:01'!
removeCustomerNamed: aName 

	^self removeFrom: active lookingFor: aName ifAbsent: 
		[self removeFrom: suspended lookingFor: aName ifAbsent: 
			[^ NotFound signal.]]

 
	"Solucion Alternativa:"

	"active remove: aName ifAbsent: [ suspended remove: aName ifAbsent: [ ^ NotFound signal ]]."
	
	
! !
!CustomerBook methodsFor: 'customer management' stamp: 'HernanWilkinson 7/6/2011 17:52'!
signalCustomerAlreadyExists 

	self error: self class customerAlreadyExistsErrorMessage! !
!CustomerBook methodsFor: 'customer management' stamp: 'HernanWilkinson 7/6/2011 17:51'!
signalCustomerNameCannotBeEmpty 

	self error: self class customerCanNotBeEmptyErrorMessage ! !
!CustomerBook methodsFor: 'customer management' stamp: 'NR 9/24/2018 02:27:53'!
suspendCustomerNamed: aName 
	
	active remove: aName ifAbsent:[ ^ CantSuspend signal ].
			
	suspended add: aName


! !
!CustomerBook methodsFor: 'collections' stamp: 'NR 5/7/2020 03:45:48'!
removeFrom: aCollection lookingFor: aName ifAbsent: aBlockToContinue
 
	1 to: aCollection size do: 
	[ :index |
		aName = (aCollection at: index)
			ifTrue: [
				aCollection removeAt: index.
				^ aName 
			] 
	].

	^aBlockToContinue value! !

!classDefinition: 'CustomerBook class' category: 'CodigoRepetido-Ejercicio' stamp: 'pc 7/5/2021 17:47:00'!
CustomerBook class
	instanceVariableNames: ''!

!classDefinition: 'CustomerBook class' category: 'CodigoRepetido-Ejercicio' stamp: 'pc 7/5/2021 17:47:00'!
CustomerBook class
	instanceVariableNames: ''!
!CustomerBook class methodsFor: 'error messages' stamp: 'NR 5/7/2020 03:44:34'!
customerAlreadyExistsErrorMessage

	^'Customer already exists'! !
!CustomerBook class methodsFor: 'error messages' stamp: 'NR 5/7/2020 03:44:24'!
customerCanNotBeEmptyErrorMessage

	^'Customer name cannot be empty'! !

!classDefinition: #NumeroTest category: 'Numero-Solution-1' stamp: 'pc 7/5/2021 17:47:00'!
TestCase subclass: #NumeroTest
	instanceVariableNames: 'zero one two four oneFifth oneHalf five twoFifth twoTwentyfifth fiveHalfs three eight negativeOne negativeTwo'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Solution-1'!

!classDefinition: #NumeroTest category: 'Numero-Solution-1' stamp: 'pc 7/5/2021 17:47:00'!
TestCase subclass: #NumeroTest
	instanceVariableNames: 'zero one two four oneFifth oneHalf five twoFifth twoTwentyfifth fiveHalfs three eight negativeOne negativeTwo'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Solution-1'!
!NumeroTest methodsFor: 'tests' stamp: 'HernanWilkinson 5/7/2016 20:11'!
test01isCeroReturnsTrueWhenAskToZero

	self assert: zero isZero! !
!NumeroTest methodsFor: 'tests' stamp: 'HernanWilkinson 5/7/2016 20:12'!
test02isCeroReturnsFalseWhenAskToOthersButZero

	self deny: one isZero! !
!NumeroTest methodsFor: 'tests' stamp: 'HernanWilkinson 5/7/2016 20:13'!
test03isOneReturnsTrueWhenAskToOne

	self assert: one isOne! !
!NumeroTest methodsFor: 'tests' stamp: 'HernanWilkinson 5/7/2016 20:13'!
test04isOneReturnsFalseWhenAskToOtherThanOne

	self deny: zero isOne! !
!NumeroTest methodsFor: 'tests' stamp: 'HernanWilkinson 5/7/2016 20:14'!
test05EnteroAddsWithEnteroCorrectly

	self assert: one + one equals: two! !
!NumeroTest methodsFor: 'tests' stamp: 'HernanWilkinson 5/7/2016 20:18'!
test06EnteroMultipliesWithEnteroCorrectly

	self assert: two * two equals: four! !
!NumeroTest methodsFor: 'tests' stamp: 'HernanWilkinson 5/7/2016 20:20'!
test07EnteroDividesEnteroCorrectly

	self assert: two / two equals: one! !
!NumeroTest methodsFor: 'tests' stamp: 'HernanWilkinson 5/7/2016 20:38'!
test08FraccionAddsWithFraccionCorrectly
"
    La suma de fracciones es:
	 
	a/b + c/d = (a.d + c.b) / (b.d)
	 
	SI ESTAN PENSANDO EN LA REDUCCION DE FRACCIONES NO SE PREOCUPEN!!
	TODAVIA NO SE ESTA TESTEANDO ESE CASO
"
	| sevenTenths |

	sevenTenths := (Entero with: 7) / (Entero with: 10).

	self assert: oneFifth + oneHalf equals: sevenTenths! !
!NumeroTest methodsFor: 'tests' stamp: 'HernanWilkinson 5/7/2016 20:52'!
test09FraccionMultipliesWithFraccionCorrectly
"
    La multiplicacion de fracciones es:
	 
	(a/b) * (c/d) = (a.c) / (b.d)
"

	self assert: oneFifth * twoFifth equals: twoTwentyfifth! !
!NumeroTest methodsFor: 'tests' stamp: 'HernanWilkinson 5/7/2016 20:56'!
test10FraccionDividesFraccionCorrectly
"
    La division de fracciones es:
	 
	(a/b) / (c/d) = (a.d) / (b.c)
"

	self assert: oneHalf / oneFifth equals: fiveHalfs! !
!NumeroTest methodsFor: 'tests' stamp: 'HernanWilkinson 5/7/2016 21:07'!
test11EnteroAddsFraccionCorrectly
"
	Ahora empieza la diversion!!
"

	self assert: one + oneFifth equals: (Entero with: 6) / (Entero with: 5)! !
!NumeroTest methodsFor: 'tests' stamp: 'HernanWilkinson 5/7/2016 21:07'!
test12FraccionAddsEnteroCorrectly

	self assert: oneFifth + one equals: (Entero with: 6) / (Entero with: 5)! !
!NumeroTest methodsFor: 'tests' stamp: 'HernanWilkinson 5/7/2016 21:50'!
test13EnteroMultipliesFraccionCorrectly

	self assert: two * oneFifth equals: twoFifth ! !
!NumeroTest methodsFor: 'tests' stamp: 'HernanWilkinson 5/7/2016 21:52'!
test14FraccionMultipliesEnteroCorrectly

	self assert: oneFifth * two equals: twoFifth ! !
!NumeroTest methodsFor: 'tests' stamp: 'HernanWilkinson 5/7/2016 21:57'!
test15EnteroDividesFraccionCorrectly

	self assert: one / twoFifth equals: fiveHalfs  ! !
!NumeroTest methodsFor: 'tests' stamp: 'HernanWilkinson 5/7/2016 21:59'!
test16FraccionDividesEnteroCorrectly

	self assert: twoFifth / five equals: twoTwentyfifth ! !
!NumeroTest methodsFor: 'tests' stamp: 'HernanWilkinson 5/7/2016 22:38'!
test17AFraccionCanBeEqualToAnEntero

	self assert: two equals: four / two! !
!NumeroTest methodsFor: 'tests' stamp: 'HernanWilkinson 5/7/2016 22:39'!
test18AparentFraccionesAreEqual

	self assert: oneHalf equals: two / four! !
!NumeroTest methodsFor: 'tests' stamp: 'HernanWilkinson 5/7/2016 22:40'!
test19AddingFraccionesCanReturnAnEntero

	self assert: oneHalf + oneHalf equals: one! !
!NumeroTest methodsFor: 'tests' stamp: 'HernanWilkinson 5/7/2016 22:42'!
test20MultiplyingFraccionesCanReturnAnEntero

	self assert: (two/five) * (five/two) equals: one! !
!NumeroTest methodsFor: 'tests' stamp: 'HernanWilkinson 5/7/2016 22:42'!
test21DividingFraccionesCanReturnAnEntero

	self assert: oneHalf / oneHalf equals: one! !
!NumeroTest methodsFor: 'tests' stamp: 'HernanWilkinson 5/7/2016 22:43'!
test22DividingEnterosCanReturnAFraccion

	self assert: two / four equals: oneHalf! !
!NumeroTest methodsFor: 'tests' stamp: 'HernanWilkinson 5/7/2016 22:46'!
test23CanNotDivideEnteroByZero

	self 
		should: [ one / zero ]
		raise: Error
		withExceptionDo: [ :anError | self assert: anError messageText equals: Numero canNotDivideByZeroErrorDescription ]
	! !
!NumeroTest methodsFor: 'tests' stamp: 'HernanWilkinson 5/7/2016 22:46'!
test24CanNotDivideFraccionByZero

	self 
		should: [ oneHalf / zero ]
		raise: Error
		withExceptionDo: [ :anError | self assert: anError messageText equals: Numero canNotDivideByZeroErrorDescription ]
	! !
!NumeroTest methodsFor: 'tests' stamp: 'HernanWilkinson 5/7/2016 22:50'!
test25AFraccionCanNotBeZero

	self deny: oneHalf isZero! !
!NumeroTest methodsFor: 'tests' stamp: 'HernanWilkinson 5/7/2016 22:50'!
test26AFraccionCanNotBeOne

	self deny: oneHalf isOne! !
!NumeroTest methodsFor: 'tests' stamp: 'NR 10/1/2018 00:55:33'!
test27EnteroSubstractsEnteroCorrectly

	self assert: two - one equals: one! !
!NumeroTest methodsFor: 'tests' stamp: 'NR 10/1/2018 00:55:42'!
test28FraccionSubstractsFraccionCorrectly
	
	self assert: twoFifth - oneFifth equals: oneFifth.! !
!NumeroTest methodsFor: 'tests' stamp: 'NR 10/1/2018 00:55:51'!
test29EnteroSubstractsFraccionCorrectly

	self assert: one - oneHalf equals: oneHalf! !
!NumeroTest methodsFor: 'tests' stamp: 'NR 10/1/2018 00:55:59'!
test30FraccionSubstractsEnteroCorrectly

	| sixFifth |
	
	sixFifth := (Entero with: 6) / (Entero with: 5).
	
	self assert: sixFifth - one equals: oneFifth! !
!NumeroTest methodsFor: 'tests' stamp: 'NR 10/1/2018 00:56:06'!
test31SubstractingFraccionesCanReturnAnEntero

	| threeHalfs |
	
	threeHalfs := (Entero with: 3) / (Entero with: 2).
	
	self assert: threeHalfs - oneHalf equals: one.! !
!NumeroTest methodsFor: 'tests' stamp: 'NR 10/1/2018 00:56:13'!
test32SubstractingSameEnterosReturnsZero

	self assert: one - one equals: zero.! !
!NumeroTest methodsFor: 'tests' stamp: 'NR 10/1/2018 00:56:20'!
test33SubstractingSameFraccionesReturnsZero

	self assert: oneHalf - oneHalf equals: zero.! !
!NumeroTest methodsFor: 'tests' stamp: 'NR 10/1/2018 00:56:28'!
test34SubstractingAHigherValueToANumberReturnsANegativeNumber

	| negativeThreeHalfs |
	
	negativeThreeHalfs := (Entero with: -3) / (Entero with: 2).	

	self assert: one - fiveHalfs equals: negativeThreeHalfs.! !
!NumeroTest methodsFor: 'tests' stamp: 'NR 10/1/2018 00:56:36'!
test35FibonacciZeroIsOne

	self assert: zero fibonacci equals: one! !
!NumeroTest methodsFor: 'tests' stamp: 'NR 10/1/2018 00:56:42'!
test36FibonacciOneIsOne

	self assert: one fibonacci equals: one! !
!NumeroTest methodsFor: 'tests' stamp: 'NR 10/1/2018 00:57:27'!
test37FibonacciEnteroReturnsAddingPreviousTwoFibonacciEnteros

	self assert: four fibonacci equals: five.
	self assert: three fibonacci equals: three. 
	self assert: five fibonacci equals: four fibonacci + three fibonacci.! !
!NumeroTest methodsFor: 'tests' stamp: 'NR 10/1/2018 00:57:37'!
test38FibonacciNotDefinedForNegativeNumbers

	self 
		should: [negativeOne fibonacci]
		raise: Error
		withExceptionDo: [ :anError | self assert: anError messageText equals: Entero negativeFibonacciErrorDescription ].! !
!NumeroTest methodsFor: 'tests' stamp: 'NR 10/1/2018 00:58:40'!
test39NegationOfEnteroIsCorrect

	self assert: two negated equals: negativeTwo.! !
!NumeroTest methodsFor: 'tests' stamp: 'NR 10/1/2018 00:58:47'!
test40NegationOfFraccionIsCorrect

	self assert: oneHalf negated equals: negativeOne / two.
		! !
!NumeroTest methodsFor: 'tests' stamp: 'NR 10/1/2018 00:58:55'!
test41SignIsCorrectlyAssignedToFractionWithTwoNegatives

	self assert: oneHalf equals: (negativeOne / negativeTwo)! !
!NumeroTest methodsFor: 'tests' stamp: 'NR 10/1/2018 00:59:03'!
test42SignIsCorrectlyAssignedToFractionWithNegativeDivisor

	self assert: oneHalf negated equals: (one / negativeTwo)
	! !
!NumeroTest methodsFor: 'setup' stamp: 'NR 10/1/2018 00:57:07' overrides: 16927572!
setUp

	zero := Entero with: 0.
	one := Entero with: 1.
	two := Entero with: 2.
	three:= Entero with: 3.
	four := Entero with: 4.
	five := Entero with: 5.
	eight := Entero with: 8.
	negativeOne := Entero with: -1.
	negativeTwo := Entero with: -2.
	
	oneHalf := one / two.
	oneFifth := one / five.
	twoFifth := two / five.
	twoTwentyfifth := two / (Entero with: 25).
	fiveHalfs := five / two.
	! !

!classDefinition: #Numero category: 'Numero-Solution-1' stamp: 'pc 7/5/2021 17:47:01'!
Object subclass: #Numero
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Solution-1'!

!classDefinition: #Numero category: 'Numero-Solution-1' stamp: 'pc 7/5/2021 17:47:01'!
Object subclass: #Numero
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Solution-1'!
!Numero methodsFor: 'arithmetic operations' stamp: 'HernanWilkinson 5/7/2016 22:48'!
* aMultiplier

	self subclassResponsibility ! !
!Numero methodsFor: 'arithmetic operations' stamp: 'HernanWilkinson 5/7/2016 22:49'!
+ anAdder

	self subclassResponsibility ! !
!Numero methodsFor: 'arithmetic operations' stamp: 'NR 10/1/2018 01:04:50'!
- aSubtrahend

	self subclassResponsibility ! !
!Numero methodsFor: 'arithmetic operations' stamp: 'HernanWilkinson 5/7/2016 22:49'!
/ aDivisor

	self subclassResponsibility ! !
!Numero methodsFor: 'arithmetic operations' stamp: 'HernanWilkinson 5/7/2016 22:48'!
invalidNumberType

	self error: self class invalidNumberTypeErrorDescription! !
!Numero methodsFor: 'arithmetic operations' stamp: 'NR 10/1/2018 01:01:39'!
negated
	
	^self * (Entero with: -1)! !
!Numero methodsFor: 'testing' stamp: 'NR 10/1/2018 01:01:15'!
isNegative

	self subclassResponsibility ! !
!Numero methodsFor: 'testing' stamp: 'HernanWilkinson 5/7/2016 22:49'!
isOne

	self subclassResponsibility ! !
!Numero methodsFor: 'testing' stamp: 'HernanWilkinson 5/7/2016 22:49'!
isZero

	self subclassResponsibility ! !

!classDefinition: 'Numero class' category: 'Numero-Solution-1' stamp: 'pc 7/5/2021 17:47:02'!
Numero class
	instanceVariableNames: ''!

!classDefinition: 'Numero class' category: 'Numero-Solution-1' stamp: 'pc 7/5/2021 17:47:02'!
Numero class
	instanceVariableNames: ''!
!Numero class methodsFor: 'error descriptions' stamp: 'HernanWilkinson 5/7/2016 22:45'!
canNotDivideByZeroErrorDescription

	^'No se puede dividir por cero'! !
!Numero class methodsFor: 'error descriptions' stamp: 'HernanWilkinson 5/7/2016 22:47'!
invalidNumberTypeErrorDescription
	^ 'Tipo de numero invalido'! !

!classDefinition: #Entero category: 'Numero-Solution-1' stamp: 'pc 7/5/2021 17:47:02'!
Numero subclass: #Entero
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Solution-1'!

!classDefinition: #Entero category: 'Numero-Solution-1' stamp: 'pc 7/5/2021 17:47:02'!
Numero subclass: #Entero
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Solution-1'!
!Entero methodsFor: 'value' stamp: 'HernanWilkinson 5/7/2016 21:02'!
integerValue

	"Usamos integerValue en vez de value para que no haya problemas con el mensaje value implementado en Object - Hernan"
	
	^value! !
!Entero methodsFor: 'testing' stamp: 'NR 10/1/2018 01:07:33' overrides: 50909788!
isNegative
	
	^value < 0! !
!Entero methodsFor: 'testing' stamp: 'HernanWilkinson 5/7/2016 20:14' overrides: 50909792!
isOne
	
	^value = 1! !
!Entero methodsFor: 'testing' stamp: 'HernanWilkinson 5/7/2016 20:12' overrides: 50909796!
isZero
	
	^value = 0! !
!Entero methodsFor: 'comparing' stamp: 'HernanWilkinson 5/7/2016 21:01' overrides: 16881029!
= anObject

	^(anObject isKindOf: self class) and: [ value = anObject integerValue ]! !
!Entero methodsFor: 'initialization' stamp: 'HernanWilkinson 5/7/2016 20:09'!
initalizeWith: aValue 
	
	value := aValue! !
!Entero methodsFor: 'arithmetic operations' stamp: 'HernanWilkinson 5/7/2016 21:55' overrides: 50909760!
* aMultiplier 
	
	(aMultiplier isKindOf: self class) ifTrue: [ ^self class with: value * aMultiplier integerValue ].
	(aMultiplier isKindOf: Fraccion) ifTrue: [ ^self * aMultiplier numerator / aMultiplier denominator ].
	
	self invalidNumberType ! !
!Entero methodsFor: 'arithmetic operations' stamp: 'HAW 4/25/2017 21:49:17' overrides: 50909765!
+ anAdder 
	
	(anAdder isKindOf: self class) ifTrue: [^self class with: value + anAdder integerValue].
	(anAdder isKindOf: Fraccion) ifTrue: [^self * anAdder denominator + anAdder numerator / anAdder denominator ].
	
	self invalidNumberType
! !

----STARTUP---- (5 July 2021 17:47:14) as C:\Users\pcomi\Documents\programs\cuis\CuisUniversity-4532.image!


----End fileIn of C:\Users\pcomi\Documents\programs\cuis\ISW1-2021-1C-2doParcial.st----!
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 17:48:02' prior: 50910344!
test01
	| rondaDeTruco temp2 temp3 temp4 temp5 |
	temp2 _ OrderedCollection new.
	temp2 add: CartaDeTruco anchoDeEspada.
	temp2 add: (CartaDeTruco oroCon: 2).
	temp2 add: (CartaDeTruco copaCon: 3).
	temp3 _ OrderedCollection new.
	temp3 add: CartaDeTruco anchoDeBasto.
	temp3 add: (CartaDeTruco oroCon: 3).
	temp3 add: (CartaDeTruco copaCon: 4).
	rondaDeTruco _ RondaDeTruco
		entreJugador: temp4
		con: temp2
		vs: temp5
		con: temp3.! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 17:48:25' prior: 50910364!
test01
	| rondaDeTruco cartasJugadorA temp3 temp4 temp5 |
	cartasJugadorA _ OrderedCollection new.
	cartasJugadorA add: CartaDeTruco anchoDeEspada.
	cartasJugadorA add: (CartaDeTruco oroCon: 2).
	cartasJugadorA add: (CartaDeTruco copaCon: 3).
	temp3 _ OrderedCollection new.
	temp3 add: CartaDeTruco anchoDeBasto.
	temp3 add: (CartaDeTruco oroCon: 3).
	temp3 add: (CartaDeTruco copaCon: 4).
	rondaDeTruco _ RondaDeTruco
		entreJugador: temp4
		con: cartasJugadorA
		vs: temp5
		con: temp3.! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 17:48:51' prior: 50910381!
test01
	| rondaDeTruco cartasJugadorA cartasJugadorB temp4 temp5 |
	cartasJugadorA _ OrderedCollection new.
	cartasJugadorA add: CartaDeTruco anchoDeEspada.
	cartasJugadorA add: (CartaDeTruco oroCon: 2).
	cartasJugadorA add: (CartaDeTruco copaCon: 3).
	cartasJugadorB _ OrderedCollection new.
	cartasJugadorB add: CartaDeTruco anchoDeBasto.
	cartasJugadorB add: (CartaDeTruco oroCon: 3).
	cartasJugadorB add: (CartaDeTruco copaCon: 4).
	rondaDeTruco _ RondaDeTruco
		entreJugador: temp4
		con: cartasJugadorA
		vs: temp5
		con: cartasJugadorB.! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 17:49:12' prior: 50910400!
test01
	| rondaDeTruco cartasJugadorA cartasJugadorB jugadorA temp5 |
	cartasJugadorA _ OrderedCollection new.
	cartasJugadorA add: CartaDeTruco anchoDeEspada.
	cartasJugadorA add: (CartaDeTruco oroCon: 2).
	cartasJugadorA add: (CartaDeTruco copaCon: 3).
	cartasJugadorB _ OrderedCollection new.
	cartasJugadorB add: CartaDeTruco anchoDeBasto.
	cartasJugadorB add: (CartaDeTruco oroCon: 3).
	cartasJugadorB add: (CartaDeTruco copaCon: 4).
	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		con: cartasJugadorA
		vs: temp5
		con: cartasJugadorB.! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 17:49:27' prior: 50910421!
test01
	| rondaDeTruco cartasJugadorA cartasJugadorB jugadorA jugadorB |
	cartasJugadorA _ OrderedCollection new.
	cartasJugadorA add: CartaDeTruco anchoDeEspada.
	cartasJugadorA add: (CartaDeTruco oroCon: 2).
	cartasJugadorA add: (CartaDeTruco copaCon: 3).
	cartasJugadorB _ OrderedCollection new.
	cartasJugadorB add: CartaDeTruco anchoDeBasto.
	cartasJugadorB add: (CartaDeTruco oroCon: 3).
	cartasJugadorB add: (CartaDeTruco copaCon: 4).
	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		con: cartasJugadorA
		vs: jugadorB
		con: cartasJugadorB.! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 17:52:29' prior: 50910442!
test01
	| rondaDeTruco cartasJugadorA cartasJugadorB jugadorA jugadorB |
	
	jugadorA := #A.
	jugadorB := #B.
	cartasJugadorA _ OrderedCollection new.
	cartasJugadorA add: CartaDeTruco anchoDeEspada.
	cartasJugadorA add: (CartaDeTruco oroCon: 2).
	cartasJugadorA add: (CartaDeTruco copaCon: 3).
	cartasJugadorB _ OrderedCollection new.
	cartasJugadorB add: CartaDeTruco anchoDeBasto.
	cartasJugadorB add: (CartaDeTruco oroCon: 3).
	cartasJugadorB add: (CartaDeTruco copaCon: 4).
	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		con: cartasJugadorA
		vs: jugadorB
		con: cartasJugadorB.
		
	self assert: rondaDeTruco mano equals: jugadorA! !

TestCase subclass: #RondaDeTrucoTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial'!

!classDefinition: #RondaDeTrucoTest category: 'ISW1-2021-1C-2doParcial' stamp: 'pc 7/5/2021 17:53:02'!
TestCase subclass: #RondaDeTrucoTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial'!

!testRun: #RondaDeTrucoTest #test01 stamp: 'pc 7/5/2021 17:53:06'!
ERROR!
!RondaDeTruco class methodsFor: 'instance creation' stamp: 'pc 7/5/2021 17:53:21'!
entreJugador: aSymbol con: anOrderedCollection vs: aSymbol3 con: anOrderedCollection4 
	"DO NOT FORGET TO RENAME COLLABORATORS AND REMOVE THIS COMMENT!!!!"
	self shouldBeImplemented.
	^self new initializeEntreJugador: aSymbol con: anOrderedCollection vs: aSymbol3 con: anOrderedCollection4 ! !
!RondaDeTruco class methodsFor: 'instance creation' stamp: 'pc 7/5/2021 17:54:14' prior: 50910501!
entreJugador: unJugador con: unaMano vs: otroJugador con: otraMano 
	
	^self new initializeEntreJugador: unJugador con: unaMano vs: otroJugador con: otraMano ! !

!testRun: #RondaDeTrucoTest #test01 stamp: 'pc 7/5/2021 17:54:17'!
ERROR!

!classDefinition: #RondaDeTruco category: 'ISW1-2021-1C-2doParcial' stamp: 'pc 7/5/2021 17:54:27'!
Object subclass: #RondaDeTruco
	instanceVariableNames: 'unJugador_CHANGE_ME'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial'!

!classDefinition: #RondaDeTruco category: 'ISW1-2021-1C-2doParcial' stamp: 'pc 7/5/2021 17:54:27'!
Object subclass: #RondaDeTruco
	instanceVariableNames: 'unJugador_CHANGE_ME unaMano_CHANGE_ME'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial'!

!classDefinition: #RondaDeTruco category: 'ISW1-2021-1C-2doParcial' stamp: 'pc 7/5/2021 17:54:27'!
Object subclass: #RondaDeTruco
	instanceVariableNames: 'unJugador_CHANGE_ME unaMano_CHANGE_ME otroJugador_CHANGE_ME'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial'!

!classDefinition: #RondaDeTruco category: 'ISW1-2021-1C-2doParcial' stamp: 'pc 7/5/2021 17:54:28'!
Object subclass: #RondaDeTruco
	instanceVariableNames: 'unJugador_CHANGE_ME unaMano_CHANGE_ME otroJugador_CHANGE_ME otraMano_CHANGE_ME'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial'!
!RondaDeTruco methodsFor: 'initialization' stamp: 'pc 7/5/2021 17:54:28'!
initializeEntreJugador: unJugador con: unaMano vs: otroJugador con: otraMano 
	self shouldBeImplemented.
	unJugador_CHANGE_ME := unJugador.
	unaMano_CHANGE_ME := unaMano.
	otroJugador_CHANGE_ME := otroJugador.
	otraMano_CHANGE_ME := otraMano.! !

!classDefinition: #RondaDeTruco category: 'ISW1-2021-1C-2doParcial' stamp: 'pc 7/5/2021 17:55:50'!
Object subclass: #RondaDeTruco
	instanceVariableNames: 'unJugador_CHANGE_ME unaMano_CHANGE_ME otroJugador_CHANGE_ME otraMano_CHANGE_ME jugadorA'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial'!

!classDefinition: #RondaDeTruco category: 'ISW1-2021-1C-2doParcial' stamp: 'pc 7/5/2021 17:55:51'!
Object subclass: #RondaDeTruco
	instanceVariableNames: 'unJugador_CHANGE_ME unaMano_CHANGE_ME otroJugador_CHANGE_ME otraMano_CHANGE_ME jugadorA cartasDeA'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial'!

!classDefinition: #RondaDeTruco category: 'ISW1-2021-1C-2doParcial' stamp: 'pc 7/5/2021 17:55:52'!
Object subclass: #RondaDeTruco
	instanceVariableNames: 'unJugador_CHANGE_ME unaMano_CHANGE_ME otroJugador_CHANGE_ME otraMano_CHANGE_ME jugadorA cartasDeA jugadorB'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial'!

!classDefinition: #RondaDeTruco category: 'ISW1-2021-1C-2doParcial' stamp: 'pc 7/5/2021 17:55:53'!
Object subclass: #RondaDeTruco
	instanceVariableNames: 'unJugador_CHANGE_ME unaMano_CHANGE_ME otroJugador_CHANGE_ME otraMano_CHANGE_ME jugadorA cartasDeA jugadorB cartasDeB'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial'!
!RondaDeTruco methodsFor: 'initialization' stamp: 'pc 7/5/2021 17:55:48' prior: 50910560!
initializeEntreJugador: unJugador con: unasCartas vs: otroJugador con: otrasCartas
	
	
	jugadorA := unJugador.
	cartasDeA := unasCartas .
	jugadorB := otroJugador.
	cartasDeB := otrasCartas .! !

!testRun: #RondaDeTrucoTest #test01 stamp: 'pc 7/5/2021 17:55:56'!
ERROR!
!RondaDeTruco methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 17:56:05'!
mano
	self shouldBeImplemented.! !
!RondaDeTruco methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 17:56:16' prior: 50910625!
mano
	^jugadorA ! !

!testRun: #RondaDeTrucoTest #test01 stamp: 'pc 7/5/2021 17:56:17'!
PASSED!

!testRun: #RondaDeTrucoTest #test01 stamp: 'pc 7/5/2021 17:56:17'!
PASSED!

!classDefinition: #RondaDeTruco category: 'ISW1-2021-1C-2doParcial' stamp: 'pc 7/5/2021 17:56:26'!
Object subclass: #RondaDeTruco
	instanceVariableNames: 'unaMano_CHANGE_ME otroJugador_CHANGE_ME otraMano_CHANGE_ME jugadorA cartasDeA jugadorB cartasDeB'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial'!

!classDefinition: #RondaDeTruco category: 'ISW1-2021-1C-2doParcial' stamp: 'pc 7/5/2021 17:56:26'!
Object subclass: #RondaDeTruco
	instanceVariableNames: 'otroJugador_CHANGE_ME otraMano_CHANGE_ME jugadorA cartasDeA jugadorB cartasDeB'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial'!

!classDefinition: #RondaDeTruco category: 'ISW1-2021-1C-2doParcial' stamp: 'pc 7/5/2021 17:56:26'!
Object subclass: #RondaDeTruco
	instanceVariableNames: 'otraMano_CHANGE_ME jugadorA cartasDeA jugadorB cartasDeB'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial'!

!classDefinition: #RondaDeTruco category: 'ISW1-2021-1C-2doParcial' stamp: 'pc 7/5/2021 17:56:26'!
Object subclass: #RondaDeTruco
	instanceVariableNames: 'jugadorA cartasDeA jugadorB cartasDeB'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial'!
!RondaDeTruco class methodsFor: 'instance creation' stamp: 'pc 7/5/2021 17:57:16' prior: 50910514!
entreJugador: unJugador con: cartasDeA vs: otroJugador con: cartasDeB 
	
	^self new initializeEntreJugador: unJugador con: cartasDeA vs: otroJugador con: cartasDeB! !

!testRun: #CartaDeTrucoTest #test01SonIgualesConMismoPaloYNumero stamp: 'pc 7/5/2021 17:57:18'!
PASSED!

!testRun: #CartaDeTrucoTest #test02SonDistintasConDistintoPalo stamp: 'pc 7/5/2021 17:57:18'!
PASSED!

!testRun: #CartaDeTrucoTest #test03SonDistintasConNumeroAunqueIgualPalo stamp: 'pc 7/5/2021 17:57:18'!
PASSED!

!testRun: #CartaDeTrucoTest #test04CartasIgualesTienenElMismoHash stamp: 'pc 7/5/2021 17:57:18'!
PASSED!

!testRun: #CartaDeTrucoTest #test05UnaCartaEsDistintaACualquierObjetoQueNoSeaCarta stamp: 'pc 7/5/2021 17:57:18'!
PASSED!

!testRun: #CartaDeTrucoTest #test07NoHayCartaDeTrucoConNumeroOcho stamp: 'pc 7/5/2021 17:57:18'!
PASSED!

!testRun: #CartaDeTrucoTest #test08NoHayCartaDeTrucoConNumeroNueve stamp: 'pc 7/5/2021 17:57:18'!
PASSED!

!testRun: #CartaDeTrucoTest #test09LosPalosDeLaCartaDeTrucoSonBastoOroEspadaYCopa stamp: 'pc 7/5/2021 17:57:18'!
PASSED!

!testRun: #CartaDeTrucoTest #test10NoSePuedeCrearCartaConNumeroMenorAUno stamp: 'pc 7/5/2021 17:57:18'!
PASSED!

!testRun: #CartaDeTrucoTest #test11NoSePuedeCrearCartaConNumeroMayorADoce stamp: 'pc 7/5/2021 17:57:18'!
PASSED!

!testRun: #CartaDeTrucoTest #test12ElNumeroDeLaCartaDebeSerEntero stamp: 'pc 7/5/2021 17:57:18'!
PASSED!

!testRun: #CartaDeTrucoTest #test13LaTablaDeValoresEsCorrecta stamp: 'pc 7/5/2021 17:57:18'!
ERROR!

!testRun: #CartaDeTrucoTest #test14HayCartasQueNoSonPardas stamp: 'pc 7/5/2021 17:57:18'!
PASSED!

!testRun: #CartaDeTrucoTest #test15HayCartasQuePierdenConOtras stamp: 'pc 7/5/2021 17:57:18'!
PASSED!

!testRun: #CartaDeTrucoTest #test16SieteDeCopasYDeBastoEsSieteFalso stamp: 'pc 7/5/2021 17:57:18'!
PASSED!

!testRun: #CartaDeTrucoTest #test17SieteDeOroYDeEspadaNoSonSieteFalso stamp: 'pc 7/5/2021 17:57:18'!
PASSED!

!testRun: #CartaDeTrucoTest #test18AnchoDeOroYDeCopaSonAnchoFalsos stamp: 'pc 7/5/2021 17:57:18'!
PASSED!

!testRun: #CartaDeTrucoTest #test19AnchoDeEspadaYDeBastosNoSonAnchoFalsos stamp: 'pc 7/5/2021 17:57:18'!
PASSED!

!testRun: #CartaDeTrucoTest #test20FallaBuscandoValorDeCartaInv�lida stamp: 'pc 7/5/2021 17:57:18'!
PASSED!

!testRun: #RondaDeTrucoTest #test01 stamp: 'pc 7/5/2021 17:57:18'!
PASSED!

!testRun: #CartaDeTrucoTest #test13LaTablaDeValoresEsCorrecta stamp: 'pc 7/5/2021 17:57:18'!
PASSED!

!testRun: #RondaDeTrucoTest #test01 stamp: 'pc 7/5/2021 17:57:24'!
PASSED!

!testRun: #RondaDeTrucoTest #test01 stamp: 'pc 7/5/2021 17:57:24'!
PASSED!
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 17:58:40'!
test02
	| rondaDeTruco cartasJugadorA cartasJugadorB jugadorA jugadorB |
	
	jugadorA := #A.
	jugadorB := #B.
	cartasJugadorA _ OrderedCollection new.
	cartasJugadorA add: CartaDeTruco anchoDeEspada.
	cartasJugadorA add: (CartaDeTruco oroCon: 2).
	cartasJugadorA add: (CartaDeTruco copaCon: 3).
	cartasJugadorB _ OrderedCollection new.
	cartasJugadorB add: CartaDeTruco anchoDeBasto.
	cartasJugadorB add: (CartaDeTruco oroCon: 3).
	cartasJugadorB add: (CartaDeTruco copaCon: 4).
	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		con: cartasJugadorA
		vs: jugadorB
		con: cartasJugadorB.
	
	
		
	self assert: rondaDeTruco rondasJugadas equals: 0! !

!testRun: #RondaDeTrucoTest #test02 stamp: 'pc 7/5/2021 17:58:43'!
ERROR!
!RondaDeTruco methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 17:58:52'!
rondasJugadas
	self shouldBeImplemented.! !
!RondaDeTruco methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 17:58:58' prior: 50910787!
rondasJugadas
	^0! !

!testRun: #RondaDeTrucoTest #test02 stamp: 'pc 7/5/2021 17:59:00'!
PASSED!

!testRun: #RondaDeTrucoTest #test01 stamp: 'pc 7/5/2021 17:59:00'!
PASSED!

!testRun: #RondaDeTrucoTest #test02 stamp: 'pc 7/5/2021 17:59:00'!
PASSED!
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 17:59:09' prior: 50910463!
test01
	| rondaDeTruco cartasJugadorA cartasJugadorB jugadorA jugadorB |
	
	jugadorA := #A.
	jugadorB := #B.
	cartasJugadorA _ OrderedCollection new.
	cartasJugadorA add: CartaDeTruco anchoDeEspada.
	cartasJugadorA add: (CartaDeTruco oroCon: 2).
	cartasJugadorA add: (CartaDeTruco copaCon: 3).
	cartasJugadorB _ OrderedCollection new.
	cartasJugadorB add: CartaDeTruco anchoDeBasto.
	cartasJugadorB add: (CartaDeTruco oroCon: 3).
	cartasJugadorB add: (CartaDeTruco copaCon: 4).
	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		con: cartasJugadorA
		vs: jugadorB
		con: cartasJugadorB.
	
	
		
	self assert: rondaDeTruco rondasJugadas equals: 0! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 18:05:23' prior: 50910761!
test02
	| rondaDeTruco cartasJugadorA cartasJugadorB jugadorA jugadorB |
	
	jugadorA := #A.
	jugadorB := #B.
	cartasJugadorA _ OrderedCollection new.
	cartasJugadorA add: CartaDeTruco anchoDeEspada.
	cartasJugadorA add: (CartaDeTruco oroCon: 2).
	cartasJugadorA add: (CartaDeTruco copaCon: 3).
	cartasJugadorB _ OrderedCollection new.
	cartasJugadorB add: CartaDeTruco anchoDeBasto.
	cartasJugadorB add: (CartaDeTruco oroCon: 3).
	cartasJugadorB add: (CartaDeTruco copaCon: 4).
	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		con: cartasJugadorA
		vs: jugadorB
		con: cartasJugadorB.
	
	rondaDeTruco enfrentamientoCon: cartasJugadorA first vs: cartasJugadorB first .
		
	self assert: rondaDeTruco rondasJugadas equals: 1.
	self assert: rondaDeTruco enfretamientosGanadosPorA equals: 1.
	! !

!testRun: #RondaDeTrucoTest #test02 stamp: 'pc 7/5/2021 18:05:31'!
ERROR!
!RondaDeTruco methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 18:05:37'!
enfrentamientoCon: aCartaDeTruco vs: aCartaDeTruco2 
	self shouldBeImplemented.! !
!RondaDeTruco methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 18:07:02' prior: 50910857!
enfrentamientoCon: aCartaDeTruco vs: aCartaDeTruco2 
	
	! !

!classDefinition: #RondaDeTruco category: 'ISW1-2021-1C-2doParcial' stamp: 'pc 7/5/2021 18:11:41'!
Object subclass: #RondaDeTruco
	instanceVariableNames: 'jugadorA cartasDeA jugadorB cartasDeB ronda'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial'!
!RondaDeTruco methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 18:11:50' prior: 50910863!
enfrentamientoCon: cartaDeTrucoA vs: cartaDeTrucoB
	
	ronda := ronda +1.
	(cartaDeTrucoA mataA: cartaDeTrucoB) ifTrue: [jugadorA add: 1] ifFalse: [jugadorB add: 1].! !

!testRun: #RondaDeTrucoTest #test02 stamp: 'pc 7/5/2021 18:11:52'!
ERROR!
!RondaDeTruco methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 18:12:00' prior: 50910877!
enfrentamientoCon: cartaDeTrucoA vs: cartaDeTrucoB
	
	ronda := ronda + 1.
	(cartaDeTrucoA mataA: cartaDeTrucoB) ifTrue: [jugadorA add: 1] ifFalse: [jugadorB add: 1].! !
!RondaDeTruco methodsFor: 'initialization' stamp: 'pc 7/5/2021 18:12:17' prior: 50910614!
initializeEntreJugador: unJugador con: unasCartas vs: otroJugador con: otrasCartas
	
	ronda := 0.
	jugadorA := unJugador.
	cartasDeA := unasCartas .
	jugadorB := otroJugador.
	cartasDeB := otrasCartas .! !

!testRun: #RondaDeTrucoTest #test02 stamp: 'pc 7/5/2021 18:12:27'!
ERROR!
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 18:14:51' prior: 50910827!
test02
	| rondaDeTruco cartasJugadorA cartasJugadorB jugadorA jugadorB |
	
	jugadorA := #A.
	jugadorB := #B.
	cartasJugadorA _ OrderedCollection new.
	cartasJugadorA add: CartaDeTruco anchoDeEspada.
	cartasJugadorA add: (CartaDeTruco oroCon: 2).
	cartasJugadorA add: (CartaDeTruco copaCon: 3).
	cartasJugadorB _ OrderedCollection new.
	cartasJugadorB add: CartaDeTruco anchoDeBasto.
	cartasJugadorB add: (CartaDeTruco oroCon: 3).
	cartasJugadorB add: (CartaDeTruco copaCon: 4).
	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		con: cartasJugadorA
		vs: jugadorB
		con: cartasJugadorB.
	
	rondaDeTruco enfrentamientoCon: cartasJugadorA first vs: cartasJugadorB first .
		
	self assert: rondaDeTruco rondasJugadas equals: 1.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorA) equals: 1.
	! !

!testRun: #RondaDeTrucoTest #test02 stamp: 'pc 7/5/2021 18:14:54'!
ERROR!

!testRun: #RondaDeTrucoTest #test02 stamp: 'pc 7/5/2021 18:15:12'!
ERROR!
!RondaDeTruco methodsFor: 'initialization' stamp: 'pc 7/5/2021 18:17:23' prior: 50910897!
initializeEntreJugador: unJugador con: unasCartas vs: otroJugador con: otrasCartas
	
	ronda := 0.
	jugadorA := Dictionary new
		at: unJugador put: 0 .
	cartasDeA := unasCartas .
	jugadorB := Dictionary new
		at: otroJugador put: 0.
	cartasDeB := otrasCartas .! !
!RondaDeTruco methodsFor: 'initialization' stamp: 'pc 7/5/2021 18:18:06' prior: 50910942!
initializeEntreJugador: unJugador con: unasCartas vs: otroJugador con: otrasCartas
	
	ronda := 0.
	jugadorA := 0.
	cartasDeA := unasCartas .
	jugadorB := 0.
	cartasDeB := otrasCartas .! !
!RondaDeTruco methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 18:18:26' prior: 50910888!
enfrentamientoCon: cartaDeTrucoA vs: cartaDeTrucoB
	
	ronda := ronda + 1.
	(cartaDeTrucoA mataA: cartaDeTrucoB) ifTrue: [jugadorA := 1] ifFalse: [jugadorB := 1].! !

!testRun: #CartaDeTrucoTest #test01SonIgualesConMismoPaloYNumero stamp: 'pc 7/5/2021 18:18:29'!
PASSED!

!testRun: #CartaDeTrucoTest #test02SonDistintasConDistintoPalo stamp: 'pc 7/5/2021 18:18:29'!
PASSED!

!testRun: #CartaDeTrucoTest #test03SonDistintasConNumeroAunqueIgualPalo stamp: 'pc 7/5/2021 18:18:29'!
PASSED!

!testRun: #CartaDeTrucoTest #test04CartasIgualesTienenElMismoHash stamp: 'pc 7/5/2021 18:18:29'!
PASSED!

!testRun: #CartaDeTrucoTest #test05UnaCartaEsDistintaACualquierObjetoQueNoSeaCarta stamp: 'pc 7/5/2021 18:18:29'!
PASSED!

!testRun: #CartaDeTrucoTest #test07NoHayCartaDeTrucoConNumeroOcho stamp: 'pc 7/5/2021 18:18:29'!
PASSED!

!testRun: #CartaDeTrucoTest #test08NoHayCartaDeTrucoConNumeroNueve stamp: 'pc 7/5/2021 18:18:29'!
PASSED!

!testRun: #CartaDeTrucoTest #test09LosPalosDeLaCartaDeTrucoSonBastoOroEspadaYCopa stamp: 'pc 7/5/2021 18:18:29'!
PASSED!

!testRun: #CartaDeTrucoTest #test10NoSePuedeCrearCartaConNumeroMenorAUno stamp: 'pc 7/5/2021 18:18:29'!
PASSED!

!testRun: #CartaDeTrucoTest #test11NoSePuedeCrearCartaConNumeroMayorADoce stamp: 'pc 7/5/2021 18:18:29'!
PASSED!

!testRun: #CartaDeTrucoTest #test12ElNumeroDeLaCartaDebeSerEntero stamp: 'pc 7/5/2021 18:18:29'!
PASSED!

!testRun: #CartaDeTrucoTest #test13LaTablaDeValoresEsCorrecta stamp: 'pc 7/5/2021 18:18:29'!
PASSED!

!testRun: #CartaDeTrucoTest #test14HayCartasQueNoSonPardas stamp: 'pc 7/5/2021 18:18:29'!
PASSED!

!testRun: #CartaDeTrucoTest #test15HayCartasQuePierdenConOtras stamp: 'pc 7/5/2021 18:18:29'!
PASSED!

!testRun: #CartaDeTrucoTest #test16SieteDeCopasYDeBastoEsSieteFalso stamp: 'pc 7/5/2021 18:18:29'!
PASSED!

!testRun: #CartaDeTrucoTest #test17SieteDeOroYDeEspadaNoSonSieteFalso stamp: 'pc 7/5/2021 18:18:29'!
PASSED!

!testRun: #CartaDeTrucoTest #test18AnchoDeOroYDeCopaSonAnchoFalsos stamp: 'pc 7/5/2021 18:18:29'!
PASSED!

!testRun: #CartaDeTrucoTest #test19AnchoDeEspadaYDeBastosNoSonAnchoFalsos stamp: 'pc 7/5/2021 18:18:29'!
PASSED!

!testRun: #CartaDeTrucoTest #test20FallaBuscandoValorDeCartaInv�lida stamp: 'pc 7/5/2021 18:18:29'!
PASSED!

!testRun: #RondaDeTrucoTest #test01 stamp: 'pc 7/5/2021 18:18:29'!
PASSED!

!testRun: #RondaDeTrucoTest #test02 stamp: 'pc 7/5/2021 18:18:29'!
FAILURE!

!testRun: #RondaDeTrucoTest #test02 stamp: 'pc 7/5/2021 18:18:29'!
FAILURE!
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 18:19:35' prior: 50910909!
test02
	| rondaDeTruco cartasJugadorA cartasJugadorB jugadorA jugadorB |
	
	jugadorA := #A.
	jugadorB := #B.
	cartasJugadorA _ OrderedCollection new.
	cartasJugadorA add: CartaDeTruco anchoDeEspada.
	cartasJugadorA add: (CartaDeTruco oroCon: 2).
	cartasJugadorA add: (CartaDeTruco copaCon: 3).
	cartasJugadorB _ OrderedCollection new.
	cartasJugadorB add: CartaDeTruco anchoDeBasto.
	cartasJugadorB add: (CartaDeTruco oroCon: 3).
	cartasJugadorB add: (CartaDeTruco copaCon: 4).
	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		con: cartasJugadorA
		vs: jugadorB
		con: cartasJugadorB.
	
	rondaDeTruco enfrentamientoCon: cartasJugadorA first vs: cartasJugadorB first .
		
	self assert: (rondaDeTruco rondasJugadas) equals: 1.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorA) equals: 1.
	! !

!testRun: #RondaDeTrucoTest #test02 stamp: 'pc 7/5/2021 18:19:48'!
FAILURE!

rondaDeTruco rondasJugadas!

!testRun: #RondaDeTrucoTest #test02 stamp: 'pc 7/5/2021 18:20:14'!
FAILURE!
!RondaDeTruco methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 18:20:23' prior: 50910792!
rondasJugadas
	^ronda! !

!testRun: #CartaDeTrucoTest #test01SonIgualesConMismoPaloYNumero stamp: 'pc 7/5/2021 18:20:30'!
PASSED!

!testRun: #CartaDeTrucoTest #test02SonDistintasConDistintoPalo stamp: 'pc 7/5/2021 18:20:30'!
PASSED!

!testRun: #CartaDeTrucoTest #test03SonDistintasConNumeroAunqueIgualPalo stamp: 'pc 7/5/2021 18:20:30'!
PASSED!

!testRun: #CartaDeTrucoTest #test04CartasIgualesTienenElMismoHash stamp: 'pc 7/5/2021 18:20:30'!
PASSED!

!testRun: #CartaDeTrucoTest #test05UnaCartaEsDistintaACualquierObjetoQueNoSeaCarta stamp: 'pc 7/5/2021 18:20:30'!
PASSED!

!testRun: #CartaDeTrucoTest #test07NoHayCartaDeTrucoConNumeroOcho stamp: 'pc 7/5/2021 18:20:30'!
PASSED!

!testRun: #CartaDeTrucoTest #test08NoHayCartaDeTrucoConNumeroNueve stamp: 'pc 7/5/2021 18:20:30'!
PASSED!

!testRun: #CartaDeTrucoTest #test09LosPalosDeLaCartaDeTrucoSonBastoOroEspadaYCopa stamp: 'pc 7/5/2021 18:20:30'!
PASSED!

!testRun: #CartaDeTrucoTest #test10NoSePuedeCrearCartaConNumeroMenorAUno stamp: 'pc 7/5/2021 18:20:30'!
PASSED!

!testRun: #CartaDeTrucoTest #test11NoSePuedeCrearCartaConNumeroMayorADoce stamp: 'pc 7/5/2021 18:20:30'!
PASSED!

!testRun: #CartaDeTrucoTest #test12ElNumeroDeLaCartaDebeSerEntero stamp: 'pc 7/5/2021 18:20:30'!
PASSED!

!testRun: #CartaDeTrucoTest #test13LaTablaDeValoresEsCorrecta stamp: 'pc 7/5/2021 18:20:30'!
PASSED!

!testRun: #CartaDeTrucoTest #test14HayCartasQueNoSonPardas stamp: 'pc 7/5/2021 18:20:30'!
PASSED!

!testRun: #CartaDeTrucoTest #test15HayCartasQuePierdenConOtras stamp: 'pc 7/5/2021 18:20:30'!
PASSED!

!testRun: #CartaDeTrucoTest #test16SieteDeCopasYDeBastoEsSieteFalso stamp: 'pc 7/5/2021 18:20:30'!
PASSED!

!testRun: #CartaDeTrucoTest #test17SieteDeOroYDeEspadaNoSonSieteFalso stamp: 'pc 7/5/2021 18:20:30'!
PASSED!

!testRun: #CartaDeTrucoTest #test18AnchoDeOroYDeCopaSonAnchoFalsos stamp: 'pc 7/5/2021 18:20:30'!
PASSED!

!testRun: #CartaDeTrucoTest #test19AnchoDeEspadaYDeBastosNoSonAnchoFalsos stamp: 'pc 7/5/2021 18:20:30'!
PASSED!

!testRun: #CartaDeTrucoTest #test20FallaBuscandoValorDeCartaInv�lida stamp: 'pc 7/5/2021 18:20:30'!
PASSED!

!testRun: #RondaDeTrucoTest #test01 stamp: 'pc 7/5/2021 18:20:30'!
PASSED!

!testRun: #RondaDeTrucoTest #test02 stamp: 'pc 7/5/2021 18:20:30'!
ERROR!

!testRun: #RondaDeTrucoTest #test02 stamp: 'pc 7/5/2021 18:20:30'!
ERROR!
!RondaDeTruco methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 18:20:36'!
enfretamientosGanadosPor: aSymbol 
	self shouldBeImplemented.! !

!classDefinition: #RondaDeTruco category: 'ISW1-2021-1C-2doParcial' stamp: 'pc 7/5/2021 18:22:32'!
Object subclass: #RondaDeTruco
	instanceVariableNames: 'jugadorA cartasDeA jugadorB cartasDeB ronda jugadores'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial'!
!RondaDeTruco methodsFor: 'initialization' stamp: 'pc 7/5/2021 18:22:30' prior: 50910954!
initializeEntreJugador: unJugador con: unasCartas vs: otroJugador con: otrasCartas
	
	ronda := 0.
	jugadores := Dictionary new
		at: unJugador put: 0;
		at: otroJugador put:0.
	cartasDeA := unasCartas .
	cartasDeB := otrasCartas .! !
!RondaDeTruco methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 18:22:57' prior: 50911154!
enfretamientosGanadosPor: unJugador 
	
	jugadores at: unJugador .! !
!RondaDeTruco methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 18:23:01' prior: 50911180!
enfretamientosGanadosPor: unJugador 
	
	^jugadores at: unJugador .! !

!testRun: #CartaDeTrucoTest #test01SonIgualesConMismoPaloYNumero stamp: 'pc 7/5/2021 18:23:03'!
PASSED!

!testRun: #CartaDeTrucoTest #test02SonDistintasConDistintoPalo stamp: 'pc 7/5/2021 18:23:03'!
PASSED!

!testRun: #CartaDeTrucoTest #test03SonDistintasConNumeroAunqueIgualPalo stamp: 'pc 7/5/2021 18:23:03'!
PASSED!

!testRun: #CartaDeTrucoTest #test04CartasIgualesTienenElMismoHash stamp: 'pc 7/5/2021 18:23:03'!
PASSED!

!testRun: #CartaDeTrucoTest #test05UnaCartaEsDistintaACualquierObjetoQueNoSeaCarta stamp: 'pc 7/5/2021 18:23:03'!
PASSED!

!testRun: #CartaDeTrucoTest #test07NoHayCartaDeTrucoConNumeroOcho stamp: 'pc 7/5/2021 18:23:03'!
PASSED!

!testRun: #CartaDeTrucoTest #test08NoHayCartaDeTrucoConNumeroNueve stamp: 'pc 7/5/2021 18:23:03'!
PASSED!

!testRun: #CartaDeTrucoTest #test09LosPalosDeLaCartaDeTrucoSonBastoOroEspadaYCopa stamp: 'pc 7/5/2021 18:23:03'!
PASSED!

!testRun: #CartaDeTrucoTest #test10NoSePuedeCrearCartaConNumeroMenorAUno stamp: 'pc 7/5/2021 18:23:03'!
PASSED!

!testRun: #CartaDeTrucoTest #test11NoSePuedeCrearCartaConNumeroMayorADoce stamp: 'pc 7/5/2021 18:23:03'!
PASSED!

!testRun: #CartaDeTrucoTest #test12ElNumeroDeLaCartaDebeSerEntero stamp: 'pc 7/5/2021 18:23:03'!
PASSED!

!testRun: #CartaDeTrucoTest #test13LaTablaDeValoresEsCorrecta stamp: 'pc 7/5/2021 18:23:03'!
PASSED!

!testRun: #CartaDeTrucoTest #test14HayCartasQueNoSonPardas stamp: 'pc 7/5/2021 18:23:03'!
PASSED!

!testRun: #CartaDeTrucoTest #test15HayCartasQuePierdenConOtras stamp: 'pc 7/5/2021 18:23:03'!
PASSED!

!testRun: #CartaDeTrucoTest #test16SieteDeCopasYDeBastoEsSieteFalso stamp: 'pc 7/5/2021 18:23:03'!
PASSED!

!testRun: #CartaDeTrucoTest #test17SieteDeOroYDeEspadaNoSonSieteFalso stamp: 'pc 7/5/2021 18:23:03'!
PASSED!

!testRun: #CartaDeTrucoTest #test18AnchoDeOroYDeCopaSonAnchoFalsos stamp: 'pc 7/5/2021 18:23:03'!
PASSED!

!testRun: #CartaDeTrucoTest #test19AnchoDeEspadaYDeBastosNoSonAnchoFalsos stamp: 'pc 7/5/2021 18:23:03'!
PASSED!

!testRun: #CartaDeTrucoTest #test20FallaBuscandoValorDeCartaInv�lida stamp: 'pc 7/5/2021 18:23:03'!
PASSED!

!testRun: #RondaDeTrucoTest #test01 stamp: 'pc 7/5/2021 18:23:03'!
PASSED!

!testRun: #RondaDeTrucoTest #test02 stamp: 'pc 7/5/2021 18:23:03'!
ERROR!

!testRun: #RondaDeTrucoTest #test02 stamp: 'pc 7/5/2021 18:23:03'!
ERROR!
!RondaDeTruco methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 18:24:04' prior: 50910963!
enfrentamientoCon: cartaDeTrucoA vs: cartaDeTrucoB
	
	ronda := ronda + 1.
	(cartaDeTrucoA mataA: cartaDeTrucoB) ifTrue: [jugadores at: jugadorA put: 1] ifFalse: [jugadores at: jugadorB put: 1].! !
!RondaDeTruco methodsFor: 'initialization' stamp: 'pc 7/5/2021 18:24:29' prior: 50911169!
initializeEntreJugador: unJugador con: unasCartas vs: otroJugador con: otrasCartas
	
	ronda := 0.
	jugadorA := unJugador .
	jugadorB := otroJugador .
	jugadores := Dictionary new
		at: unJugador put: 0;
		at: otroJugador put:0.
	cartasDeA := unasCartas .
	cartasDeB := otrasCartas .! !

!testRun: #CartaDeTrucoTest #test01SonIgualesConMismoPaloYNumero stamp: 'pc 7/5/2021 18:24:31'!
PASSED!

!testRun: #CartaDeTrucoTest #test02SonDistintasConDistintoPalo stamp: 'pc 7/5/2021 18:24:31'!
PASSED!

!testRun: #CartaDeTrucoTest #test03SonDistintasConNumeroAunqueIgualPalo stamp: 'pc 7/5/2021 18:24:31'!
PASSED!

!testRun: #CartaDeTrucoTest #test04CartasIgualesTienenElMismoHash stamp: 'pc 7/5/2021 18:24:31'!
PASSED!

!testRun: #CartaDeTrucoTest #test05UnaCartaEsDistintaACualquierObjetoQueNoSeaCarta stamp: 'pc 7/5/2021 18:24:31'!
PASSED!

!testRun: #CartaDeTrucoTest #test07NoHayCartaDeTrucoConNumeroOcho stamp: 'pc 7/5/2021 18:24:31'!
PASSED!

!testRun: #CartaDeTrucoTest #test08NoHayCartaDeTrucoConNumeroNueve stamp: 'pc 7/5/2021 18:24:31'!
PASSED!

!testRun: #CartaDeTrucoTest #test09LosPalosDeLaCartaDeTrucoSonBastoOroEspadaYCopa stamp: 'pc 7/5/2021 18:24:31'!
PASSED!

!testRun: #CartaDeTrucoTest #test10NoSePuedeCrearCartaConNumeroMenorAUno stamp: 'pc 7/5/2021 18:24:31'!
PASSED!

!testRun: #CartaDeTrucoTest #test11NoSePuedeCrearCartaConNumeroMayorADoce stamp: 'pc 7/5/2021 18:24:31'!
PASSED!

!testRun: #CartaDeTrucoTest #test12ElNumeroDeLaCartaDebeSerEntero stamp: 'pc 7/5/2021 18:24:31'!
PASSED!

!testRun: #CartaDeTrucoTest #test13LaTablaDeValoresEsCorrecta stamp: 'pc 7/5/2021 18:24:31'!
PASSED!

!testRun: #CartaDeTrucoTest #test14HayCartasQueNoSonPardas stamp: 'pc 7/5/2021 18:24:31'!
PASSED!

!testRun: #CartaDeTrucoTest #test15HayCartasQuePierdenConOtras stamp: 'pc 7/5/2021 18:24:31'!
PASSED!

!testRun: #CartaDeTrucoTest #test16SieteDeCopasYDeBastoEsSieteFalso stamp: 'pc 7/5/2021 18:24:31'!
PASSED!

!testRun: #CartaDeTrucoTest #test17SieteDeOroYDeEspadaNoSonSieteFalso stamp: 'pc 7/5/2021 18:24:31'!
PASSED!

!testRun: #CartaDeTrucoTest #test18AnchoDeOroYDeCopaSonAnchoFalsos stamp: 'pc 7/5/2021 18:24:31'!
PASSED!

!testRun: #CartaDeTrucoTest #test19AnchoDeEspadaYDeBastosNoSonAnchoFalsos stamp: 'pc 7/5/2021 18:24:31'!
PASSED!

!testRun: #CartaDeTrucoTest #test20FallaBuscandoValorDeCartaInv�lida stamp: 'pc 7/5/2021 18:24:31'!
PASSED!

!testRun: #RondaDeTrucoTest #test01 stamp: 'pc 7/5/2021 18:24:31'!
PASSED!

!testRun: #RondaDeTrucoTest #test02 stamp: 'pc 7/5/2021 18:24:31'!
ERROR!

!testRun: #RondaDeTrucoTest #test02 stamp: 'pc 7/5/2021 18:24:31'!
ERROR!
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 18:26:34' prior: 50910803!
test01
	| rondaDeTruco cartasJugadorA cartasJugadorB jugadorAa jugadorBa |
	
	jugadorAa := #A.
	jugadorBa := #B.
	cartasJugadorA _ OrderedCollection new.
	cartasJugadorA add: CartaDeTruco anchoDeEspada.
	cartasJugadorA add: (CartaDeTruco oroCon: 2).
	cartasJugadorA add: (CartaDeTruco copaCon: 3).
	cartasJugadorB _ OrderedCollection new.
	cartasJugadorB add: CartaDeTruco anchoDeBasto.
	cartasJugadorB add: (CartaDeTruco oroCon: 3).
	cartasJugadorB add: (CartaDeTruco copaCon: 4).
	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorAa
		con: cartasJugadorA
		vs: jugadorBa
		con: cartasJugadorB.
	
	
		
	self assert: rondaDeTruco rondasJugadas equals: 0! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 18:27:13' prior: 50911044!
test02
	| rondaDeTruco cartasJugadorA cartasJugadorB jugadorAa jugadorBa |
	
	jugadorAa := #A.
	jugadorBa := #B.
	cartasJugadorA _ OrderedCollection new.
	cartasJugadorA add: CartaDeTruco anchoDeEspada.
	cartasJugadorA add: (CartaDeTruco oroCon: 2).
	cartasJugadorA add: (CartaDeTruco copaCon: 3).
	cartasJugadorB _ OrderedCollection new.
	cartasJugadorB add: CartaDeTruco anchoDeBasto.
	cartasJugadorB add: (CartaDeTruco oroCon: 3).
	cartasJugadorB add: (CartaDeTruco copaCon: 4).
	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorAa
		con: cartasJugadorA
		vs: jugadorBa
		con: cartasJugadorB.
	
	rondaDeTruco enfrentamientoCon: cartasJugadorA first vs: cartasJugadorB first .
		
	self assert: (rondaDeTruco rondasJugadas) equals: 1.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorAa) equals: 1.
	! !

!classDefinition: #RondaDeTrucoTest category: 'ISW1-2021-1C-2doParcial' stamp: 'pc 7/5/2021 18:27:21'!
TestCase subclass: #RondaDeTrucoTest
	instanceVariableNames: 'jugadorA'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial'!

!classDefinition: #RondaDeTrucoTest category: 'ISW1-2021-1C-2doParcial' stamp: 'pc 7/5/2021 18:27:22'!
TestCase subclass: #RondaDeTrucoTest
	instanceVariableNames: 'jugadorA jugadorB'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial'!
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 18:27:39' prior: 50911380!
test02
	| rondaDeTruco cartasJugadorA cartasJugadorB |
	
	jugadorA := #A.
	jugadorB := #B.
	cartasJugadorA _ OrderedCollection new.
	cartasJugadorA add: CartaDeTruco anchoDeEspada.
	cartasJugadorA add: (CartaDeTruco oroCon: 2).
	cartasJugadorA add: (CartaDeTruco copaCon: 3).
	cartasJugadorB _ OrderedCollection new.
	cartasJugadorB add: CartaDeTruco anchoDeBasto.
	cartasJugadorB add: (CartaDeTruco oroCon: 3).
	cartasJugadorB add: (CartaDeTruco copaCon: 4).
	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		con: cartasJugadorA
		vs: jugadorB
		con: cartasJugadorB.
	
	rondaDeTruco enfrentamientoCon: cartasJugadorA first vs: cartasJugadorB first .
		
	self assert: (rondaDeTruco rondasJugadas) equals: 1.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorA) equals: 1.
	! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 18:28:01' prior: 50911356!
test01
	| rondaDeTruco cartasJugadorA cartasJugadorB |
	
	cartasJugadorA _ OrderedCollection new.
	cartasJugadorA add: CartaDeTruco anchoDeEspada.
	cartasJugadorA add: (CartaDeTruco oroCon: 2).
	cartasJugadorA add: (CartaDeTruco copaCon: 3).
	cartasJugadorB _ OrderedCollection new.
	cartasJugadorB add: CartaDeTruco anchoDeBasto.
	cartasJugadorB add: (CartaDeTruco oroCon: 3).
	cartasJugadorB add: (CartaDeTruco copaCon: 4).
	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		con: cartasJugadorA
		vs: jugadorB
		con: cartasJugadorB.
	
	
		
	self assert: rondaDeTruco rondasJugadas equals: 0! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 18:28:14' prior: 50911426!
test02
	| rondaDeTruco cartasJugadorA cartasJugadorB |
	
	cartasJugadorA _ OrderedCollection new.
	cartasJugadorA add: CartaDeTruco anchoDeEspada.
	cartasJugadorA add: (CartaDeTruco oroCon: 2).
	cartasJugadorA add: (CartaDeTruco copaCon: 3).
	cartasJugadorB _ OrderedCollection new.
	cartasJugadorB add: CartaDeTruco anchoDeBasto.
	cartasJugadorB add: (CartaDeTruco oroCon: 3).
	cartasJugadorB add: (CartaDeTruco copaCon: 4).
	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		con: cartasJugadorA
		vs: jugadorB
		con: cartasJugadorB.
	
	rondaDeTruco enfrentamientoCon: cartasJugadorA first vs: cartasJugadorB first .
		
	self assert: (rondaDeTruco rondasJugadas) equals: 1.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorA) equals: 1.
	! !
!RondaDeTrucoTest methodsFor: 'nil' stamp: 'pc 7/5/2021 18:28:24' overrides: 16927572!
setUp

	jugadorA := #A.
	jugadorB := #B.! !

!testRun: #RondaDeTrucoTest #test02 stamp: 'pc 7/5/2021 18:28:28'!
ERROR!
!RondaDeTruco methodsFor: 'initialization' stamp: 'pc 7/5/2021 18:30:09' prior: 50911272!
initializeEntreJugador: unJugador con: unasCartas vs: otroJugador con: otrasCartas
	
	ronda := 0.
	jugadorA := unJugador .
	jugadorB := otroJugador .
	jugadores := Dictionary new;
		at: unJugador put: 0;
		at: otroJugador put:0.
	cartasDeA := unasCartas .
	cartasDeB := otrasCartas .! !

!testRun: #RondaDeTrucoTest #test02 stamp: 'pc 7/5/2021 18:30:16'!
ERROR!
!RondaDeTruco methodsFor: 'initialization' stamp: 'pc 7/5/2021 18:30:34' prior: 50911510!
initializeEntreJugador: unJugador con: unasCartas vs: otroJugador con: otrasCartas
	
	ronda := 0.
	jugadorA := unJugador .
	jugadorB := otroJugador .
	jugadores := Dictionary new
		at: unJugador put: 0;
		at: otroJugador put:0.
	cartasDeA := unasCartas .
	cartasDeB := otrasCartas .! !
!RondaDeTruco methodsFor: 'initialization' stamp: 'pc 7/5/2021 18:31:03' prior: 50911525!
initializeEntreJugador: unJugador con: unasCartas vs: otroJugador con: otrasCartas
	
	ronda := 0.
	jugadorA := unJugador .
	jugadorB := otroJugador .
	jugadores := Dictionary new.
	jugadores	at: unJugador put: 0.
	jugadores	at: otroJugador put:0.
	cartasDeA := unasCartas .
	cartasDeB := otrasCartas .! !

!testRun: #RondaDeTrucoTest #test02 stamp: 'pc 7/5/2021 18:31:17'!
PASSED!

!testRun: #RondaDeTrucoTest #test02 stamp: 'pc 7/5/2021 18:31:21'!
PASSED!

!testRun: #RondaDeTrucoTest #test01 stamp: 'pc 7/5/2021 18:31:21'!
PASSED!

!testRun: #RondaDeTrucoTest #test02 stamp: 'pc 7/5/2021 18:31:21'!
PASSED!
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 18:32:28' prior: 50911476!
test02
	| rondaDeTruco cartasJugadorA cartasJugadorB |
	
	cartasJugadorA _ OrderedCollection new.
	cartasJugadorA add: CartaDeTruco anchoDeEspada.
	cartasJugadorA add: (CartaDeTruco oroCon: 2).
	cartasJugadorA add: (CartaDeTruco copaCon: 3).
	cartasJugadorB _ OrderedCollection new.
	cartasJugadorB add: CartaDeTruco anchoDeBasto.
	cartasJugadorB add: (CartaDeTruco oroCon: 3).
	cartasJugadorB add: (CartaDeTruco copaCon: 4).
	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		con: cartasJugadorA
		vs: jugadorB
		con: cartasJugadorB.
	
	rondaDeTruco enfrentamientoCon: cartasJugadorA first vs: cartasJugadorB first .
		
		
	self assert: (rondaDeTruco rondasJugadas) equals: 1.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorA) equals: 1.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorB) equals: 0.! !

!testRun: #RondaDeTrucoTest #test02 stamp: 'pc 7/5/2021 18:32:30'!
PASSED!

!testRun: #RondaDeTrucoTest #test01 stamp: 'pc 7/5/2021 18:32:30'!
PASSED!

!testRun: #RondaDeTrucoTest #test02 stamp: 'pc 7/5/2021 18:32:30'!
PASSED!
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 18:32:56'!
test03
	| rondaDeTruco cartasJugadorA cartasJugadorB |
	
	cartasJugadorA _ OrderedCollection new.
	cartasJugadorA add: CartaDeTruco anchoDeEspada.
	cartasJugadorA add: (CartaDeTruco oroCon: 2).
	cartasJugadorA add: (CartaDeTruco copaCon: 3).
	cartasJugadorB _ OrderedCollection new.
	cartasJugadorB add: CartaDeTruco anchoDeBasto.
	cartasJugadorB add: (CartaDeTruco oroCon: 3).
	cartasJugadorB add: (CartaDeTruco copaCon: 4).
	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		con: cartasJugadorA
		vs: jugadorB
		con: cartasJugadorB.
	
	rondaDeTruco enfrentamientoCon: cartasJugadorA first vs: cartasJugadorB first .
	rondaDeTruco enfrentamientoCon: cartasJugadorA second vs: cartasJugadorB second .	
		
	self assert: (rondaDeTruco rondasJugadas) equals: 1.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorA) equals: 1.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorB) equals: 0.! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 18:33:20' prior: 50911596!
test03
	| rondaDeTruco cartasJugadorA cartasJugadorB |
	
	cartasJugadorA _ OrderedCollection new.
	cartasJugadorA add: CartaDeTruco anchoDeEspada.
	cartasJugadorA add: (CartaDeTruco oroCon: 2).
	cartasJugadorA add: (CartaDeTruco copaCon: 3).
	cartasJugadorB _ OrderedCollection new.
	cartasJugadorB add: CartaDeTruco anchoDeBasto.
	cartasJugadorB add: (CartaDeTruco oroCon: 3).
	cartasJugadorB add: (CartaDeTruco copaCon: 4).
	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		con: cartasJugadorA
		vs: jugadorB
		con: cartasJugadorB.
	
	rondaDeTruco enfrentamientoCon: cartasJugadorA first vs: cartasJugadorB first .
	rondaDeTruco enfrentamientoCon: cartasJugadorA second vs: cartasJugadorB second .	
		
	self assert: (rondaDeTruco rondasJugadas) equals: 2.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorA) equals: 1.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorB) equals: 1.! !

!testRun: #RondaDeTrucoTest #test03 stamp: 'pc 7/5/2021 18:33:22'!
PASSED!

!testRun: #RondaDeTrucoTest #test01 stamp: 'pc 7/5/2021 18:33:22'!
PASSED!

!testRun: #RondaDeTrucoTest #test02 stamp: 'pc 7/5/2021 18:33:22'!
PASSED!

!testRun: #RondaDeTrucoTest #test03 stamp: 'pc 7/5/2021 18:33:22'!
PASSED!
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 18:34:50' prior: 50911628!
test03
	| rondaDeTruco cartasJugadorA cartasJugadorB |
	
	cartasJugadorA _ OrderedCollection new.
	cartasJugadorA add: (CartaDeTruco oroCon: 2).
	cartasJugadorA add: CartaDeTruco anchoDeEspada.
	cartasJugadorA add: (CartaDeTruco copaCon: 3).
	cartasJugadorB _ OrderedCollection new.
	cartasJugadorB add: (CartaDeTruco oroCon: 2).
	cartasJugadorB add: CartaDeTruco anchoDeBasto.
	cartasJugadorB add: (CartaDeTruco copaCon: 4).
	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		con: cartasJugadorA
		vs: jugadorB
		con: cartasJugadorB.
	
	rondaDeTruco enfrentamientoCon: cartasJugadorA first vs: cartasJugadorB first .
	rondaDeTruco enfrentamientoCon: cartasJugadorA second vs: cartasJugadorB second .	
		
	self assert: (rondaDeTruco rondasJugadas) equals: 2.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorA) equals: 1.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorB) equals: 1.! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 18:35:09' prior: 50911670!
test03
	| rondaDeTruco cartasJugadorA cartasJugadorB |
	
	cartasJugadorA _ OrderedCollection new.
	cartasJugadorA add: (CartaDeTruco oroCon: 2).
	cartasJugadorA add: CartaDeTruco anchoDeEspada.
	cartasJugadorA add: (CartaDeTruco copaCon: 3).
	cartasJugadorB _ OrderedCollection new.
	cartasJugadorB add: (CartaDeTruco oroCon: 2).
	cartasJugadorB add: CartaDeTruco anchoDeBasto.
	cartasJugadorB add: (CartaDeTruco copaCon: 4).
	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		con: cartasJugadorA
		vs: jugadorB
		con: cartasJugadorB.
	
	rondaDeTruco enfrentamientoCon: cartasJugadorA first vs: cartasJugadorB first .
		
	self assert: (rondaDeTruco rondasJugadas) equals: 1.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorA) equals: 0.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorB) equals: 0.! !

!testRun: #RondaDeTrucoTest #test03 stamp: 'pc 7/5/2021 18:35:11'!
FAILURE!
!RondaDeTruco methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 18:37:04' prior: 50911263!
enfrentamientoCon: cartaDeTrucoA vs: cartaDeTrucoB
	
	ronda := ronda + 1.
	(cartaDeTrucoA mataA: cartaDeTrucoB) ifTrue: [jugadores at: jugadorA put: 1]. 
	(cartaDeTrucoB mataA: cartaDeTrucoA) ifTrue: [jugadores at: jugadorB put: 1].
! !

!testRun: #CartaDeTrucoTest #test01SonIgualesConMismoPaloYNumero stamp: 'pc 7/5/2021 18:37:06'!
PASSED!

!testRun: #CartaDeTrucoTest #test02SonDistintasConDistintoPalo stamp: 'pc 7/5/2021 18:37:06'!
PASSED!

!testRun: #CartaDeTrucoTest #test03SonDistintasConNumeroAunqueIgualPalo stamp: 'pc 7/5/2021 18:37:06'!
PASSED!

!testRun: #CartaDeTrucoTest #test04CartasIgualesTienenElMismoHash stamp: 'pc 7/5/2021 18:37:06'!
PASSED!

!testRun: #CartaDeTrucoTest #test05UnaCartaEsDistintaACualquierObjetoQueNoSeaCarta stamp: 'pc 7/5/2021 18:37:06'!
PASSED!

!testRun: #CartaDeTrucoTest #test07NoHayCartaDeTrucoConNumeroOcho stamp: 'pc 7/5/2021 18:37:06'!
PASSED!

!testRun: #CartaDeTrucoTest #test08NoHayCartaDeTrucoConNumeroNueve stamp: 'pc 7/5/2021 18:37:06'!
PASSED!

!testRun: #CartaDeTrucoTest #test09LosPalosDeLaCartaDeTrucoSonBastoOroEspadaYCopa stamp: 'pc 7/5/2021 18:37:06'!
PASSED!

!testRun: #CartaDeTrucoTest #test10NoSePuedeCrearCartaConNumeroMenorAUno stamp: 'pc 7/5/2021 18:37:06'!
PASSED!

!testRun: #CartaDeTrucoTest #test11NoSePuedeCrearCartaConNumeroMayorADoce stamp: 'pc 7/5/2021 18:37:06'!
PASSED!

!testRun: #CartaDeTrucoTest #test12ElNumeroDeLaCartaDebeSerEntero stamp: 'pc 7/5/2021 18:37:06'!
PASSED!

!testRun: #CartaDeTrucoTest #test13LaTablaDeValoresEsCorrecta stamp: 'pc 7/5/2021 18:37:06'!
PASSED!

!testRun: #CartaDeTrucoTest #test14HayCartasQueNoSonPardas stamp: 'pc 7/5/2021 18:37:06'!
PASSED!

!testRun: #CartaDeTrucoTest #test15HayCartasQuePierdenConOtras stamp: 'pc 7/5/2021 18:37:06'!
PASSED!

!testRun: #CartaDeTrucoTest #test16SieteDeCopasYDeBastoEsSieteFalso stamp: 'pc 7/5/2021 18:37:06'!
PASSED!

!testRun: #CartaDeTrucoTest #test17SieteDeOroYDeEspadaNoSonSieteFalso stamp: 'pc 7/5/2021 18:37:06'!
PASSED!

!testRun: #CartaDeTrucoTest #test18AnchoDeOroYDeCopaSonAnchoFalsos stamp: 'pc 7/5/2021 18:37:06'!
PASSED!

!testRun: #CartaDeTrucoTest #test19AnchoDeEspadaYDeBastosNoSonAnchoFalsos stamp: 'pc 7/5/2021 18:37:06'!
PASSED!

!testRun: #CartaDeTrucoTest #test20FallaBuscandoValorDeCartaInv�lida stamp: 'pc 7/5/2021 18:37:06'!
PASSED!

!testRun: #RondaDeTrucoTest #test01 stamp: 'pc 7/5/2021 18:37:06'!
PASSED!

!testRun: #RondaDeTrucoTest #test02 stamp: 'pc 7/5/2021 18:37:06'!
PASSED!

!testRun: #RondaDeTrucoTest #test03 stamp: 'pc 7/5/2021 18:37:06'!
PASSED!

!testRun: #RondaDeTrucoTest #test03 stamp: 'pc 7/5/2021 18:37:09'!
PASSED!

!testRun: #RondaDeTrucoTest #test01 stamp: 'pc 7/5/2021 18:37:09'!
PASSED!

!testRun: #RondaDeTrucoTest #test02 stamp: 'pc 7/5/2021 18:37:09'!
PASSED!

!testRun: #RondaDeTrucoTest #test03 stamp: 'pc 7/5/2021 18:37:09'!
PASSED!
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 18:38:14'!
test04
	| rondaDeTruco cartasJugadorA cartasJugadorB |
	
	cartasJugadorA _ OrderedCollection new.
	cartasJugadorA add: (CartaDeTruco oroCon: 2).
	cartasJugadorA add: CartaDeTruco anchoDeEspada.
	cartasJugadorA add: (CartaDeTruco copaCon: 3).
	cartasJugadorB _ OrderedCollection new.
	cartasJugadorB add: (CartaDeTruco oroCon: 2).
	cartasJugadorB add: CartaDeTruco anchoDeBasto.
	cartasJugadorB add: (CartaDeTruco copaCon: 4).
	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		con: cartasJugadorA
		vs: jugadorB
		con: cartasJugadorB.
	
	rondaDeTruco enfrentamientoCon: cartasJugadorA first vs: cartasJugadorB first .
	rondaDeTruco enfrentamientoCon: cartasJugadorA second vs: cartasJugadorB second .
	
	self assert: (rondaDeTruco rondasJugadas) equals: 2.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorA) equals: 1.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorB) equals: 0.! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 18:38:28' prior: 50911826!
test04
	| rondaDeTruco cartasJugadorA cartasJugadorB |
	
	cartasJugadorA _ OrderedCollection new.
	cartasJugadorA add: (CartaDeTruco oroCon: 2).
	cartasJugadorA add: CartaDeTruco anchoDeEspada.
	cartasJugadorA add: (CartaDeTruco copaCon: 3).
	cartasJugadorB _ OrderedCollection new.
	cartasJugadorB add: (CartaDeTruco oroCon: 2).
	cartasJugadorB add: CartaDeTruco anchoDeBasto.
	cartasJugadorB add: (CartaDeTruco copaCon: 4).
	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		con: cartasJugadorA
		vs: jugadorB
		con: cartasJugadorB.
	
	rondaDeTruco enfrentamientoCon: cartasJugadorA first vs: cartasJugadorB first .
	rondaDeTruco enfrentamientoCon: cartasJugadorA second vs: cartasJugadorB second .
	
	self assert: (rondaDeTruco rondasJugadas) equals: 2.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorA) equals: 1.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorB) equals: 0.
	self assert: (rondaDeTruco ganador) equals: jugadorA .! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 18:38:36' prior: 50911858!
test04
	| rondaDeTruco cartasJugadorA cartasJugadorB |
	
	cartasJugadorA _ OrderedCollection new.
	cartasJugadorA add: (CartaDeTruco oroCon: 2).
	cartasJugadorA add: CartaDeTruco anchoDeEspada.
	cartasJugadorA add: (CartaDeTruco copaCon: 3).
	cartasJugadorB _ OrderedCollection new.
	cartasJugadorB add: (CartaDeTruco oroCon: 2).
	cartasJugadorB add: CartaDeTruco anchoDeBasto.
	cartasJugadorB add: (CartaDeTruco copaCon: 4).
	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		con: cartasJugadorA
		vs: jugadorB
		con: cartasJugadorB.
	
	rondaDeTruco enfrentamientoCon: cartasJugadorA first vs: cartasJugadorB first .
	rondaDeTruco enfrentamientoCon: cartasJugadorA second vs: cartasJugadorB second .
	
	self assert: (rondaDeTruco rondasJugadas) equals: 2.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorA) equals: 1.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorB) equals: 0.
	! !

!testRun: #RondaDeTrucoTest #test04 stamp: 'pc 7/5/2021 18:38:37'!
PASSED!

!testRun: #RondaDeTrucoTest #test01 stamp: 'pc 7/5/2021 18:38:37'!
PASSED!

!testRun: #RondaDeTrucoTest #test02 stamp: 'pc 7/5/2021 18:38:37'!
PASSED!

!testRun: #RondaDeTrucoTest #test03 stamp: 'pc 7/5/2021 18:38:37'!
PASSED!

!testRun: #RondaDeTrucoTest #test04 stamp: 'pc 7/5/2021 18:38:37'!
PASSED!
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 18:38:41' prior: 50911892!
test04
	| rondaDeTruco cartasJugadorA cartasJugadorB |
	
	cartasJugadorA _ OrderedCollection new.
	cartasJugadorA add: (CartaDeTruco oroCon: 2).
	cartasJugadorA add: CartaDeTruco anchoDeEspada.
	cartasJugadorA add: (CartaDeTruco copaCon: 3).
	cartasJugadorB _ OrderedCollection new.
	cartasJugadorB add: (CartaDeTruco oroCon: 2).
	cartasJugadorB add: CartaDeTruco anchoDeBasto.
	cartasJugadorB add: (CartaDeTruco copaCon: 4).
	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		con: cartasJugadorA
		vs: jugadorB
		con: cartasJugadorB.
	
	rondaDeTruco enfrentamientoCon: cartasJugadorA first vs: cartasJugadorB first .
	rondaDeTruco enfrentamientoCon: cartasJugadorA second vs: cartasJugadorB second .
	
	self assert: (rondaDeTruco rondasJugadas) equals: 2.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorA) equals: 1.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorB) equals: 0.
	self assert: (rondaDeTruco ganador) equals: jugadorA .! !

!testRun: #RondaDeTrucoTest #test04 stamp: 'pc 7/5/2021 18:38:45'!
ERROR!
!RondaDeTruco methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 18:38:49'!
ganador
	self shouldBeImplemented.! !

!classDefinition: #RondaDeTruco category: 'ISW1-2021-1C-2doParcial' stamp: 'pc 7/5/2021 18:46:43'!
Object subclass: #RondaDeTruco
	instanceVariableNames: 'jugadorA cartasDeA jugadorB cartasDeB ronda jugadores primerRondaParda'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial'!
!RondaDeTruco methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 18:46:52' prior: 50911972!
ganador
	
	ronda = 3 ifTrue:[
		((jugadores at: jugadorA) > (jugadores at: jugadorB)) ifTrue: [^jugadorA ] ifFalse: [^jugadorB ]].
	(ronda = 2 and: [primerRondaParda]) ifTrue:[
		((jugadores at: jugadorA) > (jugadores at: jugadorB)) ifTrue: [^jugadorA ] ifFalse: [^jugadorB ]].
	
	self error: self class noTerminoLaRondaTodavia.! !

!testRun: #RondaDeTrucoTest #test04 stamp: 'pc 7/5/2021 18:46:56'!
ERROR!
!RondaDeTruco methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 18:47:15' prior: 50911986!
ganador
	
	ronda = 3 ifTrue:[
		((jugadores at: jugadorA) > (jugadores at: jugadorB)) ifTrue: [^jugadorA ] ifFalse: [^jugadorB ]].
	(ronda = 2 and: (primerRondaParda)) ifTrue:[
		((jugadores at: jugadorA) > (jugadores at: jugadorB)) ifTrue: [^jugadorA ] ifFalse: [^jugadorB ]].
	
	self error: self class noTerminoLaRondaTodavia.! !

!testRun: #RondaDeTrucoTest #test04 stamp: 'pc 7/5/2021 18:47:18'!
ERROR!
!RondaDeTruco methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 18:47:37' prior: 50912002!
ganador
	
	ronda = 3 ifTrue:[
		((jugadores at: jugadorA) > (jugadores at: jugadorB)) ifTrue: [^jugadorA ] ifFalse: [^jugadorB ]].
	(ronda = 2 and: [primerRondaParda]) ifTrue:[
		((jugadores at: jugadorA) > (jugadores at: jugadorB)) ifTrue: [^jugadorA ] ifFalse: [^jugadorB ]].
	
	self error: self class noTerminoLaRondaTodavia.! !
!RondaDeTruco methodsFor: 'initialization' stamp: 'pc 7/5/2021 18:48:02' prior: 50911537!
initializeEntreJugador: unJugador con: unasCartas vs: otroJugador con: otrasCartas
	
	primerRondaParda := False.
	ronda := 0.
	jugadorA := unJugador .
	jugadorB := otroJugador .
	jugadores := Dictionary new.
	jugadores	at: unJugador put: 0.
	jugadores	at: otroJugador put:0.
	cartasDeA := unasCartas .
	cartasDeB := otrasCartas .! !
!RondaDeTruco methodsFor: 'initialization' stamp: 'pc 7/5/2021 18:48:08' prior: 50912032!
initializeEntreJugador: unJugador con: unasCartas vs: otroJugador con: otrasCartas
	
	primerRondaParda := false.
	ronda := 0.
	jugadorA := unJugador .
	jugadorB := otroJugador .
	jugadores := Dictionary new.
	jugadores	at: unJugador put: 0.
	jugadores	at: otroJugador put:0.
	cartasDeA := unasCartas .
	cartasDeB := otrasCartas .! !
!RondaDeTruco methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 18:48:44' prior: 50911734!
enfrentamientoCon: cartaDeTrucoA vs: cartaDeTrucoB
	
	ronda := ronda + 1.
	(cartaDeTrucoA mataA: cartaDeTrucoB) ifTrue: [jugadores at: jugadorA put: 1]. 
	(cartaDeTrucoB mataA: cartaDeTrucoA) ifTrue: [jugadores at: jugadorB put: 1].
	(cartaDeTrucoB empardaCon: cartaDeTrucoA) ifTrue: [primerRondaParda := true].
! !

!testRun: #CartaDeTrucoTest #test01SonIgualesConMismoPaloYNumero stamp: 'pc 7/5/2021 18:49:00'!
PASSED!

!testRun: #CartaDeTrucoTest #test02SonDistintasConDistintoPalo stamp: 'pc 7/5/2021 18:49:00'!
PASSED!

!testRun: #CartaDeTrucoTest #test03SonDistintasConNumeroAunqueIgualPalo stamp: 'pc 7/5/2021 18:49:00'!
PASSED!

!testRun: #CartaDeTrucoTest #test04CartasIgualesTienenElMismoHash stamp: 'pc 7/5/2021 18:49:01'!
PASSED!

!testRun: #CartaDeTrucoTest #test05UnaCartaEsDistintaACualquierObjetoQueNoSeaCarta stamp: 'pc 7/5/2021 18:49:01'!
PASSED!

!testRun: #CartaDeTrucoTest #test07NoHayCartaDeTrucoConNumeroOcho stamp: 'pc 7/5/2021 18:49:01'!
PASSED!

!testRun: #CartaDeTrucoTest #test08NoHayCartaDeTrucoConNumeroNueve stamp: 'pc 7/5/2021 18:49:01'!
PASSED!

!testRun: #CartaDeTrucoTest #test09LosPalosDeLaCartaDeTrucoSonBastoOroEspadaYCopa stamp: 'pc 7/5/2021 18:49:01'!
PASSED!

!testRun: #CartaDeTrucoTest #test10NoSePuedeCrearCartaConNumeroMenorAUno stamp: 'pc 7/5/2021 18:49:01'!
PASSED!

!testRun: #CartaDeTrucoTest #test11NoSePuedeCrearCartaConNumeroMayorADoce stamp: 'pc 7/5/2021 18:49:01'!
PASSED!

!testRun: #CartaDeTrucoTest #test12ElNumeroDeLaCartaDebeSerEntero stamp: 'pc 7/5/2021 18:49:01'!
PASSED!

!testRun: #CartaDeTrucoTest #test13LaTablaDeValoresEsCorrecta stamp: 'pc 7/5/2021 18:49:01'!
PASSED!

!testRun: #CartaDeTrucoTest #test14HayCartasQueNoSonPardas stamp: 'pc 7/5/2021 18:49:01'!
PASSED!

!testRun: #CartaDeTrucoTest #test15HayCartasQuePierdenConOtras stamp: 'pc 7/5/2021 18:49:01'!
PASSED!

!testRun: #CartaDeTrucoTest #test16SieteDeCopasYDeBastoEsSieteFalso stamp: 'pc 7/5/2021 18:49:01'!
PASSED!

!testRun: #CartaDeTrucoTest #test17SieteDeOroYDeEspadaNoSonSieteFalso stamp: 'pc 7/5/2021 18:49:01'!
PASSED!

!testRun: #CartaDeTrucoTest #test18AnchoDeOroYDeCopaSonAnchoFalsos stamp: 'pc 7/5/2021 18:49:01'!
PASSED!

!testRun: #CartaDeTrucoTest #test19AnchoDeEspadaYDeBastosNoSonAnchoFalsos stamp: 'pc 7/5/2021 18:49:01'!
PASSED!

!testRun: #CartaDeTrucoTest #test20FallaBuscandoValorDeCartaInv�lida stamp: 'pc 7/5/2021 18:49:01'!
PASSED!

!testRun: #RondaDeTrucoTest #test01 stamp: 'pc 7/5/2021 18:49:01'!
PASSED!

!testRun: #RondaDeTrucoTest #test02 stamp: 'pc 7/5/2021 18:49:01'!
PASSED!

!testRun: #RondaDeTrucoTest #test03 stamp: 'pc 7/5/2021 18:49:01'!
PASSED!

!testRun: #RondaDeTrucoTest #test04 stamp: 'pc 7/5/2021 18:49:01'!
PASSED!
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 18:51:07'!
test05
	| rondaDeTruco cartasJugadorA cartasJugadorB |
	
	cartasJugadorA _ OrderedCollection new.
	cartasJugadorA add: (CartaDeTruco oroCon: 2).
	cartasJugadorA add: CartaDeTruco anchoDeEspada.
	cartasJugadorA add: (CartaDeTruco copaCon: 3).
	cartasJugadorB _ OrderedCollection new.
	cartasJugadorB add: (CartaDeTruco oroCon: 2).
	cartasJugadorB add: CartaDeTruco anchoDeBasto.
	cartasJugadorB add: (CartaDeTruco copaCon: 4).
	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		con: cartasJugadorA
		vs: jugadorB
		con: cartasJugadorB.
	
	rondaDeTruco enfrentamientoCon: cartasJugadorA first vs: cartasJugadorB first .
	rondaDeTruco enfrentamientoCon: cartasJugadorA second vs: cartasJugadorB second .
	
	self assert: (rondaDeTruco rondasJugadas) equals: 2.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorA) equals: 1.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorB) equals: 0.
	self assert: (rondaDeTruco ganador) equals: jugadorA .! !

!testRun: #RondaDeTrucoTest #test05 stamp: 'pc 7/5/2021 18:51:08'!
PASSED!

!testRun: #CartaDeTrucoTest #test01SonIgualesConMismoPaloYNumero stamp: 'pc 7/5/2021 18:51:08'!
PASSED!

!testRun: #CartaDeTrucoTest #test02SonDistintasConDistintoPalo stamp: 'pc 7/5/2021 18:51:08'!
PASSED!

!testRun: #CartaDeTrucoTest #test03SonDistintasConNumeroAunqueIgualPalo stamp: 'pc 7/5/2021 18:51:08'!
PASSED!

!testRun: #CartaDeTrucoTest #test04CartasIgualesTienenElMismoHash stamp: 'pc 7/5/2021 18:51:08'!
PASSED!

!testRun: #CartaDeTrucoTest #test05UnaCartaEsDistintaACualquierObjetoQueNoSeaCarta stamp: 'pc 7/5/2021 18:51:08'!
PASSED!

!testRun: #CartaDeTrucoTest #test07NoHayCartaDeTrucoConNumeroOcho stamp: 'pc 7/5/2021 18:51:09'!
PASSED!

!testRun: #CartaDeTrucoTest #test08NoHayCartaDeTrucoConNumeroNueve stamp: 'pc 7/5/2021 18:51:09'!
PASSED!

!testRun: #CartaDeTrucoTest #test09LosPalosDeLaCartaDeTrucoSonBastoOroEspadaYCopa stamp: 'pc 7/5/2021 18:51:09'!
PASSED!

!testRun: #CartaDeTrucoTest #test10NoSePuedeCrearCartaConNumeroMenorAUno stamp: 'pc 7/5/2021 18:51:09'!
PASSED!

!testRun: #CartaDeTrucoTest #test11NoSePuedeCrearCartaConNumeroMayorADoce stamp: 'pc 7/5/2021 18:51:09'!
PASSED!

!testRun: #CartaDeTrucoTest #test12ElNumeroDeLaCartaDebeSerEntero stamp: 'pc 7/5/2021 18:51:09'!
PASSED!

!testRun: #CartaDeTrucoTest #test13LaTablaDeValoresEsCorrecta stamp: 'pc 7/5/2021 18:51:09'!
PASSED!

!testRun: #CartaDeTrucoTest #test14HayCartasQueNoSonPardas stamp: 'pc 7/5/2021 18:51:09'!
PASSED!

!testRun: #CartaDeTrucoTest #test15HayCartasQuePierdenConOtras stamp: 'pc 7/5/2021 18:51:09'!
PASSED!

!testRun: #CartaDeTrucoTest #test16SieteDeCopasYDeBastoEsSieteFalso stamp: 'pc 7/5/2021 18:51:09'!
PASSED!

!testRun: #CartaDeTrucoTest #test17SieteDeOroYDeEspadaNoSonSieteFalso stamp: 'pc 7/5/2021 18:51:09'!
PASSED!

!testRun: #CartaDeTrucoTest #test18AnchoDeOroYDeCopaSonAnchoFalsos stamp: 'pc 7/5/2021 18:51:09'!
PASSED!

!testRun: #CartaDeTrucoTest #test19AnchoDeEspadaYDeBastosNoSonAnchoFalsos stamp: 'pc 7/5/2021 18:51:09'!
PASSED!

!testRun: #CartaDeTrucoTest #test20FallaBuscandoValorDeCartaInv�lida stamp: 'pc 7/5/2021 18:51:09'!
PASSED!

!testRun: #RondaDeTrucoTest #test01 stamp: 'pc 7/5/2021 18:51:09'!
PASSED!

!testRun: #RondaDeTrucoTest #test02 stamp: 'pc 7/5/2021 18:51:09'!
PASSED!

!testRun: #RondaDeTrucoTest #test03 stamp: 'pc 7/5/2021 18:51:09'!
PASSED!

!testRun: #RondaDeTrucoTest #test04 stamp: 'pc 7/5/2021 18:51:09'!
PASSED!

!testRun: #RondaDeTrucoTest #test05 stamp: 'pc 7/5/2021 18:51:09'!
PASSED!

!testRun: #RondaDeTrucoTest #test05 stamp: 'pc 7/5/2021 18:51:10'!
PASSED!

!testRun: #RondaDeTrucoTest #test01 stamp: 'pc 7/5/2021 18:51:10'!
PASSED!

!testRun: #RondaDeTrucoTest #test02 stamp: 'pc 7/5/2021 18:51:10'!
PASSED!

!testRun: #RondaDeTrucoTest #test03 stamp: 'pc 7/5/2021 18:51:10'!
PASSED!

!testRun: #RondaDeTrucoTest #test04 stamp: 'pc 7/5/2021 18:51:10'!
PASSED!

!testRun: #RondaDeTrucoTest #test05 stamp: 'pc 7/5/2021 18:51:10'!
PASSED!
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 18:51:45'!
test06
	| rondaDeTruco cartasJugadorA cartasJugadorB |
	
	cartasJugadorA _ OrderedCollection new.
	cartasJugadorA add: (CartaDeTruco oroCon: 3).
	cartasJugadorA add: CartaDeTruco anchoDeEspada.
	cartasJugadorA add: (CartaDeTruco copaCon: 3).
	cartasJugadorB _ OrderedCollection new.
	cartasJugadorB add: (CartaDeTruco oroCon: 2).
	cartasJugadorB add: CartaDeTruco anchoDeBasto.
	cartasJugadorB add: (CartaDeTruco copaCon: 4).
	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		con: cartasJugadorA
		vs: jugadorB
		con: cartasJugadorB.
	
	rondaDeTruco enfrentamientoCon: cartasJugadorA first vs: cartasJugadorB first .
	rondaDeTruco enfrentamientoCon: cartasJugadorA second vs: cartasJugadorB second .
	
	self assert: (rondaDeTruco rondasJugadas) equals: 2.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorA) equals: 1.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorB) equals: 0.
	self assert: (rondaDeTruco ganador) equals: jugadorA .! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 18:52:27' prior: 50912274!
test06
	| rondaDeTruco cartasJugadorA cartasJugadorB |
	
	cartasJugadorA _ OrderedCollection new.
	cartasJugadorA add: (CartaDeTruco oroCon: 4).
	cartasJugadorA add: CartaDeTruco anchoDeEspada.
	cartasJugadorA add: (CartaDeTruco copaCon: 3).
	cartasJugadorB _ OrderedCollection new.
	cartasJugadorB add: (CartaDeTruco oroCon: 2).
	cartasJugadorB add: CartaDeTruco anchoDeBasto.
	cartasJugadorB add: (CartaDeTruco copaCon: 4).
	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		con: cartasJugadorA
		vs: jugadorB
		con: cartasJugadorB.
	
	rondaDeTruco enfrentamientoCon: cartasJugadorA first vs: cartasJugadorB first .
	rondaDeTruco enfrentamientoCon: cartasJugadorA second vs: cartasJugadorB second .
	
	self assert: (rondaDeTruco rondasJugadas) equals: 2.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorA) equals: 1.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorB) equals: 0.
	self assert: (rondaDeTruco ganador) equals: jugadorA .! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 18:52:41' prior: 50912308!
test06
	| rondaDeTruco cartasJugadorA cartasJugadorB |
	
	cartasJugadorA _ OrderedCollection new.
	cartasJugadorA add: (CartaDeTruco oroCon: 4).
	cartasJugadorA add: CartaDeTruco anchoDeEspada.
	cartasJugadorA add: (CartaDeTruco copaCon: 3).
	cartasJugadorB _ OrderedCollection new.
	cartasJugadorB add: (CartaDeTruco oroCon: 2).
	cartasJugadorB add: CartaDeTruco anchoDeBasto.
	cartasJugadorB add: (CartaDeTruco copaCon: 4).
	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		con: cartasJugadorA
		vs: jugadorB
		con: cartasJugadorB.
	
	rondaDeTruco enfrentamientoCon: cartasJugadorA first vs: cartasJugadorB first .
	rondaDeTruco enfrentamientoCon: cartasJugadorA second vs: cartasJugadorB second .
	rondaDeTruco enfrentamientoCon: cartasJugadorA third vs: cartasJugadorB third .
	
	self assert: (rondaDeTruco rondasJugadas) equals: 2.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorA) equals: 1.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorB) equals: 0.
	self assert: (rondaDeTruco ganador) equals: jugadorA .! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 18:53:03' prior: 50912342!
test06
	| rondaDeTruco cartasJugadorA cartasJugadorB |
	
	cartasJugadorA _ OrderedCollection new.
	cartasJugadorA add: (CartaDeTruco oroCon: 4).
	cartasJugadorA add: CartaDeTruco anchoDeEspada.
	cartasJugadorA add: (CartaDeTruco copaCon: 3).
	cartasJugadorB _ OrderedCollection new.
	cartasJugadorB add: (CartaDeTruco oroCon: 2).
	cartasJugadorB add: CartaDeTruco anchoDeBasto.
	cartasJugadorB add: (CartaDeTruco copaCon: 4).
	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		con: cartasJugadorA
		vs: jugadorB
		con: cartasJugadorB.
	
	rondaDeTruco enfrentamientoCon: cartasJugadorA first vs: cartasJugadorB first .
	rondaDeTruco enfrentamientoCon: cartasJugadorA second vs: cartasJugadorB second .
	rondaDeTruco enfrentamientoCon: cartasJugadorA third vs: cartasJugadorB third .
	
	self assert: (rondaDeTruco rondasJugadas) equals: 3.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorA) equals: 2.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorB) equals: 1.
	self assert: (rondaDeTruco ganador) equals: jugadorA .! !

!testRun: #RondaDeTrucoTest #test06 stamp: 'pc 7/5/2021 18:53:04'!
FAILURE!
!RondaDeTruco methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 18:56:36' prior: 50912060!
enfrentamientoCon: cartaDeTrucoA vs: cartaDeTrucoB
	
	ronda := ronda + 1.
	(cartaDeTrucoA mataA: cartaDeTrucoB) ifTrue: [jugadores add: jugadorA ]. 
	(cartaDeTrucoB mataA: cartaDeTrucoA) ifTrue: [jugadores at: jugadorB].
	(cartaDeTrucoB empardaCon: cartaDeTrucoA) ifTrue: [primerRondaParda := true].
! !
!RondaDeTruco methodsFor: 'initialization' stamp: 'pc 7/5/2021 18:56:57' prior: 50912046!
initializeEntreJugador: unJugador con: unasCartas vs: otroJugador con: otrasCartas
	
	primerRondaParda := false.
	ronda := 0.
	jugadorA := unJugador .
	jugadorB := otroJugador .
	jugadores := Bag new.
	cartasDeA := unasCartas .
	cartasDeB := otrasCartas .! !

!testRun: #CartaDeTrucoTest #test01SonIgualesConMismoPaloYNumero stamp: 'pc 7/5/2021 18:56:59'!
PASSED!

!testRun: #CartaDeTrucoTest #test02SonDistintasConDistintoPalo stamp: 'pc 7/5/2021 18:56:59'!
PASSED!

!testRun: #CartaDeTrucoTest #test03SonDistintasConNumeroAunqueIgualPalo stamp: 'pc 7/5/2021 18:56:59'!
PASSED!

!testRun: #CartaDeTrucoTest #test04CartasIgualesTienenElMismoHash stamp: 'pc 7/5/2021 18:56:59'!
PASSED!

!testRun: #CartaDeTrucoTest #test05UnaCartaEsDistintaACualquierObjetoQueNoSeaCarta stamp: 'pc 7/5/2021 18:56:59'!
PASSED!

!testRun: #CartaDeTrucoTest #test07NoHayCartaDeTrucoConNumeroOcho stamp: 'pc 7/5/2021 18:56:59'!
PASSED!

!testRun: #CartaDeTrucoTest #test08NoHayCartaDeTrucoConNumeroNueve stamp: 'pc 7/5/2021 18:56:59'!
PASSED!

!testRun: #CartaDeTrucoTest #test09LosPalosDeLaCartaDeTrucoSonBastoOroEspadaYCopa stamp: 'pc 7/5/2021 18:56:59'!
PASSED!

!testRun: #CartaDeTrucoTest #test10NoSePuedeCrearCartaConNumeroMenorAUno stamp: 'pc 7/5/2021 18:56:59'!
PASSED!

!testRun: #CartaDeTrucoTest #test11NoSePuedeCrearCartaConNumeroMayorADoce stamp: 'pc 7/5/2021 18:56:59'!
PASSED!

!testRun: #CartaDeTrucoTest #test12ElNumeroDeLaCartaDebeSerEntero stamp: 'pc 7/5/2021 18:56:59'!
PASSED!

!testRun: #CartaDeTrucoTest #test13LaTablaDeValoresEsCorrecta stamp: 'pc 7/5/2021 18:56:59'!
PASSED!

!testRun: #CartaDeTrucoTest #test14HayCartasQueNoSonPardas stamp: 'pc 7/5/2021 18:56:59'!
PASSED!

!testRun: #CartaDeTrucoTest #test15HayCartasQuePierdenConOtras stamp: 'pc 7/5/2021 18:56:59'!
PASSED!

!testRun: #CartaDeTrucoTest #test16SieteDeCopasYDeBastoEsSieteFalso stamp: 'pc 7/5/2021 18:56:59'!
PASSED!

!testRun: #CartaDeTrucoTest #test17SieteDeOroYDeEspadaNoSonSieteFalso stamp: 'pc 7/5/2021 18:56:59'!
PASSED!

!testRun: #CartaDeTrucoTest #test18AnchoDeOroYDeCopaSonAnchoFalsos stamp: 'pc 7/5/2021 18:56:59'!
PASSED!

!testRun: #CartaDeTrucoTest #test19AnchoDeEspadaYDeBastosNoSonAnchoFalsos stamp: 'pc 7/5/2021 18:56:59'!
PASSED!

!testRun: #CartaDeTrucoTest #test20FallaBuscandoValorDeCartaInv�lida stamp: 'pc 7/5/2021 18:56:59'!
PASSED!

!testRun: #RondaDeTrucoTest #test01 stamp: 'pc 7/5/2021 18:56:59'!
PASSED!

!testRun: #RondaDeTrucoTest #test02 stamp: 'pc 7/5/2021 18:56:59'!
ERROR!

!testRun: #RondaDeTrucoTest #test03 stamp: 'pc 7/5/2021 18:56:59'!
ERROR!

!testRun: #RondaDeTrucoTest #test04 stamp: 'pc 7/5/2021 18:56:59'!
ERROR!

!testRun: #RondaDeTrucoTest #test05 stamp: 'pc 7/5/2021 18:56:59'!
ERROR!

!testRun: #RondaDeTrucoTest #test06 stamp: 'pc 7/5/2021 18:56:59'!
ERROR!

!testRun: #RondaDeTrucoTest #test02 stamp: 'pc 7/5/2021 18:57:01'!
ERROR!
!RondaDeTruco methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 18:57:54' prior: 50911186!
enfretamientosGanadosPor: unJugador 
	
	^jugadores occurrencesOf: unJugador .! !

!testRun: #RondaDeTrucoTest #test02 stamp: 'pc 7/5/2021 18:57:57'!
PASSED!

!testRun: #CartaDeTrucoTest #test01SonIgualesConMismoPaloYNumero stamp: 'pc 7/5/2021 18:57:59'!
PASSED!

!testRun: #CartaDeTrucoTest #test02SonDistintasConDistintoPalo stamp: 'pc 7/5/2021 18:57:59'!
PASSED!

!testRun: #CartaDeTrucoTest #test03SonDistintasConNumeroAunqueIgualPalo stamp: 'pc 7/5/2021 18:57:59'!
PASSED!

!testRun: #CartaDeTrucoTest #test04CartasIgualesTienenElMismoHash stamp: 'pc 7/5/2021 18:57:59'!
PASSED!

!testRun: #CartaDeTrucoTest #test05UnaCartaEsDistintaACualquierObjetoQueNoSeaCarta stamp: 'pc 7/5/2021 18:57:59'!
PASSED!

!testRun: #CartaDeTrucoTest #test07NoHayCartaDeTrucoConNumeroOcho stamp: 'pc 7/5/2021 18:57:59'!
PASSED!

!testRun: #CartaDeTrucoTest #test08NoHayCartaDeTrucoConNumeroNueve stamp: 'pc 7/5/2021 18:57:59'!
PASSED!

!testRun: #CartaDeTrucoTest #test09LosPalosDeLaCartaDeTrucoSonBastoOroEspadaYCopa stamp: 'pc 7/5/2021 18:57:59'!
PASSED!

!testRun: #CartaDeTrucoTest #test10NoSePuedeCrearCartaConNumeroMenorAUno stamp: 'pc 7/5/2021 18:57:59'!
PASSED!

!testRun: #CartaDeTrucoTest #test11NoSePuedeCrearCartaConNumeroMayorADoce stamp: 'pc 7/5/2021 18:57:59'!
PASSED!

!testRun: #CartaDeTrucoTest #test12ElNumeroDeLaCartaDebeSerEntero stamp: 'pc 7/5/2021 18:57:59'!
PASSED!

!testRun: #CartaDeTrucoTest #test13LaTablaDeValoresEsCorrecta stamp: 'pc 7/5/2021 18:57:59'!
PASSED!

!testRun: #CartaDeTrucoTest #test14HayCartasQueNoSonPardas stamp: 'pc 7/5/2021 18:57:59'!
PASSED!

!testRun: #CartaDeTrucoTest #test15HayCartasQuePierdenConOtras stamp: 'pc 7/5/2021 18:57:59'!
PASSED!

!testRun: #CartaDeTrucoTest #test16SieteDeCopasYDeBastoEsSieteFalso stamp: 'pc 7/5/2021 18:57:59'!
PASSED!

!testRun: #CartaDeTrucoTest #test17SieteDeOroYDeEspadaNoSonSieteFalso stamp: 'pc 7/5/2021 18:57:59'!
PASSED!

!testRun: #CartaDeTrucoTest #test18AnchoDeOroYDeCopaSonAnchoFalsos stamp: 'pc 7/5/2021 18:57:59'!
PASSED!

!testRun: #CartaDeTrucoTest #test19AnchoDeEspadaYDeBastosNoSonAnchoFalsos stamp: 'pc 7/5/2021 18:57:59'!
PASSED!

!testRun: #CartaDeTrucoTest #test20FallaBuscandoValorDeCartaInv�lida stamp: 'pc 7/5/2021 18:57:59'!
PASSED!

!testRun: #RondaDeTrucoTest #test01 stamp: 'pc 7/5/2021 18:57:59'!
PASSED!

!testRun: #RondaDeTrucoTest #test02 stamp: 'pc 7/5/2021 18:57:59'!
PASSED!

!testRun: #RondaDeTrucoTest #test03 stamp: 'pc 7/5/2021 18:57:59'!
PASSED!

!testRun: #RondaDeTrucoTest #test04 stamp: 'pc 7/5/2021 18:57:59'!
ERROR!

!testRun: #RondaDeTrucoTest #test05 stamp: 'pc 7/5/2021 18:57:59'!
ERROR!

!testRun: #RondaDeTrucoTest #test06 stamp: 'pc 7/5/2021 18:57:59'!
ERROR!

!testRun: #RondaDeTrucoTest #test04 stamp: 'pc 7/5/2021 18:58:00'!
ERROR!
!RondaDeTruco methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 18:58:35' prior: 50912018!
ganador
	
	ronda = 3 ifTrue:[
		((jugadores occurrencesOf: jugadorA) > (jugadores occurrencesOf: jugadorB)) ifTrue: [^jugadorA ] ifFalse: [^jugadorB ]].
	(ronda = 2 and: [primerRondaParda]) ifTrue:[
		((jugadores occurrencesOf: jugadorA) > (jugadores occurrencesOf: jugadorB)) ifTrue: [^jugadorA ] ifFalse: [^jugadorB ]].
	
	self error: self class noTerminoLaRondaTodavia.! !

!testRun: #RondaDeTrucoTest #test04 stamp: 'pc 7/5/2021 18:58:37'!
PASSED!

!testRun: #CartaDeTrucoTest #test01SonIgualesConMismoPaloYNumero stamp: 'pc 7/5/2021 18:58:39'!
PASSED!

!testRun: #CartaDeTrucoTest #test02SonDistintasConDistintoPalo stamp: 'pc 7/5/2021 18:58:39'!
PASSED!

!testRun: #CartaDeTrucoTest #test03SonDistintasConNumeroAunqueIgualPalo stamp: 'pc 7/5/2021 18:58:39'!
PASSED!

!testRun: #CartaDeTrucoTest #test04CartasIgualesTienenElMismoHash stamp: 'pc 7/5/2021 18:58:39'!
PASSED!

!testRun: #CartaDeTrucoTest #test05UnaCartaEsDistintaACualquierObjetoQueNoSeaCarta stamp: 'pc 7/5/2021 18:58:39'!
PASSED!

!testRun: #CartaDeTrucoTest #test07NoHayCartaDeTrucoConNumeroOcho stamp: 'pc 7/5/2021 18:58:39'!
PASSED!

!testRun: #CartaDeTrucoTest #test08NoHayCartaDeTrucoConNumeroNueve stamp: 'pc 7/5/2021 18:58:39'!
PASSED!

!testRun: #CartaDeTrucoTest #test09LosPalosDeLaCartaDeTrucoSonBastoOroEspadaYCopa stamp: 'pc 7/5/2021 18:58:39'!
PASSED!

!testRun: #CartaDeTrucoTest #test10NoSePuedeCrearCartaConNumeroMenorAUno stamp: 'pc 7/5/2021 18:58:39'!
PASSED!

!testRun: #CartaDeTrucoTest #test11NoSePuedeCrearCartaConNumeroMayorADoce stamp: 'pc 7/5/2021 18:58:39'!
PASSED!

!testRun: #CartaDeTrucoTest #test12ElNumeroDeLaCartaDebeSerEntero stamp: 'pc 7/5/2021 18:58:39'!
PASSED!

!testRun: #CartaDeTrucoTest #test13LaTablaDeValoresEsCorrecta stamp: 'pc 7/5/2021 18:58:39'!
PASSED!

!testRun: #CartaDeTrucoTest #test14HayCartasQueNoSonPardas stamp: 'pc 7/5/2021 18:58:39'!
PASSED!

!testRun: #CartaDeTrucoTest #test15HayCartasQuePierdenConOtras stamp: 'pc 7/5/2021 18:58:39'!
PASSED!

!testRun: #CartaDeTrucoTest #test16SieteDeCopasYDeBastoEsSieteFalso stamp: 'pc 7/5/2021 18:58:39'!
PASSED!

!testRun: #CartaDeTrucoTest #test17SieteDeOroYDeEspadaNoSonSieteFalso stamp: 'pc 7/5/2021 18:58:39'!
PASSED!

!testRun: #CartaDeTrucoTest #test18AnchoDeOroYDeCopaSonAnchoFalsos stamp: 'pc 7/5/2021 18:58:39'!
PASSED!

!testRun: #CartaDeTrucoTest #test19AnchoDeEspadaYDeBastosNoSonAnchoFalsos stamp: 'pc 7/5/2021 18:58:39'!
PASSED!

!testRun: #CartaDeTrucoTest #test20FallaBuscandoValorDeCartaInv�lida stamp: 'pc 7/5/2021 18:58:39'!
PASSED!

!testRun: #RondaDeTrucoTest #test01 stamp: 'pc 7/5/2021 18:58:39'!
PASSED!

!testRun: #RondaDeTrucoTest #test02 stamp: 'pc 7/5/2021 18:58:39'!
PASSED!

!testRun: #RondaDeTrucoTest #test03 stamp: 'pc 7/5/2021 18:58:39'!
PASSED!

!testRun: #RondaDeTrucoTest #test04 stamp: 'pc 7/5/2021 18:58:39'!
PASSED!

!testRun: #RondaDeTrucoTest #test05 stamp: 'pc 7/5/2021 18:58:39'!
PASSED!

!testRun: #RondaDeTrucoTest #test06 stamp: 'pc 7/5/2021 18:58:39'!
ERROR!

!testRun: #RondaDeTrucoTest #test06 stamp: 'pc 7/5/2021 18:58:39'!
ERROR!
!RondaDeTruco methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 18:58:46' prior: 50912417!
enfrentamientoCon: cartaDeTrucoA vs: cartaDeTrucoB
	
	ronda := ronda + 1.
	(cartaDeTrucoA mataA: cartaDeTrucoB) ifTrue: [jugadores add: jugadorA ]. 
	(cartaDeTrucoB mataA: cartaDeTrucoA) ifTrue: [jugadores add: jugadorB].
	(cartaDeTrucoB empardaCon: cartaDeTrucoA) ifTrue: [primerRondaParda := true].
! !

!testRun: #RondaDeTrucoTest #test06 stamp: 'pc 7/5/2021 18:58:48'!
FAILURE!

rondaDeTruco rondasJugadas!

!testRun: #RondaDeTrucoTest #test06 stamp: 'pc 7/5/2021 18:59:54'!
PASSED!

!testRun: #CartaDeTrucoTest #test01SonIgualesConMismoPaloYNumero stamp: 'pc 7/5/2021 18:59:57'!
PASSED!

!testRun: #CartaDeTrucoTest #test02SonDistintasConDistintoPalo stamp: 'pc 7/5/2021 18:59:57'!
PASSED!

!testRun: #CartaDeTrucoTest #test03SonDistintasConNumeroAunqueIgualPalo stamp: 'pc 7/5/2021 18:59:57'!
PASSED!

!testRun: #CartaDeTrucoTest #test04CartasIgualesTienenElMismoHash stamp: 'pc 7/5/2021 18:59:57'!
PASSED!

!testRun: #CartaDeTrucoTest #test05UnaCartaEsDistintaACualquierObjetoQueNoSeaCarta stamp: 'pc 7/5/2021 18:59:57'!
PASSED!

!testRun: #CartaDeTrucoTest #test07NoHayCartaDeTrucoConNumeroOcho stamp: 'pc 7/5/2021 18:59:57'!
PASSED!

!testRun: #CartaDeTrucoTest #test08NoHayCartaDeTrucoConNumeroNueve stamp: 'pc 7/5/2021 18:59:57'!
PASSED!

!testRun: #CartaDeTrucoTest #test09LosPalosDeLaCartaDeTrucoSonBastoOroEspadaYCopa stamp: 'pc 7/5/2021 18:59:57'!
PASSED!

!testRun: #CartaDeTrucoTest #test10NoSePuedeCrearCartaConNumeroMenorAUno stamp: 'pc 7/5/2021 18:59:57'!
PASSED!

!testRun: #CartaDeTrucoTest #test11NoSePuedeCrearCartaConNumeroMayorADoce stamp: 'pc 7/5/2021 18:59:57'!
PASSED!

!testRun: #CartaDeTrucoTest #test12ElNumeroDeLaCartaDebeSerEntero stamp: 'pc 7/5/2021 18:59:57'!
PASSED!

!testRun: #CartaDeTrucoTest #test13LaTablaDeValoresEsCorrecta stamp: 'pc 7/5/2021 18:59:57'!
PASSED!

!testRun: #CartaDeTrucoTest #test14HayCartasQueNoSonPardas stamp: 'pc 7/5/2021 18:59:57'!
PASSED!

!testRun: #CartaDeTrucoTest #test15HayCartasQuePierdenConOtras stamp: 'pc 7/5/2021 18:59:57'!
PASSED!

!testRun: #CartaDeTrucoTest #test16SieteDeCopasYDeBastoEsSieteFalso stamp: 'pc 7/5/2021 18:59:57'!
PASSED!

!testRun: #CartaDeTrucoTest #test17SieteDeOroYDeEspadaNoSonSieteFalso stamp: 'pc 7/5/2021 18:59:57'!
PASSED!

!testRun: #CartaDeTrucoTest #test18AnchoDeOroYDeCopaSonAnchoFalsos stamp: 'pc 7/5/2021 18:59:57'!
PASSED!

!testRun: #CartaDeTrucoTest #test19AnchoDeEspadaYDeBastosNoSonAnchoFalsos stamp: 'pc 7/5/2021 18:59:57'!
PASSED!

!testRun: #CartaDeTrucoTest #test20FallaBuscandoValorDeCartaInv�lida stamp: 'pc 7/5/2021 18:59:57'!
PASSED!

!testRun: #RondaDeTrucoTest #test01 stamp: 'pc 7/5/2021 18:59:57'!
PASSED!

!testRun: #RondaDeTrucoTest #test02 stamp: 'pc 7/5/2021 18:59:57'!
PASSED!

!testRun: #RondaDeTrucoTest #test03 stamp: 'pc 7/5/2021 18:59:58'!
PASSED!

!testRun: #RondaDeTrucoTest #test04 stamp: 'pc 7/5/2021 18:59:58'!
PASSED!

!testRun: #RondaDeTrucoTest #test05 stamp: 'pc 7/5/2021 18:59:58'!
PASSED!

!testRun: #RondaDeTrucoTest #test06 stamp: 'pc 7/5/2021 18:59:58'!
PASSED!
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 19:00:44'!
test07
	| rondaDeTruco cartasJugadorA cartasJugadorB |
	
	cartasJugadorA _ OrderedCollection new.
	cartasJugadorA add: (CartaDeTruco copaCon: 2).
	cartasJugadorA add: CartaDeTruco anchoDeEspada.
	cartasJugadorA add: (CartaDeTruco copaCon: 3).
	cartasJugadorB _ OrderedCollection new.
	cartasJugadorB add: (CartaDeTruco oroCon: 2).
	cartasJugadorB add: CartaDeTruco anchoDeBasto.
	cartasJugadorB add: (CartaDeTruco copaCon: 4).
	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		con: cartasJugadorA
		vs: jugadorB
		con: cartasJugadorB.
	
	rondaDeTruco enfrentamientoCon: cartasJugadorA first vs: cartasJugadorB first .
	rondaDeTruco enfrentamientoCon: cartasJugadorA second vs: cartasJugadorB second .
	
	self assert: (rondaDeTruco rondasJugadas) equals: 2.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorA) equals: 1.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorB) equals: 0.
	self assert: (rondaDeTruco ganador) equals: jugadorA .! !

!testRun: #RondaDeTrucoTest #test07 stamp: 'pc 7/5/2021 19:00:45'!
PASSED!

!testRun: #RondaDeTrucoTest #test01 stamp: 'pc 7/5/2021 19:00:45'!
PASSED!

!testRun: #RondaDeTrucoTest #test02 stamp: 'pc 7/5/2021 19:00:45'!
PASSED!

!testRun: #RondaDeTrucoTest #test03 stamp: 'pc 7/5/2021 19:00:45'!
PASSED!

!testRun: #RondaDeTrucoTest #test04 stamp: 'pc 7/5/2021 19:00:45'!
PASSED!

!testRun: #RondaDeTrucoTest #test05 stamp: 'pc 7/5/2021 19:00:45'!
PASSED!

!testRun: #RondaDeTrucoTest #test06 stamp: 'pc 7/5/2021 19:00:45'!
PASSED!

!testRun: #RondaDeTrucoTest #test07 stamp: 'pc 7/5/2021 19:00:45'!
PASSED!
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 19:00:58'!
test08
	| rondaDeTruco cartasJugadorA cartasJugadorB |
	
	cartasJugadorA _ OrderedCollection new.
	cartasJugadorA add: (CartaDeTruco copaCon: 2).
	cartasJugadorA add: CartaDeTruco anchoDeEspada.
	cartasJugadorA add: (CartaDeTruco copaCon: 3).
	cartasJugadorB _ OrderedCollection new.
	cartasJugadorB add: (CartaDeTruco oroCon: 2).
	cartasJugadorB add: CartaDeTruco anchoDeBasto.
	cartasJugadorB add: (CartaDeTruco copaCon: 4).
	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		con: cartasJugadorA
		vs: jugadorB
		con: cartasJugadorB.
	
	rondaDeTruco enfrentamientoCon: cartasJugadorA first vs: cartasJugadorB first .
	rondaDeTruco enfrentamientoCon: cartasJugadorA second vs: cartasJugadorB second.
	
	self assert: (rondaDeTruco rondasJugadas) equals: 2.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorA) equals: 1.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorB) equals: 0.
	self assert: (rondaDeTruco ganador) equals: jugadorA .! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 19:04:56' prior: 50912861!
test08
	| rondaDeTruco |

	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		vs: jugadorB.
	
	self 
		should: [rondaDeTruco enfrentamientoCon: CartaDeTruco anchoDeBasto vs: CartaDeTruco anchoDeBasto .]
		raise: Error -MessageNotUnderstood 
		withExceptionDo: [:anError|
			self assert: RondaDeTruco cartaRepetidaError equals: anError messageText .
			self assert: (rondaDeTruco rondasJugadas) equals: 0.
			].
	! !
!RondaDeTruco methodsFor: 'initialization' stamp: 'pc 7/5/2021 19:05:39' prior: 50912430!
initializeEntreJugador: unJugador con: unasCartas vs: otroJugador con: otrasCartas
	
	primerRondaParda := false.
	ronda := 0.
	jugadorA := unJugador .
	jugadorB := otroJugador .
	jugadores := Bag new.
	cartasDeA := OrderedCollection new.
	cartasDeB := OrderedCollection new.! !
!RondaDeTruco methodsFor: 'initialization' stamp: 'pc 7/5/2021 19:08:20' prior: 50912911!
initializeEntreJugador: unJugador con: unasCartas vs: otroJugador con: otrasCartas
	
	primerRondaParda := false.
	ronda := 0.
	jugadorA := unJugador .
	jugadorB := otroJugador .
	jugadores := Bag new.
	cartasDeA := OrderedCollection new.
	cartasDeB := OrderedCollection new.! !
!RondaDeTruco methodsFor: 'initialization' stamp: 'pc 7/5/2021 19:08:43'!
initializeEntreJugador: unJugador vs: otroJugador con: otrasCartas
	
	primerRondaParda := false.
	ronda := 0.
	jugadorA := unJugador .
	jugadorB := otroJugador .
	jugadores := Bag new.
	cartasDeA := OrderedCollection new.
	cartasDeB := OrderedCollection new.! !
!RondaDeTruco class methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 19:08:43' prior: 50910678!
entreJugador: unJugador con: cartasDeA vs: otroJugador con: cartasDeB 
	
	^self new initializeEntreJugador: unJugador vs: otroJugador con: cartasDeB! !

!methodRemoval: RondaDeTruco #initializeEntreJugador:con:vs:con: stamp: 'pc 7/5/2021 19:08:43'!
initializeEntreJugador: unJugador con: unasCartas vs: otroJugador con: otrasCartas
	
	primerRondaParda := false.
	ronda := 0.
	jugadorA := unJugador .
	jugadorB := otroJugador .
	jugadores := Bag new.
	cartasDeA := OrderedCollection new.
	cartasDeB := OrderedCollection new.!
!RondaDeTruco methodsFor: 'initialization' stamp: 'pc 7/5/2021 19:08:52'!
initializeEntreJugador: unJugador vs: otroJugador 
	
	primerRondaParda := false.
	ronda := 0.
	jugadorA := unJugador .
	jugadorB := otroJugador .
	jugadores := Bag new.
	cartasDeA := OrderedCollection new.
	cartasDeB := OrderedCollection new.! !
!RondaDeTruco class methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 19:08:52' prior: 50912946!
entreJugador: unJugador con: cartasDeA vs: otroJugador con: cartasDeB 
	
	^self new initializeEntreJugador: unJugador vs: otroJugador ! !

!methodRemoval: RondaDeTruco #initializeEntreJugador:vs:con: stamp: 'pc 7/5/2021 19:08:52'!
initializeEntreJugador: unJugador vs: otroJugador con: otrasCartas
	
	primerRondaParda := false.
	ronda := 0.
	jugadorA := unJugador .
	jugadorB := otroJugador .
	jugadores := Bag new.
	cartasDeA := OrderedCollection new.
	cartasDeB := OrderedCollection new.!
!RondaDeTruco class methodsFor: 'instance creation' stamp: 'pc 7/5/2021 19:09:04'!
entreJugador: unJugador vs: otroJugador con: cartasDeB 
	
	^self new initializeEntreJugador: unJugador vs: otroJugador ! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 19:09:05' prior: 50911560!
test02
	| rondaDeTruco cartasJugadorA cartasJugadorB |
	
	cartasJugadorA _ OrderedCollection new.
	cartasJugadorA add: CartaDeTruco anchoDeEspada.
	cartasJugadorA add: (CartaDeTruco oroCon: 2).
	cartasJugadorA add: (CartaDeTruco copaCon: 3).
	cartasJugadorB _ OrderedCollection new.
	cartasJugadorB add: CartaDeTruco anchoDeBasto.
	cartasJugadorB add: (CartaDeTruco oroCon: 3).
	cartasJugadorB add: (CartaDeTruco copaCon: 4).
	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		vs: jugadorB
		con: cartasJugadorB.
	
	rondaDeTruco enfrentamientoCon: cartasJugadorA first vs: cartasJugadorB first .
		
		
	self assert: (rondaDeTruco rondasJugadas) equals: 1.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorA) equals: 1.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorB) equals: 0.! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 19:09:05' prior: 50912809!
test07
	| rondaDeTruco cartasJugadorA cartasJugadorB |
	
	cartasJugadorA _ OrderedCollection new.
	cartasJugadorA add: (CartaDeTruco copaCon: 2).
	cartasJugadorA add: CartaDeTruco anchoDeEspada.
	cartasJugadorA add: (CartaDeTruco copaCon: 3).
	cartasJugadorB _ OrderedCollection new.
	cartasJugadorB add: (CartaDeTruco oroCon: 2).
	cartasJugadorB add: CartaDeTruco anchoDeBasto.
	cartasJugadorB add: (CartaDeTruco copaCon: 4).
	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		vs: jugadorB
		con: cartasJugadorB.
	
	rondaDeTruco enfrentamientoCon: cartasJugadorA first vs: cartasJugadorB first .
	rondaDeTruco enfrentamientoCon: cartasJugadorA second vs: cartasJugadorB second .
	
	self assert: (rondaDeTruco rondasJugadas) equals: 2.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorA) equals: 1.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorB) equals: 0.
	self assert: (rondaDeTruco ganador) equals: jugadorA .! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 19:09:05' prior: 50912147!
test05
	| rondaDeTruco cartasJugadorA cartasJugadorB |
	
	cartasJugadorA _ OrderedCollection new.
	cartasJugadorA add: (CartaDeTruco oroCon: 2).
	cartasJugadorA add: CartaDeTruco anchoDeEspada.
	cartasJugadorA add: (CartaDeTruco copaCon: 3).
	cartasJugadorB _ OrderedCollection new.
	cartasJugadorB add: (CartaDeTruco oroCon: 2).
	cartasJugadorB add: CartaDeTruco anchoDeBasto.
	cartasJugadorB add: (CartaDeTruco copaCon: 4).
	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		vs: jugadorB
		con: cartasJugadorB.
	
	rondaDeTruco enfrentamientoCon: cartasJugadorA first vs: cartasJugadorB first .
	rondaDeTruco enfrentamientoCon: cartasJugadorA second vs: cartasJugadorB second .
	
	self assert: (rondaDeTruco rondasJugadas) equals: 2.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorA) equals: 1.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorB) equals: 0.
	self assert: (rondaDeTruco ganador) equals: jugadorA .! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 19:09:05' prior: 50911454!
test01
	| rondaDeTruco cartasJugadorA cartasJugadorB |
	
	cartasJugadorA _ OrderedCollection new.
	cartasJugadorA add: CartaDeTruco anchoDeEspada.
	cartasJugadorA add: (CartaDeTruco oroCon: 2).
	cartasJugadorA add: (CartaDeTruco copaCon: 3).
	cartasJugadorB _ OrderedCollection new.
	cartasJugadorB add: CartaDeTruco anchoDeBasto.
	cartasJugadorB add: (CartaDeTruco oroCon: 3).
	cartasJugadorB add: (CartaDeTruco copaCon: 4).
	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		vs: jugadorB
		con: cartasJugadorB.
	
	
		
	self assert: rondaDeTruco rondasJugadas equals: 0! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 19:09:05' prior: 50912378!
test06
	| rondaDeTruco cartasJugadorA cartasJugadorB |
	
	cartasJugadorA _ OrderedCollection new.
	cartasJugadorA add: (CartaDeTruco oroCon: 4).
	cartasJugadorA add: CartaDeTruco anchoDeEspada.
	cartasJugadorA add: (CartaDeTruco copaCon: 3).
	cartasJugadorB _ OrderedCollection new.
	cartasJugadorB add: (CartaDeTruco oroCon: 2).
	cartasJugadorB add: CartaDeTruco anchoDeBasto.
	cartasJugadorB add: (CartaDeTruco copaCon: 4).
	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		vs: jugadorB
		con: cartasJugadorB.
	
	rondaDeTruco enfrentamientoCon: cartasJugadorA first vs: cartasJugadorB first .
	rondaDeTruco enfrentamientoCon: cartasJugadorA second vs: cartasJugadorB second .
	rondaDeTruco enfrentamientoCon: cartasJugadorA third vs: cartasJugadorB third .
	
	self assert: (rondaDeTruco rondasJugadas) equals: 3.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorA) equals: 2.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorB) equals: 1.
	self assert: (rondaDeTruco ganador) equals: jugadorA .! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 19:09:05' prior: 50911702!
test03
	| rondaDeTruco cartasJugadorA cartasJugadorB |
	
	cartasJugadorA _ OrderedCollection new.
	cartasJugadorA add: (CartaDeTruco oroCon: 2).
	cartasJugadorA add: CartaDeTruco anchoDeEspada.
	cartasJugadorA add: (CartaDeTruco copaCon: 3).
	cartasJugadorB _ OrderedCollection new.
	cartasJugadorB add: (CartaDeTruco oroCon: 2).
	cartasJugadorB add: CartaDeTruco anchoDeBasto.
	cartasJugadorB add: (CartaDeTruco copaCon: 4).
	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		vs: jugadorB
		con: cartasJugadorB.
	
	rondaDeTruco enfrentamientoCon: cartasJugadorA first vs: cartasJugadorB first .
		
	self assert: (rondaDeTruco rondasJugadas) equals: 1.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorA) equals: 0.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorB) equals: 0.! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 19:09:05' prior: 50911936!
test04
	| rondaDeTruco cartasJugadorA cartasJugadorB |
	
	cartasJugadorA _ OrderedCollection new.
	cartasJugadorA add: (CartaDeTruco oroCon: 2).
	cartasJugadorA add: CartaDeTruco anchoDeEspada.
	cartasJugadorA add: (CartaDeTruco copaCon: 3).
	cartasJugadorB _ OrderedCollection new.
	cartasJugadorB add: (CartaDeTruco oroCon: 2).
	cartasJugadorB add: CartaDeTruco anchoDeBasto.
	cartasJugadorB add: (CartaDeTruco copaCon: 4).
	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		vs: jugadorB
		con: cartasJugadorB.
	
	rondaDeTruco enfrentamientoCon: cartasJugadorA first vs: cartasJugadorB first .
	rondaDeTruco enfrentamientoCon: cartasJugadorA second vs: cartasJugadorB second .
	
	self assert: (rondaDeTruco rondasJugadas) equals: 2.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorA) equals: 1.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorB) equals: 0.
	self assert: (rondaDeTruco ganador) equals: jugadorA .! !

!methodRemoval: RondaDeTruco class #entreJugador:con:vs:con: stamp: 'pc 7/5/2021 19:09:05'!
entreJugador: unJugador con: cartasDeA vs: otroJugador con: cartasDeB 
	
	^self new initializeEntreJugador: unJugador vs: otroJugador !
!RondaDeTruco class methodsFor: 'instance creation' stamp: 'pc 7/5/2021 19:09:13'!
entreJugador: unJugador vs: otroJugador  
	
	^self new initializeEntreJugador: unJugador vs: otroJugador ! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 19:09:13' prior: 50913118!
test06
	| rondaDeTruco cartasJugadorA cartasJugadorB |
	
	cartasJugadorA _ OrderedCollection new.
	cartasJugadorA add: (CartaDeTruco oroCon: 4).
	cartasJugadorA add: CartaDeTruco anchoDeEspada.
	cartasJugadorA add: (CartaDeTruco copaCon: 3).
	cartasJugadorB _ OrderedCollection new.
	cartasJugadorB add: (CartaDeTruco oroCon: 2).
	cartasJugadorB add: CartaDeTruco anchoDeBasto.
	cartasJugadorB add: (CartaDeTruco copaCon: 4).
	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		vs: jugadorB
		.
	
	rondaDeTruco enfrentamientoCon: cartasJugadorA first vs: cartasJugadorB first .
	rondaDeTruco enfrentamientoCon: cartasJugadorA second vs: cartasJugadorB second .
	rondaDeTruco enfrentamientoCon: cartasJugadorA third vs: cartasJugadorB third .
	
	self assert: (rondaDeTruco rondasJugadas) equals: 3.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorA) equals: 2.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorB) equals: 1.
	self assert: (rondaDeTruco ganador) equals: jugadorA .! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 19:09:13' prior: 50913001!
test02
	| rondaDeTruco cartasJugadorA cartasJugadorB |
	
	cartasJugadorA _ OrderedCollection new.
	cartasJugadorA add: CartaDeTruco anchoDeEspada.
	cartasJugadorA add: (CartaDeTruco oroCon: 2).
	cartasJugadorA add: (CartaDeTruco copaCon: 3).
	cartasJugadorB _ OrderedCollection new.
	cartasJugadorB add: CartaDeTruco anchoDeBasto.
	cartasJugadorB add: (CartaDeTruco oroCon: 3).
	cartasJugadorB add: (CartaDeTruco copaCon: 4).
	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		vs: jugadorB
		.
	
	rondaDeTruco enfrentamientoCon: cartasJugadorA first vs: cartasJugadorB first .
		
		
	self assert: (rondaDeTruco rondasJugadas) equals: 1.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorA) equals: 1.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorB) equals: 0.! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 19:09:13' prior: 50913063!
test05
	| rondaDeTruco cartasJugadorA cartasJugadorB |
	
	cartasJugadorA _ OrderedCollection new.
	cartasJugadorA add: (CartaDeTruco oroCon: 2).
	cartasJugadorA add: CartaDeTruco anchoDeEspada.
	cartasJugadorA add: (CartaDeTruco copaCon: 3).
	cartasJugadorB _ OrderedCollection new.
	cartasJugadorB add: (CartaDeTruco oroCon: 2).
	cartasJugadorB add: CartaDeTruco anchoDeBasto.
	cartasJugadorB add: (CartaDeTruco copaCon: 4).
	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		vs: jugadorB
		.
	
	rondaDeTruco enfrentamientoCon: cartasJugadorA first vs: cartasJugadorB first .
	rondaDeTruco enfrentamientoCon: cartasJugadorA second vs: cartasJugadorB second .
	
	self assert: (rondaDeTruco rondasJugadas) equals: 2.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorA) equals: 1.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorB) equals: 0.
	self assert: (rondaDeTruco ganador) equals: jugadorA .! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 19:09:13' prior: 50913030!
test07
	| rondaDeTruco cartasJugadorA cartasJugadorB |
	
	cartasJugadorA _ OrderedCollection new.
	cartasJugadorA add: (CartaDeTruco copaCon: 2).
	cartasJugadorA add: CartaDeTruco anchoDeEspada.
	cartasJugadorA add: (CartaDeTruco copaCon: 3).
	cartasJugadorB _ OrderedCollection new.
	cartasJugadorB add: (CartaDeTruco oroCon: 2).
	cartasJugadorB add: CartaDeTruco anchoDeBasto.
	cartasJugadorB add: (CartaDeTruco copaCon: 4).
	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		vs: jugadorB
		.
	
	rondaDeTruco enfrentamientoCon: cartasJugadorA first vs: cartasJugadorB first .
	rondaDeTruco enfrentamientoCon: cartasJugadorA second vs: cartasJugadorB second .
	
	self assert: (rondaDeTruco rondasJugadas) equals: 2.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorA) equals: 1.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorB) equals: 0.
	self assert: (rondaDeTruco ganador) equals: jugadorA .! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 19:09:13' prior: 50913154!
test03
	| rondaDeTruco cartasJugadorA cartasJugadorB |
	
	cartasJugadorA _ OrderedCollection new.
	cartasJugadorA add: (CartaDeTruco oroCon: 2).
	cartasJugadorA add: CartaDeTruco anchoDeEspada.
	cartasJugadorA add: (CartaDeTruco copaCon: 3).
	cartasJugadorB _ OrderedCollection new.
	cartasJugadorB add: (CartaDeTruco oroCon: 2).
	cartasJugadorB add: CartaDeTruco anchoDeBasto.
	cartasJugadorB add: (CartaDeTruco copaCon: 4).
	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		vs: jugadorB
		.
	
	rondaDeTruco enfrentamientoCon: cartasJugadorA first vs: cartasJugadorB first .
		
	self assert: (rondaDeTruco rondasJugadas) equals: 1.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorA) equals: 0.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorB) equals: 0.! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 19:09:13' prior: 50913183!
test04
	| rondaDeTruco cartasJugadorA cartasJugadorB |
	
	cartasJugadorA _ OrderedCollection new.
	cartasJugadorA add: (CartaDeTruco oroCon: 2).
	cartasJugadorA add: CartaDeTruco anchoDeEspada.
	cartasJugadorA add: (CartaDeTruco copaCon: 3).
	cartasJugadorB _ OrderedCollection new.
	cartasJugadorB add: (CartaDeTruco oroCon: 2).
	cartasJugadorB add: CartaDeTruco anchoDeBasto.
	cartasJugadorB add: (CartaDeTruco copaCon: 4).
	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		vs: jugadorB
		.
	
	rondaDeTruco enfrentamientoCon: cartasJugadorA first vs: cartasJugadorB first .
	rondaDeTruco enfrentamientoCon: cartasJugadorA second vs: cartasJugadorB second .
	
	self assert: (rondaDeTruco rondasJugadas) equals: 2.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorA) equals: 1.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorB) equals: 0.
	self assert: (rondaDeTruco ganador) equals: jugadorA .! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 19:09:13' prior: 50913096!
test01
	| rondaDeTruco cartasJugadorA cartasJugadorB |
	
	cartasJugadorA _ OrderedCollection new.
	cartasJugadorA add: CartaDeTruco anchoDeEspada.
	cartasJugadorA add: (CartaDeTruco oroCon: 2).
	cartasJugadorA add: (CartaDeTruco copaCon: 3).
	cartasJugadorB _ OrderedCollection new.
	cartasJugadorB add: CartaDeTruco anchoDeBasto.
	cartasJugadorB add: (CartaDeTruco oroCon: 3).
	cartasJugadorB add: (CartaDeTruco copaCon: 4).
	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		vs: jugadorB
		.
	
	
		
	self assert: rondaDeTruco rondasJugadas equals: 0! !

!methodRemoval: RondaDeTruco class #entreJugador:vs:con: stamp: 'pc 7/5/2021 19:09:13'!
entreJugador: unJugador vs: otroJugador con: cartasDeB 
	
	^self new initializeEntreJugador: unJugador vs: otroJugador !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 19:09:26' prior: 50913420!
test01
	| rondaDeTruco cartasJugadorA cartasJugadorB |
	
	cartasJugadorA _ OrderedCollection new.
	cartasJugadorA add: CartaDeTruco anchoDeEspada.
	cartasJugadorA add: (CartaDeTruco oroCon: 2).
	cartasJugadorA add: (CartaDeTruco copaCon: 3).
	cartasJugadorB _ OrderedCollection new.
	cartasJugadorB add: CartaDeTruco anchoDeBasto.
	cartasJugadorB add: (CartaDeTruco oroCon: 3).
	cartasJugadorB add: (CartaDeTruco copaCon: 4).
	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		vs: jugadorB
		.
	
	self assert: rondaDeTruco rondasJugadas equals: 0! !

!testRun: #RondaDeTrucoTest #test01 stamp: 'pc 7/5/2021 19:09:28'!
PASSED!

!testRun: #CartaDeTrucoTest #test01SonIgualesConMismoPaloYNumero stamp: 'pc 7/5/2021 19:09:28'!
PASSED!

!testRun: #CartaDeTrucoTest #test02SonDistintasConDistintoPalo stamp: 'pc 7/5/2021 19:09:28'!
PASSED!

!testRun: #CartaDeTrucoTest #test03SonDistintasConNumeroAunqueIgualPalo stamp: 'pc 7/5/2021 19:09:28'!
PASSED!

!testRun: #CartaDeTrucoTest #test04CartasIgualesTienenElMismoHash stamp: 'pc 7/5/2021 19:09:28'!
PASSED!

!testRun: #CartaDeTrucoTest #test05UnaCartaEsDistintaACualquierObjetoQueNoSeaCarta stamp: 'pc 7/5/2021 19:09:28'!
PASSED!

!testRun: #CartaDeTrucoTest #test07NoHayCartaDeTrucoConNumeroOcho stamp: 'pc 7/5/2021 19:09:28'!
PASSED!

!testRun: #CartaDeTrucoTest #test08NoHayCartaDeTrucoConNumeroNueve stamp: 'pc 7/5/2021 19:09:28'!
PASSED!

!testRun: #CartaDeTrucoTest #test09LosPalosDeLaCartaDeTrucoSonBastoOroEspadaYCopa stamp: 'pc 7/5/2021 19:09:28'!
PASSED!

!testRun: #CartaDeTrucoTest #test10NoSePuedeCrearCartaConNumeroMenorAUno stamp: 'pc 7/5/2021 19:09:28'!
PASSED!

!testRun: #CartaDeTrucoTest #test11NoSePuedeCrearCartaConNumeroMayorADoce stamp: 'pc 7/5/2021 19:09:28'!
PASSED!

!testRun: #CartaDeTrucoTest #test12ElNumeroDeLaCartaDebeSerEntero stamp: 'pc 7/5/2021 19:09:28'!
PASSED!

!testRun: #CartaDeTrucoTest #test13LaTablaDeValoresEsCorrecta stamp: 'pc 7/5/2021 19:09:28'!
PASSED!

!testRun: #CartaDeTrucoTest #test14HayCartasQueNoSonPardas stamp: 'pc 7/5/2021 19:09:28'!
PASSED!

!testRun: #CartaDeTrucoTest #test15HayCartasQuePierdenConOtras stamp: 'pc 7/5/2021 19:09:28'!
PASSED!

!testRun: #CartaDeTrucoTest #test16SieteDeCopasYDeBastoEsSieteFalso stamp: 'pc 7/5/2021 19:09:28'!
PASSED!

!testRun: #CartaDeTrucoTest #test17SieteDeOroYDeEspadaNoSonSieteFalso stamp: 'pc 7/5/2021 19:09:28'!
PASSED!

!testRun: #CartaDeTrucoTest #test18AnchoDeOroYDeCopaSonAnchoFalsos stamp: 'pc 7/5/2021 19:09:28'!
PASSED!

!testRun: #CartaDeTrucoTest #test19AnchoDeEspadaYDeBastosNoSonAnchoFalsos stamp: 'pc 7/5/2021 19:09:28'!
PASSED!

!testRun: #CartaDeTrucoTest #test20FallaBuscandoValorDeCartaInv�lida stamp: 'pc 7/5/2021 19:09:28'!
PASSED!

!testRun: #RondaDeTrucoTest #test01 stamp: 'pc 7/5/2021 19:09:28'!
PASSED!

!testRun: #RondaDeTrucoTest #test02 stamp: 'pc 7/5/2021 19:09:28'!
PASSED!

!testRun: #RondaDeTrucoTest #test03 stamp: 'pc 7/5/2021 19:09:28'!
PASSED!

!testRun: #RondaDeTrucoTest #test04 stamp: 'pc 7/5/2021 19:09:28'!
PASSED!

!testRun: #RondaDeTrucoTest #test05 stamp: 'pc 7/5/2021 19:09:28'!
PASSED!

!testRun: #RondaDeTrucoTest #test06 stamp: 'pc 7/5/2021 19:09:28'!
PASSED!

!testRun: #RondaDeTrucoTest #test07 stamp: 'pc 7/5/2021 19:09:28'!
PASSED!

!testRun: #RondaDeTrucoTest #test08 stamp: 'pc 7/5/2021 19:09:28'!
FAILURE!

!testRun: #RondaDeTrucoTest #test08 stamp: 'pc 7/5/2021 19:09:28'!
FAILURE!

!testRun: #RondaDeTrucoTest #test08 stamp: 'pc 7/5/2021 19:09:48'!
FAILURE!

!testRun: #RondaDeTrucoTest #test08 stamp: 'pc 7/5/2021 19:09:48'!
FAILURE!

!classDefinition: #RondaDeTruco category: 'ISW1-2021-1C-2doParcial' stamp: 'pc 7/5/2021 19:10:58'!
Object subclass: #RondaDeTruco
	instanceVariableNames: 'jugadorA cartasDeA jugadorB cartasDeB ronda jugadores primerRondaParda cartasUsadas'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial'!
!RondaDeTruco methodsFor: 'initialization' stamp: 'pc 7/5/2021 19:10:56' prior: 50912965!
initializeEntreJugador: unJugador vs: otroJugador 
	
	primerRondaParda := false.
	ronda := 0.
	jugadorA := unJugador .
	jugadorB := otroJugador .
	jugadores := Bag new.
	cartasUsadas := OrderedCollection new.
	cartasDeA := OrderedCollection new.
	cartasDeB := OrderedCollection new.! !
!RondaDeTruco methodsFor: 'initialization' stamp: 'pc 7/5/2021 19:11:01' prior: 50913572!
initializeEntreJugador: unJugador vs: otroJugador 
	
	primerRondaParda := false.
	ronda := 0.
	jugadorA := unJugador .
	jugadorB := otroJugador .
	jugadores := Bag new.
	cartasUsadas := OrderedCollection new.! !
!RondaDeTruco methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 19:12:51' prior: 50912712!
enfrentamientoCon: cartaDeTrucoA vs: cartaDeTrucoB
	
	((cartasUsadas includes: cartaDeTrucoA) or: (cartasUsadas includes: cartaDeTrucoB )) ifTrue: [^self error: self class cartaRepetidaError].
	
	ronda := ronda + 1.
	(cartaDeTrucoA mataA: cartaDeTrucoB) ifTrue: [jugadores add: jugadorA ]. 
	(cartaDeTrucoB mataA: cartaDeTrucoA) ifTrue: [jugadores add: jugadorB].
	(cartaDeTrucoB empardaCon: cartaDeTrucoA) ifTrue: [primerRondaParda := true].
! !

!testRun: #RondaDeTrucoTest #test08 stamp: 'pc 7/5/2021 19:12:55'!
PASSED!

!testRun: #CartaDeTrucoTest #test01SonIgualesConMismoPaloYNumero stamp: 'pc 7/5/2021 19:12:58'!
PASSED!

!testRun: #CartaDeTrucoTest #test02SonDistintasConDistintoPalo stamp: 'pc 7/5/2021 19:12:58'!
PASSED!

!testRun: #CartaDeTrucoTest #test03SonDistintasConNumeroAunqueIgualPalo stamp: 'pc 7/5/2021 19:12:58'!
PASSED!

!testRun: #CartaDeTrucoTest #test04CartasIgualesTienenElMismoHash stamp: 'pc 7/5/2021 19:12:58'!
PASSED!

!testRun: #CartaDeTrucoTest #test05UnaCartaEsDistintaACualquierObjetoQueNoSeaCarta stamp: 'pc 7/5/2021 19:12:58'!
PASSED!

!testRun: #CartaDeTrucoTest #test07NoHayCartaDeTrucoConNumeroOcho stamp: 'pc 7/5/2021 19:12:58'!
PASSED!

!testRun: #CartaDeTrucoTest #test08NoHayCartaDeTrucoConNumeroNueve stamp: 'pc 7/5/2021 19:12:58'!
PASSED!

!testRun: #CartaDeTrucoTest #test09LosPalosDeLaCartaDeTrucoSonBastoOroEspadaYCopa stamp: 'pc 7/5/2021 19:12:58'!
PASSED!

!testRun: #CartaDeTrucoTest #test10NoSePuedeCrearCartaConNumeroMenorAUno stamp: 'pc 7/5/2021 19:12:58'!
PASSED!

!testRun: #CartaDeTrucoTest #test11NoSePuedeCrearCartaConNumeroMayorADoce stamp: 'pc 7/5/2021 19:12:58'!
PASSED!

!testRun: #CartaDeTrucoTest #test12ElNumeroDeLaCartaDebeSerEntero stamp: 'pc 7/5/2021 19:12:58'!
PASSED!

!testRun: #CartaDeTrucoTest #test13LaTablaDeValoresEsCorrecta stamp: 'pc 7/5/2021 19:12:58'!
PASSED!

!testRun: #CartaDeTrucoTest #test14HayCartasQueNoSonPardas stamp: 'pc 7/5/2021 19:12:58'!
PASSED!

!testRun: #CartaDeTrucoTest #test15HayCartasQuePierdenConOtras stamp: 'pc 7/5/2021 19:12:58'!
PASSED!

!testRun: #CartaDeTrucoTest #test16SieteDeCopasYDeBastoEsSieteFalso stamp: 'pc 7/5/2021 19:12:58'!
PASSED!

!testRun: #CartaDeTrucoTest #test17SieteDeOroYDeEspadaNoSonSieteFalso stamp: 'pc 7/5/2021 19:12:58'!
PASSED!

!testRun: #CartaDeTrucoTest #test18AnchoDeOroYDeCopaSonAnchoFalsos stamp: 'pc 7/5/2021 19:12:58'!
PASSED!

!testRun: #CartaDeTrucoTest #test19AnchoDeEspadaYDeBastosNoSonAnchoFalsos stamp: 'pc 7/5/2021 19:12:58'!
PASSED!

!testRun: #CartaDeTrucoTest #test20FallaBuscandoValorDeCartaInv�lida stamp: 'pc 7/5/2021 19:12:58'!
PASSED!

!testRun: #RondaDeTrucoTest #test01 stamp: 'pc 7/5/2021 19:12:58'!
PASSED!

!testRun: #RondaDeTrucoTest #test02 stamp: 'pc 7/5/2021 19:12:58'!
PASSED!

!testRun: #RondaDeTrucoTest #test03 stamp: 'pc 7/5/2021 19:12:58'!
PASSED!

!testRun: #RondaDeTrucoTest #test04 stamp: 'pc 7/5/2021 19:12:58'!
PASSED!

!testRun: #RondaDeTrucoTest #test05 stamp: 'pc 7/5/2021 19:12:58'!
PASSED!

!testRun: #RondaDeTrucoTest #test06 stamp: 'pc 7/5/2021 19:12:58'!
PASSED!

!testRun: #RondaDeTrucoTest #test07 stamp: 'pc 7/5/2021 19:12:58'!
PASSED!

!testRun: #RondaDeTrucoTest #test08 stamp: 'pc 7/5/2021 19:12:58'!
FAILURE!

!testRun: #RondaDeTrucoTest #test08 stamp: 'pc 7/5/2021 19:12:58'!
FAILURE!

!testRun: #RondaDeTrucoTest #test08 stamp: 'pc 7/5/2021 19:13:09'!
FAILURE!
!RondaDeTruco methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 19:13:44' prior: 50913594!
enfrentamientoCon: cartaDeTrucoA vs: cartaDeTrucoB
	
	((cartasUsadas includes: cartaDeTrucoA) or: [cartasUsadas includes: cartaDeTrucoB ]) ifTrue: [^self error: self class cartaRepetidaError].
	
	ronda := ronda + 1.
	(cartaDeTrucoA mataA: cartaDeTrucoB) ifTrue: [jugadores add: jugadorA ]. 
	(cartaDeTrucoB mataA: cartaDeTrucoA) ifTrue: [jugadores add: jugadorB].
	(cartaDeTrucoB empardaCon: cartaDeTrucoA) ifTrue: [primerRondaParda := true].
! !
!RondaDeTruco methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 19:14:43' prior: 50913702!
enfrentamientoCon: cartaDeTrucoA vs: cartaDeTrucoB
	
	((cartasUsadas includes: cartaDeTrucoA) or: [(cartasUsadas includes: cartaDeTrucoB) or: [cartaDeTrucoA = cartaDeTrucoB ]]) ifTrue: [^self error: self class cartaRepetidaError].
	
	ronda := ronda + 1.
	(cartaDeTrucoA mataA: cartaDeTrucoB) ifTrue: [jugadores add: jugadorA ]. 
	(cartaDeTrucoB mataA: cartaDeTrucoA) ifTrue: [jugadores add: jugadorB].
	(cartaDeTrucoB empardaCon: cartaDeTrucoA) ifTrue: [primerRondaParda := true].
! !

!testRun: #RondaDeTrucoTest #test08 stamp: 'pc 7/5/2021 19:14:45'!
ERROR!
!RondaDeTruco class methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 19:14:54'!
cartaRepetidaError
	self shouldBeImplemented.! !
!RondaDeTruco class methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 19:15:14' prior: 50913740!
cartaRepetidaError
	^'la carta quese quiere usar ya fue usada'! !

!testRun: #RondaDeTrucoTest #test08 stamp: 'pc 7/5/2021 19:15:15'!
PASSED!

!testRun: #CartaDeTrucoTest #test01SonIgualesConMismoPaloYNumero stamp: 'pc 7/5/2021 19:15:19'!
PASSED!

!testRun: #CartaDeTrucoTest #test02SonDistintasConDistintoPalo stamp: 'pc 7/5/2021 19:15:19'!
PASSED!

!testRun: #CartaDeTrucoTest #test03SonDistintasConNumeroAunqueIgualPalo stamp: 'pc 7/5/2021 19:15:19'!
PASSED!

!testRun: #CartaDeTrucoTest #test04CartasIgualesTienenElMismoHash stamp: 'pc 7/5/2021 19:15:19'!
PASSED!

!testRun: #CartaDeTrucoTest #test05UnaCartaEsDistintaACualquierObjetoQueNoSeaCarta stamp: 'pc 7/5/2021 19:15:19'!
PASSED!

!testRun: #CartaDeTrucoTest #test07NoHayCartaDeTrucoConNumeroOcho stamp: 'pc 7/5/2021 19:15:19'!
PASSED!

!testRun: #CartaDeTrucoTest #test08NoHayCartaDeTrucoConNumeroNueve stamp: 'pc 7/5/2021 19:15:19'!
PASSED!

!testRun: #CartaDeTrucoTest #test09LosPalosDeLaCartaDeTrucoSonBastoOroEspadaYCopa stamp: 'pc 7/5/2021 19:15:19'!
PASSED!

!testRun: #CartaDeTrucoTest #test10NoSePuedeCrearCartaConNumeroMenorAUno stamp: 'pc 7/5/2021 19:15:19'!
PASSED!

!testRun: #CartaDeTrucoTest #test11NoSePuedeCrearCartaConNumeroMayorADoce stamp: 'pc 7/5/2021 19:15:19'!
PASSED!

!testRun: #CartaDeTrucoTest #test12ElNumeroDeLaCartaDebeSerEntero stamp: 'pc 7/5/2021 19:15:19'!
PASSED!

!testRun: #CartaDeTrucoTest #test13LaTablaDeValoresEsCorrecta stamp: 'pc 7/5/2021 19:15:19'!
PASSED!

!testRun: #CartaDeTrucoTest #test14HayCartasQueNoSonPardas stamp: 'pc 7/5/2021 19:15:19'!
PASSED!

!testRun: #CartaDeTrucoTest #test15HayCartasQuePierdenConOtras stamp: 'pc 7/5/2021 19:15:19'!
PASSED!

!testRun: #CartaDeTrucoTest #test16SieteDeCopasYDeBastoEsSieteFalso stamp: 'pc 7/5/2021 19:15:19'!
PASSED!

!testRun: #CartaDeTrucoTest #test17SieteDeOroYDeEspadaNoSonSieteFalso stamp: 'pc 7/5/2021 19:15:19'!
PASSED!

!testRun: #CartaDeTrucoTest #test18AnchoDeOroYDeCopaSonAnchoFalsos stamp: 'pc 7/5/2021 19:15:19'!
PASSED!

!testRun: #CartaDeTrucoTest #test19AnchoDeEspadaYDeBastosNoSonAnchoFalsos stamp: 'pc 7/5/2021 19:15:19'!
PASSED!

!testRun: #CartaDeTrucoTest #test20FallaBuscandoValorDeCartaInv�lida stamp: 'pc 7/5/2021 19:15:19'!
PASSED!

!testRun: #RondaDeTrucoTest #test01 stamp: 'pc 7/5/2021 19:15:19'!
PASSED!

!testRun: #RondaDeTrucoTest #test02 stamp: 'pc 7/5/2021 19:15:19'!
PASSED!

!testRun: #RondaDeTrucoTest #test03 stamp: 'pc 7/5/2021 19:15:19'!
ERROR!

!testRun: #RondaDeTrucoTest #test04 stamp: 'pc 7/5/2021 19:15:19'!
ERROR!

!testRun: #RondaDeTrucoTest #test05 stamp: 'pc 7/5/2021 19:15:19'!
ERROR!

!testRun: #RondaDeTrucoTest #test06 stamp: 'pc 7/5/2021 19:15:19'!
PASSED!

!testRun: #RondaDeTrucoTest #test07 stamp: 'pc 7/5/2021 19:15:19'!
PASSED!

!testRun: #RondaDeTrucoTest #test08 stamp: 'pc 7/5/2021 19:15:19'!
PASSED!

!testRun: #RondaDeTrucoTest #test03 stamp: 'pc 7/5/2021 19:15:22'!
ERROR!

!testRun: #RondaDeTrucoTest #test03 stamp: 'pc 7/5/2021 19:15:28'!
ERROR!
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 19:15:52' prior: 50913359!
test03
	| rondaDeTruco cartasJugadorA cartasJugadorB |
	
	cartasJugadorA _ OrderedCollection new.
	cartasJugadorA add: (CartaDeTruco bastoCon: 2).
	cartasJugadorA add: CartaDeTruco anchoDeEspada.
	cartasJugadorA add: (CartaDeTruco copaCon: 3).
	cartasJugadorB _ OrderedCollection new.
	cartasJugadorB add: (CartaDeTruco oroCon: 2).
	cartasJugadorB add: CartaDeTruco anchoDeBasto.
	cartasJugadorB add: (CartaDeTruco copaCon: 4).
	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		vs: jugadorB
		.
	
	rondaDeTruco enfrentamientoCon: cartasJugadorA first vs: cartasJugadorB first .
		
	self assert: (rondaDeTruco rondasJugadas) equals: 1.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorA) equals: 0.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorB) equals: 0.! !

!testRun: #RondaDeTrucoTest #test03 stamp: 'pc 7/5/2021 19:15:53'!
PASSED!
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 19:16:02' prior: 50913387!
test04
	| rondaDeTruco cartasJugadorA cartasJugadorB |
	
	cartasJugadorA _ OrderedCollection new.
	cartasJugadorA add: (CartaDeTruco oroCon: 2).
	cartasJugadorA add: CartaDeTruco anchoDeEspada.
	cartasJugadorA add: (CartaDeTruco copaCon: 3).
	cartasJugadorB _ OrderedCollection new.
	cartasJugadorB add: (CartaDeTruco bastoCon: 2).
	cartasJugadorB add: CartaDeTruco anchoDeBasto.
	cartasJugadorB add: (CartaDeTruco copaCon: 4).
	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		vs: jugadorB
		.
	
	rondaDeTruco enfrentamientoCon: cartasJugadorA first vs: cartasJugadorB first .
	rondaDeTruco enfrentamientoCon: cartasJugadorA second vs: cartasJugadorB second .
	
	self assert: (rondaDeTruco rondasJugadas) equals: 2.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorA) equals: 1.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorB) equals: 0.
	self assert: (rondaDeTruco ganador) equals: jugadorA .! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 19:16:09' prior: 50913293!
test05
	| rondaDeTruco cartasJugadorA cartasJugadorB |
	
	cartasJugadorA _ OrderedCollection new.
	cartasJugadorA add: (CartaDeTruco bastoCon: 2).
	cartasJugadorA add: CartaDeTruco anchoDeEspada.
	cartasJugadorA add: (CartaDeTruco copaCon: 3).
	cartasJugadorB _ OrderedCollection new.
	cartasJugadorB add: (CartaDeTruco oroCon: 2).
	cartasJugadorB add: CartaDeTruco anchoDeBasto.
	cartasJugadorB add: (CartaDeTruco copaCon: 4).
	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		vs: jugadorB
		.
	
	rondaDeTruco enfrentamientoCon: cartasJugadorA first vs: cartasJugadorB first .
	rondaDeTruco enfrentamientoCon: cartasJugadorA second vs: cartasJugadorB second .
	
	self assert: (rondaDeTruco rondasJugadas) equals: 2.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorA) equals: 1.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorB) equals: 0.
	self assert: (rondaDeTruco ganador) equals: jugadorA .! !

!testRun: #CartaDeTrucoTest #test01SonIgualesConMismoPaloYNumero stamp: 'pc 7/5/2021 19:16:11'!
PASSED!

!testRun: #CartaDeTrucoTest #test02SonDistintasConDistintoPalo stamp: 'pc 7/5/2021 19:16:11'!
PASSED!

!testRun: #CartaDeTrucoTest #test03SonDistintasConNumeroAunqueIgualPalo stamp: 'pc 7/5/2021 19:16:11'!
PASSED!

!testRun: #CartaDeTrucoTest #test04CartasIgualesTienenElMismoHash stamp: 'pc 7/5/2021 19:16:11'!
PASSED!

!testRun: #CartaDeTrucoTest #test05UnaCartaEsDistintaACualquierObjetoQueNoSeaCarta stamp: 'pc 7/5/2021 19:16:11'!
PASSED!

!testRun: #CartaDeTrucoTest #test07NoHayCartaDeTrucoConNumeroOcho stamp: 'pc 7/5/2021 19:16:11'!
PASSED!

!testRun: #CartaDeTrucoTest #test08NoHayCartaDeTrucoConNumeroNueve stamp: 'pc 7/5/2021 19:16:11'!
PASSED!

!testRun: #CartaDeTrucoTest #test09LosPalosDeLaCartaDeTrucoSonBastoOroEspadaYCopa stamp: 'pc 7/5/2021 19:16:11'!
PASSED!

!testRun: #CartaDeTrucoTest #test10NoSePuedeCrearCartaConNumeroMenorAUno stamp: 'pc 7/5/2021 19:16:11'!
PASSED!

!testRun: #CartaDeTrucoTest #test11NoSePuedeCrearCartaConNumeroMayorADoce stamp: 'pc 7/5/2021 19:16:11'!
PASSED!

!testRun: #CartaDeTrucoTest #test12ElNumeroDeLaCartaDebeSerEntero stamp: 'pc 7/5/2021 19:16:11'!
PASSED!

!testRun: #CartaDeTrucoTest #test13LaTablaDeValoresEsCorrecta stamp: 'pc 7/5/2021 19:16:11'!
PASSED!

!testRun: #CartaDeTrucoTest #test14HayCartasQueNoSonPardas stamp: 'pc 7/5/2021 19:16:11'!
PASSED!

!testRun: #CartaDeTrucoTest #test15HayCartasQuePierdenConOtras stamp: 'pc 7/5/2021 19:16:11'!
PASSED!

!testRun: #CartaDeTrucoTest #test16SieteDeCopasYDeBastoEsSieteFalso stamp: 'pc 7/5/2021 19:16:11'!
PASSED!

!testRun: #CartaDeTrucoTest #test17SieteDeOroYDeEspadaNoSonSieteFalso stamp: 'pc 7/5/2021 19:16:11'!
PASSED!

!testRun: #CartaDeTrucoTest #test18AnchoDeOroYDeCopaSonAnchoFalsos stamp: 'pc 7/5/2021 19:16:11'!
PASSED!

!testRun: #CartaDeTrucoTest #test19AnchoDeEspadaYDeBastosNoSonAnchoFalsos stamp: 'pc 7/5/2021 19:16:11'!
PASSED!

!testRun: #CartaDeTrucoTest #test20FallaBuscandoValorDeCartaInv�lida stamp: 'pc 7/5/2021 19:16:11'!
PASSED!

!testRun: #RondaDeTrucoTest #test01 stamp: 'pc 7/5/2021 19:16:11'!
PASSED!

!testRun: #RondaDeTrucoTest #test02 stamp: 'pc 7/5/2021 19:16:11'!
PASSED!

!testRun: #RondaDeTrucoTest #test06 stamp: 'pc 7/5/2021 19:16:11'!
PASSED!

!testRun: #RondaDeTrucoTest #test07 stamp: 'pc 7/5/2021 19:16:11'!
PASSED!

!testRun: #RondaDeTrucoTest #test08 stamp: 'pc 7/5/2021 19:16:11'!
PASSED!

!testRun: #RondaDeTrucoTest #test03 stamp: 'pc 7/5/2021 19:16:11'!
PASSED!

!testRun: #RondaDeTrucoTest #test04 stamp: 'pc 7/5/2021 19:16:11'!
PASSED!

!testRun: #RondaDeTrucoTest #test05 stamp: 'pc 7/5/2021 19:16:11'!
PASSED!
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 19:16:41'!
test09
	| rondaDeTruco |

	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		vs: jugadorB.
	
	self 
		should: [rondaDeTruco enfrentamientoCon: CartaDeTruco anchoDeEspada vs: CartaDeTruco anchoDeBasto .]
		raise: Error -MessageNotUnderstood 
		withExceptionDo: [:anError|
			self assert: RondaDeTruco cartaRepetidaError equals: anError messageText .
			self assert: (rondaDeTruco rondasJugadas) equals: 0.
			].
	! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 19:17:28' prior: 50912895!
test08
	| rondaDeTruco |

	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		vs: jugadorB.
	
	rondaDeTruco enfrentamientoCon: (CartaDeTruco espadaCon: 3) vs: (CartaDeTruco espadaCon:1 ).
	
	self 
		should: [rondaDeTruco enfrentamientoCon: CartaDeTruco anchoDeBasto vs: CartaDeTruco anchoDeBasto .]
		raise: Error -MessageNotUnderstood 
		withExceptionDo: [:anError|
			self assert: RondaDeTruco cartaRepetidaError equals: anError messageText .
			self assert: (rondaDeTruco rondasJugadas) equals: 0.
			].
	! !

!testRun: #RondaDeTrucoTest #test08 stamp: 'pc 7/5/2021 19:17:30'!
FAILURE!
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 19:17:36' prior: 50914038!
test08
	| rondaDeTruco |

	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		vs: jugadorB.
	
	rondaDeTruco enfrentamientoCon: (CartaDeTruco espadaCon: 3) vs: (CartaDeTruco espadaCon:1 ).
	
	self 
		should: [rondaDeTruco enfrentamientoCon: CartaDeTruco anchoDeBasto vs: CartaDeTruco anchoDeBasto .]
		raise: Error -MessageNotUnderstood 
		withExceptionDo: [:anError|
			self assert: RondaDeTruco cartaRepetidaError equals: anError messageText .
			self assert: (rondaDeTruco rondasJugadas) equals: 1.
			].
	! !

!testRun: #RondaDeTrucoTest #test08 stamp: 'pc 7/5/2021 19:17:37'!
PASSED!

!testRun: #RondaDeTrucoTest #test01 stamp: 'pc 7/5/2021 19:17:37'!
PASSED!

!testRun: #RondaDeTrucoTest #test02 stamp: 'pc 7/5/2021 19:17:37'!
PASSED!

!testRun: #RondaDeTrucoTest #test03 stamp: 'pc 7/5/2021 19:17:37'!
PASSED!

!testRun: #RondaDeTrucoTest #test04 stamp: 'pc 7/5/2021 19:17:37'!
PASSED!

!testRun: #RondaDeTrucoTest #test05 stamp: 'pc 7/5/2021 19:17:37'!
PASSED!

!testRun: #RondaDeTrucoTest #test06 stamp: 'pc 7/5/2021 19:17:37'!
PASSED!

!testRun: #RondaDeTrucoTest #test07 stamp: 'pc 7/5/2021 19:17:37'!
PASSED!

!testRun: #RondaDeTrucoTest #test08 stamp: 'pc 7/5/2021 19:17:37'!
PASSED!

!testRun: #RondaDeTrucoTest #test09 stamp: 'pc 7/5/2021 19:17:37'!
FAILURE!

!testRun: #RondaDeTrucoTest #test09 stamp: 'pc 7/5/2021 19:17:37'!
FAILURE!

!testRun: #RondaDeTrucoTest #test08 stamp: 'pc 7/5/2021 19:17:41'!
PASSED!

!testRun: #RondaDeTrucoTest #test01 stamp: 'pc 7/5/2021 19:17:41'!
PASSED!

!testRun: #RondaDeTrucoTest #test02 stamp: 'pc 7/5/2021 19:17:41'!
PASSED!

!testRun: #RondaDeTrucoTest #test03 stamp: 'pc 7/5/2021 19:17:41'!
PASSED!

!testRun: #RondaDeTrucoTest #test04 stamp: 'pc 7/5/2021 19:17:41'!
PASSED!

!testRun: #RondaDeTrucoTest #test05 stamp: 'pc 7/5/2021 19:17:41'!
PASSED!

!testRun: #RondaDeTrucoTest #test06 stamp: 'pc 7/5/2021 19:17:41'!
PASSED!

!testRun: #RondaDeTrucoTest #test07 stamp: 'pc 7/5/2021 19:17:41'!
PASSED!

!testRun: #RondaDeTrucoTest #test08 stamp: 'pc 7/5/2021 19:17:41'!
PASSED!

!testRun: #RondaDeTrucoTest #test09 stamp: 'pc 7/5/2021 19:17:41'!
FAILURE!

!testRun: #RondaDeTrucoTest #test09 stamp: 'pc 7/5/2021 19:17:41'!
FAILURE!
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 19:18:05' prior: 50914060!
test08
	| rondaDeTruco |

	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		vs: jugadorB.

	
	self 
		should: [rondaDeTruco enfrentamientoCon: CartaDeTruco anchoDeBasto vs: CartaDeTruco anchoDeBasto .]
		raise: Error -MessageNotUnderstood 
		withExceptionDo: [:anError|
			self assert: RondaDeTruco cartaRepetidaError equals: anError messageText .
			self assert: (rondaDeTruco rondasJugadas) equals: 1.
			].
	! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 19:18:10' prior: 50914132!
test08
	| rondaDeTruco |

	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		vs: jugadorB.

	
	self 
		should: [rondaDeTruco enfrentamientoCon: CartaDeTruco anchoDeBasto vs: CartaDeTruco anchoDeBasto .]
		raise: Error -MessageNotUnderstood 
		withExceptionDo: [:anError|
			self assert: RondaDeTruco cartaRepetidaError equals: anError messageText .
			self assert: (rondaDeTruco rondasJugadas) equals: 0.
			].
	! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 19:18:18' prior: 50914021!
test09
	| rondaDeTruco |

	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		vs: jugadorB.
	
	rondaDeTruco enfrentamientoCon: (CartaDeTruco espadaCon: 3) vs: (CartaDeTruco espadaCon:1 ).
	
	self 
		should: [rondaDeTruco enfrentamientoCon: CartaDeTruco anchoDeEspada vs: CartaDeTruco anchoDeBasto .]
		raise: Error -MessageNotUnderstood 
		withExceptionDo: [:anError|
			self assert: RondaDeTruco cartaRepetidaError equals: anError messageText .
			self assert: (rondaDeTruco rondasJugadas) equals: 1.
			].
	! !

!testRun: #RondaDeTrucoTest #test09 stamp: 'pc 7/5/2021 19:18:19'!
FAILURE!
!RondaDeTruco methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 19:19:11' prior: 50913719!
enfrentamientoCon: cartaDeTrucoA vs: cartaDeTrucoB
	
	((cartasUsadas includes: cartaDeTrucoA) or: [(cartasUsadas includes: cartaDeTrucoB) or: [cartaDeTrucoA = cartaDeTrucoB ]]) ifTrue: [^self error: self class cartaRepetidaError].
	
	cartasUsadas add: cartaDeTrucoA .
	cartasUsadas add: cartaDeTrucoB .
	
	ronda := ronda + 1.
	(cartaDeTrucoA mataA: cartaDeTrucoB) ifTrue: [jugadores add: jugadorA ]. 
	(cartaDeTrucoB mataA: cartaDeTrucoA) ifTrue: [jugadores add: jugadorB].
	(cartaDeTrucoB empardaCon: cartaDeTrucoA) ifTrue: [primerRondaParda := true].
! !

!testRun: #RondaDeTrucoTest #test09 stamp: 'pc 7/5/2021 19:19:12'!
PASSED!

!testRun: #RondaDeTrucoTest #test01 stamp: 'pc 7/5/2021 19:19:12'!
PASSED!

!testRun: #RondaDeTrucoTest #test02 stamp: 'pc 7/5/2021 19:19:12'!
PASSED!

!testRun: #RondaDeTrucoTest #test03 stamp: 'pc 7/5/2021 19:19:12'!
PASSED!

!testRun: #RondaDeTrucoTest #test04 stamp: 'pc 7/5/2021 19:19:12'!
PASSED!

!testRun: #RondaDeTrucoTest #test05 stamp: 'pc 7/5/2021 19:19:12'!
PASSED!

!testRun: #RondaDeTrucoTest #test06 stamp: 'pc 7/5/2021 19:19:12'!
PASSED!

!testRun: #RondaDeTrucoTest #test07 stamp: 'pc 7/5/2021 19:19:12'!
PASSED!

!testRun: #RondaDeTrucoTest #test08 stamp: 'pc 7/5/2021 19:19:12'!
PASSED!

!testRun: #RondaDeTrucoTest #test09 stamp: 'pc 7/5/2021 19:19:12'!
PASSED!
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 19:20:17'!
test10
	| rondaDeTruco |

	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		vs: jugadorB.
	
	rondaDeTruco enfrentamientoCon: (CartaDeTruco espadaCon: 3) vs: (CartaDeTruco espadaCon:1 ).
	
	self 
		should: [rondaDeTruco ganador]
		raise: Error -MessageNotUnderstood 
		withExceptionDo: [:anError|
			self assert: RondaDeTruco noTerminoLaRondaTodavia equals: anError messageText .
			self assert: (rondaDeTruco rondasJugadas) equals: 0.
			].
	! !

!testRun: #RondaDeTrucoTest #test10 stamp: 'pc 7/5/2021 19:20:20'!
ERROR!
!RondaDeTruco class methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 19:20:26'!
noTerminoLaRondaTodavia
	self shouldBeImplemented.! !
!RondaDeTruco class methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 19:20:44' prior: 50914252!
noTerminoLaRondaTodavia
	
	^'no se puede saber el ganador antes de que termine la ronda'! !

!testRun: #RondaDeTrucoTest #test10 stamp: 'pc 7/5/2021 19:20:45'!
FAILURE!

!testRun: #RondaDeTrucoTest #test10 stamp: 'pc 7/5/2021 19:20:45'!
PASSED!

!testRun: #RondaDeTrucoTest #test01 stamp: 'pc 7/5/2021 19:20:45'!
PASSED!

!testRun: #RondaDeTrucoTest #test02 stamp: 'pc 7/5/2021 19:20:45'!
PASSED!

!testRun: #RondaDeTrucoTest #test03 stamp: 'pc 7/5/2021 19:20:45'!
PASSED!

!testRun: #RondaDeTrucoTest #test04 stamp: 'pc 7/5/2021 19:20:45'!
PASSED!

!testRun: #RondaDeTrucoTest #test05 stamp: 'pc 7/5/2021 19:20:45'!
PASSED!

!testRun: #RondaDeTrucoTest #test06 stamp: 'pc 7/5/2021 19:20:45'!
PASSED!

!testRun: #RondaDeTrucoTest #test07 stamp: 'pc 7/5/2021 19:20:45'!
PASSED!

!testRun: #RondaDeTrucoTest #test08 stamp: 'pc 7/5/2021 19:20:45'!
PASSED!

!testRun: #RondaDeTrucoTest #test09 stamp: 'pc 7/5/2021 19:20:45'!
PASSED!

!testRun: #RondaDeTrucoTest #test10 stamp: 'pc 7/5/2021 19:20:45'!
FAILURE!

!testRun: #RondaDeTrucoTest #test10 stamp: 'pc 7/5/2021 19:20:45'!
FAILURE!

!testRun: #RondaDeTrucoTest #test10 stamp: 'pc 7/5/2021 19:21:08'!
FAILURE!
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 19:21:21' prior: 50914232!
test10
	| rondaDeTruco |

	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		vs: jugadorB.
	
	rondaDeTruco enfrentamientoCon: (CartaDeTruco espadaCon: 3) vs: (CartaDeTruco espadaCon:1 ).
	
	self 
		should: [rondaDeTruco ganador]
		raise: Error -MessageNotUnderstood 
		withExceptionDo: [:anError|
			self assert: RondaDeTruco noTerminoLaRondaTodavia equals: anError messageText .
			self assert: (rondaDeTruco rondasJugadas) equals: 1.
			].
	! !

!testRun: #RondaDeTrucoTest #test10 stamp: 'pc 7/5/2021 19:21:23'!
PASSED!

!testRun: #RondaDeTrucoTest #test01 stamp: 'pc 7/5/2021 19:21:23'!
PASSED!

!testRun: #RondaDeTrucoTest #test02 stamp: 'pc 7/5/2021 19:21:23'!
PASSED!

!testRun: #RondaDeTrucoTest #test03 stamp: 'pc 7/5/2021 19:21:23'!
PASSED!

!testRun: #RondaDeTrucoTest #test04 stamp: 'pc 7/5/2021 19:21:23'!
PASSED!

!testRun: #RondaDeTrucoTest #test05 stamp: 'pc 7/5/2021 19:21:23'!
PASSED!

!testRun: #RondaDeTrucoTest #test06 stamp: 'pc 7/5/2021 19:21:23'!
PASSED!

!testRun: #RondaDeTrucoTest #test07 stamp: 'pc 7/5/2021 19:21:23'!
PASSED!

!testRun: #RondaDeTrucoTest #test08 stamp: 'pc 7/5/2021 19:21:23'!
PASSED!

!testRun: #RondaDeTrucoTest #test09 stamp: 'pc 7/5/2021 19:21:23'!
PASSED!

!testRun: #RondaDeTrucoTest #test10 stamp: 'pc 7/5/2021 19:21:23'!
PASSED!
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 19:21:58' prior: 50913448!
test01
	| rondaDeTruco |

	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		vs: jugadorB
		.
	
	self assert: rondaDeTruco rondasJugadas equals: 0! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 19:22:33' prior: 50913265!
test02
	| rondaDeTruco cartasJugadorA cartasJugadorB |
	
	cartasJugadorA _ OrderedCollection new.
	cartasJugadorA add: CartaDeTruco anchoDeEspada.
	cartasJugadorA add: (CartaDeTruco oroCon: 2).
	cartasJugadorA add: (CartaDeTruco copaCon: 3).
	cartasJugadorB _ OrderedCollection new.
	cartasJugadorB add: CartaDeTruco anchoDeBasto.
	cartasJugadorB add: (CartaDeTruco oroCon: 3).
	cartasJugadorB add: (CartaDeTruco copaCon: 4).
	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		vs: jugadorB
		.
	
	rondaDeTruco enfrentamientoCon: CartaDeTruco anchoDeEspada vs: CartaDeTruco anchoDeBasto.
		
		
	self assert: (rondaDeTruco rondasJugadas) equals: 1.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorA) equals: 1.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorB) equals: 0.! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 19:22:39' prior: 50914349!
test02
	| rondaDeTruco |

	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		vs: jugadorB
		.
	
	rondaDeTruco enfrentamientoCon: CartaDeTruco anchoDeEspada vs: CartaDeTruco anchoDeBasto.
		
		
	self assert: (rondaDeTruco rondasJugadas) equals: 1.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorA) equals: 1.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorB) equals: 0.! !

!testRun: #RondaDeTrucoTest #test02 stamp: 'pc 7/5/2021 19:22:43'!
PASSED!

!testRun: #RondaDeTrucoTest #test01 stamp: 'pc 7/5/2021 19:22:43'!
PASSED!

!testRun: #RondaDeTrucoTest #test02 stamp: 'pc 7/5/2021 19:22:43'!
PASSED!

!testRun: #RondaDeTrucoTest #test03 stamp: 'pc 7/5/2021 19:22:43'!
PASSED!

!testRun: #RondaDeTrucoTest #test04 stamp: 'pc 7/5/2021 19:22:43'!
PASSED!

!testRun: #RondaDeTrucoTest #test05 stamp: 'pc 7/5/2021 19:22:43'!
PASSED!

!testRun: #RondaDeTrucoTest #test06 stamp: 'pc 7/5/2021 19:22:43'!
PASSED!

!testRun: #RondaDeTrucoTest #test07 stamp: 'pc 7/5/2021 19:22:43'!
PASSED!

!testRun: #RondaDeTrucoTest #test08 stamp: 'pc 7/5/2021 19:22:43'!
PASSED!

!testRun: #RondaDeTrucoTest #test09 stamp: 'pc 7/5/2021 19:22:43'!
PASSED!

!testRun: #RondaDeTrucoTest #test10 stamp: 'pc 7/5/2021 19:22:43'!
PASSED!
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 19:23:08' prior: 50913841!
test03
	| rondaDeTruco cartasJugadorA cartasJugadorB |
	
	cartasJugadorA _ OrderedCollection new.
	cartasJugadorA add: (CartaDeTruco bastoCon: 2).
	cartasJugadorA add: CartaDeTruco anchoDeEspada.
	cartasJugadorA add: (CartaDeTruco copaCon: 3).
	cartasJugadorB _ OrderedCollection new.
	cartasJugadorB add: (CartaDeTruco oroCon: 2).
	cartasJugadorB add: CartaDeTruco anchoDeBasto.
	cartasJugadorB add: (CartaDeTruco copaCon: 4).
	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		vs: jugadorB
		.
	
	rondaDeTruco enfrentamientoCon: (CartaDeTruco bastoCon: 2) vs: (CartaDeTruco oroCon: 2) .
		
	self assert: (rondaDeTruco rondasJugadas) equals: 1.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorA) equals: 0.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorB) equals: 0.! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 19:23:13' prior: 50914420!
test03
	| rondaDeTruco |
	
	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		vs: jugadorB
		.
	
	rondaDeTruco enfrentamientoCon: (CartaDeTruco bastoCon: 2) vs: (CartaDeTruco oroCon: 2) .
		
	self assert: (rondaDeTruco rondasJugadas) equals: 1.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorA) equals: 0.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorB) equals: 0.! !

!testRun: #RondaDeTrucoTest #test03 stamp: 'pc 7/5/2021 19:23:16'!
PASSED!

!testRun: #RondaDeTrucoTest #test01 stamp: 'pc 7/5/2021 19:23:16'!
PASSED!

!testRun: #RondaDeTrucoTest #test02 stamp: 'pc 7/5/2021 19:23:16'!
PASSED!

!testRun: #RondaDeTrucoTest #test03 stamp: 'pc 7/5/2021 19:23:16'!
PASSED!

!testRun: #RondaDeTrucoTest #test04 stamp: 'pc 7/5/2021 19:23:16'!
PASSED!

!testRun: #RondaDeTrucoTest #test05 stamp: 'pc 7/5/2021 19:23:16'!
PASSED!

!testRun: #RondaDeTrucoTest #test06 stamp: 'pc 7/5/2021 19:23:16'!
PASSED!

!testRun: #RondaDeTrucoTest #test07 stamp: 'pc 7/5/2021 19:23:16'!
PASSED!

!testRun: #RondaDeTrucoTest #test08 stamp: 'pc 7/5/2021 19:23:16'!
PASSED!

!testRun: #RondaDeTrucoTest #test09 stamp: 'pc 7/5/2021 19:23:16'!
PASSED!

!testRun: #RondaDeTrucoTest #test10 stamp: 'pc 7/5/2021 19:23:16'!
PASSED!
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 19:24:08' prior: 50913872!
test04
	| rondaDeTruco cartasJugadorA cartasJugadorB |
	
	cartasJugadorA _ OrderedCollection new.
	cartasJugadorA add: (CartaDeTruco oroCon: 2).
	cartasJugadorA add: CartaDeTruco anchoDeEspada.
	cartasJugadorA add: (CartaDeTruco copaCon: 3).
	cartasJugadorB _ OrderedCollection new.
	cartasJugadorB add: (CartaDeTruco bastoCon: 2).
	cartasJugadorB add: CartaDeTruco anchoDeBasto.
	cartasJugadorB add: (CartaDeTruco copaCon: 4).
	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		vs: jugadorB
		.
	
	rondaDeTruco enfrentamientoCon: (CartaDeTruco oroCon: 2) vs: (CartaDeTruco bastoCon: 2).
	rondaDeTruco enfrentamientoCon: CartaDeTruco anchoDeEspada vs:CartaDeTruco anchoDeBasto. .
	
	self assert: (rondaDeTruco rondasJugadas) equals: 2.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorA) equals: 1.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorB) equals: 0.
	self assert: (rondaDeTruco ganador) equals: jugadorA .! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 19:24:14' prior: 50914491!
test04
	| rondaDeTruco |
	

	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		vs: jugadorB
		.
	
	rondaDeTruco enfrentamientoCon: (CartaDeTruco oroCon: 2) vs: (CartaDeTruco bastoCon: 2).
	rondaDeTruco enfrentamientoCon: CartaDeTruco anchoDeEspada vs:CartaDeTruco anchoDeBasto. .
	
	self assert: (rondaDeTruco rondasJugadas) equals: 2.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorA) equals: 1.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorB) equals: 0.
	self assert: (rondaDeTruco ganador) equals: jugadorA .! !

!testRun: #RondaDeTrucoTest #test04 stamp: 'pc 7/5/2021 19:24:17'!
PASSED!

!testRun: #RondaDeTrucoTest #test01 stamp: 'pc 7/5/2021 19:24:17'!
PASSED!

!testRun: #RondaDeTrucoTest #test02 stamp: 'pc 7/5/2021 19:24:17'!
PASSED!

!testRun: #RondaDeTrucoTest #test03 stamp: 'pc 7/5/2021 19:24:17'!
PASSED!

!testRun: #RondaDeTrucoTest #test04 stamp: 'pc 7/5/2021 19:24:17'!
PASSED!

!testRun: #RondaDeTrucoTest #test05 stamp: 'pc 7/5/2021 19:24:17'!
PASSED!

!testRun: #RondaDeTrucoTest #test06 stamp: 'pc 7/5/2021 19:24:17'!
PASSED!

!testRun: #RondaDeTrucoTest #test07 stamp: 'pc 7/5/2021 19:24:17'!
PASSED!

!testRun: #RondaDeTrucoTest #test08 stamp: 'pc 7/5/2021 19:24:17'!
PASSED!

!testRun: #RondaDeTrucoTest #test09 stamp: 'pc 7/5/2021 19:24:17'!
PASSED!

!testRun: #RondaDeTrucoTest #test10 stamp: 'pc 7/5/2021 19:24:17'!
PASSED!
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 19:25:09' prior: 50913905!
test05
	| rondaDeTruco cartasJugadorA cartasJugadorB |
	
	cartasJugadorA _ OrderedCollection new.
	cartasJugadorA add: (CartaDeTruco bastoCon: 2).
	cartasJugadorA add: CartaDeTruco anchoDeEspada.
	cartasJugadorA add: (CartaDeTruco copaCon: 3).
	cartasJugadorB _ OrderedCollection new.
	cartasJugadorB add: (CartaDeTruco oroCon: 2).
	cartasJugadorB add: CartaDeTruco anchoDeBasto.
	cartasJugadorB add: (CartaDeTruco copaCon: 4).
	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		vs: jugadorB
		.
	
	rondaDeTruco enfrentamientoCon: (CartaDeTruco bastoCon: 2) vs: (CartaDeTruco oroCon: 2) .
	rondaDeTruco enfrentamientoCon: CartaDeTruco anchoDeEspada vs: CartaDeTruco anchoDeBasto.
	
	self assert: (rondaDeTruco rondasJugadas) equals: 2.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorA) equals: 1.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorB) equals: 0.
	self assert: (rondaDeTruco ganador) equals: jugadorA .! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 19:25:13' prior: 50914571!
test05
	| rondaDeTruco |
	
	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		vs: jugadorB
		.
	
	rondaDeTruco enfrentamientoCon: (CartaDeTruco bastoCon: 2) vs: (CartaDeTruco oroCon: 2) .
	rondaDeTruco enfrentamientoCon: CartaDeTruco anchoDeEspada vs: CartaDeTruco anchoDeBasto.
	
	self assert: (rondaDeTruco rondasJugadas) equals: 2.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorA) equals: 1.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorB) equals: 0.
	self assert: (rondaDeTruco ganador) equals: jugadorA .! !

!testRun: #RondaDeTrucoTest #test05 stamp: 'pc 7/5/2021 19:25:16'!
PASSED!

!testRun: #RondaDeTrucoTest #test01 stamp: 'pc 7/5/2021 19:25:16'!
PASSED!

!testRun: #RondaDeTrucoTest #test02 stamp: 'pc 7/5/2021 19:25:16'!
PASSED!

!testRun: #RondaDeTrucoTest #test03 stamp: 'pc 7/5/2021 19:25:16'!
PASSED!

!testRun: #RondaDeTrucoTest #test04 stamp: 'pc 7/5/2021 19:25:16'!
PASSED!

!testRun: #RondaDeTrucoTest #test05 stamp: 'pc 7/5/2021 19:25:16'!
PASSED!

!testRun: #RondaDeTrucoTest #test06 stamp: 'pc 7/5/2021 19:25:16'!
PASSED!

!testRun: #RondaDeTrucoTest #test07 stamp: 'pc 7/5/2021 19:25:16'!
PASSED!

!testRun: #RondaDeTrucoTest #test08 stamp: 'pc 7/5/2021 19:25:16'!
PASSED!

!testRun: #RondaDeTrucoTest #test09 stamp: 'pc 7/5/2021 19:25:16'!
PASSED!

!testRun: #RondaDeTrucoTest #test10 stamp: 'pc 7/5/2021 19:25:16'!
PASSED!
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 19:26:03' prior: 50913230!
test06
	| rondaDeTruco cartasJugadorA cartasJugadorB |
	
	cartasJugadorA _ OrderedCollection new.
	cartasJugadorA add: (CartaDeTruco oroCon: 4).
	cartasJugadorA add: CartaDeTruco anchoDeEspada.
	cartasJugadorA add: (CartaDeTruco copaCon: 3).
	cartasJugadorB _ OrderedCollection new.
	cartasJugadorB add: (CartaDeTruco oroCon: 2).
	cartasJugadorB add: CartaDeTruco anchoDeBasto.
	cartasJugadorB add: (CartaDeTruco copaCon: 4).
	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		vs: jugadorB
		.
	
	rondaDeTruco enfrentamientoCon: (CartaDeTruco oroCon: 4) vs: (CartaDeTruco oroCon: 2) .
	rondaDeTruco enfrentamientoCon: CartaDeTruco anchoDeEspada vs: 	CartaDeTruco anchoDeBasto. .
	rondaDeTruco enfrentamientoCon: cartasJugadorA third vs: cartasJugadorB third .
	
	self assert: (rondaDeTruco rondasJugadas) equals: 3.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorA) equals: 2.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorB) equals: 1.
	self assert: (rondaDeTruco ganador) equals: jugadorA .! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 19:26:34' prior: 50914651!
test06
	| rondaDeTruco |
	
	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		vs: jugadorB
		.
	
	rondaDeTruco enfrentamientoCon: (CartaDeTruco oroCon: 4) vs: (CartaDeTruco oroCon: 2) .
	rondaDeTruco enfrentamientoCon: CartaDeTruco anchoDeEspada vs: 	CartaDeTruco anchoDeBasto. .
	rondaDeTruco enfrentamientoCon: (CartaDeTruco copaCon: 3) vs: (CartaDeTruco copaCon: 4) .
	
	self assert: (rondaDeTruco rondasJugadas) equals: 3.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorA) equals: 2.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorB) equals: 1.
	self assert: (rondaDeTruco ganador) equals: jugadorA .! !

!testRun: #RondaDeTrucoTest #test06 stamp: 'pc 7/5/2021 19:26:38'!
PASSED!

!testRun: #RondaDeTrucoTest #test01 stamp: 'pc 7/5/2021 19:26:38'!
PASSED!

!testRun: #RondaDeTrucoTest #test02 stamp: 'pc 7/5/2021 19:26:38'!
PASSED!

!testRun: #RondaDeTrucoTest #test03 stamp: 'pc 7/5/2021 19:26:38'!
PASSED!

!testRun: #RondaDeTrucoTest #test04 stamp: 'pc 7/5/2021 19:26:38'!
PASSED!

!testRun: #RondaDeTrucoTest #test05 stamp: 'pc 7/5/2021 19:26:38'!
PASSED!

!testRun: #RondaDeTrucoTest #test06 stamp: 'pc 7/5/2021 19:26:38'!
PASSED!

!testRun: #RondaDeTrucoTest #test07 stamp: 'pc 7/5/2021 19:26:38'!
PASSED!

!testRun: #RondaDeTrucoTest #test08 stamp: 'pc 7/5/2021 19:26:38'!
PASSED!

!testRun: #RondaDeTrucoTest #test09 stamp: 'pc 7/5/2021 19:26:38'!
PASSED!

!testRun: #RondaDeTrucoTest #test10 stamp: 'pc 7/5/2021 19:26:38'!
PASSED!
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 19:27:14' prior: 50913326!
test07
	| rondaDeTruco cartasJugadorA cartasJugadorB |
	
	cartasJugadorA _ OrderedCollection new.
	cartasJugadorA add: (CartaDeTruco copaCon: 2).
	cartasJugadorA add: CartaDeTruco anchoDeEspada.
	cartasJugadorA add: (CartaDeTruco copaCon: 3).
	cartasJugadorB _ OrderedCollection new.
	cartasJugadorB add: (CartaDeTruco oroCon: 2).
	cartasJugadorB add: CartaDeTruco anchoDeBasto.
	cartasJugadorB add: (CartaDeTruco copaCon: 4).
	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		vs: jugadorB
		.
	
	rondaDeTruco enfrentamientoCon: (CartaDeTruco copaCon: 2) vs:  (CartaDeTruco oroCon: 2).
	rondaDeTruco enfrentamientoCon: CartaDeTruco anchoDeEspada vs: CartaDeTruco anchoDeBasto.
	
	self assert: (rondaDeTruco rondasJugadas) equals: 2.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorA) equals: 1.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorB) equals: 0.
	self assert: (rondaDeTruco ganador) equals: jugadorA .! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 19:27:19' prior: 50914737!
test07
	| rondaDeTruco |
	
	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		vs: jugadorB
		.
	
	rondaDeTruco enfrentamientoCon: (CartaDeTruco copaCon: 2) vs:  (CartaDeTruco oroCon: 2).
	rondaDeTruco enfrentamientoCon: CartaDeTruco anchoDeEspada vs: CartaDeTruco anchoDeBasto.
	
	self assert: (rondaDeTruco rondasJugadas) equals: 2.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorA) equals: 1.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorB) equals: 0.
	self assert: (rondaDeTruco ganador) equals: jugadorA .! !

!testRun: #RondaDeTrucoTest #test07 stamp: 'pc 7/5/2021 19:27:23'!
PASSED!

!testRun: #RondaDeTrucoTest #test01 stamp: 'pc 7/5/2021 19:27:23'!
PASSED!

!testRun: #RondaDeTrucoTest #test02 stamp: 'pc 7/5/2021 19:27:23'!
PASSED!

!testRun: #RondaDeTrucoTest #test03 stamp: 'pc 7/5/2021 19:27:23'!
PASSED!

!testRun: #RondaDeTrucoTest #test04 stamp: 'pc 7/5/2021 19:27:23'!
PASSED!

!testRun: #RondaDeTrucoTest #test05 stamp: 'pc 7/5/2021 19:27:23'!
PASSED!

!testRun: #RondaDeTrucoTest #test06 stamp: 'pc 7/5/2021 19:27:23'!
PASSED!

!testRun: #RondaDeTrucoTest #test07 stamp: 'pc 7/5/2021 19:27:23'!
PASSED!

!testRun: #RondaDeTrucoTest #test08 stamp: 'pc 7/5/2021 19:27:23'!
PASSED!

!testRun: #RondaDeTrucoTest #test09 stamp: 'pc 7/5/2021 19:27:23'!
PASSED!

!testRun: #RondaDeTrucoTest #test10 stamp: 'pc 7/5/2021 19:27:23'!
PASSED!
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 19:27:43'!
test11
	| rondaDeTruco |
	
	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		vs: jugadorB
		.
	
	rondaDeTruco enfrentamientoCon: (CartaDeTruco oroCon: 4) vs: (CartaDeTruco oroCon: 2) .
	rondaDeTruco enfrentamientoCon: CartaDeTruco anchoDeEspada vs: 	CartaDeTruco anchoDeBasto.
	rondaDeTruco enfrentamientoCon: (CartaDeTruco copaCon: 3) vs: (CartaDeTruco copaCon: 4) .
	
	self assert: (rondaDeTruco rondasJugadas) equals: 3.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorA) equals: 2.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorB) equals: 1.
	self assert: (rondaDeTruco ganador) equals: jugadorA .! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 19:27:50' prior: 50914687!
test06
	| rondaDeTruco |
	
	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		vs: jugadorB
		.
	
	rondaDeTruco enfrentamientoCon: (CartaDeTruco oroCon: 4) vs: (CartaDeTruco oroCon: 2) .
	rondaDeTruco enfrentamientoCon: CartaDeTruco anchoDeEspada vs: 	CartaDeTruco anchoDeBasto. 
	rondaDeTruco enfrentamientoCon: (CartaDeTruco copaCon: 3) vs: (CartaDeTruco copaCon: 4) .
	
	self assert: (rondaDeTruco rondasJugadas) equals: 3.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorA) equals: 2.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorB) equals: 1.
	self assert: (rondaDeTruco ganador) equals: jugadorA .! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 19:28:25' prior: 50914816!
test11
	| rondaDeTruco |
	
	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		vs: jugadorB
		.
	
	rondaDeTruco enfrentamientoCon: (CartaDeTruco oroCon: 4) vs: (CartaDeTruco oroCon: 2) .
	rondaDeTruco enfrentamientoCon: CartaDeTruco anchoDeEspada vs: 	CartaDeTruco anchoDeBasto.
	rondaDeTruco enfrentamientoCon: (CartaDeTruco copaCon: 3) vs: (CartaDeTruco copaCon: 4).
	
	self assert: (rondaDeTruco rondasJugadas) equals: 3.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorA) equals: 2.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorB) equals: 1.
	self assert: (rondaDeTruco ganador) equals: jugadorA .! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 19:31:15' prior: 50914864!
test11
	| rondaDeTruco |
	
	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		vs: jugadorB
		.
	
	rondaDeTruco enfrentamientoCon: (CartaDeTruco oroCon: 4) vs: (CartaDeTruco oroCon: 2) .
	rondaDeTruco enfrentamientoCon: CartaDeTruco anchoDeBasto vs: 	CartaDeTruco anchoDeEspada.
	
	self 
	should: [rondaDeTruco enfrentamientoCon: (CartaDeTruco copaCon: 3) vs: (CartaDeTruco copaCon: 4)] 
	raise:  Error - MessageNotUnderstood 
	withExceptionDo: [:anError|
		self assert: RondaDeTruco noSePuedeJugarCuandoYaHayGanadorError equals: anError messageText. 
		self assert: (rondaDeTruco rondasJugadas) equals: 2.
		self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorA) equals: 0.
		self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorB) equals: 2.
		self assert: (rondaDeTruco ganador) equals: jugadorB .]
	! !

!testRun: #RondaDeTrucoTest #test11 stamp: 'pc 7/5/2021 19:31:18'!
FAILURE!
!RondaDeTruco methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 19:32:12' prior: 50914188!
enfrentamientoCon: cartaDeTrucoA vs: cartaDeTrucoB
	
	((cartasUsadas includes: cartaDeTrucoA) or: [(cartasUsadas includes: cartaDeTrucoB) or: [cartaDeTrucoA = cartaDeTrucoB ]]) ifTrue: [^self error: self class cartaRepetidaError].
	
	cartasUsadas add: cartaDeTrucoA.
	cartasUsadas add: cartaDeTrucoB.
	
	ronda := ronda + 1.
	(cartaDeTrucoA mataA: cartaDeTrucoB) ifTrue: [jugadores add: jugadorA ]. 
	(cartaDeTrucoB mataA: cartaDeTrucoA) ifTrue: [jugadores add: jugadorB].
	(cartaDeTrucoB empardaCon: cartaDeTrucoA) ifTrue: [primerRondaParda := true].
! !
!RondaDeTruco methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 19:36:16' prior: 50914920!
enfrentamientoCon: cartaDeTrucoA vs: cartaDeTrucoB
	
	((self enfretamientosGanadosPor: jugadorA) = 2 or: [(self enfretamientosGanadosPor: jugadorB) =2] ) ifTrue: [self error: self class noSePuedeJugarCuandoYaHayGanadorError].
	
	((cartasUsadas includes: cartaDeTrucoA) or: [(cartasUsadas includes: cartaDeTrucoB) or: [cartaDeTrucoA = cartaDeTrucoB ]]) ifTrue: [^self error: self class cartaRepetidaError].
	
	cartasUsadas add: cartaDeTrucoA.
	cartasUsadas add: cartaDeTrucoB.
	
	ronda := ronda + 1.
	(cartaDeTrucoA mataA: cartaDeTrucoB) ifTrue: [jugadores add: jugadorA ]. 
	(cartaDeTrucoB mataA: cartaDeTrucoA) ifTrue: [jugadores add: jugadorB].
	(cartaDeTrucoB empardaCon: cartaDeTrucoA) ifTrue: [primerRondaParda := true].
! !

!testRun: #RondaDeTrucoTest #test11 stamp: 'pc 7/5/2021 19:36:18'!
ERROR!
!RondaDeTruco class methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 19:36:23'!
noSePuedeJugarCuandoYaHayGanadorError
	self shouldBeImplemented.! !
!RondaDeTruco class methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 19:36:41' prior: 50914969!
noSePuedeJugarCuandoYaHayGanadorError
	^'no se puede continuar el partido una vez finalizado'! !

!testRun: #RondaDeTrucoTest #test11 stamp: 'pc 7/5/2021 19:36:42'!
ERROR!
!RondaDeTruco methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 19:38:48' prior: 50912613!
ganador
	
	ronda = 3 ifTrue:[
		((jugadores occurrencesOf: jugadorA) > (jugadores occurrencesOf: jugadorB)) ifTrue: [^jugadorA ] ifFalse: [^jugadorB ]].
	(ronda = 2 and: [primerRondaParda or: [(self enfretamientosGanadosPor: jugadorA) = 2 or: [(self enfretamientosGanadosPor: jugadorB) =2] ]]) ifTrue:[
		((jugadores occurrencesOf: jugadorA) > (jugadores occurrencesOf: jugadorB)) ifTrue: [^jugadorA ] ifFalse: [^jugadorB ]].
	
	self error: self class noTerminoLaRondaTodavia.! !

!testRun: #RondaDeTrucoTest #test11 stamp: 'pc 7/5/2021 19:38:52'!
PASSED!

!testRun: #RondaDeTrucoTest #test01 stamp: 'pc 7/5/2021 19:38:52'!
PASSED!

!testRun: #RondaDeTrucoTest #test02 stamp: 'pc 7/5/2021 19:38:52'!
PASSED!

!testRun: #RondaDeTrucoTest #test03 stamp: 'pc 7/5/2021 19:38:52'!
PASSED!

!testRun: #RondaDeTrucoTest #test04 stamp: 'pc 7/5/2021 19:38:52'!
PASSED!

!testRun: #RondaDeTrucoTest #test05 stamp: 'pc 7/5/2021 19:38:52'!
PASSED!

!testRun: #RondaDeTrucoTest #test06 stamp: 'pc 7/5/2021 19:38:52'!
PASSED!

!testRun: #RondaDeTrucoTest #test07 stamp: 'pc 7/5/2021 19:38:52'!
PASSED!

!testRun: #RondaDeTrucoTest #test08 stamp: 'pc 7/5/2021 19:38:52'!
PASSED!

!testRun: #RondaDeTrucoTest #test09 stamp: 'pc 7/5/2021 19:38:52'!
PASSED!

!testRun: #RondaDeTrucoTest #test10 stamp: 'pc 7/5/2021 19:38:52'!
PASSED!

!testRun: #RondaDeTrucoTest #test11 stamp: 'pc 7/5/2021 19:38:52'!
PASSED!

!testRun: #CartaDeTrucoTest #test01SonIgualesConMismoPaloYNumero stamp: 'pc 7/5/2021 19:39:15'!
PASSED!

!testRun: #CartaDeTrucoTest #test02SonDistintasConDistintoPalo stamp: 'pc 7/5/2021 19:39:15'!
PASSED!

!testRun: #CartaDeTrucoTest #test03SonDistintasConNumeroAunqueIgualPalo stamp: 'pc 7/5/2021 19:39:15'!
PASSED!

!testRun: #CartaDeTrucoTest #test04CartasIgualesTienenElMismoHash stamp: 'pc 7/5/2021 19:39:15'!
PASSED!

!testRun: #CartaDeTrucoTest #test05UnaCartaEsDistintaACualquierObjetoQueNoSeaCarta stamp: 'pc 7/5/2021 19:39:15'!
PASSED!

!testRun: #CartaDeTrucoTest #test07NoHayCartaDeTrucoConNumeroOcho stamp: 'pc 7/5/2021 19:39:15'!
PASSED!

!testRun: #CartaDeTrucoTest #test08NoHayCartaDeTrucoConNumeroNueve stamp: 'pc 7/5/2021 19:39:15'!
PASSED!

!testRun: #CartaDeTrucoTest #test09LosPalosDeLaCartaDeTrucoSonBastoOroEspadaYCopa stamp: 'pc 7/5/2021 19:39:15'!
PASSED!

!testRun: #CartaDeTrucoTest #test10NoSePuedeCrearCartaConNumeroMenorAUno stamp: 'pc 7/5/2021 19:39:15'!
PASSED!

!testRun: #CartaDeTrucoTest #test11NoSePuedeCrearCartaConNumeroMayorADoce stamp: 'pc 7/5/2021 19:39:15'!
PASSED!

!testRun: #CartaDeTrucoTest #test12ElNumeroDeLaCartaDebeSerEntero stamp: 'pc 7/5/2021 19:39:15'!
PASSED!

!testRun: #CartaDeTrucoTest #test13LaTablaDeValoresEsCorrecta stamp: 'pc 7/5/2021 19:39:15'!
PASSED!

!testRun: #CartaDeTrucoTest #test14HayCartasQueNoSonPardas stamp: 'pc 7/5/2021 19:39:15'!
PASSED!

!testRun: #CartaDeTrucoTest #test15HayCartasQuePierdenConOtras stamp: 'pc 7/5/2021 19:39:15'!
PASSED!

!testRun: #CartaDeTrucoTest #test16SieteDeCopasYDeBastoEsSieteFalso stamp: 'pc 7/5/2021 19:39:15'!
PASSED!

!testRun: #CartaDeTrucoTest #test17SieteDeOroYDeEspadaNoSonSieteFalso stamp: 'pc 7/5/2021 19:39:15'!
PASSED!

!testRun: #CartaDeTrucoTest #test18AnchoDeOroYDeCopaSonAnchoFalsos stamp: 'pc 7/5/2021 19:39:15'!
PASSED!

!testRun: #CartaDeTrucoTest #test19AnchoDeEspadaYDeBastosNoSonAnchoFalsos stamp: 'pc 7/5/2021 19:39:15'!
PASSED!

!testRun: #CartaDeTrucoTest #test20FallaBuscandoValorDeCartaInv�lida stamp: 'pc 7/5/2021 19:39:15'!
PASSED!

!testRun: #RondaDeTrucoTest #test01 stamp: 'pc 7/5/2021 19:39:15'!
PASSED!

!testRun: #RondaDeTrucoTest #test02 stamp: 'pc 7/5/2021 19:39:15'!
PASSED!

!testRun: #RondaDeTrucoTest #test03 stamp: 'pc 7/5/2021 19:39:15'!
PASSED!

!testRun: #RondaDeTrucoTest #test04 stamp: 'pc 7/5/2021 19:39:15'!
PASSED!

!testRun: #RondaDeTrucoTest #test05 stamp: 'pc 7/5/2021 19:39:15'!
PASSED!

!testRun: #RondaDeTrucoTest #test06 stamp: 'pc 7/5/2021 19:39:15'!
PASSED!

!testRun: #RondaDeTrucoTest #test07 stamp: 'pc 7/5/2021 19:39:15'!
PASSED!

!testRun: #RondaDeTrucoTest #test08 stamp: 'pc 7/5/2021 19:39:15'!
PASSED!

!testRun: #RondaDeTrucoTest #test09 stamp: 'pc 7/5/2021 19:39:15'!
PASSED!

!testRun: #RondaDeTrucoTest #test10 stamp: 'pc 7/5/2021 19:39:15'!
PASSED!

!testRun: #RondaDeTrucoTest #test11 stamp: 'pc 7/5/2021 19:39:15'!
PASSED!
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 19:42:02' prior: 50914449!
test03
	| rondaDeTruco |
	
	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		vs: jugadorB
		.
	
	rondaDeTruco enfrentamientoCon: (CartaDeTruco bastoCon: 2) vs: (CartaDeTruco oroCon: 2) .
	rondaDeTruco enfrentamientoCon: (CartaDeTruco bastoCon: 7) vs: (CartaDeTruco copaCon: 7) .	
	
	self assert: (rondaDeTruco rondasJugadas) equals: 0.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorA) equals: 0.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorB) equals: 0.
	! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 19:42:02' prior: 50915122!
test03
	| rondaDeTruco |
	
	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		vs: jugadorB
		.
	
	rondaDeTruco enfrentamientoCon: (CartaDeTruco bastoCon: 2) vs: (CartaDeTruco oroCon: 2) .
	rondaDeTruco enfrentamientoCon: (CartaDeTruco bastoCon: 7) vs: (CartaDeTruco copaCon: 7) .	
	
	self assert: (rondaDeTruco rondasJugadas) equals: 0.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorA) equals: 0.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorB) equals: 0.
	! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 19:42:51' prior: 50915141!
test03
	| rondaDeTruco |
	
	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		vs: jugadorB
		.
	
	rondaDeTruco enfrentamientoCon: (CartaDeTruco bastoCon: 2) vs: (CartaDeTruco oroCon: 2) .
	
	self assert: (rondaDeTruco rondasJugadas) equals: 0.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorA) equals: 0.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorB) equals: 0.
	! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 19:42:59'!
test12
	| rondaDeTruco |
	
	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		vs: jugadorB
		.
	
	rondaDeTruco enfrentamientoCon: (CartaDeTruco bastoCon: 2) vs: (CartaDeTruco oroCon: 2) .
	rondaDeTruco enfrentamientoCon: (CartaDeTruco bastoCon: 7) vs: (CartaDeTruco copaCon: 7) .	
	
	self assert: (rondaDeTruco rondasJugadas) equals: 0.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorA) equals: 0.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorB) equals: 0.
	! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 19:43:03' prior: 50915176!
test12
	| rondaDeTruco |
	
	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		vs: jugadorB
		.
	
	rondaDeTruco enfrentamientoCon: (CartaDeTruco bastoCon: 2) vs: (CartaDeTruco oroCon: 2) .
	rondaDeTruco enfrentamientoCon: (CartaDeTruco bastoCon: 7) vs: (CartaDeTruco copaCon: 7) .	
	
	self assert: (rondaDeTruco rondasJugadas) equals: 0.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorA) equals: 0.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorB) equals: 0.
	
	! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 19:43:16' prior: 50915195!
test12
	| rondaDeTruco |
	
	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		vs: jugadorB
		.
	
	rondaDeTruco enfrentamientoCon: (CartaDeTruco bastoCon: 2) vs: (CartaDeTruco oroCon: 2) .
	rondaDeTruco enfrentamientoCon: (CartaDeTruco bastoCon: 7) vs: (CartaDeTruco copaCon: 7) .	
	
	self assert: (rondaDeTruco rondasJugadas) equals: 0.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorA) equals: 0.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorB) equals: 0.
	self assert: (rondaDeTruco ganador) equals: jugadorB .
	
	! !

!testRun: #RondaDeTrucoTest #test12 stamp: 'pc 7/5/2021 19:43:19'!
FAILURE!
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 19:43:30' prior: 50915214!
test12
	| rondaDeTruco |
	
	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		vs: jugadorB
		.
	
	rondaDeTruco enfrentamientoCon: (CartaDeTruco bastoCon: 2) vs: (CartaDeTruco oroCon: 2) .
	rondaDeTruco enfrentamientoCon: (CartaDeTruco bastoCon: 7) vs: (CartaDeTruco copaCon: 7) .	
	
	self assert: (rondaDeTruco rondasJugadas) equals: 2.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorA) equals: 0.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorB) equals: 0.
	self assert: (rondaDeTruco ganador) equals: jugadorB .
	
	! !

!testRun: #RondaDeTrucoTest #test12 stamp: 'pc 7/5/2021 19:43:31'!
PASSED!

!testRun: #RondaDeTrucoTest #test01 stamp: 'pc 7/5/2021 19:43:31'!
PASSED!

!testRun: #RondaDeTrucoTest #test02 stamp: 'pc 7/5/2021 19:43:31'!
PASSED!

!testRun: #RondaDeTrucoTest #test03 stamp: 'pc 7/5/2021 19:43:31'!
FAILURE!

!testRun: #RondaDeTrucoTest #test04 stamp: 'pc 7/5/2021 19:43:31'!
PASSED!

!testRun: #RondaDeTrucoTest #test05 stamp: 'pc 7/5/2021 19:43:31'!
PASSED!

!testRun: #RondaDeTrucoTest #test06 stamp: 'pc 7/5/2021 19:43:31'!
PASSED!

!testRun: #RondaDeTrucoTest #test07 stamp: 'pc 7/5/2021 19:43:31'!
PASSED!

!testRun: #RondaDeTrucoTest #test08 stamp: 'pc 7/5/2021 19:43:31'!
PASSED!

!testRun: #RondaDeTrucoTest #test09 stamp: 'pc 7/5/2021 19:43:31'!
PASSED!

!testRun: #RondaDeTrucoTest #test10 stamp: 'pc 7/5/2021 19:43:31'!
PASSED!

!testRun: #RondaDeTrucoTest #test11 stamp: 'pc 7/5/2021 19:43:31'!
PASSED!

!testRun: #RondaDeTrucoTest #test12 stamp: 'pc 7/5/2021 19:43:31'!
PASSED!

!testRun: #RondaDeTrucoTest #test03 stamp: 'pc 7/5/2021 19:43:31'!
FAILURE!
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 19:43:40' prior: 50915160!
test03
	| rondaDeTruco |
	
	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		vs: jugadorB
		.
	
	rondaDeTruco enfrentamientoCon: (CartaDeTruco bastoCon: 2) vs: (CartaDeTruco oroCon: 2) .
	
	self assert: (rondaDeTruco rondasJugadas) equals: 1.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorA) equals: 0.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorB) equals: 0.
	! !

!testRun: #RondaDeTrucoTest #test03 stamp: 'pc 7/5/2021 19:43:42'!
PASSED!

!testRun: #RondaDeTrucoTest #test12 stamp: 'pc 7/5/2021 19:43:46'!
PASSED!

!testRun: #RondaDeTrucoTest #test01 stamp: 'pc 7/5/2021 19:43:46'!
PASSED!

!testRun: #RondaDeTrucoTest #test02 stamp: 'pc 7/5/2021 19:43:46'!
PASSED!

!testRun: #RondaDeTrucoTest #test03 stamp: 'pc 7/5/2021 19:43:46'!
PASSED!

!testRun: #RondaDeTrucoTest #test04 stamp: 'pc 7/5/2021 19:43:46'!
PASSED!

!testRun: #RondaDeTrucoTest #test05 stamp: 'pc 7/5/2021 19:43:46'!
PASSED!

!testRun: #RondaDeTrucoTest #test06 stamp: 'pc 7/5/2021 19:43:46'!
PASSED!

!testRun: #RondaDeTrucoTest #test07 stamp: 'pc 7/5/2021 19:43:46'!
PASSED!

!testRun: #RondaDeTrucoTest #test08 stamp: 'pc 7/5/2021 19:43:46'!
PASSED!

!testRun: #RondaDeTrucoTest #test09 stamp: 'pc 7/5/2021 19:43:46'!
PASSED!

!testRun: #RondaDeTrucoTest #test10 stamp: 'pc 7/5/2021 19:43:46'!
PASSED!

!testRun: #RondaDeTrucoTest #test11 stamp: 'pc 7/5/2021 19:43:46'!
PASSED!

!testRun: #RondaDeTrucoTest #test12 stamp: 'pc 7/5/2021 19:43:46'!
PASSED!
!RondaDeTruco methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 19:46:30' prior: 50914941!
enfrentamientoCon: cartaDeTrucoA vs: cartaDeTrucoB
	
	((self enfretamientosGanadosPor: jugadorA) = 2 or: [(self enfretamientosGanadosPor: jugadorB) =2] ) ifTrue: [self error: self class noSePuedeJugarCuandoYaHayGanadorError].
	
	((cartasUsadas includes: cartaDeTrucoA) or: [(cartasUsadas includes: cartaDeTrucoB) or: [cartaDeTrucoA = cartaDeTrucoB ]]) ifTrue: [^self error: self class cartaRepetidaError].
	
	cartasUsadas add: cartaDeTrucoA.
	cartasUsadas add: cartaDeTrucoB.
	
	ronda := ronda + 1.
	(cartaDeTrucoA mataA: cartaDeTrucoB) ifTrue: [jugadores add: jugadorA ]. 
	(cartaDeTrucoB mataA: cartaDeTrucoA) ifTrue: [jugadores add: jugadorB].
	((cartaDeTrucoB empardaCon: cartaDeTrucoA) and: primerRondaParda) ifTrue: [jugadores add: self jugadorMano].
	(cartaDeTrucoB empardaCon: cartaDeTrucoA) ifTrue: [primerRondaParda := true].
! !

Object subclass: #RondaDeTruco
	instanceVariableNames: 'jugadorA jugadorB ronda jugadores primerRondaParda cartasUsadas'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial'!

Object subclass: #RondaDeTruco
	instanceVariableNames: 'jugadorA jugadorB cartasDeB ronda jugadores primerRondaParda cartasUsadas'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial'!

Object subclass: #RondaDeTruco
	instanceVariableNames: 'jugadorA cartasDeA jugadorB ronda jugadores primerRondaParda cartasUsadas'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial'!
!RondaDeTruco methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 19:51:08'!
jugadorMano
	^jugadorA ! !

!testRun: #RondaDeTrucoTest #test12 stamp: 'pc 7/5/2021 19:51:27'!
ERROR!

!testRun: #RondaDeTrucoTest #test12 stamp: 'pc 7/5/2021 19:51:35'!
FAILURE!

!testRun: #RondaDeTrucoTest #test12 stamp: 'pc 7/5/2021 19:51:35'!
FAILURE!

----QUIT----(5 July 2021 19:53:39) CuisUniversity-4532.image priorSource: 16885898!

----STARTUP---- (5 July 2021 19:53:44) as C:\Users\pcomi\Documents\programs\cuis\CuisUniversity-4532.image!


!testRun: #CartaDeTrucoTest #test01SonIgualesConMismoPaloYNumero stamp: 'pc 7/5/2021 19:54:00'!
PASSED!

!testRun: #CartaDeTrucoTest #test02SonDistintasConDistintoPalo stamp: 'pc 7/5/2021 19:54:00'!
PASSED!

!testRun: #CartaDeTrucoTest #test03SonDistintasConNumeroAunqueIgualPalo stamp: 'pc 7/5/2021 19:54:00'!
PASSED!

!testRun: #CartaDeTrucoTest #test04CartasIgualesTienenElMismoHash stamp: 'pc 7/5/2021 19:54:00'!
PASSED!

!testRun: #CartaDeTrucoTest #test05UnaCartaEsDistintaACualquierObjetoQueNoSeaCarta stamp: 'pc 7/5/2021 19:54:00'!
PASSED!

!testRun: #CartaDeTrucoTest #test07NoHayCartaDeTrucoConNumeroOcho stamp: 'pc 7/5/2021 19:54:00'!
PASSED!

!testRun: #CartaDeTrucoTest #test08NoHayCartaDeTrucoConNumeroNueve stamp: 'pc 7/5/2021 19:54:00'!
PASSED!

!testRun: #CartaDeTrucoTest #test09LosPalosDeLaCartaDeTrucoSonBastoOroEspadaYCopa stamp: 'pc 7/5/2021 19:54:00'!
PASSED!

!testRun: #CartaDeTrucoTest #test10NoSePuedeCrearCartaConNumeroMenorAUno stamp: 'pc 7/5/2021 19:54:00'!
PASSED!

!testRun: #CartaDeTrucoTest #test11NoSePuedeCrearCartaConNumeroMayorADoce stamp: 'pc 7/5/2021 19:54:00'!
PASSED!

!testRun: #CartaDeTrucoTest #test12ElNumeroDeLaCartaDebeSerEntero stamp: 'pc 7/5/2021 19:54:00'!
PASSED!

!testRun: #CartaDeTrucoTest #test13LaTablaDeValoresEsCorrecta stamp: 'pc 7/5/2021 19:54:00'!
PASSED!

!testRun: #CartaDeTrucoTest #test14HayCartasQueNoSonPardas stamp: 'pc 7/5/2021 19:54:00'!
PASSED!

!testRun: #CartaDeTrucoTest #test15HayCartasQuePierdenConOtras stamp: 'pc 7/5/2021 19:54:00'!
PASSED!

!testRun: #CartaDeTrucoTest #test16SieteDeCopasYDeBastoEsSieteFalso stamp: 'pc 7/5/2021 19:54:00'!
PASSED!

!testRun: #CartaDeTrucoTest #test17SieteDeOroYDeEspadaNoSonSieteFalso stamp: 'pc 7/5/2021 19:54:00'!
PASSED!

!testRun: #CartaDeTrucoTest #test18AnchoDeOroYDeCopaSonAnchoFalsos stamp: 'pc 7/5/2021 19:54:00'!
PASSED!

!testRun: #CartaDeTrucoTest #test19AnchoDeEspadaYDeBastosNoSonAnchoFalsos stamp: 'pc 7/5/2021 19:54:00'!
PASSED!

!testRun: #CartaDeTrucoTest #test20FallaBuscandoValorDeCartaInv�lida stamp: 'pc 7/5/2021 19:54:00'!
PASSED!

!testRun: #RondaDeTrucoTest #test01 stamp: 'pc 7/5/2021 19:54:00'!
PASSED!

!testRun: #RondaDeTrucoTest #test02 stamp: 'pc 7/5/2021 19:54:00'!
PASSED!

!testRun: #RondaDeTrucoTest #test03 stamp: 'pc 7/5/2021 19:54:00'!
PASSED!

!testRun: #RondaDeTrucoTest #test04 stamp: 'pc 7/5/2021 19:54:00'!
PASSED!

!testRun: #RondaDeTrucoTest #test05 stamp: 'pc 7/5/2021 19:54:00'!
PASSED!

!testRun: #RondaDeTrucoTest #test06 stamp: 'pc 7/5/2021 19:54:00'!
PASSED!

!testRun: #RondaDeTrucoTest #test07 stamp: 'pc 7/5/2021 19:54:00'!
PASSED!

!testRun: #RondaDeTrucoTest #test08 stamp: 'pc 7/5/2021 19:54:00'!
PASSED!

!testRun: #RondaDeTrucoTest #test09 stamp: 'pc 7/5/2021 19:54:00'!
PASSED!

!testRun: #RondaDeTrucoTest #test10 stamp: 'pc 7/5/2021 19:54:00'!
PASSED!

!testRun: #RondaDeTrucoTest #test11 stamp: 'pc 7/5/2021 19:54:00'!
PASSED!

!testRun: #RondaDeTrucoTest #test12 stamp: 'pc 7/5/2021 19:54:00'!
FAILURE!

!testRun: #RondaDeTrucoTest #test12 stamp: 'pc 7/5/2021 19:54:00'!
FAILURE!
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 19:55:35' prior: 50915237!
test12
	| rondaDeTruco |
	
	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		vs: jugadorB
		.
	
	rondaDeTruco enfrentamientoCon: (CartaDeTruco bastoCon: 2) vs: (CartaDeTruco oroCon: 2) .
	rondaDeTruco enfrentamientoCon: (CartaDeTruco bastoCon: 7) vs: (CartaDeTruco copaCon: 7) .	
	
	self assert: (rondaDeTruco rondasJugadas) equals: 2.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorA) equals: 0.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorB) equals: 1.
	self assert: (rondaDeTruco ganador) equals: jugadorB .
	
	! !

!testRun: #RondaDeTrucoTest #test12 stamp: 'pc 7/5/2021 19:55:36'!
FAILURE!
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 19:55:54' prior: 50915502!
test12
	| rondaDeTruco |
	
	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		vs: jugadorB
		.
	
	rondaDeTruco enfrentamientoCon: (CartaDeTruco bastoCon: 2) vs: (CartaDeTruco oroCon: 2) .
	rondaDeTruco enfrentamientoCon: (CartaDeTruco bastoCon: 7) vs: (CartaDeTruco copaCon: 7) .	
	
	self assert: (rondaDeTruco rondasJugadas) equals: 2.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorA) equals: 1.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorB) equals: 1.
	self assert: (rondaDeTruco ganador) equals: jugadorB .
	
	! !

!testRun: #RondaDeTrucoTest #test12 stamp: 'pc 7/5/2021 19:55:57'!
FAILURE!
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 19:56:04' prior: 50915525!
test12
	| rondaDeTruco |
	
	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		vs: jugadorB
		.
	
	rondaDeTruco enfrentamientoCon: (CartaDeTruco bastoCon: 2) vs: (CartaDeTruco oroCon: 2) .
	rondaDeTruco enfrentamientoCon: (CartaDeTruco bastoCon: 7) vs: (CartaDeTruco copaCon: 7) .	
	
	self assert: (rondaDeTruco rondasJugadas) equals: 2.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorA) equals: 1.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorB) equals: 0.
	self assert: (rondaDeTruco ganador) equals: jugadorB .
	
	! !

!testRun: #RondaDeTrucoTest #test12 stamp: 'pc 7/5/2021 19:56:05'!
FAILURE!

!testRun: #RondaDeTrucoTest #test12 stamp: 'pc 7/5/2021 19:56:06'!
PASSED!

!testRun: #RondaDeTrucoTest #test01 stamp: 'pc 7/5/2021 19:56:06'!
PASSED!

!testRun: #RondaDeTrucoTest #test02 stamp: 'pc 7/5/2021 19:56:06'!
PASSED!

!testRun: #RondaDeTrucoTest #test03 stamp: 'pc 7/5/2021 19:56:06'!
PASSED!

!testRun: #RondaDeTrucoTest #test04 stamp: 'pc 7/5/2021 19:56:06'!
PASSED!

!testRun: #RondaDeTrucoTest #test05 stamp: 'pc 7/5/2021 19:56:06'!
PASSED!

!testRun: #RondaDeTrucoTest #test06 stamp: 'pc 7/5/2021 19:56:06'!
PASSED!

!testRun: #RondaDeTrucoTest #test07 stamp: 'pc 7/5/2021 19:56:06'!
PASSED!

!testRun: #RondaDeTrucoTest #test08 stamp: 'pc 7/5/2021 19:56:06'!
PASSED!

!testRun: #RondaDeTrucoTest #test09 stamp: 'pc 7/5/2021 19:56:06'!
PASSED!

!testRun: #RondaDeTrucoTest #test10 stamp: 'pc 7/5/2021 19:56:06'!
PASSED!

!testRun: #RondaDeTrucoTest #test11 stamp: 'pc 7/5/2021 19:56:06'!
PASSED!

!testRun: #RondaDeTrucoTest #test12 stamp: 'pc 7/5/2021 19:56:06'!
FAILURE!

!testRun: #RondaDeTrucoTest #test12 stamp: 'pc 7/5/2021 19:56:06'!
FAILURE!
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 19:56:39' prior: 50915548!
test12
	| rondaDeTruco |
	
	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		vs: jugadorB
		.
	
	rondaDeTruco enfrentamientoCon: (CartaDeTruco bastoCon: 2) vs: (CartaDeTruco oroCon: 2) .
	rondaDeTruco enfrentamientoCon: (CartaDeTruco bastoCon: 7) vs: (CartaDeTruco copaCon: 7) .	
	
	self assert: (rondaDeTruco rondasJugadas) equals: 2.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorA) equals: 1.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorB) equals: 0.
	self assert: (rondaDeTruco ganador) equals: jugadorA .
	
	! !

!testRun: #RondaDeTrucoTest #test12 stamp: 'pc 7/5/2021 19:56:40'!
PASSED!

!testRun: #RondaDeTrucoTest #test01 stamp: 'pc 7/5/2021 19:56:40'!
PASSED!

!testRun: #RondaDeTrucoTest #test02 stamp: 'pc 7/5/2021 19:56:40'!
PASSED!

!testRun: #RondaDeTrucoTest #test03 stamp: 'pc 7/5/2021 19:56:40'!
PASSED!

!testRun: #RondaDeTrucoTest #test04 stamp: 'pc 7/5/2021 19:56:40'!
PASSED!

!testRun: #RondaDeTrucoTest #test05 stamp: 'pc 7/5/2021 19:56:40'!
PASSED!

!testRun: #RondaDeTrucoTest #test06 stamp: 'pc 7/5/2021 19:56:40'!
PASSED!

!testRun: #RondaDeTrucoTest #test07 stamp: 'pc 7/5/2021 19:56:40'!
PASSED!

!testRun: #RondaDeTrucoTest #test08 stamp: 'pc 7/5/2021 19:56:40'!
PASSED!

!testRun: #RondaDeTrucoTest #test09 stamp: 'pc 7/5/2021 19:56:40'!
PASSED!

!testRun: #RondaDeTrucoTest #test10 stamp: 'pc 7/5/2021 19:56:41'!
PASSED!

!testRun: #RondaDeTrucoTest #test11 stamp: 'pc 7/5/2021 19:56:41'!
PASSED!

!testRun: #RondaDeTrucoTest #test12 stamp: 'pc 7/5/2021 19:56:41'!
PASSED!
!RondaDeTruco methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 20:01:39' prior: 50915340!
enfrentamientoCon: cartaDeTrucoA vs: cartaDeTrucoB
	
	self revisarFinalizacionDeRonda.
	
	((cartasUsadas includes: cartaDeTrucoA) or: [(cartasUsadas includes: cartaDeTrucoB) or: [cartaDeTrucoA = cartaDeTrucoB ]]) ifTrue: [^self error: self class cartaRepetidaError].
	
	cartasUsadas add: cartaDeTrucoA.
	cartasUsadas add: cartaDeTrucoB.
	
	ronda := ronda + 1.
	(cartaDeTrucoA mataA: cartaDeTrucoB) ifTrue: [jugadores add: jugadorA ]. 
	(cartaDeTrucoB mataA: cartaDeTrucoA) ifTrue: [jugadores add: jugadorB].
	((cartaDeTrucoB empardaCon: cartaDeTrucoA) and: primerRondaParda) ifTrue: [jugadores add: self jugadorMano].
	(cartaDeTrucoB empardaCon: cartaDeTrucoA) ifTrue: [primerRondaParda := true].
! !
!RondaDeTruco methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 20:01:56'!
revisarFinalizacionDeRonda.
	
	((self enfretamientosGanadosPor: jugadorA) = 2 or: [(self enfretamientosGanadosPor: jugadorB) =2] ) ifTrue: [self error: self class noSePuedeJugarCuandoYaHayGanadorError].
! !
!RondaDeTruco methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 20:02:46' prior: 50915657!
enfrentamientoCon: cartaDeTrucoA vs: cartaDeTrucoB
	
	self revisarFinalizacionDeRonda.
	
	self revisarCartasRepetidasEntre: cartaDeTrucoA y: cartaDeTrucoB.
	
	cartasUsadas add: cartaDeTrucoA.
	cartasUsadas add: cartaDeTrucoB.
	
	ronda := ronda + 1.
	(cartaDeTrucoA mataA: cartaDeTrucoB) ifTrue: [jugadores add: jugadorA ]. 
	(cartaDeTrucoB mataA: cartaDeTrucoA) ifTrue: [jugadores add: jugadorB].
	((cartaDeTrucoB empardaCon: cartaDeTrucoA) and: primerRondaParda) ifTrue: [jugadores add: self jugadorMano].
	(cartaDeTrucoB empardaCon: cartaDeTrucoA) ifTrue: [primerRondaParda := true].
! !
!RondaDeTruco methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 20:03:00'!
revisarCartasRepetidasEntre: cartaDeTrucoA y: cartaDeTrucoB.
	
		((cartasUsadas includes: cartaDeTrucoA) or: [(cartasUsadas includes: cartaDeTrucoB) or: [cartaDeTrucoA = cartaDeTrucoB ]]) ifTrue: [^self error: self class cartaRepetidaError].
! !
!RondaDeTruco methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 20:03:37' prior: 50915692!
enfrentamientoCon: cartaDeTrucoA vs: cartaDeTrucoB
	
	self revisarFinalizacionDeRonda.
	
	self revisarCartasRepetidasEntre: cartaDeTrucoA y: cartaDeTrucoB.
	
	self utilizarCartas.
	
	ronda := ronda + 1.
	(cartaDeTrucoA mataA: cartaDeTrucoB) ifTrue: [jugadores add: jugadorA ]. 
	(cartaDeTrucoB mataA: cartaDeTrucoA) ifTrue: [jugadores add: jugadorB].
	((cartaDeTrucoB empardaCon: cartaDeTrucoA) and: primerRondaParda) ifTrue: [jugadores add: self jugadorMano].
	(cartaDeTrucoB empardaCon: cartaDeTrucoA) ifTrue: [primerRondaParda := true].
! !
!RondaDeTruco methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 20:04:42' prior: 50915724!
enfrentamientoCon: cartaDeTrucoA vs: cartaDeTrucoB
	
	self revisarFinalizacionDeRonda.
	
	self revisarCartasRepetidasEntre: cartaDeTrucoA y: cartaDeTrucoB.
	
	cartasUsadas add: cartaDeTrucoA.
	cartasUsadas add: cartaDeTrucoB.

	
	ronda := ronda + 1.
	(cartaDeTrucoA mataA: cartaDeTrucoB) ifTrue: [jugadores add: jugadorA ]. 
	(cartaDeTrucoB mataA: cartaDeTrucoA) ifTrue: [jugadores add: jugadorB].
	((cartaDeTrucoB empardaCon: cartaDeTrucoA) and: primerRondaParda) ifTrue: [jugadores add: self jugadorMano].
	(cartaDeTrucoB empardaCon: cartaDeTrucoA) ifTrue: [primerRondaParda := true].
! !
!RondaDeTruco methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 20:04:49' prior: 50915744!
enfrentamientoCon: cartaDeTrucoA vs: cartaDeTrucoB
	
	self revisarFinalizacionDeRonda.
	
	self revisarCartasRepetidasEntre: cartaDeTrucoA y: cartaDeTrucoB.
	
	cartasUsadas add: cartaDeTrucoA.
	cartasUsadas add: cartaDeTrucoB.

	ronda := ronda + 1.
	(cartaDeTrucoA mataA: cartaDeTrucoB) ifTrue: [jugadores add: jugadorA ]. 
	(cartaDeTrucoB mataA: cartaDeTrucoA) ifTrue: [jugadores add: jugadorB].
	((cartaDeTrucoB empardaCon: cartaDeTrucoA) and: primerRondaParda) ifTrue: [jugadores add: self jugadorMano].
	(cartaDeTrucoB empardaCon: cartaDeTrucoA) ifTrue: [primerRondaParda := true].
! !

!testRun: #CartaDeTrucoTest #test01SonIgualesConMismoPaloYNumero stamp: 'pc 7/5/2021 20:04:49'!
PASSED!

!testRun: #CartaDeTrucoTest #test02SonDistintasConDistintoPalo stamp: 'pc 7/5/2021 20:04:49'!
PASSED!

!testRun: #CartaDeTrucoTest #test03SonDistintasConNumeroAunqueIgualPalo stamp: 'pc 7/5/2021 20:04:49'!
PASSED!

!testRun: #CartaDeTrucoTest #test04CartasIgualesTienenElMismoHash stamp: 'pc 7/5/2021 20:04:49'!
PASSED!

!testRun: #CartaDeTrucoTest #test05UnaCartaEsDistintaACualquierObjetoQueNoSeaCarta stamp: 'pc 7/5/2021 20:04:49'!
PASSED!

!testRun: #CartaDeTrucoTest #test07NoHayCartaDeTrucoConNumeroOcho stamp: 'pc 7/5/2021 20:04:49'!
PASSED!

!testRun: #CartaDeTrucoTest #test08NoHayCartaDeTrucoConNumeroNueve stamp: 'pc 7/5/2021 20:04:49'!
PASSED!

!testRun: #CartaDeTrucoTest #test09LosPalosDeLaCartaDeTrucoSonBastoOroEspadaYCopa stamp: 'pc 7/5/2021 20:04:49'!
PASSED!

!testRun: #CartaDeTrucoTest #test10NoSePuedeCrearCartaConNumeroMenorAUno stamp: 'pc 7/5/2021 20:04:49'!
PASSED!

!testRun: #CartaDeTrucoTest #test11NoSePuedeCrearCartaConNumeroMayorADoce stamp: 'pc 7/5/2021 20:04:49'!
PASSED!

!testRun: #CartaDeTrucoTest #test12ElNumeroDeLaCartaDebeSerEntero stamp: 'pc 7/5/2021 20:04:49'!
PASSED!

!testRun: #CartaDeTrucoTest #test13LaTablaDeValoresEsCorrecta stamp: 'pc 7/5/2021 20:04:49'!
PASSED!

!testRun: #CartaDeTrucoTest #test14HayCartasQueNoSonPardas stamp: 'pc 7/5/2021 20:04:49'!
PASSED!

!testRun: #CartaDeTrucoTest #test15HayCartasQuePierdenConOtras stamp: 'pc 7/5/2021 20:04:49'!
PASSED!

!testRun: #CartaDeTrucoTest #test16SieteDeCopasYDeBastoEsSieteFalso stamp: 'pc 7/5/2021 20:04:49'!
PASSED!

!testRun: #CartaDeTrucoTest #test17SieteDeOroYDeEspadaNoSonSieteFalso stamp: 'pc 7/5/2021 20:04:49'!
PASSED!

!testRun: #CartaDeTrucoTest #test18AnchoDeOroYDeCopaSonAnchoFalsos stamp: 'pc 7/5/2021 20:04:49'!
PASSED!

!testRun: #CartaDeTrucoTest #test19AnchoDeEspadaYDeBastosNoSonAnchoFalsos stamp: 'pc 7/5/2021 20:04:49'!
PASSED!

!testRun: #CartaDeTrucoTest #test20FallaBuscandoValorDeCartaInv�lida stamp: 'pc 7/5/2021 20:04:49'!
PASSED!

!testRun: #RondaDeTrucoTest #test01 stamp: 'pc 7/5/2021 20:04:49'!
PASSED!

!testRun: #RondaDeTrucoTest #test02 stamp: 'pc 7/5/2021 20:04:49'!
PASSED!

!testRun: #RondaDeTrucoTest #test03 stamp: 'pc 7/5/2021 20:04:49'!
PASSED!

!testRun: #RondaDeTrucoTest #test04 stamp: 'pc 7/5/2021 20:04:49'!
PASSED!

!testRun: #RondaDeTrucoTest #test05 stamp: 'pc 7/5/2021 20:04:49'!
PASSED!

!testRun: #RondaDeTrucoTest #test06 stamp: 'pc 7/5/2021 20:04:49'!
PASSED!

!testRun: #RondaDeTrucoTest #test07 stamp: 'pc 7/5/2021 20:04:49'!
PASSED!

!testRun: #RondaDeTrucoTest #test08 stamp: 'pc 7/5/2021 20:04:49'!
PASSED!

!testRun: #RondaDeTrucoTest #test09 stamp: 'pc 7/5/2021 20:04:49'!
PASSED!

!testRun: #RondaDeTrucoTest #test10 stamp: 'pc 7/5/2021 20:04:49'!
PASSED!

!testRun: #RondaDeTrucoTest #test11 stamp: 'pc 7/5/2021 20:04:49'!
PASSED!

!testRun: #RondaDeTrucoTest #test12 stamp: 'pc 7/5/2021 20:04:49'!
PASSED!

!classDefinition: #RondaDeTruco category: 'ISW1-2021-1C-2doParcial' stamp: 'pc 7/5/2021 20:06:33'!
Object subclass: #RondaDeTruco
	instanceVariableNames: 'jugadorA jugadorB cartasDeB ronda jugadores primerRondaParda cartasUsadas'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial'!

!classDefinition: #RondaDeTruco category: 'ISW1-2021-1C-2doParcial' stamp: 'pc 7/5/2021 20:06:33'!
Object subclass: #RondaDeTruco
	instanceVariableNames: 'jugadorA jugadorB ronda jugadores primerRondaParda cartasUsadas'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial'!
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 20:09:17'!
test13
	| rondaDeTruco |
	
	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		vs: jugadorB
		.
	
	rondaDeTruco jugar.
	
	self assert: (rondaDeTruco rondasJugadas) equals: 3.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorA) equals: 1.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorB) equals: 0.
	self assert: (rondaDeTruco ganador) equals: jugadorA .
	
	! !

!testRun: #RondaDeTrucoTest #test13 stamp: 'pc 7/5/2021 20:09:20'!
ERROR!
!RondaDeTruco methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 20:09:39'!
jugar
	self shouldBeImplemented.! !
!RondaDeTruco methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 20:10:17' prior: 50915918!
jugar
	
	self enfrentamientoCon: (CartaDeTruco oroCon: 4) vs: (CartaDeTruco oroCon: 2) .
	self enfrentamientoCon: CartaDeTruco anchoDeEspada vs: 	CartaDeTruco anchoDeBasto. 
	self enfrentamientoCon: (CartaDeTruco copaCon: 3) vs: (CartaDeTruco copaCon: 4) .! !
!RondaDeTruco methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 20:12:33' prior: 50915923!
jugar
	
	self enfrentamientoCon: jugadorA first vs: jugadorB first.
	self enfrentamientoCon:  jugadorA second vs: 	 jugadorB second. 
	self enfrentamientoCon:  jugadorA third vs:  jugadorB third.! !

!testRun: #RondaDeTrucoTest #test13 stamp: 'pc 7/5/2021 20:12:48'!
ERROR!
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 20:14:34' prior: 50911503 overrides: 16927572!
setUp

	jugadorA := OrderedCollection new.
	jugadorB := OrderedCollection new.! !

!testRun: #CartaDeTrucoTest #test01SonIgualesConMismoPaloYNumero stamp: 'pc 7/5/2021 20:14:35'!
PASSED!

!testRun: #CartaDeTrucoTest #test02SonDistintasConDistintoPalo stamp: 'pc 7/5/2021 20:14:35'!
PASSED!

!testRun: #CartaDeTrucoTest #test03SonDistintasConNumeroAunqueIgualPalo stamp: 'pc 7/5/2021 20:14:35'!
PASSED!

!testRun: #CartaDeTrucoTest #test04CartasIgualesTienenElMismoHash stamp: 'pc 7/5/2021 20:14:35'!
PASSED!

!testRun: #CartaDeTrucoTest #test05UnaCartaEsDistintaACualquierObjetoQueNoSeaCarta stamp: 'pc 7/5/2021 20:14:35'!
PASSED!

!testRun: #CartaDeTrucoTest #test07NoHayCartaDeTrucoConNumeroOcho stamp: 'pc 7/5/2021 20:14:35'!
PASSED!

!testRun: #CartaDeTrucoTest #test08NoHayCartaDeTrucoConNumeroNueve stamp: 'pc 7/5/2021 20:14:35'!
PASSED!

!testRun: #CartaDeTrucoTest #test09LosPalosDeLaCartaDeTrucoSonBastoOroEspadaYCopa stamp: 'pc 7/5/2021 20:14:35'!
PASSED!

!testRun: #CartaDeTrucoTest #test10NoSePuedeCrearCartaConNumeroMenorAUno stamp: 'pc 7/5/2021 20:14:35'!
PASSED!

!testRun: #CartaDeTrucoTest #test11NoSePuedeCrearCartaConNumeroMayorADoce stamp: 'pc 7/5/2021 20:14:35'!
PASSED!

!testRun: #CartaDeTrucoTest #test12ElNumeroDeLaCartaDebeSerEntero stamp: 'pc 7/5/2021 20:14:35'!
PASSED!

!testRun: #CartaDeTrucoTest #test13LaTablaDeValoresEsCorrecta stamp: 'pc 7/5/2021 20:14:35'!
PASSED!

!testRun: #CartaDeTrucoTest #test14HayCartasQueNoSonPardas stamp: 'pc 7/5/2021 20:14:35'!
PASSED!

!testRun: #CartaDeTrucoTest #test15HayCartasQuePierdenConOtras stamp: 'pc 7/5/2021 20:14:35'!
PASSED!

!testRun: #CartaDeTrucoTest #test16SieteDeCopasYDeBastoEsSieteFalso stamp: 'pc 7/5/2021 20:14:35'!
PASSED!

!testRun: #CartaDeTrucoTest #test17SieteDeOroYDeEspadaNoSonSieteFalso stamp: 'pc 7/5/2021 20:14:35'!
PASSED!

!testRun: #CartaDeTrucoTest #test18AnchoDeOroYDeCopaSonAnchoFalsos stamp: 'pc 7/5/2021 20:14:35'!
PASSED!

!testRun: #CartaDeTrucoTest #test19AnchoDeEspadaYDeBastosNoSonAnchoFalsos stamp: 'pc 7/5/2021 20:14:35'!
PASSED!

!testRun: #CartaDeTrucoTest #test20FallaBuscandoValorDeCartaInv�lida stamp: 'pc 7/5/2021 20:14:35'!
PASSED!

!testRun: #RondaDeTrucoTest #test01 stamp: 'pc 7/5/2021 20:14:35'!
PASSED!

!testRun: #RondaDeTrucoTest #test02 stamp: 'pc 7/5/2021 20:14:35'!
FAILURE!

!testRun: #RondaDeTrucoTest #test03 stamp: 'pc 7/5/2021 20:14:35'!
PASSED!

!testRun: #RondaDeTrucoTest #test04 stamp: 'pc 7/5/2021 20:14:35'!
FAILURE!

!testRun: #RondaDeTrucoTest #test05 stamp: 'pc 7/5/2021 20:14:35'!
FAILURE!

!testRun: #RondaDeTrucoTest #test06 stamp: 'pc 7/5/2021 20:14:35'!
ERROR!

!testRun: #RondaDeTrucoTest #test07 stamp: 'pc 7/5/2021 20:14:35'!
FAILURE!

!testRun: #RondaDeTrucoTest #test08 stamp: 'pc 7/5/2021 20:14:35'!
PASSED!

!testRun: #RondaDeTrucoTest #test09 stamp: 'pc 7/5/2021 20:14:35'!
PASSED!

!testRun: #RondaDeTrucoTest #test10 stamp: 'pc 7/5/2021 20:14:36'!
PASSED!

!testRun: #RondaDeTrucoTest #test11 stamp: 'pc 7/5/2021 20:14:36'!
FAILURE!

!testRun: #RondaDeTrucoTest #test12 stamp: 'pc 7/5/2021 20:14:36'!
FAILURE!

!testRun: #RondaDeTrucoTest #test13 stamp: 'pc 7/5/2021 20:14:36'!
ERROR!

!testRun: #RondaDeTrucoTest #test06 stamp: 'pc 7/5/2021 20:14:38'!
ERROR!
!RondaDeTruco methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 20:15:03' prior: 50915682!
revisarFinalizacionDeRonda.
	
	((self enfretamientosGanadosPor: #A) = 2 or: [(self enfretamientosGanadosPor: #B) =2] ) ifTrue: [self error: self class noSePuedeJugarCuandoYaHayGanadorError].
! !

!testRun: #RondaDeTrucoTest #test06 stamp: 'pc 7/5/2021 20:15:04'!
FAILURE!

!testRun: #CartaDeTrucoTest #test01SonIgualesConMismoPaloYNumero stamp: 'pc 7/5/2021 20:15:13'!
PASSED!

!testRun: #CartaDeTrucoTest #test02SonDistintasConDistintoPalo stamp: 'pc 7/5/2021 20:15:13'!
PASSED!

!testRun: #CartaDeTrucoTest #test03SonDistintasConNumeroAunqueIgualPalo stamp: 'pc 7/5/2021 20:15:13'!
PASSED!

!testRun: #CartaDeTrucoTest #test04CartasIgualesTienenElMismoHash stamp: 'pc 7/5/2021 20:15:13'!
PASSED!

!testRun: #CartaDeTrucoTest #test05UnaCartaEsDistintaACualquierObjetoQueNoSeaCarta stamp: 'pc 7/5/2021 20:15:13'!
PASSED!

!testRun: #CartaDeTrucoTest #test07NoHayCartaDeTrucoConNumeroOcho stamp: 'pc 7/5/2021 20:15:13'!
PASSED!

!testRun: #CartaDeTrucoTest #test08NoHayCartaDeTrucoConNumeroNueve stamp: 'pc 7/5/2021 20:15:13'!
PASSED!

!testRun: #CartaDeTrucoTest #test09LosPalosDeLaCartaDeTrucoSonBastoOroEspadaYCopa stamp: 'pc 7/5/2021 20:15:13'!
PASSED!

!testRun: #CartaDeTrucoTest #test10NoSePuedeCrearCartaConNumeroMenorAUno stamp: 'pc 7/5/2021 20:15:13'!
PASSED!

!testRun: #CartaDeTrucoTest #test11NoSePuedeCrearCartaConNumeroMayorADoce stamp: 'pc 7/5/2021 20:15:13'!
PASSED!

!testRun: #CartaDeTrucoTest #test12ElNumeroDeLaCartaDebeSerEntero stamp: 'pc 7/5/2021 20:15:13'!
PASSED!

!testRun: #CartaDeTrucoTest #test13LaTablaDeValoresEsCorrecta stamp: 'pc 7/5/2021 20:15:13'!
PASSED!

!testRun: #CartaDeTrucoTest #test14HayCartasQueNoSonPardas stamp: 'pc 7/5/2021 20:15:13'!
PASSED!

!testRun: #CartaDeTrucoTest #test15HayCartasQuePierdenConOtras stamp: 'pc 7/5/2021 20:15:13'!
PASSED!

!testRun: #CartaDeTrucoTest #test16SieteDeCopasYDeBastoEsSieteFalso stamp: 'pc 7/5/2021 20:15:13'!
PASSED!

!testRun: #CartaDeTrucoTest #test17SieteDeOroYDeEspadaNoSonSieteFalso stamp: 'pc 7/5/2021 20:15:13'!
PASSED!

!testRun: #CartaDeTrucoTest #test18AnchoDeOroYDeCopaSonAnchoFalsos stamp: 'pc 7/5/2021 20:15:13'!
PASSED!

!testRun: #CartaDeTrucoTest #test19AnchoDeEspadaYDeBastosNoSonAnchoFalsos stamp: 'pc 7/5/2021 20:15:13'!
PASSED!

!testRun: #CartaDeTrucoTest #test20FallaBuscandoValorDeCartaInv�lida stamp: 'pc 7/5/2021 20:15:13'!
PASSED!

!testRun: #RondaDeTrucoTest #test01 stamp: 'pc 7/5/2021 20:15:13'!
PASSED!

!testRun: #RondaDeTrucoTest #test03 stamp: 'pc 7/5/2021 20:15:13'!
PASSED!

!testRun: #RondaDeTrucoTest #test08 stamp: 'pc 7/5/2021 20:15:13'!
PASSED!

!testRun: #RondaDeTrucoTest #test09 stamp: 'pc 7/5/2021 20:15:13'!
PASSED!

!testRun: #RondaDeTrucoTest #test10 stamp: 'pc 7/5/2021 20:15:13'!
PASSED!

!testRun: #RondaDeTrucoTest #test06 stamp: 'pc 7/5/2021 20:15:13'!
FAILURE!

!testRun: #RondaDeTrucoTest #test13 stamp: 'pc 7/5/2021 20:15:13'!
ERROR!

!testRun: #RondaDeTrucoTest #test02 stamp: 'pc 7/5/2021 20:15:13'!
FAILURE!

!testRun: #RondaDeTrucoTest #test04 stamp: 'pc 7/5/2021 20:15:13'!
FAILURE!

!testRun: #RondaDeTrucoTest #test05 stamp: 'pc 7/5/2021 20:15:13'!
FAILURE!

!testRun: #RondaDeTrucoTest #test07 stamp: 'pc 7/5/2021 20:15:13'!
FAILURE!

!testRun: #RondaDeTrucoTest #test11 stamp: 'pc 7/5/2021 20:15:13'!
FAILURE!

!testRun: #RondaDeTrucoTest #test12 stamp: 'pc 7/5/2021 20:15:13'!
FAILURE!

!testRun: #RondaDeTrucoTest #test13 stamp: 'pc 7/5/2021 20:15:16'!
ERROR!
!RondaDeTruco methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 20:16:01' prior: 50915766!
enfrentamientoCon: cartaDeTrucoA vs: cartaDeTrucoB
	
	self revisarFinalizacionDeRonda.
	
	self revisarCartasRepetidasEntre: cartaDeTrucoA y: cartaDeTrucoB.
	
	cartasUsadas add: cartaDeTrucoA.
	cartasUsadas add: cartaDeTrucoB.

	ronda := ronda + 1.
	(cartaDeTrucoA mataA: cartaDeTrucoB) ifTrue: [jugadores add: #A ]. 
	(cartaDeTrucoB mataA: cartaDeTrucoA) ifTrue: [jugadores add: #B].
	((cartaDeTrucoB empardaCon: cartaDeTrucoA) and: primerRondaParda) ifTrue: [jugadores add: self jugadorMano].
	(cartaDeTrucoB empardaCon: cartaDeTrucoA) ifTrue: [primerRondaParda := true].
! !
!RondaDeTruco methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 20:16:07' prior: 50915389!
jugadorMano
	^#A! !

!methodRemoval: RondaDeTruco #mano stamp: 'pc 7/5/2021 20:16:22'!
mano
	^jugadorA !
!RondaDeTruco methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 20:17:24' prior: 50914984!
ganador
	
	ronda = 3 ifTrue:[
		((jugadores occurrencesOf: #A) > (jugadores occurrencesOf: #B)) ifTrue: [^#A ] ifFalse: [^#A]].
	(ronda = 2 and: [primerRondaParda or: [(self enfretamientosGanadosPor: #A) = 2 or: [(self enfretamientosGanadosPor: #B) =2] ]]) ifTrue:[
		((jugadores occurrencesOf: #A) > (jugadores occurrencesOf: #B)) ifTrue: [^#A ] ifFalse: [^#B ]].
	
	self error: self class noTerminoLaRondaTodavia.! !

!testRun: #CartaDeTrucoTest #test01SonIgualesConMismoPaloYNumero stamp: 'pc 7/5/2021 20:17:25'!
PASSED!

!testRun: #CartaDeTrucoTest #test02SonDistintasConDistintoPalo stamp: 'pc 7/5/2021 20:17:25'!
PASSED!

!testRun: #CartaDeTrucoTest #test03SonDistintasConNumeroAunqueIgualPalo stamp: 'pc 7/5/2021 20:17:25'!
PASSED!

!testRun: #CartaDeTrucoTest #test04CartasIgualesTienenElMismoHash stamp: 'pc 7/5/2021 20:17:25'!
PASSED!

!testRun: #CartaDeTrucoTest #test05UnaCartaEsDistintaACualquierObjetoQueNoSeaCarta stamp: 'pc 7/5/2021 20:17:25'!
PASSED!

!testRun: #CartaDeTrucoTest #test07NoHayCartaDeTrucoConNumeroOcho stamp: 'pc 7/5/2021 20:17:25'!
PASSED!

!testRun: #CartaDeTrucoTest #test08NoHayCartaDeTrucoConNumeroNueve stamp: 'pc 7/5/2021 20:17:25'!
PASSED!

!testRun: #CartaDeTrucoTest #test09LosPalosDeLaCartaDeTrucoSonBastoOroEspadaYCopa stamp: 'pc 7/5/2021 20:17:25'!
PASSED!

!testRun: #CartaDeTrucoTest #test10NoSePuedeCrearCartaConNumeroMenorAUno stamp: 'pc 7/5/2021 20:17:25'!
PASSED!

!testRun: #CartaDeTrucoTest #test11NoSePuedeCrearCartaConNumeroMayorADoce stamp: 'pc 7/5/2021 20:17:25'!
PASSED!

!testRun: #CartaDeTrucoTest #test12ElNumeroDeLaCartaDebeSerEntero stamp: 'pc 7/5/2021 20:17:25'!
PASSED!

!testRun: #CartaDeTrucoTest #test13LaTablaDeValoresEsCorrecta stamp: 'pc 7/5/2021 20:17:25'!
PASSED!

!testRun: #CartaDeTrucoTest #test14HayCartasQueNoSonPardas stamp: 'pc 7/5/2021 20:17:25'!
PASSED!

!testRun: #CartaDeTrucoTest #test15HayCartasQuePierdenConOtras stamp: 'pc 7/5/2021 20:17:25'!
PASSED!

!testRun: #CartaDeTrucoTest #test16SieteDeCopasYDeBastoEsSieteFalso stamp: 'pc 7/5/2021 20:17:25'!
PASSED!

!testRun: #CartaDeTrucoTest #test17SieteDeOroYDeEspadaNoSonSieteFalso stamp: 'pc 7/5/2021 20:17:25'!
PASSED!

!testRun: #CartaDeTrucoTest #test18AnchoDeOroYDeCopaSonAnchoFalsos stamp: 'pc 7/5/2021 20:17:25'!
PASSED!

!testRun: #CartaDeTrucoTest #test19AnchoDeEspadaYDeBastosNoSonAnchoFalsos stamp: 'pc 7/5/2021 20:17:25'!
PASSED!

!testRun: #CartaDeTrucoTest #test20FallaBuscandoValorDeCartaInv�lida stamp: 'pc 7/5/2021 20:17:25'!
PASSED!

!testRun: #RondaDeTrucoTest #test01 stamp: 'pc 7/5/2021 20:17:25'!
PASSED!

!testRun: #RondaDeTrucoTest #test02 stamp: 'pc 7/5/2021 20:17:25'!
FAILURE!

!testRun: #RondaDeTrucoTest #test03 stamp: 'pc 7/5/2021 20:17:25'!
PASSED!

!testRun: #RondaDeTrucoTest #test04 stamp: 'pc 7/5/2021 20:17:25'!
FAILURE!

!testRun: #RondaDeTrucoTest #test05 stamp: 'pc 7/5/2021 20:17:25'!
FAILURE!

!testRun: #RondaDeTrucoTest #test06 stamp: 'pc 7/5/2021 20:17:25'!
FAILURE!

!testRun: #RondaDeTrucoTest #test07 stamp: 'pc 7/5/2021 20:17:25'!
FAILURE!

!testRun: #RondaDeTrucoTest #test08 stamp: 'pc 7/5/2021 20:17:25'!
PASSED!

!testRun: #RondaDeTrucoTest #test09 stamp: 'pc 7/5/2021 20:17:25'!
PASSED!

!testRun: #RondaDeTrucoTest #test10 stamp: 'pc 7/5/2021 20:17:25'!
PASSED!

!testRun: #RondaDeTrucoTest #test11 stamp: 'pc 7/5/2021 20:17:25'!
FAILURE!

!testRun: #RondaDeTrucoTest #test12 stamp: 'pc 7/5/2021 20:17:25'!
FAILURE!

!testRun: #RondaDeTrucoTest #test13 stamp: 'pc 7/5/2021 20:17:25'!
ERROR!

!testRun: #RondaDeTrucoTest #test13 stamp: 'pc 7/5/2021 20:17:27'!
ERROR!

!testRun: #RondaDeTrucoTest #test13 stamp: 'pc 7/5/2021 20:17:34'!
ERROR!

!testRun: #RondaDeTrucoTest #test02 stamp: 'pc 7/5/2021 20:17:40'!
FAILURE!
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 20:18:12' prior: 50914378!
test02
	| rondaDeTruco |

	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		vs: jugadorB
		.
	
	rondaDeTruco enfrentamientoCon: CartaDeTruco anchoDeEspada vs: CartaDeTruco anchoDeBasto.
		
		
	self assert: (rondaDeTruco rondasJugadas) equals: 1.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorA) equals: 1.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorB) equals: 0.! !

Object subclass: #jugador
	instanceVariableNames: 'nombre cartas'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial'!

Object subclass: #Jugador
	instanceVariableNames: 'nombre cartas'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial'!

!classDefinition: #Jugador category: 'ISW1-2021-1C-2doParcial' stamp: 'pc 7/5/2021 20:19:12'!
Object subclass: #Jugador
	instanceVariableNames: 'nombre cartas'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial'!
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 20:21:03' prior: 50915948 overrides: 16927572!
setUp

	
	jugadorA := Jugador llamado: #A.
	jugadorB := Jugador llamado: #B.! !
!Jugador class methodsFor: 'no messages' stamp: 'pc 7/5/2021 20:21:37'!
llamado: unNombre
	
	self new initializeWith: unNombre! !
!Jugador methodsFor: 'no messages' stamp: 'pc 7/5/2021 20:22:17'!
initializeWith: unNombre
	nombre := unNombre.
	cartas := OrderedCollection new.! !
!Jugador methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 20:22:48'!
conCartas: tresCartas

	cartas addAll: tresCartas .! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 20:22:59' prior: 50916343 overrides: 16927572!
setUp

	jugadorA := Jugador llamado: #A.
	jugadorB := Jugador llamado: #B.! !
!Jugador methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 20:23:40'!
nombre
	^nombre! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 20:23:58' prior: 50916309!
test02
	| rondaDeTruco |

	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		vs: jugadorB
		.
	
	rondaDeTruco enfrentamientoCon: CartaDeTruco anchoDeEspada vs: CartaDeTruco anchoDeBasto.
		
		
	self assert: (rondaDeTruco rondasJugadas) equals: 1.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorA nombre) equals: 1.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorB nombre) equals: 0.! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 20:24:21' prior: 50915291!
test03
	| rondaDeTruco |
	
	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		vs: jugadorB
		.
	
	rondaDeTruco enfrentamientoCon: (CartaDeTruco bastoCon: 2) vs: (CartaDeTruco oroCon: 2) .
	
	self assert: (rondaDeTruco rondasJugadas) equals: 1.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorA) equals: 0.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorB) equals: 0.
	! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 20:24:28' prior: 50916372!
test02
	| rondaDeTruco |

	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		vs: jugadorB
		.
	
	rondaDeTruco enfrentamientoCon: CartaDeTruco anchoDeEspada vs: CartaDeTruco anchoDeBasto.
		
		
	self assert: (rondaDeTruco rondasJugadas) equals: 1.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorA) equals: 1.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorB) equals: 0.! !
!RondaDeTruco methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 20:24:37' prior: 50912523!
enfretamientosGanadosPor: unJugador 
	
	^jugadores occurrencesOf: unJugador nombre.! !
!RondaDeTruco methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 20:25:14' prior: 50916162!
enfrentamientoCon: cartaDeTrucoA vs: cartaDeTrucoB
	
	self revisarFinalizacionDeRonda.
	
	self revisarCartasRepetidasEntre: cartaDeTrucoA y: cartaDeTrucoB.
	
	cartasUsadas add: cartaDeTrucoA.
	cartasUsadas add: cartaDeTrucoB.

	ronda := ronda + 1.
	(cartaDeTrucoA mataA: cartaDeTrucoB) ifTrue: [jugadores add: jugadorA nombre]. 
	(cartaDeTrucoB mataA: cartaDeTrucoA) ifTrue: [jugadores add:jugadorB nombre].
	((cartaDeTrucoB empardaCon: cartaDeTrucoA) and: primerRondaParda) ifTrue: [jugadores add: self jugadorMano].
	(cartaDeTrucoB empardaCon: cartaDeTrucoA) ifTrue: [primerRondaParda := true].
! !
!RondaDeTruco methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 20:26:20' prior: 50916190!
ganador
	
	ronda = 3 ifTrue:[
		((jugadores occurrencesOf: jugadorA nombre) > (jugadores occurrencesOf: jugadorB nombre)) ifTrue: [^jugadorA nombre ] ifFalse: [^jugadorB nombre]].
	(ronda = 2 and: [primerRondaParda or: [(self enfretamientosGanadosPor: jugadorA nombre) = 2 or: [(self enfretamientosGanadosPor: jugadorB nombre) =2] ]]) ifTrue:[
		((jugadores occurrencesOf: jugadorA nombre) > (jugadores occurrencesOf: jugadorB nombre)) ifTrue: [^jugadorA nombre ] ifFalse: [^jugadorB nombre]].
	
	self error: self class noTerminoLaRondaTodavia.! !
!RondaDeTruco methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 20:26:49' prior: 50916183!
jugadorMano
	^jugadorA nombre! !
!RondaDeTruco methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 20:27:17' prior: 50916052!
revisarFinalizacionDeRonda.
	
	((self enfretamientosGanadosPor: jugadorA nombre) = 2 or: [(self enfretamientosGanadosPor: jugadorB nombre) =2] ) ifTrue: [self error: self class noSePuedeJugarCuandoYaHayGanadorError].
! !

!testRun: #RondaDeTrucoTest #test12 stamp: 'pc 7/5/2021 20:27:31'!
ERROR!

!testRun: #RondaDeTrucoTest #test12 stamp: 'pc 7/5/2021 20:27:31'!
ERROR!
!Jugador class methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 20:28:08' prior: 50916348!
llamado: unNombre
	
	^self new initializeWith: unNombre! !

!testRun: #RondaDeTrucoTest #test03 stamp: 'pc 7/5/2021 20:28:16'!
ERROR!

!testRun: #RondaDeTrucoTest #test03 stamp: 'pc 7/5/2021 20:28:16'!
ERROR!
!RondaDeTruco methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 20:29:07' prior: 50916474!
revisarFinalizacionDeRonda.
	
	((self enfretamientosGanadosPor: jugadorA ) = 2 or: [(self enfretamientosGanadosPor: jugadorB ) =2] ) ifTrue: [self error: self class noSePuedeJugarCuandoYaHayGanadorError].
! !

!testRun: #RondaDeTrucoTest #test03 stamp: 'pc 7/5/2021 20:29:09'!
PASSED!

!testRun: #RondaDeTrucoTest #test03 stamp: 'pc 7/5/2021 20:29:16'!
PASSED!

!testRun: #RondaDeTrucoTest #test03 stamp: 'pc 7/5/2021 20:29:19'!
PASSED!

!testRun: #RondaDeTrucoTest #test01 stamp: 'pc 7/5/2021 20:29:19'!
PASSED!

!testRun: #RondaDeTrucoTest #test02 stamp: 'pc 7/5/2021 20:29:19'!
PASSED!

!testRun: #RondaDeTrucoTest #test03 stamp: 'pc 7/5/2021 20:29:19'!
PASSED!

!testRun: #RondaDeTrucoTest #test04 stamp: 'pc 7/5/2021 20:29:19'!
FAILURE!

!testRun: #RondaDeTrucoTest #test05 stamp: 'pc 7/5/2021 20:29:19'!
FAILURE!

!testRun: #RondaDeTrucoTest #test06 stamp: 'pc 7/5/2021 20:29:19'!
FAILURE!

!testRun: #RondaDeTrucoTest #test07 stamp: 'pc 7/5/2021 20:29:19'!
FAILURE!

!testRun: #RondaDeTrucoTest #test08 stamp: 'pc 7/5/2021 20:29:19'!
PASSED!

!testRun: #RondaDeTrucoTest #test09 stamp: 'pc 7/5/2021 20:29:19'!
PASSED!

!testRun: #RondaDeTrucoTest #test10 stamp: 'pc 7/5/2021 20:29:19'!
PASSED!

!testRun: #RondaDeTrucoTest #test11 stamp: 'pc 7/5/2021 20:29:19'!
ERROR!

!testRun: #RondaDeTrucoTest #test12 stamp: 'pc 7/5/2021 20:29:19'!
FAILURE!

!testRun: #RondaDeTrucoTest #test13 stamp: 'pc 7/5/2021 20:29:19'!
ERROR!

!testRun: #RondaDeTrucoTest #test04 stamp: 'pc 7/5/2021 20:29:22'!
FAILURE!
!RondaDeTruco methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 20:30:11' prior: 50916449!
ganador
	
	ronda = 3 ifTrue:[
		((jugadores occurrencesOf: jugadorA nombre) > (jugadores occurrencesOf: jugadorB nombre)) ifTrue: [^jugadorA  ] ifFalse: [^jugadorB ]].
	(ronda = 2 and: [primerRondaParda or: [(self enfretamientosGanadosPor: jugadorA nombre) = 2 or: [(self enfretamientosGanadosPor: jugadorB nombre) =2] ]]) ifTrue:[
		((jugadores occurrencesOf: jugadorA nombre) > (jugadores occurrencesOf: jugadorB nombre)) ifTrue: [^jugadorA  ] ifFalse: [^jugadorB ]].
	
	self error: self class noTerminoLaRondaTodavia.! !

!testRun: #CartaDeTrucoTest #test01SonIgualesConMismoPaloYNumero stamp: 'pc 7/5/2021 20:30:14'!
PASSED!

!testRun: #CartaDeTrucoTest #test02SonDistintasConDistintoPalo stamp: 'pc 7/5/2021 20:30:14'!
PASSED!

!testRun: #CartaDeTrucoTest #test03SonDistintasConNumeroAunqueIgualPalo stamp: 'pc 7/5/2021 20:30:14'!
PASSED!

!testRun: #CartaDeTrucoTest #test04CartasIgualesTienenElMismoHash stamp: 'pc 7/5/2021 20:30:14'!
PASSED!

!testRun: #CartaDeTrucoTest #test05UnaCartaEsDistintaACualquierObjetoQueNoSeaCarta stamp: 'pc 7/5/2021 20:30:14'!
PASSED!

!testRun: #CartaDeTrucoTest #test07NoHayCartaDeTrucoConNumeroOcho stamp: 'pc 7/5/2021 20:30:14'!
PASSED!

!testRun: #CartaDeTrucoTest #test08NoHayCartaDeTrucoConNumeroNueve stamp: 'pc 7/5/2021 20:30:14'!
PASSED!

!testRun: #CartaDeTrucoTest #test09LosPalosDeLaCartaDeTrucoSonBastoOroEspadaYCopa stamp: 'pc 7/5/2021 20:30:14'!
PASSED!

!testRun: #CartaDeTrucoTest #test10NoSePuedeCrearCartaConNumeroMenorAUno stamp: 'pc 7/5/2021 20:30:14'!
PASSED!

!testRun: #CartaDeTrucoTest #test11NoSePuedeCrearCartaConNumeroMayorADoce stamp: 'pc 7/5/2021 20:30:14'!
PASSED!

!testRun: #CartaDeTrucoTest #test12ElNumeroDeLaCartaDebeSerEntero stamp: 'pc 7/5/2021 20:30:14'!
PASSED!

!testRun: #CartaDeTrucoTest #test13LaTablaDeValoresEsCorrecta stamp: 'pc 7/5/2021 20:30:14'!
PASSED!

!testRun: #CartaDeTrucoTest #test14HayCartasQueNoSonPardas stamp: 'pc 7/5/2021 20:30:14'!
PASSED!

!testRun: #CartaDeTrucoTest #test15HayCartasQuePierdenConOtras stamp: 'pc 7/5/2021 20:30:14'!
PASSED!

!testRun: #CartaDeTrucoTest #test16SieteDeCopasYDeBastoEsSieteFalso stamp: 'pc 7/5/2021 20:30:14'!
PASSED!

!testRun: #CartaDeTrucoTest #test17SieteDeOroYDeEspadaNoSonSieteFalso stamp: 'pc 7/5/2021 20:30:14'!
PASSED!

!testRun: #CartaDeTrucoTest #test18AnchoDeOroYDeCopaSonAnchoFalsos stamp: 'pc 7/5/2021 20:30:14'!
PASSED!

!testRun: #CartaDeTrucoTest #test19AnchoDeEspadaYDeBastosNoSonAnchoFalsos stamp: 'pc 7/5/2021 20:30:14'!
PASSED!

!testRun: #CartaDeTrucoTest #test20FallaBuscandoValorDeCartaInv�lida stamp: 'pc 7/5/2021 20:30:14'!
PASSED!

!testRun: #RondaDeTrucoTest #test01 stamp: 'pc 7/5/2021 20:30:14'!
PASSED!

!testRun: #RondaDeTrucoTest #test02 stamp: 'pc 7/5/2021 20:30:14'!
PASSED!

!testRun: #RondaDeTrucoTest #test03 stamp: 'pc 7/5/2021 20:30:14'!
PASSED!

!testRun: #RondaDeTrucoTest #test04 stamp: 'pc 7/5/2021 20:30:14'!
PASSED!

!testRun: #RondaDeTrucoTest #test05 stamp: 'pc 7/5/2021 20:30:14'!
PASSED!

!testRun: #RondaDeTrucoTest #test06 stamp: 'pc 7/5/2021 20:30:14'!
PASSED!

!testRun: #RondaDeTrucoTest #test07 stamp: 'pc 7/5/2021 20:30:14'!
PASSED!

!testRun: #RondaDeTrucoTest #test08 stamp: 'pc 7/5/2021 20:30:14'!
PASSED!

!testRun: #RondaDeTrucoTest #test09 stamp: 'pc 7/5/2021 20:30:14'!
PASSED!

!testRun: #RondaDeTrucoTest #test10 stamp: 'pc 7/5/2021 20:30:14'!
PASSED!

!testRun: #RondaDeTrucoTest #test11 stamp: 'pc 7/5/2021 20:30:14'!
ERROR!

!testRun: #RondaDeTrucoTest #test12 stamp: 'pc 7/5/2021 20:30:14'!
PASSED!

!testRun: #RondaDeTrucoTest #test13 stamp: 'pc 7/5/2021 20:30:14'!
ERROR!

!testRun: #RondaDeTrucoTest #test11 stamp: 'pc 7/5/2021 20:30:16'!
ERROR!
!RondaDeTruco methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 20:30:43' prior: 50916549!
ganador
	
	ronda = 3 ifTrue:[
		((jugadores occurrencesOf: jugadorA nombre) > (jugadores occurrencesOf: jugadorB nombre)) ifTrue: [^jugadorA  ] ifFalse: [^jugadorB ]].
	(ronda = 2 and: [primerRondaParda or: [(self enfretamientosGanadosPor: jugadorA ) = 2 or: [(self enfretamientosGanadosPor: jugadorB nombre) =2] ]]) ifTrue:[
		((jugadores occurrencesOf: jugadorA nombre) > (jugadores occurrencesOf: jugadorB nombre)) ifTrue: [^jugadorA  ] ifFalse: [^jugadorB ]].
	
	self error: self class noTerminoLaRondaTodavia.! !

!testRun: #RondaDeTrucoTest #test11 stamp: 'pc 7/5/2021 20:30:45'!
ERROR!
!RondaDeTruco methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 20:30:54' prior: 50916667!
ganador
	
	ronda = 3 ifTrue:[
		((jugadores occurrencesOf: jugadorA nombre) > (jugadores occurrencesOf: jugadorB nombre)) ifTrue: [^jugadorA  ] ifFalse: [^jugadorB ]].
	(ronda = 2 and: [primerRondaParda or: [(self enfretamientosGanadosPor: jugadorA ) = 2 or: [(self enfretamientosGanadosPor: jugadorB ) =2] ]]) ifTrue:[
		((jugadores occurrencesOf: jugadorA nombre) > (jugadores occurrencesOf: jugadorB nombre)) ifTrue: [^jugadorA  ] ifFalse: [^jugadorB ]].
	
	self error: self class noTerminoLaRondaTodavia.! !

!testRun: #RondaDeTrucoTest #test11 stamp: 'pc 7/5/2021 20:31:03'!
PASSED!

!testRun: #CartaDeTrucoTest #test01SonIgualesConMismoPaloYNumero stamp: 'pc 7/5/2021 20:31:05'!
PASSED!

!testRun: #CartaDeTrucoTest #test02SonDistintasConDistintoPalo stamp: 'pc 7/5/2021 20:31:05'!
PASSED!

!testRun: #CartaDeTrucoTest #test03SonDistintasConNumeroAunqueIgualPalo stamp: 'pc 7/5/2021 20:31:05'!
PASSED!

!testRun: #CartaDeTrucoTest #test04CartasIgualesTienenElMismoHash stamp: 'pc 7/5/2021 20:31:05'!
PASSED!

!testRun: #CartaDeTrucoTest #test05UnaCartaEsDistintaACualquierObjetoQueNoSeaCarta stamp: 'pc 7/5/2021 20:31:05'!
PASSED!

!testRun: #CartaDeTrucoTest #test07NoHayCartaDeTrucoConNumeroOcho stamp: 'pc 7/5/2021 20:31:05'!
PASSED!

!testRun: #CartaDeTrucoTest #test08NoHayCartaDeTrucoConNumeroNueve stamp: 'pc 7/5/2021 20:31:05'!
PASSED!

!testRun: #CartaDeTrucoTest #test09LosPalosDeLaCartaDeTrucoSonBastoOroEspadaYCopa stamp: 'pc 7/5/2021 20:31:05'!
PASSED!

!testRun: #CartaDeTrucoTest #test10NoSePuedeCrearCartaConNumeroMenorAUno stamp: 'pc 7/5/2021 20:31:05'!
PASSED!

!testRun: #CartaDeTrucoTest #test11NoSePuedeCrearCartaConNumeroMayorADoce stamp: 'pc 7/5/2021 20:31:05'!
PASSED!

!testRun: #CartaDeTrucoTest #test12ElNumeroDeLaCartaDebeSerEntero stamp: 'pc 7/5/2021 20:31:05'!
PASSED!

!testRun: #CartaDeTrucoTest #test13LaTablaDeValoresEsCorrecta stamp: 'pc 7/5/2021 20:31:05'!
PASSED!

!testRun: #CartaDeTrucoTest #test14HayCartasQueNoSonPardas stamp: 'pc 7/5/2021 20:31:05'!
PASSED!

!testRun: #CartaDeTrucoTest #test15HayCartasQuePierdenConOtras stamp: 'pc 7/5/2021 20:31:05'!
PASSED!

!testRun: #CartaDeTrucoTest #test16SieteDeCopasYDeBastoEsSieteFalso stamp: 'pc 7/5/2021 20:31:05'!
PASSED!

!testRun: #CartaDeTrucoTest #test17SieteDeOroYDeEspadaNoSonSieteFalso stamp: 'pc 7/5/2021 20:31:05'!
PASSED!

!testRun: #CartaDeTrucoTest #test18AnchoDeOroYDeCopaSonAnchoFalsos stamp: 'pc 7/5/2021 20:31:05'!
PASSED!

!testRun: #CartaDeTrucoTest #test19AnchoDeEspadaYDeBastosNoSonAnchoFalsos stamp: 'pc 7/5/2021 20:31:05'!
PASSED!

!testRun: #CartaDeTrucoTest #test20FallaBuscandoValorDeCartaInv�lida stamp: 'pc 7/5/2021 20:31:05'!
PASSED!

!testRun: #RondaDeTrucoTest #test01 stamp: 'pc 7/5/2021 20:31:05'!
PASSED!

!testRun: #RondaDeTrucoTest #test02 stamp: 'pc 7/5/2021 20:31:05'!
PASSED!

!testRun: #RondaDeTrucoTest #test03 stamp: 'pc 7/5/2021 20:31:05'!
PASSED!

!testRun: #RondaDeTrucoTest #test04 stamp: 'pc 7/5/2021 20:31:05'!
PASSED!

!testRun: #RondaDeTrucoTest #test05 stamp: 'pc 7/5/2021 20:31:05'!
PASSED!

!testRun: #RondaDeTrucoTest #test06 stamp: 'pc 7/5/2021 20:31:05'!
PASSED!

!testRun: #RondaDeTrucoTest #test07 stamp: 'pc 7/5/2021 20:31:05'!
PASSED!

!testRun: #RondaDeTrucoTest #test08 stamp: 'pc 7/5/2021 20:31:05'!
PASSED!

!testRun: #RondaDeTrucoTest #test09 stamp: 'pc 7/5/2021 20:31:05'!
PASSED!

!testRun: #RondaDeTrucoTest #test10 stamp: 'pc 7/5/2021 20:31:05'!
PASSED!

!testRun: #RondaDeTrucoTest #test12 stamp: 'pc 7/5/2021 20:31:05'!
PASSED!

!testRun: #RondaDeTrucoTest #test11 stamp: 'pc 7/5/2021 20:31:05'!
PASSED!

!testRun: #RondaDeTrucoTest #test13 stamp: 'pc 7/5/2021 20:31:05'!
ERROR!

!testRun: #RondaDeTrucoTest #test13 stamp: 'pc 7/5/2021 20:31:05'!
ERROR!
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 20:34:56' prior: 50915900!
test13
	| rondaDeTruco tresCartasA tresCartasB |
	tresCartasA := OrderedCollection new.
	tresCartasA add: (CartaDeTruco oroCon: 4).
	tresCartasA add: CartaDeTruco anchoDeEspada.
	tresCartasA add: (CartaDeTruco copaCon: 3).
	tresCartasB := OrderedCollection new.
	tresCartasB add: (CartaDeTruco oroCon: 2).
	tresCartasB add: CartaDeTruco anchoDeBasto.
	tresCartasB add: (CartaDeTruco copaCon: 4).
	jugadorA conCartas: tresCartasA.
	jugadorB conCartas: tresCartasB.
	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		vs: jugadorB
		.
	
	rondaDeTruco jugar.
	
	self assert: (rondaDeTruco rondasJugadas) equals: 3.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorA) equals: 1.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorB) equals: 0.
	self assert: (rondaDeTruco ganador) equals: jugadorA .
	
	! !

!testRun: #RondaDeTrucoTest #test13 stamp: 'pc 7/5/2021 20:35:02'!
ERROR!
!Jugador methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 20:35:50'!
cartas
	^cartas ! !
!RondaDeTruco methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 20:36:20' prior: 50915935!
jugar
	
	self enfrentamientoCon: jugadorA cartas first vs: jugadorB cartas first.
	self enfrentamientoCon:  jugadorA cartas second vs: 	 jugadorB cartas second. 
	self enfrentamientoCon:  jugadorA cartas third vs:  jugadorB cartas third.! !

!testRun: #RondaDeTrucoTest #test13 stamp: 'pc 7/5/2021 20:36:22'!
FAILURE!
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 20:36:46' prior: 50916809!
test13
	| rondaDeTruco tresCartasA tresCartasB |
	tresCartasA := OrderedCollection new.
	tresCartasA add: (CartaDeTruco oroCon: 4).
	tresCartasA add: CartaDeTruco anchoDeEspada.
	tresCartasA add: (CartaDeTruco copaCon: 3).
	tresCartasB := OrderedCollection new.
	tresCartasB add: (CartaDeTruco oroCon: 2).
	tresCartasB add: CartaDeTruco anchoDeBasto.
	tresCartasB add: (CartaDeTruco copaCon: 4).
	jugadorA conCartas: tresCartasA.
	jugadorB conCartas: tresCartasB.
	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		vs: jugadorB
		.
	
	rondaDeTruco jugar.
	
	self assert: (rondaDeTruco rondasJugadas) equals: 3.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorA) equals: 2.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorB) equals: 1.
	self assert: (rondaDeTruco ganador) equals: jugadorA .
	
	! !

!testRun: #RondaDeTrucoTest #test13 stamp: 'pc 7/5/2021 20:36:47'!
PASSED!

!testRun: #RondaDeTrucoTest #test01 stamp: 'pc 7/5/2021 20:36:47'!
PASSED!

!testRun: #RondaDeTrucoTest #test02 stamp: 'pc 7/5/2021 20:36:47'!
PASSED!

!testRun: #RondaDeTrucoTest #test03 stamp: 'pc 7/5/2021 20:36:47'!
PASSED!

!testRun: #RondaDeTrucoTest #test04 stamp: 'pc 7/5/2021 20:36:47'!
PASSED!

!testRun: #RondaDeTrucoTest #test05 stamp: 'pc 7/5/2021 20:36:47'!
PASSED!

!testRun: #RondaDeTrucoTest #test06 stamp: 'pc 7/5/2021 20:36:47'!
PASSED!

!testRun: #RondaDeTrucoTest #test07 stamp: 'pc 7/5/2021 20:36:47'!
PASSED!

!testRun: #RondaDeTrucoTest #test08 stamp: 'pc 7/5/2021 20:36:48'!
PASSED!

!testRun: #RondaDeTrucoTest #test09 stamp: 'pc 7/5/2021 20:36:48'!
PASSED!

!testRun: #RondaDeTrucoTest #test10 stamp: 'pc 7/5/2021 20:36:48'!
PASSED!

!testRun: #RondaDeTrucoTest #test11 stamp: 'pc 7/5/2021 20:36:48'!
PASSED!

!testRun: #RondaDeTrucoTest #test12 stamp: 'pc 7/5/2021 20:36:48'!
PASSED!

!testRun: #RondaDeTrucoTest #test13 stamp: 'pc 7/5/2021 20:36:48'!
PASSED!
!RondaDeTruco methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 20:39:39' prior: 50916689!
ganador
	
	ronda = 3 ifTrue:[
		((jugadores occurrencesOf: jugadorA nombre) > (jugadores occurrencesOf: jugadorB nombre)) ifTrue: [^jugadorA  ] ifFalse: [^jugadorB ]].
	(ronda = 2 and: [primerRondaParda or: [(self enfretamientosGanadosPor: jugadorA ) = 2 or: [(self enfretamientosGanadosPor: jugadorB ) =2]]])
		ifTrue:[
		((jugadores occurrencesOf: jugadorA nombre) > (jugadores occurrencesOf: jugadorB nombre)) ifTrue: [^jugadorA  ] ifFalse: [^jugadorB ]].
	
	self error: self class noTerminoLaRondaTodavia.! !

Object subclass: #RondaDeTrucoEstado
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial'!

!classDefinition: #RondaDeTrucoEstado category: 'ISW1-2021-1C-2doParcial' stamp: 'pc 7/5/2021 20:40:05'!
Object subclass: #RondaDeTrucoEstado
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial'!

RondaDeTrucoEstado subclass: #Enfrentamiento1
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial'!

!classDefinition: #Enfrentamiento1 category: 'ISW1-2021-1C-2doParcial' stamp: 'pc 7/5/2021 20:40:31'!
RondaDeTrucoEstado subclass: #Enfrentamiento1
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial'!

RondaDeTrucoEstado subclass: #Enfrentamiento2
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial'!

!classDefinition: #Enfrentamiento2 category: 'ISW1-2021-1C-2doParcial' stamp: 'pc 7/5/2021 20:40:34'!
RondaDeTrucoEstado subclass: #Enfrentamiento2
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial'!

RondaDeTrucoEstado subclass: #Enfrentamiento3
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial'!

!classDefinition: #Enfrentamiento3 category: 'ISW1-2021-1C-2doParcial' stamp: 'pc 7/5/2021 20:40:37'!
RondaDeTrucoEstado subclass: #Enfrentamiento3
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial'!
!RondaDeTruco methodsFor: 'initialization' stamp: 'pc 7/5/2021 20:40:59' prior: 50913584!
initializeEntreJugador: unJugador vs: otroJugador 
	
	primerRondaParda := false.
	ronda := Enfrentamiento1 .
	jugadorA := unJugador .
	jugadorB := otroJugador .
	jugadores := Bag new.
	cartasUsadas := OrderedCollection new.! !
!RondaDeTruco methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 20:41:13' prior: 50916844!
jugar
	
	self enfrentamientoCon: jugadorA cartas first vs: jugadorB cartas first.
	self enfrentamientoCon: jugadorA cartas second vs: 	 jugadorB cartas second. 
	self enfrentamientoCon: jugadorA cartas third vs:  jugadorB cartas third.! !
!RondaDeTruco methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 20:43:33' prior: 50916499!
revisarFinalizacionDeRonda.
	
	ronda .
	((self enfretamientosGanadosPor: jugadorA ) = 2 or: [(self enfretamientosGanadosPor: jugadorB ) =2] ) ifTrue: [self error: self class noSePuedeJugarCuandoYaHayGanadorError].
! !
!RondaDeTruco methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 20:44:01' prior: 50917014!
revisarFinalizacionDeRonda.
	
	((self enfretamientosGanadosPor: jugadorA ) = 2 or: [(self enfretamientosGanadosPor: jugadorB ) =2] ) ifTrue: [self error: self class noSePuedeJugarCuandoYaHayGanadorError].
! !
!RondaDeTruco methodsFor: 'initialization' stamp: 'pc 7/5/2021 20:47:27' prior: 50916992!
initializeEntreJugador: unJugador vs: otroJugador 
	
	primerRondaParda := false.
	ronda := 1 .
	jugadorA := unJugador .
	jugadorB := otroJugador .
	jugadores := Bag new.
	cartasUsadas := OrderedCollection new.! !

!testRun: #CartaDeTrucoTest #test01SonIgualesConMismoPaloYNumero stamp: 'pc 7/5/2021 20:47:28'!
PASSED!

!testRun: #CartaDeTrucoTest #test02SonDistintasConDistintoPalo stamp: 'pc 7/5/2021 20:47:28'!
PASSED!

!testRun: #CartaDeTrucoTest #test03SonDistintasConNumeroAunqueIgualPalo stamp: 'pc 7/5/2021 20:47:28'!
PASSED!

!testRun: #CartaDeTrucoTest #test04CartasIgualesTienenElMismoHash stamp: 'pc 7/5/2021 20:47:28'!
PASSED!

!testRun: #CartaDeTrucoTest #test05UnaCartaEsDistintaACualquierObjetoQueNoSeaCarta stamp: 'pc 7/5/2021 20:47:28'!
PASSED!

!testRun: #CartaDeTrucoTest #test07NoHayCartaDeTrucoConNumeroOcho stamp: 'pc 7/5/2021 20:47:28'!
PASSED!

!testRun: #CartaDeTrucoTest #test08NoHayCartaDeTrucoConNumeroNueve stamp: 'pc 7/5/2021 20:47:28'!
PASSED!

!testRun: #CartaDeTrucoTest #test09LosPalosDeLaCartaDeTrucoSonBastoOroEspadaYCopa stamp: 'pc 7/5/2021 20:47:28'!
PASSED!

!testRun: #CartaDeTrucoTest #test10NoSePuedeCrearCartaConNumeroMenorAUno stamp: 'pc 7/5/2021 20:47:28'!
PASSED!

!testRun: #CartaDeTrucoTest #test11NoSePuedeCrearCartaConNumeroMayorADoce stamp: 'pc 7/5/2021 20:47:28'!
PASSED!

!testRun: #CartaDeTrucoTest #test12ElNumeroDeLaCartaDebeSerEntero stamp: 'pc 7/5/2021 20:47:29'!
PASSED!

!testRun: #CartaDeTrucoTest #test13LaTablaDeValoresEsCorrecta stamp: 'pc 7/5/2021 20:47:29'!
PASSED!

!testRun: #CartaDeTrucoTest #test14HayCartasQueNoSonPardas stamp: 'pc 7/5/2021 20:47:29'!
PASSED!

!testRun: #CartaDeTrucoTest #test15HayCartasQuePierdenConOtras stamp: 'pc 7/5/2021 20:47:29'!
PASSED!

!testRun: #CartaDeTrucoTest #test16SieteDeCopasYDeBastoEsSieteFalso stamp: 'pc 7/5/2021 20:47:29'!
PASSED!

!testRun: #CartaDeTrucoTest #test17SieteDeOroYDeEspadaNoSonSieteFalso stamp: 'pc 7/5/2021 20:47:29'!
PASSED!

!testRun: #CartaDeTrucoTest #test18AnchoDeOroYDeCopaSonAnchoFalsos stamp: 'pc 7/5/2021 20:47:29'!
PASSED!

!testRun: #CartaDeTrucoTest #test19AnchoDeEspadaYDeBastosNoSonAnchoFalsos stamp: 'pc 7/5/2021 20:47:29'!
PASSED!

!testRun: #CartaDeTrucoTest #test20FallaBuscandoValorDeCartaInv�lida stamp: 'pc 7/5/2021 20:47:29'!
PASSED!

!testRun: #RondaDeTrucoTest #test01 stamp: 'pc 7/5/2021 20:47:29'!
FAILURE!

!testRun: #RondaDeTrucoTest #test02 stamp: 'pc 7/5/2021 20:47:29'!
FAILURE!

!testRun: #RondaDeTrucoTest #test03 stamp: 'pc 7/5/2021 20:47:29'!
FAILURE!

!testRun: #RondaDeTrucoTest #test04 stamp: 'pc 7/5/2021 20:47:29'!
FAILURE!

!testRun: #RondaDeTrucoTest #test05 stamp: 'pc 7/5/2021 20:47:29'!
FAILURE!

!testRun: #RondaDeTrucoTest #test06 stamp: 'pc 7/5/2021 20:47:29'!
FAILURE!

!testRun: #RondaDeTrucoTest #test07 stamp: 'pc 7/5/2021 20:47:29'!
FAILURE!

!testRun: #RondaDeTrucoTest #test08 stamp: 'pc 7/5/2021 20:47:29'!
FAILURE!

!testRun: #RondaDeTrucoTest #test09 stamp: 'pc 7/5/2021 20:47:29'!
FAILURE!

!testRun: #RondaDeTrucoTest #test10 stamp: 'pc 7/5/2021 20:47:29'!
FAILURE!

!testRun: #RondaDeTrucoTest #test11 stamp: 'pc 7/5/2021 20:47:29'!
FAILURE!

!testRun: #RondaDeTrucoTest #test12 stamp: 'pc 7/5/2021 20:47:29'!
FAILURE!

!testRun: #RondaDeTrucoTest #test13 stamp: 'pc 7/5/2021 20:47:29'!
FAILURE!

!testRun: #RondaDeTrucoTest #test01 stamp: 'pc 7/5/2021 20:47:31'!
FAILURE!
!RondaDeTruco methodsFor: 'initialization' stamp: 'pc 7/5/2021 20:47:41' prior: 50917034!
initializeEntreJugador: unJugador vs: otroJugador 
	
	primerRondaParda := false.
	ronda := 0 .
	jugadorA := unJugador .
	jugadorB := otroJugador .
	jugadores := Bag new.
	cartasUsadas := OrderedCollection new.! !

!testRun: #CartaDeTrucoTest #test01SonIgualesConMismoPaloYNumero stamp: 'pc 7/5/2021 20:47:43'!
PASSED!

!testRun: #CartaDeTrucoTest #test02SonDistintasConDistintoPalo stamp: 'pc 7/5/2021 20:47:43'!
PASSED!

!testRun: #CartaDeTrucoTest #test03SonDistintasConNumeroAunqueIgualPalo stamp: 'pc 7/5/2021 20:47:43'!
PASSED!

!testRun: #CartaDeTrucoTest #test04CartasIgualesTienenElMismoHash stamp: 'pc 7/5/2021 20:47:43'!
PASSED!

!testRun: #CartaDeTrucoTest #test05UnaCartaEsDistintaACualquierObjetoQueNoSeaCarta stamp: 'pc 7/5/2021 20:47:43'!
PASSED!

!testRun: #CartaDeTrucoTest #test07NoHayCartaDeTrucoConNumeroOcho stamp: 'pc 7/5/2021 20:47:43'!
PASSED!

!testRun: #CartaDeTrucoTest #test08NoHayCartaDeTrucoConNumeroNueve stamp: 'pc 7/5/2021 20:47:43'!
PASSED!

!testRun: #CartaDeTrucoTest #test09LosPalosDeLaCartaDeTrucoSonBastoOroEspadaYCopa stamp: 'pc 7/5/2021 20:47:43'!
PASSED!

!testRun: #CartaDeTrucoTest #test10NoSePuedeCrearCartaConNumeroMenorAUno stamp: 'pc 7/5/2021 20:47:43'!
PASSED!

!testRun: #CartaDeTrucoTest #test11NoSePuedeCrearCartaConNumeroMayorADoce stamp: 'pc 7/5/2021 20:47:43'!
PASSED!

!testRun: #CartaDeTrucoTest #test12ElNumeroDeLaCartaDebeSerEntero stamp: 'pc 7/5/2021 20:47:43'!
PASSED!

!testRun: #CartaDeTrucoTest #test13LaTablaDeValoresEsCorrecta stamp: 'pc 7/5/2021 20:47:43'!
PASSED!

!testRun: #CartaDeTrucoTest #test14HayCartasQueNoSonPardas stamp: 'pc 7/5/2021 20:47:43'!
PASSED!

!testRun: #CartaDeTrucoTest #test15HayCartasQuePierdenConOtras stamp: 'pc 7/5/2021 20:47:43'!
PASSED!

!testRun: #CartaDeTrucoTest #test16SieteDeCopasYDeBastoEsSieteFalso stamp: 'pc 7/5/2021 20:47:43'!
PASSED!

!testRun: #CartaDeTrucoTest #test17SieteDeOroYDeEspadaNoSonSieteFalso stamp: 'pc 7/5/2021 20:47:43'!
PASSED!

!testRun: #CartaDeTrucoTest #test18AnchoDeOroYDeCopaSonAnchoFalsos stamp: 'pc 7/5/2021 20:47:43'!
PASSED!

!testRun: #CartaDeTrucoTest #test19AnchoDeEspadaYDeBastosNoSonAnchoFalsos stamp: 'pc 7/5/2021 20:47:43'!
PASSED!

!testRun: #CartaDeTrucoTest #test20FallaBuscandoValorDeCartaInv�lida stamp: 'pc 7/5/2021 20:47:43'!
PASSED!

!testRun: #RondaDeTrucoTest #test01 stamp: 'pc 7/5/2021 20:47:43'!
PASSED!

!testRun: #RondaDeTrucoTest #test02 stamp: 'pc 7/5/2021 20:47:43'!
PASSED!

!testRun: #RondaDeTrucoTest #test03 stamp: 'pc 7/5/2021 20:47:43'!
PASSED!

!testRun: #RondaDeTrucoTest #test04 stamp: 'pc 7/5/2021 20:47:43'!
PASSED!

!testRun: #RondaDeTrucoTest #test05 stamp: 'pc 7/5/2021 20:47:43'!
PASSED!

!testRun: #RondaDeTrucoTest #test06 stamp: 'pc 7/5/2021 20:47:43'!
PASSED!

!testRun: #RondaDeTrucoTest #test07 stamp: 'pc 7/5/2021 20:47:43'!
PASSED!

!testRun: #RondaDeTrucoTest #test08 stamp: 'pc 7/5/2021 20:47:43'!
PASSED!

!testRun: #RondaDeTrucoTest #test09 stamp: 'pc 7/5/2021 20:47:43'!
PASSED!

!testRun: #RondaDeTrucoTest #test10 stamp: 'pc 7/5/2021 20:47:43'!
PASSED!

!testRun: #RondaDeTrucoTest #test11 stamp: 'pc 7/5/2021 20:47:43'!
PASSED!

!testRun: #RondaDeTrucoTest #test12 stamp: 'pc 7/5/2021 20:47:43'!
PASSED!

!testRun: #RondaDeTrucoTest #test13 stamp: 'pc 7/5/2021 20:47:43'!
PASSED!
!RondaDeTruco class methodsFor: 'instance creation' stamp: 'pc 7/5/2021 20:51:48'!
entreJugador: unJugador vs: otroJugador primeraParda: rondaPreviaParda   
	
	^self new initializeEntreJugador: unJugador vs: otroJugador ! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 20:51:48' prior: 50914604!
test05
	| rondaDeTruco |
	
	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		vs: jugadorB primeraParda: true
		.
	
	rondaDeTruco enfrentamientoCon: (CartaDeTruco bastoCon: 2) vs: (CartaDeTruco oroCon: 2) .
	rondaDeTruco enfrentamientoCon: CartaDeTruco anchoDeEspada vs: CartaDeTruco anchoDeBasto.
	
	self assert: (rondaDeTruco rondasJugadas) equals: 2.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorA) equals: 1.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorB) equals: 0.
	self assert: (rondaDeTruco ganador) equals: jugadorA .! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 20:51:48' prior: 50914166!
test09
	| rondaDeTruco |

	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		vs: jugadorB primeraParda: true.
	
	rondaDeTruco enfrentamientoCon: (CartaDeTruco espadaCon: 3) vs: (CartaDeTruco espadaCon:1 ).
	
	self 
		should: [rondaDeTruco enfrentamientoCon: CartaDeTruco anchoDeEspada vs: CartaDeTruco anchoDeBasto .]
		raise: Error -MessageNotUnderstood 
		withExceptionDo: [:anError|
			self assert: RondaDeTruco cartaRepetidaError equals: anError messageText .
			self assert: (rondaDeTruco rondasJugadas) equals: 1.
			].
	! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 20:51:48' prior: 50914888!
test11
	| rondaDeTruco |
	
	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		vs: jugadorB primeraParda: true
		.
	
	rondaDeTruco enfrentamientoCon: (CartaDeTruco oroCon: 4) vs: (CartaDeTruco oroCon: 2) .
	rondaDeTruco enfrentamientoCon: CartaDeTruco anchoDeBasto vs: 	CartaDeTruco anchoDeEspada.
	
	self 
	should: [rondaDeTruco enfrentamientoCon: (CartaDeTruco copaCon: 3) vs: (CartaDeTruco copaCon: 4)] 
	raise:  Error - MessageNotUnderstood 
	withExceptionDo: [:anError|
		self assert: RondaDeTruco noSePuedeJugarCuandoYaHayGanadorError equals: anError messageText. 
		self assert: (rondaDeTruco rondasJugadas) equals: 2.
		self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorA) equals: 0.
		self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorB) equals: 2.
		self assert: (rondaDeTruco ganador) equals: jugadorB .]
	! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 20:51:48' prior: 50915605!
test12
	| rondaDeTruco |
	
	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		vs: jugadorB primeraParda: true
		.
	
	rondaDeTruco enfrentamientoCon: (CartaDeTruco bastoCon: 2) vs: (CartaDeTruco oroCon: 2) .
	rondaDeTruco enfrentamientoCon: (CartaDeTruco bastoCon: 7) vs: (CartaDeTruco copaCon: 7) .	
	
	self assert: (rondaDeTruco rondasJugadas) equals: 2.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorA) equals: 1.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorB) equals: 0.
	self assert: (rondaDeTruco ganador) equals: jugadorA .
	
	! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 20:51:48' prior: 50914341!
test01
	| rondaDeTruco |

	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		vs: jugadorB primeraParda: true
		.
	
	self assert: rondaDeTruco rondasJugadas equals: 0! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 20:51:48' prior: 50914840!
test06
	| rondaDeTruco |
	
	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		vs: jugadorB primeraParda: true
		.
	
	rondaDeTruco enfrentamientoCon: (CartaDeTruco oroCon: 4) vs: (CartaDeTruco oroCon: 2) .
	rondaDeTruco enfrentamientoCon: CartaDeTruco anchoDeEspada vs: 	CartaDeTruco anchoDeBasto. 
	rondaDeTruco enfrentamientoCon: (CartaDeTruco copaCon: 3) vs: (CartaDeTruco copaCon: 4) .
	
	self assert: (rondaDeTruco rondasJugadas) equals: 3.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorA) equals: 2.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorB) equals: 1.
	self assert: (rondaDeTruco ganador) equals: jugadorA .! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 20:51:48' prior: 50914770!
test07
	| rondaDeTruco |
	
	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		vs: jugadorB primeraParda: true
		.
	
	rondaDeTruco enfrentamientoCon: (CartaDeTruco copaCon: 2) vs:  (CartaDeTruco oroCon: 2).
	rondaDeTruco enfrentamientoCon: CartaDeTruco anchoDeEspada vs: CartaDeTruco anchoDeBasto.
	
	self assert: (rondaDeTruco rondasJugadas) equals: 2.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorA) equals: 1.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorB) equals: 0.
	self assert: (rondaDeTruco ganador) equals: jugadorA .! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 20:51:48' prior: 50914297!
test10
	| rondaDeTruco |

	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		vs: jugadorB primeraParda: true.
	
	rondaDeTruco enfrentamientoCon: (CartaDeTruco espadaCon: 3) vs: (CartaDeTruco espadaCon:1 ).
	
	self 
		should: [rondaDeTruco ganador]
		raise: Error -MessageNotUnderstood 
		withExceptionDo: [:anError|
			self assert: RondaDeTruco noTerminoLaRondaTodavia equals: anError messageText .
			self assert: (rondaDeTruco rondasJugadas) equals: 1.
			].
	! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 20:51:48' prior: 50916405!
test02
	| rondaDeTruco |

	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		vs: jugadorB primeraParda: true
		.
	
	rondaDeTruco enfrentamientoCon: CartaDeTruco anchoDeEspada vs: CartaDeTruco anchoDeBasto.
		
		
	self assert: (rondaDeTruco rondasJugadas) equals: 1.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorA) equals: 1.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorB) equals: 0.! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 20:51:48' prior: 50916389!
test03
	| rondaDeTruco |
	
	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		vs: jugadorB primeraParda: true
		.
	
	rondaDeTruco enfrentamientoCon: (CartaDeTruco bastoCon: 2) vs: (CartaDeTruco oroCon: 2) .
	
	self assert: (rondaDeTruco rondasJugadas) equals: 1.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorA) equals: 0.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorB) equals: 0.
	! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 20:51:48' prior: 50916858!
test13
	| rondaDeTruco tresCartasA tresCartasB |
	tresCartasA := OrderedCollection new.
	tresCartasA add: (CartaDeTruco oroCon: 4).
	tresCartasA add: CartaDeTruco anchoDeEspada.
	tresCartasA add: (CartaDeTruco copaCon: 3).
	tresCartasB := OrderedCollection new.
	tresCartasB add: (CartaDeTruco oroCon: 2).
	tresCartasB add: CartaDeTruco anchoDeBasto.
	tresCartasB add: (CartaDeTruco copaCon: 4).
	jugadorA conCartas: tresCartasA.
	jugadorB conCartas: tresCartasB.
	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		vs: jugadorB primeraParda: true
		.
	
	rondaDeTruco jugar.
	
	self assert: (rondaDeTruco rondasJugadas) equals: 3.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorA) equals: 2.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorB) equals: 1.
	self assert: (rondaDeTruco ganador) equals: jugadorA .
	
	! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 20:51:48' prior: 50914524!
test04
	| rondaDeTruco |
	

	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		vs: jugadorB primeraParda: true
		.
	
	rondaDeTruco enfrentamientoCon: (CartaDeTruco oroCon: 2) vs: (CartaDeTruco bastoCon: 2).
	rondaDeTruco enfrentamientoCon: CartaDeTruco anchoDeEspada vs:CartaDeTruco anchoDeBasto. .
	
	self assert: (rondaDeTruco rondasJugadas) equals: 2.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorA) equals: 1.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorB) equals: 0.
	self assert: (rondaDeTruco ganador) equals: jugadorA .! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 20:51:48' prior: 50914149!
test08
	| rondaDeTruco |

	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		vs: jugadorB primeraParda: true.

	
	self 
		should: [rondaDeTruco enfrentamientoCon: CartaDeTruco anchoDeBasto vs: CartaDeTruco anchoDeBasto .]
		raise: Error -MessageNotUnderstood 
		withExceptionDo: [:anError|
			self assert: RondaDeTruco cartaRepetidaError equals: anError messageText .
			self assert: (rondaDeTruco rondasJugadas) equals: 0.
			].
	! !

!methodRemoval: RondaDeTruco class #entreJugador:vs: stamp: 'pc 7/5/2021 20:51:48'!
entreJugador: unJugador vs: otroJugador  
	
	^self new initializeEntreJugador: unJugador vs: otroJugador !
!RondaDeTruco methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 20:55:02'!
enfrentamientoEntre: cartaDeTrucoA vs: cartaDeTrucoB
	
	self revisarFinalizacionDeRonda.
	
	self revisarCartasRepetidasEntre: cartaDeTrucoA y: cartaDeTrucoB.
	
	cartasUsadas add: cartaDeTrucoA.
	cartasUsadas add: cartaDeTrucoB.

	ronda := ronda + 1.
	(cartaDeTrucoA mataA: cartaDeTrucoB) ifTrue: [jugadores add: jugadorA nombre]. 
	(cartaDeTrucoB mataA: cartaDeTrucoA) ifTrue: [jugadores add:jugadorB nombre].
	((cartaDeTrucoB empardaCon: cartaDeTrucoA) and: primerRondaParda) ifTrue: [jugadores add: self jugadorMano].
	(cartaDeTrucoB empardaCon: cartaDeTrucoA) ifTrue: [primerRondaParda := true].
! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 20:55:02' prior: 50917420!
test02
	| rondaDeTruco |

	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		vs: jugadorB primeraParda: true
		.
	
	rondaDeTruco enfrentamientoEntre: CartaDeTruco anchoDeEspada vs: CartaDeTruco anchoDeBasto.
		
		
	self assert: (rondaDeTruco rondasJugadas) equals: 1.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorA) equals: 1.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorB) equals: 0.! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 20:55:02' prior: 50917402!
test10
	| rondaDeTruco |

	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		vs: jugadorB primeraParda: true.
	
	rondaDeTruco enfrentamientoEntre: (CartaDeTruco espadaCon: 3) vs: (CartaDeTruco espadaCon:1 ).
	
	self 
		should: [rondaDeTruco ganador]
		raise: Error -MessageNotUnderstood 
		withExceptionDo: [:anError|
			self assert: RondaDeTruco noTerminoLaRondaTodavia equals: anError messageText .
			self assert: (rondaDeTruco rondasJugadas) equals: 1.
			].
	! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 20:55:02' prior: 50917296!
test11
	| rondaDeTruco |
	
	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		vs: jugadorB primeraParda: true
		.
	
	rondaDeTruco enfrentamientoEntre: (CartaDeTruco oroCon: 4) vs: (CartaDeTruco oroCon: 2) .
	rondaDeTruco enfrentamientoEntre: CartaDeTruco anchoDeBasto vs: 	CartaDeTruco anchoDeEspada.
	
	self 
	should: [rondaDeTruco enfrentamientoEntre: (CartaDeTruco copaCon: 3) vs: (CartaDeTruco copaCon: 4)] 
	raise:  Error - MessageNotUnderstood 
	withExceptionDo: [:anError|
		self assert: RondaDeTruco noSePuedeJugarCuandoYaHayGanadorError equals: anError messageText. 
		self assert: (rondaDeTruco rondasJugadas) equals: 2.
		self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorA) equals: 0.
		self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorB) equals: 2.
		self assert: (rondaDeTruco ganador) equals: jugadorB .]
	! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 20:55:02' prior: 50917437!
test03
	| rondaDeTruco |
	
	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		vs: jugadorB primeraParda: true
		.
	
	rondaDeTruco enfrentamientoEntre: (CartaDeTruco bastoCon: 2) vs: (CartaDeTruco oroCon: 2) .
	
	self assert: (rondaDeTruco rondasJugadas) equals: 1.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorA) equals: 0.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorB) equals: 0.
	! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 20:55:02' prior: 50917484!
test04
	| rondaDeTruco |
	

	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		vs: jugadorB primeraParda: true
		.
	
	rondaDeTruco enfrentamientoEntre: (CartaDeTruco oroCon: 2) vs: (CartaDeTruco bastoCon: 2).
	rondaDeTruco enfrentamientoEntre: CartaDeTruco anchoDeEspada vs:CartaDeTruco anchoDeBasto. .
	
	self assert: (rondaDeTruco rondasJugadas) equals: 2.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorA) equals: 1.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorB) equals: 0.
	self assert: (rondaDeTruco ganador) equals: jugadorA .! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 20:55:02' prior: 50917381!
test07
	| rondaDeTruco |
	
	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		vs: jugadorB primeraParda: true
		.
	
	rondaDeTruco enfrentamientoEntre: (CartaDeTruco copaCon: 2) vs:  (CartaDeTruco oroCon: 2).
	rondaDeTruco enfrentamientoEntre: CartaDeTruco anchoDeEspada vs: CartaDeTruco anchoDeBasto.
	
	self assert: (rondaDeTruco rondasJugadas) equals: 2.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorA) equals: 1.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorB) equals: 0.
	self assert: (rondaDeTruco ganador) equals: jugadorA .! !
!RondaDeTruco methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 20:55:02' prior: 50917003!
jugar
	
	self enfrentamientoEntre: jugadorA cartas first vs: jugadorB cartas first.
	self enfrentamientoEntre: jugadorA cartas second vs: 	 jugadorB cartas second. 
	self enfrentamientoEntre: jugadorA cartas third vs:  jugadorB cartas third.! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 20:55:02' prior: 50917505!
test08
	| rondaDeTruco |

	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		vs: jugadorB primeraParda: true.

	
	self 
		should: [rondaDeTruco enfrentamientoEntre: CartaDeTruco anchoDeBasto vs: CartaDeTruco anchoDeBasto .]
		raise: Error -MessageNotUnderstood 
		withExceptionDo: [:anError|
			self assert: RondaDeTruco cartaRepetidaError equals: anError messageText .
			self assert: (rondaDeTruco rondasJugadas) equals: 0.
			].
	! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 20:55:02' prior: 50917255!
test05
	| rondaDeTruco |
	
	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		vs: jugadorB primeraParda: true
		.
	
	rondaDeTruco enfrentamientoEntre: (CartaDeTruco bastoCon: 2) vs: (CartaDeTruco oroCon: 2) .
	rondaDeTruco enfrentamientoEntre: CartaDeTruco anchoDeEspada vs: CartaDeTruco anchoDeBasto.
	
	self assert: (rondaDeTruco rondasJugadas) equals: 2.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorA) equals: 1.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorB) equals: 0.
	self assert: (rondaDeTruco ganador) equals: jugadorA .! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 20:55:02' prior: 50917276!
test09
	| rondaDeTruco |

	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		vs: jugadorB primeraParda: true.
	
	rondaDeTruco enfrentamientoEntre: (CartaDeTruco espadaCon: 3) vs: (CartaDeTruco espadaCon:1 ).
	
	self 
		should: [rondaDeTruco enfrentamientoEntre: CartaDeTruco anchoDeEspada vs: CartaDeTruco anchoDeBasto .]
		raise: Error -MessageNotUnderstood 
		withExceptionDo: [:anError|
			self assert: RondaDeTruco cartaRepetidaError equals: anError messageText .
			self assert: (rondaDeTruco rondasJugadas) equals: 1.
			].
	! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 20:55:02' prior: 50917326!
test12
	| rondaDeTruco |
	
	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		vs: jugadorB primeraParda: true
		.
	
	rondaDeTruco enfrentamientoEntre: (CartaDeTruco bastoCon: 2) vs: (CartaDeTruco oroCon: 2) .
	rondaDeTruco enfrentamientoEntre: (CartaDeTruco bastoCon: 7) vs: (CartaDeTruco copaCon: 7) .	
	
	self assert: (rondaDeTruco rondasJugadas) equals: 2.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorA) equals: 1.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorB) equals: 0.
	self assert: (rondaDeTruco ganador) equals: jugadorA .
	
	! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 20:55:02' prior: 50917357!
test06
	| rondaDeTruco |
	
	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		vs: jugadorB primeraParda: true
		.
	
	rondaDeTruco enfrentamientoEntre: (CartaDeTruco oroCon: 4) vs: (CartaDeTruco oroCon: 2) .
	rondaDeTruco enfrentamientoEntre: CartaDeTruco anchoDeEspada vs: 	CartaDeTruco anchoDeBasto. 
	rondaDeTruco enfrentamientoEntre: (CartaDeTruco copaCon: 3) vs: (CartaDeTruco copaCon: 4) .
	
	self assert: (rondaDeTruco rondasJugadas) equals: 3.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorA) equals: 2.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorB) equals: 1.
	self assert: (rondaDeTruco ganador) equals: jugadorA .! !

!methodRemoval: RondaDeTruco #enfrentamientoCon:vs: stamp: 'pc 7/5/2021 20:55:02'!
enfrentamientoCon: cartaDeTrucoA vs: cartaDeTrucoB
	
	self revisarFinalizacionDeRonda.
	
	self revisarCartasRepetidasEntre: cartaDeTrucoA y: cartaDeTrucoB.
	
	cartasUsadas add: cartaDeTrucoA.
	cartasUsadas add: cartaDeTrucoB.

	ronda := ronda + 1.
	(cartaDeTrucoA mataA: cartaDeTrucoB) ifTrue: [jugadores add: jugadorA nombre]. 
	(cartaDeTrucoB mataA: cartaDeTrucoA) ifTrue: [jugadores add:jugadorB nombre].
	((cartaDeTrucoB empardaCon: cartaDeTrucoA) and: primerRondaParda) ifTrue: [jugadores add: self jugadorMano].
	(cartaDeTrucoB empardaCon: cartaDeTrucoA) ifTrue: [primerRondaParda := true].
!

!testRun: #CartaDeTrucoTest #test01SonIgualesConMismoPaloYNumero stamp: 'pc 7/5/2021 20:55:05'!
PASSED!

!testRun: #CartaDeTrucoTest #test02SonDistintasConDistintoPalo stamp: 'pc 7/5/2021 20:55:05'!
PASSED!

!testRun: #CartaDeTrucoTest #test03SonDistintasConNumeroAunqueIgualPalo stamp: 'pc 7/5/2021 20:55:05'!
PASSED!

!testRun: #CartaDeTrucoTest #test04CartasIgualesTienenElMismoHash stamp: 'pc 7/5/2021 20:55:05'!
PASSED!

!testRun: #CartaDeTrucoTest #test05UnaCartaEsDistintaACualquierObjetoQueNoSeaCarta stamp: 'pc 7/5/2021 20:55:05'!
PASSED!

!testRun: #CartaDeTrucoTest #test07NoHayCartaDeTrucoConNumeroOcho stamp: 'pc 7/5/2021 20:55:05'!
PASSED!

!testRun: #CartaDeTrucoTest #test08NoHayCartaDeTrucoConNumeroNueve stamp: 'pc 7/5/2021 20:55:05'!
PASSED!

!testRun: #CartaDeTrucoTest #test09LosPalosDeLaCartaDeTrucoSonBastoOroEspadaYCopa stamp: 'pc 7/5/2021 20:55:05'!
PASSED!

!testRun: #CartaDeTrucoTest #test10NoSePuedeCrearCartaConNumeroMenorAUno stamp: 'pc 7/5/2021 20:55:05'!
PASSED!

!testRun: #CartaDeTrucoTest #test11NoSePuedeCrearCartaConNumeroMayorADoce stamp: 'pc 7/5/2021 20:55:05'!
PASSED!

!testRun: #CartaDeTrucoTest #test12ElNumeroDeLaCartaDebeSerEntero stamp: 'pc 7/5/2021 20:55:05'!
PASSED!

!testRun: #CartaDeTrucoTest #test13LaTablaDeValoresEsCorrecta stamp: 'pc 7/5/2021 20:55:05'!
PASSED!

!testRun: #CartaDeTrucoTest #test14HayCartasQueNoSonPardas stamp: 'pc 7/5/2021 20:55:05'!
PASSED!

!testRun: #CartaDeTrucoTest #test15HayCartasQuePierdenConOtras stamp: 'pc 7/5/2021 20:55:05'!
PASSED!

!testRun: #CartaDeTrucoTest #test16SieteDeCopasYDeBastoEsSieteFalso stamp: 'pc 7/5/2021 20:55:05'!
PASSED!

!testRun: #CartaDeTrucoTest #test17SieteDeOroYDeEspadaNoSonSieteFalso stamp: 'pc 7/5/2021 20:55:05'!
PASSED!

!testRun: #CartaDeTrucoTest #test18AnchoDeOroYDeCopaSonAnchoFalsos stamp: 'pc 7/5/2021 20:55:05'!
PASSED!

!testRun: #CartaDeTrucoTest #test19AnchoDeEspadaYDeBastosNoSonAnchoFalsos stamp: 'pc 7/5/2021 20:55:05'!
PASSED!

!testRun: #CartaDeTrucoTest #test20FallaBuscandoValorDeCartaInv�lida stamp: 'pc 7/5/2021 20:55:05'!
PASSED!

!testRun: #RondaDeTrucoTest #test01 stamp: 'pc 7/5/2021 20:55:05'!
PASSED!

!testRun: #RondaDeTrucoTest #test02 stamp: 'pc 7/5/2021 20:55:05'!
PASSED!

!testRun: #RondaDeTrucoTest #test03 stamp: 'pc 7/5/2021 20:55:05'!
PASSED!

!testRun: #RondaDeTrucoTest #test04 stamp: 'pc 7/5/2021 20:55:05'!
PASSED!

!testRun: #RondaDeTrucoTest #test05 stamp: 'pc 7/5/2021 20:55:05'!
PASSED!

!testRun: #RondaDeTrucoTest #test06 stamp: 'pc 7/5/2021 20:55:05'!
PASSED!

!testRun: #RondaDeTrucoTest #test07 stamp: 'pc 7/5/2021 20:55:05'!
PASSED!

!testRun: #RondaDeTrucoTest #test08 stamp: 'pc 7/5/2021 20:55:05'!
PASSED!

!testRun: #RondaDeTrucoTest #test09 stamp: 'pc 7/5/2021 20:55:05'!
PASSED!

!testRun: #RondaDeTrucoTest #test10 stamp: 'pc 7/5/2021 20:55:05'!
PASSED!

!testRun: #RondaDeTrucoTest #test11 stamp: 'pc 7/5/2021 20:55:05'!
PASSED!

!testRun: #RondaDeTrucoTest #test12 stamp: 'pc 7/5/2021 20:55:05'!
PASSED!

!testRun: #RondaDeTrucoTest #test13 stamp: 'pc 7/5/2021 20:55:05'!
PASSED!
!RondaDeTruco class methodsFor: 'instance creation' stamp: 'pc 7/5/2021 20:57:44'!
entreJugador: unJugador vs: otroJugador primeraParda: rondaPreviaParda previaParda: aBool jugadores: aBag cartasUsadas: aCollection   
	
	^self new initializeEntreJugador: unJugador vs: otroJugador primeraParda: rondaPreviaParda previaParda: aBool jugadores: aBag cartasUsadas: aCollection ! !
!RondaDeTruco class methodsFor: 'instance creation' stamp: 'pc 7/5/2021 20:59:11'!
entreJugador: unJugador vs: otroJugador previaParda: aBool jugadores: aBag cartasUsadas: aCollection   
	
	^self new initializeEntreJugador: unJugador vs: otroJugador previaParda: aBool jugadores: aBag cartasUsadas: aCollection ! !

!methodRemoval: RondaDeTruco class #entreJugador:vs:primeraParda:previaParda:jugadores:cartasUsadas: stamp: 'pc 7/5/2021 20:59:19'!
entreJugador: unJugador vs: otroJugador primeraParda: rondaPreviaParda previaParda: aBool jugadores: aBag cartasUsadas: aCollection   
	
	^self new initializeEntreJugador: unJugador vs: otroJugador primeraParda: rondaPreviaParda previaParda: aBool jugadores: aBag cartasUsadas: aCollection !

!methodRemoval: RondaDeTruco class #entreJugador:vs:previaParda:jugadores:cartasUsadas: stamp: 'pc 7/5/2021 21:00:15'!
entreJugador: unJugador vs: otroJugador previaParda: aBool jugadores: aBag cartasUsadas: aCollection   
	
	^self new initializeEntreJugador: unJugador vs: otroJugador previaParda: aBool jugadores: aBag cartasUsadas: aCollection !

!testRun: #CartaDeTrucoTest #test01SonIgualesConMismoPaloYNumero stamp: 'pc 7/5/2021 21:00:19'!
PASSED!

!testRun: #CartaDeTrucoTest #test02SonDistintasConDistintoPalo stamp: 'pc 7/5/2021 21:00:19'!
PASSED!

!testRun: #CartaDeTrucoTest #test03SonDistintasConNumeroAunqueIgualPalo stamp: 'pc 7/5/2021 21:00:19'!
PASSED!

!testRun: #CartaDeTrucoTest #test04CartasIgualesTienenElMismoHash stamp: 'pc 7/5/2021 21:00:19'!
PASSED!

!testRun: #CartaDeTrucoTest #test05UnaCartaEsDistintaACualquierObjetoQueNoSeaCarta stamp: 'pc 7/5/2021 21:00:19'!
PASSED!

!testRun: #CartaDeTrucoTest #test07NoHayCartaDeTrucoConNumeroOcho stamp: 'pc 7/5/2021 21:00:19'!
PASSED!

!testRun: #CartaDeTrucoTest #test08NoHayCartaDeTrucoConNumeroNueve stamp: 'pc 7/5/2021 21:00:19'!
PASSED!

!testRun: #CartaDeTrucoTest #test09LosPalosDeLaCartaDeTrucoSonBastoOroEspadaYCopa stamp: 'pc 7/5/2021 21:00:19'!
PASSED!

!testRun: #CartaDeTrucoTest #test10NoSePuedeCrearCartaConNumeroMenorAUno stamp: 'pc 7/5/2021 21:00:19'!
PASSED!

!testRun: #CartaDeTrucoTest #test11NoSePuedeCrearCartaConNumeroMayorADoce stamp: 'pc 7/5/2021 21:00:19'!
PASSED!

!testRun: #CartaDeTrucoTest #test12ElNumeroDeLaCartaDebeSerEntero stamp: 'pc 7/5/2021 21:00:19'!
PASSED!

!testRun: #CartaDeTrucoTest #test13LaTablaDeValoresEsCorrecta stamp: 'pc 7/5/2021 21:00:19'!
PASSED!

!testRun: #CartaDeTrucoTest #test14HayCartasQueNoSonPardas stamp: 'pc 7/5/2021 21:00:19'!
PASSED!

!testRun: #CartaDeTrucoTest #test15HayCartasQuePierdenConOtras stamp: 'pc 7/5/2021 21:00:19'!
PASSED!

!testRun: #CartaDeTrucoTest #test16SieteDeCopasYDeBastoEsSieteFalso stamp: 'pc 7/5/2021 21:00:19'!
PASSED!

!testRun: #CartaDeTrucoTest #test17SieteDeOroYDeEspadaNoSonSieteFalso stamp: 'pc 7/5/2021 21:00:19'!
PASSED!

!testRun: #CartaDeTrucoTest #test18AnchoDeOroYDeCopaSonAnchoFalsos stamp: 'pc 7/5/2021 21:00:19'!
PASSED!

!testRun: #CartaDeTrucoTest #test19AnchoDeEspadaYDeBastosNoSonAnchoFalsos stamp: 'pc 7/5/2021 21:00:19'!
PASSED!

!testRun: #CartaDeTrucoTest #test20FallaBuscandoValorDeCartaInv�lida stamp: 'pc 7/5/2021 21:00:19'!
PASSED!

!testRun: #RondaDeTrucoTest #test01 stamp: 'pc 7/5/2021 21:00:19'!
PASSED!

!testRun: #RondaDeTrucoTest #test02 stamp: 'pc 7/5/2021 21:00:19'!
PASSED!

!testRun: #RondaDeTrucoTest #test03 stamp: 'pc 7/5/2021 21:00:19'!
PASSED!

!testRun: #RondaDeTrucoTest #test04 stamp: 'pc 7/5/2021 21:00:19'!
PASSED!

!testRun: #RondaDeTrucoTest #test05 stamp: 'pc 7/5/2021 21:00:19'!
PASSED!

!testRun: #RondaDeTrucoTest #test06 stamp: 'pc 7/5/2021 21:00:19'!
PASSED!

!testRun: #RondaDeTrucoTest #test07 stamp: 'pc 7/5/2021 21:00:19'!
PASSED!

!testRun: #RondaDeTrucoTest #test08 stamp: 'pc 7/5/2021 21:00:19'!
PASSED!

!testRun: #RondaDeTrucoTest #test09 stamp: 'pc 7/5/2021 21:00:19'!
PASSED!

!testRun: #RondaDeTrucoTest #test10 stamp: 'pc 7/5/2021 21:00:19'!
PASSED!

!testRun: #RondaDeTrucoTest #test11 stamp: 'pc 7/5/2021 21:00:19'!
PASSED!

!testRun: #RondaDeTrucoTest #test12 stamp: 'pc 7/5/2021 21:00:19'!
PASSED!

!testRun: #RondaDeTrucoTest #test13 stamp: 'pc 7/5/2021 21:00:19'!
PASSED!
!RondaDeTrucoEstado class methodsFor: 'nil' stamp: 'pc 7/5/2021 21:00:36'!
entreJugador: unJugador vs: otroJugador previaParda: aBool jugadores: aBag cartasUsadas: aCollection   ! !
!RondaDeTrucoEstado class methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 21:01:04' prior: 50918048!
entreJugador: unJugador vs: otroJugador previaParda: aBool jugadores: aBag cartasUsadas: aCollection   
	
	^self new initializeEntreJugador: unJugador vs: otroJugador previaParda: aBool jugadores: aBag cartasUsadas: aCollection! !

!classDefinition: #RondaDeTrucoEstado category: 'ISW1-2021-1C-2doParcial' stamp: 'pc 7/5/2021 21:02:33'!
Object subclass: #RondaDeTrucoEstado
	instanceVariableNames: 'previaRondaParda'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial'!

!classDefinition: #RondaDeTrucoEstado category: 'ISW1-2021-1C-2doParcial' stamp: 'pc 7/5/2021 21:02:34'!
Object subclass: #RondaDeTrucoEstado
	instanceVariableNames: 'previaRondaParda jugadorA'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial'!

!classDefinition: #RondaDeTrucoEstado category: 'ISW1-2021-1C-2doParcial' stamp: 'pc 7/5/2021 21:02:35'!
Object subclass: #RondaDeTrucoEstado
	instanceVariableNames: 'previaRondaParda jugadorA jugadorB'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial'!

!classDefinition: #RondaDeTrucoEstado category: 'ISW1-2021-1C-2doParcial' stamp: 'pc 7/5/2021 21:02:36'!
Object subclass: #RondaDeTrucoEstado
	instanceVariableNames: 'previaRondaParda jugadorA jugadorB jugadores'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial'!

!classDefinition: #RondaDeTrucoEstado category: 'ISW1-2021-1C-2doParcial' stamp: 'pc 7/5/2021 21:02:37'!
Object subclass: #RondaDeTrucoEstado
	instanceVariableNames: 'previaRondaParda jugadorA jugadorB jugadores cartasUsadas'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial'!
!RondaDeTrucoEstado methodsFor: 'no messages' stamp: 'pc 7/5/2021 21:02:31'!
initializeEntreJugador: unJugador vs: otroJugador previaParda: aBool jugadores: aBag cartasUsadas: aCollection

	previaRondaParda := aBool.
	jugadorA := unJugador .
	jugadorB := otroJugador .
	jugadores := aBag .
	cartasUsadas := aCollection ! !
!Enfrentamiento1 methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 21:02:52' overrides: 50918110!
initializeEntreJugador: unJugador vs: otroJugador previaParda: aBool jugadores: aBag cartasUsadas: aCollection

	previaRondaParda := aBool.
	jugadorA := unJugador .
	jugadorB := otroJugador .
	jugadores := aBag .
	cartasUsadas := aCollection ! !
!Enfrentamiento2 methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 21:02:52' overrides: 50918110!
initializeEntreJugador: unJugador vs: otroJugador previaParda: aBool jugadores: aBag cartasUsadas: aCollection

	previaRondaParda := aBool.
	jugadorA := unJugador .
	jugadorB := otroJugador .
	jugadores := aBag .
	cartasUsadas := aCollection ! !
!Enfrentamiento3 methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 21:02:52' overrides: 50918110!
initializeEntreJugador: unJugador vs: otroJugador previaParda: aBool jugadores: aBag cartasUsadas: aCollection

	previaRondaParda := aBool.
	jugadorA := unJugador .
	jugadorB := otroJugador .
	jugadores := aBag .
	cartasUsadas := aCollection ! !

!methodRemoval: RondaDeTrucoEstado #initializeEntreJugador:vs:previaParda:jugadores:cartasUsadas: stamp: 'pc 7/5/2021 21:02:52'!
initializeEntreJugador: unJugador vs: otroJugador previaParda: aBool jugadores: aBag cartasUsadas: aCollection

	previaRondaParda := aBool.
	jugadorA := unJugador .
	jugadorB := otroJugador .
	jugadores := aBag .
	cartasUsadas := aCollection !
!Enfrentamiento1 methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 21:03:22' prior: 50918121!
initializeEntreJugador: unJugador vs: otroJugador previaParda: aBool jugadores: aBag cartasUsadas: aCollection

	previaRondaParda := aBool.
	jugadorA := unJugador .
	jugadorB := otroJugador .
	jugadores := aBag .
	cartasUsadas := aCollection ! !

!classRenamed: #RondaDeTrucoEstado as: #NumeroRondaDeTruco stamp: 'pc 7/5/2021 21:03:55'!
Smalltalk renameClassNamed: #RondaDeTrucoEstado as: #NumeroRondaDeTruco!
!Enfrentamiento1 methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 21:05:47'!
enfrentamientoEntre: cartaDeTrucoA vs: cartaDeTrucoB
	
	self revisarCartasRepetidasEntre: cartaDeTrucoA y: cartaDeTrucoB.
	
	cartasUsadas add: cartaDeTrucoA.
	cartasUsadas add: cartaDeTrucoB.

	(cartaDeTrucoA mataA: cartaDeTrucoB) ifTrue: [jugadores add: jugadorA nombre]. 
	(cartaDeTrucoB mataA: cartaDeTrucoA) ifTrue: [jugadores add:jugadorB nombre].! !

!classDefinition: #Enfrentamiento1 category: 'ISW1-2021-1C-2doParcial' stamp: 'pc 7/5/2021 21:09:37'!
NumeroRondaDeTruco subclass: #Enfrentamiento1
	instanceVariableNames: 'ronda'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial'!
!Enfrentamiento1 methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 21:09:50' prior: 50918182!
enfrentamientoEntre: cartaDeTrucoA vs: cartaDeTrucoB
	
	self revisarCartasRepetidasEntre: cartaDeTrucoA y: cartaDeTrucoB.
	
	cartasUsadas add: cartaDeTrucoA.
	cartasUsadas add: cartaDeTrucoB.

	(cartaDeTrucoA mataA: cartaDeTrucoB) ifTrue: [^jugadorA nombre]. 
	(cartaDeTrucoB mataA: cartaDeTrucoA) ifTrue: [^jugadorB nombre].
	
	((cartaDeTrucoB empardaCon: cartaDeTrucoA) ifTrue: [
		ronda previaRondaParda.
		^ronda jugadorMano]).

! !
!NumeroRondaDeTruco class methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 21:10:51'!
entreJugador: unJugador vs: otroJugador ronda: unaRondaTruco   
	
	^self new initializeEntreJugador: unJugador vs: otroJugador ronda: unaRondaTruco ! !

!methodRemoval: NumeroRondaDeTruco class #entreJugador:vs:previaParda:jugadores:cartasUsadas: stamp: 'pc 7/5/2021 21:11:16'!
entreJugador: unJugador vs: otroJugador previaParda: aBool jugadores: aBag cartasUsadas: aCollection   
	
	^self new initializeEntreJugador: unJugador vs: otroJugador previaParda: aBool jugadores: aBag cartasUsadas: aCollection!

!testRun: #CartaDeTrucoTest #test01SonIgualesConMismoPaloYNumero stamp: 'pc 7/5/2021 21:11:19'!
PASSED!

!testRun: #CartaDeTrucoTest #test02SonDistintasConDistintoPalo stamp: 'pc 7/5/2021 21:11:19'!
PASSED!

!testRun: #CartaDeTrucoTest #test03SonDistintasConNumeroAunqueIgualPalo stamp: 'pc 7/5/2021 21:11:19'!
PASSED!

!testRun: #CartaDeTrucoTest #test04CartasIgualesTienenElMismoHash stamp: 'pc 7/5/2021 21:11:19'!
PASSED!

!testRun: #CartaDeTrucoTest #test05UnaCartaEsDistintaACualquierObjetoQueNoSeaCarta stamp: 'pc 7/5/2021 21:11:19'!
PASSED!

!testRun: #CartaDeTrucoTest #test07NoHayCartaDeTrucoConNumeroOcho stamp: 'pc 7/5/2021 21:11:19'!
PASSED!

!testRun: #CartaDeTrucoTest #test08NoHayCartaDeTrucoConNumeroNueve stamp: 'pc 7/5/2021 21:11:19'!
PASSED!

!testRun: #CartaDeTrucoTest #test09LosPalosDeLaCartaDeTrucoSonBastoOroEspadaYCopa stamp: 'pc 7/5/2021 21:11:19'!
PASSED!

!testRun: #CartaDeTrucoTest #test10NoSePuedeCrearCartaConNumeroMenorAUno stamp: 'pc 7/5/2021 21:11:19'!
PASSED!

!testRun: #CartaDeTrucoTest #test11NoSePuedeCrearCartaConNumeroMayorADoce stamp: 'pc 7/5/2021 21:11:19'!
PASSED!

!testRun: #CartaDeTrucoTest #test12ElNumeroDeLaCartaDebeSerEntero stamp: 'pc 7/5/2021 21:11:19'!
PASSED!

!testRun: #CartaDeTrucoTest #test13LaTablaDeValoresEsCorrecta stamp: 'pc 7/5/2021 21:11:19'!
PASSED!

!testRun: #CartaDeTrucoTest #test14HayCartasQueNoSonPardas stamp: 'pc 7/5/2021 21:11:19'!
PASSED!

!testRun: #CartaDeTrucoTest #test15HayCartasQuePierdenConOtras stamp: 'pc 7/5/2021 21:11:19'!
PASSED!

!testRun: #CartaDeTrucoTest #test16SieteDeCopasYDeBastoEsSieteFalso stamp: 'pc 7/5/2021 21:11:19'!
PASSED!

!testRun: #CartaDeTrucoTest #test17SieteDeOroYDeEspadaNoSonSieteFalso stamp: 'pc 7/5/2021 21:11:20'!
PASSED!

!testRun: #CartaDeTrucoTest #test18AnchoDeOroYDeCopaSonAnchoFalsos stamp: 'pc 7/5/2021 21:11:20'!
PASSED!

!testRun: #CartaDeTrucoTest #test19AnchoDeEspadaYDeBastosNoSonAnchoFalsos stamp: 'pc 7/5/2021 21:11:20'!
PASSED!

!testRun: #CartaDeTrucoTest #test20FallaBuscandoValorDeCartaInv�lida stamp: 'pc 7/5/2021 21:11:20'!
PASSED!

!testRun: #RondaDeTrucoTest #test01 stamp: 'pc 7/5/2021 21:11:20'!
PASSED!

!testRun: #RondaDeTrucoTest #test02 stamp: 'pc 7/5/2021 21:11:20'!
PASSED!

!testRun: #RondaDeTrucoTest #test03 stamp: 'pc 7/5/2021 21:11:20'!
PASSED!

!testRun: #RondaDeTrucoTest #test04 stamp: 'pc 7/5/2021 21:11:20'!
PASSED!

!testRun: #RondaDeTrucoTest #test05 stamp: 'pc 7/5/2021 21:11:20'!
PASSED!

!testRun: #RondaDeTrucoTest #test06 stamp: 'pc 7/5/2021 21:11:20'!
PASSED!

!testRun: #RondaDeTrucoTest #test07 stamp: 'pc 7/5/2021 21:11:20'!
PASSED!

!testRun: #RondaDeTrucoTest #test08 stamp: 'pc 7/5/2021 21:11:20'!
PASSED!

!testRun: #RondaDeTrucoTest #test09 stamp: 'pc 7/5/2021 21:11:20'!
PASSED!

!testRun: #RondaDeTrucoTest #test10 stamp: 'pc 7/5/2021 21:11:20'!
PASSED!

!testRun: #RondaDeTrucoTest #test11 stamp: 'pc 7/5/2021 21:11:20'!
PASSED!

!testRun: #RondaDeTrucoTest #test12 stamp: 'pc 7/5/2021 21:11:20'!
PASSED!

!testRun: #RondaDeTrucoTest #test13 stamp: 'pc 7/5/2021 21:11:20'!
PASSED!
!Enfrentamiento1 methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 21:12:14'!
initializeEntreJugador: unJugador vs: otroJugador ronda: unaRondaTruco 

	jugadorA := unJugador .
	jugadorB := otroJugador .
	ronda:=unaRondaTruco ! !

!methodRemoval: Enfrentamiento1 #initializeEntreJugador:vs:previaParda:jugadores:cartasUsadas: stamp: 'pc 7/5/2021 21:12:19'!
initializeEntreJugador: unJugador vs: otroJugador previaParda: aBool jugadores: aBag cartasUsadas: aCollection

	previaRondaParda := aBool.
	jugadorA := unJugador .
	jugadorB := otroJugador .
	jugadores := aBag .
	cartasUsadas := aCollection !
!Enfrentamiento1 methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 21:12:36' prior: 50918205!
enfrentamientoEntre: cartaDeTrucoA vs: cartaDeTrucoB
	
	self revisarCartasRepetidasEntre: cartaDeTrucoA y: cartaDeTrucoB.
	
	cartasUsadas add: cartaDeTrucoA.
	cartasUsadas add: cartaDeTrucoB.

	(cartaDeTrucoA mataA: cartaDeTrucoB) ifTrue: [^jugadorA nombre]. 
	(cartaDeTrucoB mataA: cartaDeTrucoA) ifTrue: [^jugadorB nombre].
	
	((cartaDeTrucoB empardaCon: cartaDeTrucoA) ifTrue: [
		ronda rondaPreviaParda.
		^ronda jugadorMano]).

! !
!Enfrentamiento1 methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 21:14:23'!
ganador 
	
	self error: self class noTerminoLaRondaTodavia.

! !

!methodRemoval: Enfrentamiento2 #initializeEntreJugador:vs:previaParda:jugadores:cartasUsadas: stamp: 'pc 7/5/2021 21:14:52'!
initializeEntreJugador: unJugador vs: otroJugador previaParda: aBool jugadores: aBag cartasUsadas: aCollection

	previaRondaParda := aBool.
	jugadorA := unJugador .
	jugadorB := otroJugador .
	jugadores := aBag .
	cartasUsadas := aCollection !

!methodRemoval: Enfrentamiento3 #initializeEntreJugador:vs:previaParda:jugadores:cartasUsadas: stamp: 'pc 7/5/2021 21:14:59'!
initializeEntreJugador: unJugador vs: otroJugador previaParda: aBool jugadores: aBag cartasUsadas: aCollection

	previaRondaParda := aBool.
	jugadorA := unJugador .
	jugadorB := otroJugador .
	jugadores := aBag .
	cartasUsadas := aCollection !
!Enfrentamiento1 methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 21:15:36' prior: 50918373!
ganador 
	
	^ronda class noTerminoLaRondaTodavia.

! !

!classDefinition: #Enfrentamiento2 category: 'ISW1-2021-1C-2doParcial' stamp: 'pc 7/5/2021 21:15:55'!
NumeroRondaDeTruco subclass: #Enfrentamiento2
	instanceVariableNames: 'ronda'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial'!
!Enfrentamiento2 methodsFor: 'no messages' stamp: 'pc 7/5/2021 21:15:52'!
initializeEntreJugador: unJugador vs: otroJugador ronda: unaRondaTruco 

	jugadorA := unJugador .
	jugadorB := otroJugador .
	ronda:=unaRondaTruco ! !

!classDefinition: #Enfrentamiento3 category: 'ISW1-2021-1C-2doParcial' stamp: 'pc 7/5/2021 21:16:01'!
NumeroRondaDeTruco subclass: #Enfrentamiento3
	instanceVariableNames: 'ronda'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial'!
!Enfrentamiento3 methodsFor: 'no messages' stamp: 'pc 7/5/2021 21:16:00'!
initializeEntreJugador: unJugador vs: otroJugador ronda: unaRondaTruco 

	jugadorA := unJugador .
	jugadorB := otroJugador .
	ronda:=unaRondaTruco ! !
!Enfrentamiento2 methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 21:16:25'!
enfrentamientoEntre: cartaDeTrucoA vs: cartaDeTrucoB
	
	self revisarCartasRepetidasEntre: cartaDeTrucoA y: cartaDeTrucoB.
	
	cartasUsadas add: cartaDeTrucoA.
	cartasUsadas add: cartaDeTrucoB.

	(cartaDeTrucoA mataA: cartaDeTrucoB) ifTrue: [^jugadorA nombre]. 
	(cartaDeTrucoB mataA: cartaDeTrucoA) ifTrue: [^jugadorB nombre].
	
	((cartaDeTrucoB empardaCon: cartaDeTrucoA) ifTrue: [
		ronda rondaPreviaParda.
		^ronda jugadorMano]).! !

!classRemoval: #Enfrentamiento1 stamp: 'pc 7/5/2021 21:17:35'!
NumeroRondaDeTruco subclass: #Enfrentamiento1
	instanceVariableNames: 'ronda'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial'!

!classRemoval: #Enfrentamiento2 stamp: 'pc 7/5/2021 21:17:35'!
NumeroRondaDeTruco subclass: #Enfrentamiento2
	instanceVariableNames: 'ronda'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial'!

!classRemoval: #Enfrentamiento3 stamp: 'pc 7/5/2021 21:17:36'!
NumeroRondaDeTruco subclass: #Enfrentamiento3
	instanceVariableNames: 'ronda'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial'!

!classRemoval: #NumeroRondaDeTruco stamp: 'pc 7/5/2021 21:17:36'!
Object subclass: #NumeroRondaDeTruco
	instanceVariableNames: 'previaRondaParda jugadorA jugadorB jugadores cartasUsadas'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial'!

Object subclass: #NumeroRondaDeTruco
	instanceVariableNames: 'jugadorA jugadorB ronda jugadores primerRondaParda cartasUsadas'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial'!

!classDefinition: #NumeroRondaDeTruco category: 'ISW1-2021-1C-2doParcial' stamp: 'pc 7/5/2021 21:17:45'!
Object subclass: #NumeroRondaDeTruco
	instanceVariableNames: 'jugadorA jugadorB ronda jugadores primerRondaParda cartasUsadas'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial'!

NumeroRondaDeTruco class
	instanceVariableNames: ''!

!classDefinition: 'NumeroRondaDeTruco class' category: 'ISW1-2021-1C-2doParcial' stamp: 'pc 7/5/2021 21:17:45'!
NumeroRondaDeTruco class
	instanceVariableNames: ''!
!NumeroRondaDeTruco methodsFor: 'initialization' stamp: 'pc 7/5/2021 21:17:45'!
initializeEntreJugador: unJugador vs: otroJugador 
	
	primerRondaParda := false.
	ronda := 0 .
	jugadorA := unJugador .
	jugadorB := otroJugador .
	jugadores := Bag new.
	cartasUsadas := OrderedCollection new.! !
!NumeroRondaDeTruco methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 21:17:45'!
enfrentamientoEntre: cartaDeTrucoA vs: cartaDeTrucoB
	
	self revisarFinalizacionDeRonda.
	
	self revisarCartasRepetidasEntre: cartaDeTrucoA y: cartaDeTrucoB.
	
	cartasUsadas add: cartaDeTrucoA.
	cartasUsadas add: cartaDeTrucoB.

	ronda := ronda + 1.
	(cartaDeTrucoA mataA: cartaDeTrucoB) ifTrue: [jugadores add: jugadorA nombre]. 
	(cartaDeTrucoB mataA: cartaDeTrucoA) ifTrue: [jugadores add:jugadorB nombre].
	((cartaDeTrucoB empardaCon: cartaDeTrucoA) and: primerRondaParda) ifTrue: [jugadores add: self jugadorMano].
	(cartaDeTrucoB empardaCon: cartaDeTrucoA) ifTrue: [primerRondaParda := true].
! !
!NumeroRondaDeTruco methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 21:17:45'!
enfretamientosGanadosPor: unJugador 
	
	^jugadores occurrencesOf: unJugador nombre.! !
!NumeroRondaDeTruco methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 21:17:45'!
ganador
	
	ronda = 3 ifTrue:[
		((jugadores occurrencesOf: jugadorA nombre) > (jugadores occurrencesOf: jugadorB nombre)) ifTrue: [^jugadorA  ] ifFalse: [^jugadorB ]].
	(ronda = 2 and: [primerRondaParda or: [(self enfretamientosGanadosPor: jugadorA ) = 2 or: [(self enfretamientosGanadosPor: jugadorB ) =2]]])
		ifTrue:[
		((jugadores occurrencesOf: jugadorA nombre) > (jugadores occurrencesOf: jugadorB nombre)) ifTrue: [^jugadorA  ] ifFalse: [^jugadorB ]].
	
	self error: self class noTerminoLaRondaTodavia.! !
!NumeroRondaDeTruco methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 21:17:45'!
jugadorMano
	^jugadorA nombre! !
!NumeroRondaDeTruco methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 21:17:45'!
jugar
	
	self enfrentamientoEntre: jugadorA cartas first vs: jugadorB cartas first.
	self enfrentamientoEntre: jugadorA cartas second vs: 	 jugadorB cartas second. 
	self enfrentamientoEntre: jugadorA cartas third vs:  jugadorB cartas third.! !
!NumeroRondaDeTruco methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 21:17:45'!
revisarCartasRepetidasEntre: cartaDeTrucoA y: cartaDeTrucoB.
	
		((cartasUsadas includes: cartaDeTrucoA) or: [(cartasUsadas includes: cartaDeTrucoB) or: [cartaDeTrucoA = cartaDeTrucoB ]]) ifTrue: [^self error: self class cartaRepetidaError].
! !
!NumeroRondaDeTruco methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 21:17:45'!
revisarFinalizacionDeRonda.
	
	((self enfretamientosGanadosPor: jugadorA ) = 2 or: [(self enfretamientosGanadosPor: jugadorB ) =2] ) ifTrue: [self error: self class noSePuedeJugarCuandoYaHayGanadorError].
! !
!NumeroRondaDeTruco methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 21:17:45'!
rondasJugadas
	^ronda! !
!NumeroRondaDeTruco class methodsFor: 'instance creation' stamp: 'pc 7/5/2021 21:17:45'!
entreJugador: unJugador vs: otroJugador primeraParda: rondaPreviaParda   
	
	^self new initializeEntreJugador: unJugador vs: otroJugador ! !
!NumeroRondaDeTruco class methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 21:17:45'!
cartaRepetidaError
	^'la carta quese quiere usar ya fue usada'! !
!NumeroRondaDeTruco class methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 21:17:45'!
noSePuedeJugarCuandoYaHayGanadorError
	^'no se puede continuar el partido una vez finalizado'! !
!NumeroRondaDeTruco class methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 21:17:45'!
noTerminoLaRondaTodavia
	
	^'no se puede saber el ganador antes de que termine la ronda'! !

NumeroRondaDeTruco subclass: #ronda1
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial'!

NumeroRondaDeTruco subclass: #Ronda1
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial'!

!classDefinition: #Ronda1 category: 'ISW1-2021-1C-2doParcial' stamp: 'pc 7/5/2021 21:18:30'!
NumeroRondaDeTruco subclass: #Ronda1
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial'!

NumeroRondaDeTruco subclass: #Ronda2
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial'!

!classDefinition: #Ronda2 category: 'ISW1-2021-1C-2doParcial' stamp: 'pc 7/5/2021 21:18:34'!
NumeroRondaDeTruco subclass: #Ronda2
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial'!

NumeroRondaDeTruco subclass: #Ronda3
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial'!

!classDefinition: #Ronda3 category: 'ISW1-2021-1C-2doParcial' stamp: 'pc 7/5/2021 21:18:36'!
NumeroRondaDeTruco subclass: #Ronda3
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial'!
!NumeroRondaDeTruco class methodsFor: 'instance creation' stamp: 'pc 7/5/2021 21:19:29'!
entreJugador: unJugador vs: otroJugador unaPartida: unaPartidaDeTruco
	
	^self new initializeEntreJugador: unJugador vs: otroJugador unaPartida: unaPartidaDeTruco! !

!methodRemoval: NumeroRondaDeTruco class #entreJugador:vs:primeraParda: stamp: 'pc 7/5/2021 21:19:35'!
entreJugador: unJugador vs: otroJugador primeraParda: rondaPreviaParda   
	
	^self new initializeEntreJugador: unJugador vs: otroJugador !

!classDefinition: #NumeroRondaDeTruco category: 'ISW1-2021-1C-2doParcial' stamp: 'pc 7/5/2021 21:20:19'!
Object subclass: #NumeroRondaDeTruco
	instanceVariableNames: 'jugadorA jugadorB ronda jugadores primerRondaParda cartasUsadas partida'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial'!
!NumeroRondaDeTruco methodsFor: 'initialization' stamp: 'pc 7/5/2021 21:20:17'!
 initializeEntreJugador: unJugador vs: otroJugador unaPartida: unaPartidaDeTruco 
	
	partida:=unaPartidaDeTruco .
	jugadorA := unJugador .
	jugadorB := otroJugador .! !

!methodRemoval: NumeroRondaDeTruco #initializeEntreJugador:vs: stamp: 'pc 7/5/2021 21:20:27'!
initializeEntreJugador: unJugador vs: otroJugador 
	
	primerRondaParda := false.
	ronda := 0 .
	jugadorA := unJugador .
	jugadorB := otroJugador .
	jugadores := Bag new.
	cartasUsadas := OrderedCollection new.!
!Ronda1 methodsFor: 'initialization' stamp: 'pc 7/5/2021 21:20:43' overrides: 50918698!
initializeEntreJugador: unJugador vs: otroJugador unaPartida: unaPartidaDeTruco 
	
	partida:=unaPartidaDeTruco .
	jugadorA := unJugador .
	jugadorB := otroJugador .! !
!Ronda2 methodsFor: 'initialization' stamp: 'pc 7/5/2021 21:20:43' overrides: 50918698!
initializeEntreJugador: unJugador vs: otroJugador unaPartida: unaPartidaDeTruco 
	
	partida:=unaPartidaDeTruco .
	jugadorA := unJugador .
	jugadorB := otroJugador .! !
!Ronda3 methodsFor: 'initialization' stamp: 'pc 7/5/2021 21:20:43' overrides: 50918698!
initializeEntreJugador: unJugador vs: otroJugador unaPartida: unaPartidaDeTruco 
	
	partida:=unaPartidaDeTruco .
	jugadorA := unJugador .
	jugadorB := otroJugador .! !

!methodRemoval: NumeroRondaDeTruco #initializeEntreJugador:vs:unaPartida: stamp: 'pc 7/5/2021 21:20:43'!
initializeEntreJugador: unJugador vs: otroJugador unaPartida: unaPartidaDeTruco 
	
	partida:=unaPartidaDeTruco .
	jugadorA := unJugador .
	jugadorB := otroJugador .!
!Ronda1 methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 21:20:52' overrides: 50918519!
enfrentamientoEntre: cartaDeTrucoA vs: cartaDeTrucoB
	
	self revisarFinalizacionDeRonda.
	
	self revisarCartasRepetidasEntre: cartaDeTrucoA y: cartaDeTrucoB.
	
	cartasUsadas add: cartaDeTrucoA.
	cartasUsadas add: cartaDeTrucoB.

	ronda := ronda + 1.
	(cartaDeTrucoA mataA: cartaDeTrucoB) ifTrue: [jugadores add: jugadorA nombre]. 
	(cartaDeTrucoB mataA: cartaDeTrucoA) ifTrue: [jugadores add:jugadorB nombre].
	((cartaDeTrucoB empardaCon: cartaDeTrucoA) and: primerRondaParda) ifTrue: [jugadores add: self jugadorMano].
	(cartaDeTrucoB empardaCon: cartaDeTrucoA) ifTrue: [primerRondaParda := true].
! !
!Ronda2 methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 21:20:52' overrides: 50918519!
enfrentamientoEntre: cartaDeTrucoA vs: cartaDeTrucoB
	
	self revisarFinalizacionDeRonda.
	
	self revisarCartasRepetidasEntre: cartaDeTrucoA y: cartaDeTrucoB.
	
	cartasUsadas add: cartaDeTrucoA.
	cartasUsadas add: cartaDeTrucoB.

	ronda := ronda + 1.
	(cartaDeTrucoA mataA: cartaDeTrucoB) ifTrue: [jugadores add: jugadorA nombre]. 
	(cartaDeTrucoB mataA: cartaDeTrucoA) ifTrue: [jugadores add:jugadorB nombre].
	((cartaDeTrucoB empardaCon: cartaDeTrucoA) and: primerRondaParda) ifTrue: [jugadores add: self jugadorMano].
	(cartaDeTrucoB empardaCon: cartaDeTrucoA) ifTrue: [primerRondaParda := true].
! !
!Ronda3 methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 21:20:52' overrides: 50918519!
enfrentamientoEntre: cartaDeTrucoA vs: cartaDeTrucoB
	
	self revisarFinalizacionDeRonda.
	
	self revisarCartasRepetidasEntre: cartaDeTrucoA y: cartaDeTrucoB.
	
	cartasUsadas add: cartaDeTrucoA.
	cartasUsadas add: cartaDeTrucoB.

	ronda := ronda + 1.
	(cartaDeTrucoA mataA: cartaDeTrucoB) ifTrue: [jugadores add: jugadorA nombre]. 
	(cartaDeTrucoB mataA: cartaDeTrucoA) ifTrue: [jugadores add:jugadorB nombre].
	((cartaDeTrucoB empardaCon: cartaDeTrucoA) and: primerRondaParda) ifTrue: [jugadores add: self jugadorMano].
	(cartaDeTrucoB empardaCon: cartaDeTrucoA) ifTrue: [primerRondaParda := true].
! !

!methodRemoval: NumeroRondaDeTruco #enfrentamientoEntre:vs: stamp: 'pc 7/5/2021 21:20:53'!
enfrentamientoEntre: cartaDeTrucoA vs: cartaDeTrucoB
	
	self revisarFinalizacionDeRonda.
	
	self revisarCartasRepetidasEntre: cartaDeTrucoA y: cartaDeTrucoB.
	
	cartasUsadas add: cartaDeTrucoA.
	cartasUsadas add: cartaDeTrucoB.

	ronda := ronda + 1.
	(cartaDeTrucoA mataA: cartaDeTrucoB) ifTrue: [jugadores add: jugadorA nombre]. 
	(cartaDeTrucoB mataA: cartaDeTrucoA) ifTrue: [jugadores add:jugadorB nombre].
	((cartaDeTrucoB empardaCon: cartaDeTrucoA) and: primerRondaParda) ifTrue: [jugadores add: self jugadorMano].
	(cartaDeTrucoB empardaCon: cartaDeTrucoA) ifTrue: [primerRondaParda := true].
!
!Ronda1 methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 21:21:18' prior: 50918749!
enfrentamientoEntre: cartaDeTrucoA vs: cartaDeTrucoB
	
	self revisarCartasRepetidasEntre: cartaDeTrucoA y: cartaDeTrucoB.
	
	cartasUsadas add: cartaDeTrucoA.
	cartasUsadas add: cartaDeTrucoB.

	ronda := ronda + 1.
	(cartaDeTrucoA mataA: cartaDeTrucoB) ifTrue: [jugadores add: jugadorA nombre]. 
	(cartaDeTrucoB mataA: cartaDeTrucoA) ifTrue: [jugadores add:jugadorB nombre].
	((cartaDeTrucoB empardaCon: cartaDeTrucoA) and: primerRondaParda) ifTrue: [jugadores add: self jugadorMano].
	(cartaDeTrucoB empardaCon: cartaDeTrucoA) ifTrue: [primerRondaParda := true].
! !
!Ronda1 methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 21:21:57' overrides: 50918581!
revisarCartasRepetidasEntre: cartaDeTrucoA y: cartaDeTrucoB.
	
		((cartasUsadas includes: cartaDeTrucoA) or: [(cartasUsadas includes: cartaDeTrucoB) or: [cartaDeTrucoA = cartaDeTrucoB ]]) ifTrue: [^self error: self class cartaRepetidaError].
! !
!Ronda2 methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 21:21:57' overrides: 50918581!
revisarCartasRepetidasEntre: cartaDeTrucoA y: cartaDeTrucoB.
	
		((cartasUsadas includes: cartaDeTrucoA) or: [(cartasUsadas includes: cartaDeTrucoB) or: [cartaDeTrucoA = cartaDeTrucoB ]]) ifTrue: [^self error: self class cartaRepetidaError].
! !
!Ronda3 methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 21:21:57' overrides: 50918581!
revisarCartasRepetidasEntre: cartaDeTrucoA y: cartaDeTrucoB.
	
		((cartasUsadas includes: cartaDeTrucoA) or: [(cartasUsadas includes: cartaDeTrucoB) or: [cartaDeTrucoA = cartaDeTrucoB ]]) ifTrue: [^self error: self class cartaRepetidaError].
! !

!methodRemoval: NumeroRondaDeTruco #revisarCartasRepetidasEntre:y: stamp: 'pc 7/5/2021 21:21:57'!
revisarCartasRepetidasEntre: cartaDeTrucoA y: cartaDeTrucoB.
	
		((cartasUsadas includes: cartaDeTrucoA) or: [(cartasUsadas includes: cartaDeTrucoB) or: [cartaDeTrucoA = cartaDeTrucoB ]]) ifTrue: [^self error: self class cartaRepetidaError].
!
!Ronda1 methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 21:22:26' prior: 50918858!
revisarCartasRepetidasEntre: cartaDeTrucoA y: cartaDeTrucoB.
	
cartaDeTrucoA = cartaDeTrucoB ifTrue: [^self error: self class cartaRepetidaError].
! !
!Ronda1 methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 21:22:50' overrides: 50918592!
revisarFinalizacionDeRonda.
	
	((self enfretamientosGanadosPor: jugadorA ) = 2 or: [(self enfretamientosGanadosPor: jugadorB ) =2] ) ifTrue: [self error: self class noSePuedeJugarCuandoYaHayGanadorError].
! !
!Ronda2 methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 21:22:50' overrides: 50918592!
revisarFinalizacionDeRonda.
	
	((self enfretamientosGanadosPor: jugadorA ) = 2 or: [(self enfretamientosGanadosPor: jugadorB ) =2] ) ifTrue: [self error: self class noSePuedeJugarCuandoYaHayGanadorError].
! !
!Ronda3 methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 21:22:50' overrides: 50918592!
revisarFinalizacionDeRonda.
	
	((self enfretamientosGanadosPor: jugadorA ) = 2 or: [(self enfretamientosGanadosPor: jugadorB ) =2] ) ifTrue: [self error: self class noSePuedeJugarCuandoYaHayGanadorError].
! !

!methodRemoval: NumeroRondaDeTruco #revisarFinalizacionDeRonda stamp: 'pc 7/5/2021 21:22:50'!
revisarFinalizacionDeRonda.
	
	((self enfretamientosGanadosPor: jugadorA ) = 2 or: [(self enfretamientosGanadosPor: jugadorB ) =2] ) ifTrue: [self error: self class noSePuedeJugarCuandoYaHayGanadorError].
!

!methodRemoval: Ronda1 #revisarFinalizacionDeRonda stamp: 'pc 7/5/2021 21:23:09'!
revisarFinalizacionDeRonda.
	
	((self enfretamientosGanadosPor: jugadorA ) = 2 or: [(self enfretamientosGanadosPor: jugadorB ) =2] ) ifTrue: [self error: self class noSePuedeJugarCuandoYaHayGanadorError].
!
!Ronda1 methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 21:23:55' prior: 50918837!
enfrentamientoEntre: cartaDeTrucoA vs: cartaDeTrucoB
	
	self revisarCartasRepetidasEntre: cartaDeTrucoA y: cartaDeTrucoB.
	
	cartasUsadas add: cartaDeTrucoA.
	cartasUsadas add: cartaDeTrucoB.

	ronda := ronda + 1.
	(cartaDeTrucoA mataA: cartaDeTrucoB) ifTrue: [jugadores add: jugadorA nombre]. 
	(cartaDeTrucoB mataA: cartaDeTrucoA) ifTrue: [jugadores add:jugadorB nombre].
	(cartaDeTrucoB empardaCon: cartaDeTrucoA) ifTrue: [primerRondaParda := true].
! !

!testRun: #CartaDeTrucoTest #test01SonIgualesConMismoPaloYNumero stamp: 'pc 7/5/2021 21:24:07'!
PASSED!

!testRun: #CartaDeTrucoTest #test02SonDistintasConDistintoPalo stamp: 'pc 7/5/2021 21:24:07'!
PASSED!

!testRun: #CartaDeTrucoTest #test03SonDistintasConNumeroAunqueIgualPalo stamp: 'pc 7/5/2021 21:24:07'!
PASSED!

!testRun: #CartaDeTrucoTest #test04CartasIgualesTienenElMismoHash stamp: 'pc 7/5/2021 21:24:07'!
PASSED!

!testRun: #CartaDeTrucoTest #test05UnaCartaEsDistintaACualquierObjetoQueNoSeaCarta stamp: 'pc 7/5/2021 21:24:07'!
PASSED!

!testRun: #CartaDeTrucoTest #test07NoHayCartaDeTrucoConNumeroOcho stamp: 'pc 7/5/2021 21:24:07'!
PASSED!

!testRun: #CartaDeTrucoTest #test08NoHayCartaDeTrucoConNumeroNueve stamp: 'pc 7/5/2021 21:24:07'!
PASSED!

!testRun: #CartaDeTrucoTest #test09LosPalosDeLaCartaDeTrucoSonBastoOroEspadaYCopa stamp: 'pc 7/5/2021 21:24:07'!
PASSED!

!testRun: #CartaDeTrucoTest #test10NoSePuedeCrearCartaConNumeroMenorAUno stamp: 'pc 7/5/2021 21:24:07'!
PASSED!

!testRun: #CartaDeTrucoTest #test11NoSePuedeCrearCartaConNumeroMayorADoce stamp: 'pc 7/5/2021 21:24:07'!
PASSED!

!testRun: #CartaDeTrucoTest #test12ElNumeroDeLaCartaDebeSerEntero stamp: 'pc 7/5/2021 21:24:07'!
PASSED!

!testRun: #CartaDeTrucoTest #test13LaTablaDeValoresEsCorrecta stamp: 'pc 7/5/2021 21:24:07'!
PASSED!

!testRun: #CartaDeTrucoTest #test14HayCartasQueNoSonPardas stamp: 'pc 7/5/2021 21:24:07'!
PASSED!

!testRun: #CartaDeTrucoTest #test15HayCartasQuePierdenConOtras stamp: 'pc 7/5/2021 21:24:07'!
PASSED!

!testRun: #CartaDeTrucoTest #test16SieteDeCopasYDeBastoEsSieteFalso stamp: 'pc 7/5/2021 21:24:07'!
PASSED!

!testRun: #CartaDeTrucoTest #test17SieteDeOroYDeEspadaNoSonSieteFalso stamp: 'pc 7/5/2021 21:24:07'!
PASSED!

!testRun: #CartaDeTrucoTest #test18AnchoDeOroYDeCopaSonAnchoFalsos stamp: 'pc 7/5/2021 21:24:07'!
PASSED!

!testRun: #CartaDeTrucoTest #test19AnchoDeEspadaYDeBastosNoSonAnchoFalsos stamp: 'pc 7/5/2021 21:24:07'!
PASSED!

!testRun: #CartaDeTrucoTest #test20FallaBuscandoValorDeCartaInv�lida stamp: 'pc 7/5/2021 21:24:07'!
PASSED!

!testRun: #RondaDeTrucoTest #test01 stamp: 'pc 7/5/2021 21:24:07'!
PASSED!

!testRun: #RondaDeTrucoTest #test02 stamp: 'pc 7/5/2021 21:24:07'!
PASSED!

!testRun: #RondaDeTrucoTest #test03 stamp: 'pc 7/5/2021 21:24:07'!
PASSED!

!testRun: #RondaDeTrucoTest #test04 stamp: 'pc 7/5/2021 21:24:07'!
PASSED!

!testRun: #RondaDeTrucoTest #test05 stamp: 'pc 7/5/2021 21:24:07'!
PASSED!

!testRun: #RondaDeTrucoTest #test06 stamp: 'pc 7/5/2021 21:24:07'!
PASSED!

!testRun: #RondaDeTrucoTest #test07 stamp: 'pc 7/5/2021 21:24:07'!
PASSED!

!testRun: #RondaDeTrucoTest #test08 stamp: 'pc 7/5/2021 21:24:07'!
PASSED!

!testRun: #RondaDeTrucoTest #test09 stamp: 'pc 7/5/2021 21:24:07'!
PASSED!

!testRun: #RondaDeTrucoTest #test10 stamp: 'pc 7/5/2021 21:24:07'!
PASSED!

!testRun: #RondaDeTrucoTest #test11 stamp: 'pc 7/5/2021 21:24:07'!
PASSED!

!testRun: #RondaDeTrucoTest #test12 stamp: 'pc 7/5/2021 21:24:07'!
PASSED!

!testRun: #RondaDeTrucoTest #test13 stamp: 'pc 7/5/2021 21:24:07'!
PASSED!

!classRenamed: #Ronda1 as: #RondaNormal stamp: 'pc 7/5/2021 21:25:36'!
Smalltalk renameClassNamed: #Ronda1 as: #RondaNormal!

!classRenamed: #RondaNormal as: #Ronda1 stamp: 'pc 7/5/2021 21:26:02'!
Smalltalk renameClassNamed: #RondaNormal as: #Ronda1!
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 21:31:43' prior: 50917454!
test13
	| rondaDeTruco tresCartasA tresCartasB |
	tresCartasA := OrderedCollection new.
	tresCartasA add: (CartaDeTruco oroCon: 4).
	tresCartasA add: CartaDeTruco anchoDeEspada.
	tresCartasA add: (CartaDeTruco copaCon: 3).
	tresCartasB := OrderedCollection new.
	tresCartasB add: (CartaDeTruco oroCon: 2).
	tresCartasB add: CartaDeTruco anchoDeBasto.
	tresCartasB add: (CartaDeTruco copaCon: 4).
	jugadorA conCartas: tresCartasA.
	jugadorB conCartas: tresCartasB.
	rondaDeTruco _ RondaDeTruco
		entreJugador: jugadorA
		vs: jugadorB primeraParda: true.
	
	rondaDeTruco jugar.
	
	self assert: (rondaDeTruco rondasJugadas) equals: 3.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorA) equals: 2.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorB) equals: 1.
	self assert: (rondaDeTruco ganador) equals: jugadorA .
	
	! !

!testRun: #RondaDeTrucoTest #test13 stamp: 'pc 7/5/2021 21:31:45'!
PASSED!

!testRun: #CartaDeTrucoTest #test01SonIgualesConMismoPaloYNumero stamp: 'pc 7/5/2021 21:31:45'!
PASSED!

!testRun: #CartaDeTrucoTest #test02SonDistintasConDistintoPalo stamp: 'pc 7/5/2021 21:31:45'!
PASSED!

!testRun: #CartaDeTrucoTest #test03SonDistintasConNumeroAunqueIgualPalo stamp: 'pc 7/5/2021 21:31:45'!
PASSED!

!testRun: #CartaDeTrucoTest #test04CartasIgualesTienenElMismoHash stamp: 'pc 7/5/2021 21:31:45'!
PASSED!

!testRun: #CartaDeTrucoTest #test05UnaCartaEsDistintaACualquierObjetoQueNoSeaCarta stamp: 'pc 7/5/2021 21:31:45'!
PASSED!

!testRun: #CartaDeTrucoTest #test07NoHayCartaDeTrucoConNumeroOcho stamp: 'pc 7/5/2021 21:31:45'!
PASSED!

!testRun: #CartaDeTrucoTest #test08NoHayCartaDeTrucoConNumeroNueve stamp: 'pc 7/5/2021 21:31:45'!
PASSED!

!testRun: #CartaDeTrucoTest #test09LosPalosDeLaCartaDeTrucoSonBastoOroEspadaYCopa stamp: 'pc 7/5/2021 21:31:45'!
PASSED!

!testRun: #CartaDeTrucoTest #test10NoSePuedeCrearCartaConNumeroMenorAUno stamp: 'pc 7/5/2021 21:31:45'!
PASSED!

!testRun: #CartaDeTrucoTest #test11NoSePuedeCrearCartaConNumeroMayorADoce stamp: 'pc 7/5/2021 21:31:45'!
PASSED!

!testRun: #CartaDeTrucoTest #test12ElNumeroDeLaCartaDebeSerEntero stamp: 'pc 7/5/2021 21:31:45'!
PASSED!

!testRun: #CartaDeTrucoTest #test13LaTablaDeValoresEsCorrecta stamp: 'pc 7/5/2021 21:31:45'!
PASSED!

!testRun: #CartaDeTrucoTest #test14HayCartasQueNoSonPardas stamp: 'pc 7/5/2021 21:31:45'!
PASSED!

!testRun: #CartaDeTrucoTest #test15HayCartasQuePierdenConOtras stamp: 'pc 7/5/2021 21:31:45'!
PASSED!

!testRun: #CartaDeTrucoTest #test16SieteDeCopasYDeBastoEsSieteFalso stamp: 'pc 7/5/2021 21:31:45'!
PASSED!

!testRun: #CartaDeTrucoTest #test17SieteDeOroYDeEspadaNoSonSieteFalso stamp: 'pc 7/5/2021 21:31:45'!
PASSED!

!testRun: #CartaDeTrucoTest #test18AnchoDeOroYDeCopaSonAnchoFalsos stamp: 'pc 7/5/2021 21:31:45'!
PASSED!

!testRun: #CartaDeTrucoTest #test19AnchoDeEspadaYDeBastosNoSonAnchoFalsos stamp: 'pc 7/5/2021 21:31:45'!
PASSED!

!testRun: #CartaDeTrucoTest #test20FallaBuscandoValorDeCartaInv�lida stamp: 'pc 7/5/2021 21:31:45'!
PASSED!

!testRun: #RondaDeTrucoTest #test01 stamp: 'pc 7/5/2021 21:31:45'!
PASSED!

!testRun: #RondaDeTrucoTest #test02 stamp: 'pc 7/5/2021 21:31:45'!
PASSED!

!testRun: #RondaDeTrucoTest #test03 stamp: 'pc 7/5/2021 21:31:45'!
PASSED!

!testRun: #RondaDeTrucoTest #test04 stamp: 'pc 7/5/2021 21:31:45'!
PASSED!

!testRun: #RondaDeTrucoTest #test05 stamp: 'pc 7/5/2021 21:31:45'!
PASSED!

!testRun: #RondaDeTrucoTest #test06 stamp: 'pc 7/5/2021 21:31:45'!
PASSED!

!testRun: #RondaDeTrucoTest #test07 stamp: 'pc 7/5/2021 21:31:45'!
PASSED!

!testRun: #RondaDeTrucoTest #test08 stamp: 'pc 7/5/2021 21:31:45'!
PASSED!

!testRun: #RondaDeTrucoTest #test09 stamp: 'pc 7/5/2021 21:31:45'!
PASSED!

!testRun: #RondaDeTrucoTest #test10 stamp: 'pc 7/5/2021 21:31:45'!
PASSED!

!testRun: #RondaDeTrucoTest #test11 stamp: 'pc 7/5/2021 21:31:45'!
PASSED!

!testRun: #RondaDeTrucoTest #test12 stamp: 'pc 7/5/2021 21:31:45'!
PASSED!

!testRun: #RondaDeTrucoTest #test13 stamp: 'pc 7/5/2021 21:31:45'!
PASSED!
!Ronda1 methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 21:33:13' prior: 50918958!
enfrentamientoEntre: cartaDeTrucoA vs: cartaDeTrucoB
	
	self revisarCartasRepetidasEntre: cartaDeTrucoA y: cartaDeTrucoB.
	
	cartasUsadas add: cartaDeTrucoA.
	cartasUsadas add: cartaDeTrucoB.

	ronda := ronda + 1.
	(cartaDeTrucoA mataA: cartaDeTrucoB) ifTrue: [^jugadores add: jugadorA nombre]. 
	(cartaDeTrucoB mataA: cartaDeTrucoA) ifTrue: [^jugadorB nombre].
	(cartaDeTrucoB empardaCon: cartaDeTrucoA) ifTrue: [partida priviaRondaParda].
! !
!NumeroRondaDeTruco methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 21:34:57' prior: 50918602!
rondasJugadas
	^ronda numero! !
!Ronda1 methodsFor: 'nil' stamp: 'pc 7/5/2021 21:35:12'!
numero 
	^1! !
!Ronda2 methodsFor: 'initialization' stamp: 'pc 7/5/2021 21:35:27'!
numero 
	^2! !
!Ronda3 methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 21:35:31'!
numero 
	^3! !
!Ronda1 methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 21:36:10' prior: 50919207!
enfrentamientoEntre: cartaDeTrucoA vs: cartaDeTrucoB
	
	self revisarCartasRepetidasEntre: cartaDeTrucoA y: cartaDeTrucoB.
	
	cartasUsadas add: cartaDeTrucoA.
	cartasUsadas add: cartaDeTrucoB.

	ronda := ronda + 1.
	(cartaDeTrucoA mataA: cartaDeTrucoB) ifTrue: [^jugadorA nombre]. 
	(cartaDeTrucoB mataA: cartaDeTrucoA) ifTrue: [^jugadorB nombre].
	(cartaDeTrucoB empardaCon: cartaDeTrucoA) ifTrue: [partida priviaRondaParda].
! !
!NumeroRondaDeTruco methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 21:37:37' prior: 50918570!
jugar
	
	jugadores add: (ronda enfrentamientoEntre: jugadorA cartas first vs: jugadorB cartas first).
	self enfrentamientoEntre: jugadorA cartas second vs: 	 jugadorB cartas second. 
	self enfrentamientoEntre: jugadorA cartas third vs:  jugadorB cartas third.! !
!NumeroRondaDeTruco methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 21:38:23' prior: 50919255!
jugar
	
	jugadores add: (ronda enfrentamientoEntre: jugadorA cartas first vs: jugadorB cartas first).
	
	self enfrentamientoEntre: jugadorA cartas second vs: 	 jugadorB cartas second. 
	self enfrentamientoEntre: jugadorA cartas third vs:  jugadorB cartas third.! !
!Ronda1 methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 21:39:17' prior: 50919238!
enfrentamientoEntre: cartaDeTrucoA vs: cartaDeTrucoB
	
	self revisarCartasRepetidasEntre: cartaDeTrucoA y: cartaDeTrucoB.
	
	cartasUsadas add: cartaDeTrucoA.
	cartasUsadas add: cartaDeTrucoB.

	(cartaDeTrucoA mataA: cartaDeTrucoB) ifTrue: [^jugadorA nombre]. 
	(cartaDeTrucoB mataA: cartaDeTrucoA) ifTrue: [^jugadorB nombre].
	(cartaDeTrucoB empardaCon: cartaDeTrucoA) ifTrue: [partida priviaRondaParda].
! !
!Ronda1 methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 21:39:50' prior: 50919279!
enfrentamientoEntre: cartaDeTrucoA vs: cartaDeTrucoB
	
	self revisarCartasRepetidasEntre: cartaDeTrucoA y: cartaDeTrucoB.
	
	cartasUsadas add: cartaDeTrucoA.
	cartasUsadas add: cartaDeTrucoB.

	partida cambiarDeRonda.
	(cartaDeTrucoA mataA: cartaDeTrucoB) ifTrue: [^jugadorA nombre]. 
	(cartaDeTrucoB mataA: cartaDeTrucoA) ifTrue: [^jugadorB nombre].
	(cartaDeTrucoB empardaCon: cartaDeTrucoA) ifTrue: [partida priviaRondaParda].
! !
!NumeroRondaDeTruco methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 21:40:31' prior: 50919267!
jugar
	
	jugadores add: (ronda enfrentamientoEntre: jugadorA cartas first vs: jugadorB cartas first).
	
	jugadores add: (ronda enfrentamientoEntre: jugadorA cartas second vs: 	 jugadorB cartas second). 
	jugadores add: (ronda enfrentamientoEntre: jugadorA cartas third vs:  jugadorB cartas third).! !
!NumeroRondaDeTruco methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 21:40:36' prior: 50919312!
jugar
	
	jugadores add: (ronda enfrentamientoEntre: jugadorA cartas first vs: jugadorB cartas first).
	
	jugadores add: (ronda enfrentamientoEntre: jugadorA cartas second vs: 	 jugadorB cartas second). 
	
	jugadores add: (ronda enfrentamientoEntre: jugadorA cartas third vs:  jugadorB cartas third).! !

!classRenamed: #RondaDeTruco as: #RondaDeTrucoSinRefactor stamp: 'pc 7/5/2021 21:41:56'!
Smalltalk renameClassNamed: #RondaDeTruco as: #RondaDeTrucoSinRefactor!
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 21:41:57' prior: 50917585!
test11
	| rondaDeTruco |
	
	rondaDeTruco _ RondaDeTrucoSinRefactor
		entreJugador: jugadorA
		vs: jugadorB primeraParda: true
		.
	
	rondaDeTruco enfrentamientoEntre: (CartaDeTruco oroCon: 4) vs: (CartaDeTruco oroCon: 2) .
	rondaDeTruco enfrentamientoEntre: CartaDeTruco anchoDeBasto vs: 	CartaDeTruco anchoDeEspada.
	
	self 
	should: [rondaDeTruco enfrentamientoEntre: (CartaDeTruco copaCon: 3) vs: (CartaDeTruco copaCon: 4)] 
	raise:  Error - MessageNotUnderstood 
	withExceptionDo: [:anError|
		self assert: RondaDeTrucoSinRefactor noSePuedeJugarCuandoYaHayGanadorError equals: anError messageText. 
		self assert: (rondaDeTruco rondasJugadas) equals: 2.
		self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorA) equals: 0.
		self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorB) equals: 2.
		self assert: (rondaDeTruco ganador) equals: jugadorB .]
	! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 21:41:57' prior: 50917765!
test06
	| rondaDeTruco |
	
	rondaDeTruco _ RondaDeTrucoSinRefactor
		entreJugador: jugadorA
		vs: jugadorB primeraParda: true
		.
	
	rondaDeTruco enfrentamientoEntre: (CartaDeTruco oroCon: 4) vs: (CartaDeTruco oroCon: 2) .
	rondaDeTruco enfrentamientoEntre: CartaDeTruco anchoDeEspada vs: 	CartaDeTruco anchoDeBasto. 
	rondaDeTruco enfrentamientoEntre: (CartaDeTruco copaCon: 3) vs: (CartaDeTruco copaCon: 4) .
	
	self assert: (rondaDeTruco rondasJugadas) equals: 3.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorA) equals: 2.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorB) equals: 1.
	self assert: (rondaDeTruco ganador) equals: jugadorA .! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 21:41:57' prior: 50917632!
test04
	| rondaDeTruco |
	

	rondaDeTruco _ RondaDeTrucoSinRefactor
		entreJugador: jugadorA
		vs: jugadorB primeraParda: true
		.
	
	rondaDeTruco enfrentamientoEntre: (CartaDeTruco oroCon: 2) vs: (CartaDeTruco bastoCon: 2).
	rondaDeTruco enfrentamientoEntre: CartaDeTruco anchoDeEspada vs:CartaDeTruco anchoDeBasto. .
	
	self assert: (rondaDeTruco rondasJugadas) equals: 2.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorA) equals: 1.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorB) equals: 0.
	self assert: (rondaDeTruco ganador) equals: jugadorA .! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 21:41:57' prior: 50917743!
test12
	| rondaDeTruco |
	
	rondaDeTruco _ RondaDeTrucoSinRefactor
		entreJugador: jugadorA
		vs: jugadorB primeraParda: true
		.
	
	rondaDeTruco enfrentamientoEntre: (CartaDeTruco bastoCon: 2) vs: (CartaDeTruco oroCon: 2) .
	rondaDeTruco enfrentamientoEntre: (CartaDeTruco bastoCon: 7) vs: (CartaDeTruco copaCon: 7) .	
	
	self assert: (rondaDeTruco rondasJugadas) equals: 2.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorA) equals: 1.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorB) equals: 0.
	self assert: (rondaDeTruco ganador) equals: jugadorA .
	
	! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 21:41:57' prior: 50917615!
test03
	| rondaDeTruco |
	
	rondaDeTruco _ RondaDeTrucoSinRefactor
		entreJugador: jugadorA
		vs: jugadorB primeraParda: true
		.
	
	rondaDeTruco enfrentamientoEntre: (CartaDeTruco bastoCon: 2) vs: (CartaDeTruco oroCon: 2) .
	
	self assert: (rondaDeTruco rondasJugadas) equals: 1.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorA) equals: 0.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorB) equals: 0.
	! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 21:41:57' prior: 50917685!
test08
	| rondaDeTruco |

	rondaDeTruco _ RondaDeTrucoSinRefactor
		entreJugador: jugadorA
		vs: jugadorB primeraParda: true.

	
	self 
		should: [rondaDeTruco enfrentamientoEntre: CartaDeTruco anchoDeBasto vs: CartaDeTruco anchoDeBasto .]
		raise: Error -MessageNotUnderstood 
		withExceptionDo: [:anError|
			self assert: RondaDeTrucoSinRefactor cartaRepetidaError equals: anError messageText .
			self assert: (rondaDeTruco rondasJugadas) equals: 0.
			].
	! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 21:41:57' prior: 50917723!
test09
	| rondaDeTruco |

	rondaDeTruco _ RondaDeTrucoSinRefactor
		entreJugador: jugadorA
		vs: jugadorB primeraParda: true.
	
	rondaDeTruco enfrentamientoEntre: (CartaDeTruco espadaCon: 3) vs: (CartaDeTruco espadaCon:1 ).
	
	self 
		should: [rondaDeTruco enfrentamientoEntre: CartaDeTruco anchoDeEspada vs: CartaDeTruco anchoDeBasto .]
		raise: Error -MessageNotUnderstood 
		withExceptionDo: [:anError|
			self assert: RondaDeTrucoSinRefactor cartaRepetidaError equals: anError messageText .
			self assert: (rondaDeTruco rondasJugadas) equals: 1.
			].
	! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 21:41:57' prior: 50917550!
test02
	| rondaDeTruco |

	rondaDeTruco _ RondaDeTrucoSinRefactor
		entreJugador: jugadorA
		vs: jugadorB primeraParda: true
		.
	
	rondaDeTruco enfrentamientoEntre: CartaDeTruco anchoDeEspada vs: CartaDeTruco anchoDeBasto.
		
		
	self assert: (rondaDeTruco rondasJugadas) equals: 1.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorA) equals: 1.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorB) equals: 0.! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 21:41:57' prior: 50917702!
test05
	| rondaDeTruco |
	
	rondaDeTruco _ RondaDeTrucoSinRefactor
		entreJugador: jugadorA
		vs: jugadorB primeraParda: true
		.
	
	rondaDeTruco enfrentamientoEntre: (CartaDeTruco bastoCon: 2) vs: (CartaDeTruco oroCon: 2) .
	rondaDeTruco enfrentamientoEntre: CartaDeTruco anchoDeEspada vs: CartaDeTruco anchoDeBasto.
	
	self assert: (rondaDeTruco rondasJugadas) equals: 2.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorA) equals: 1.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorB) equals: 0.
	self assert: (rondaDeTruco ganador) equals: jugadorA .! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 21:41:57' prior: 50919079!
test13
	| rondaDeTruco tresCartasA tresCartasB |
	tresCartasA := OrderedCollection new.
	tresCartasA add: (CartaDeTruco oroCon: 4).
	tresCartasA add: CartaDeTruco anchoDeEspada.
	tresCartasA add: (CartaDeTruco copaCon: 3).
	tresCartasB := OrderedCollection new.
	tresCartasB add: (CartaDeTruco oroCon: 2).
	tresCartasB add: CartaDeTruco anchoDeBasto.
	tresCartasB add: (CartaDeTruco copaCon: 4).
	jugadorA conCartas: tresCartasA.
	jugadorB conCartas: tresCartasB.
	rondaDeTruco _ RondaDeTrucoSinRefactor
		entreJugador: jugadorA
		vs: jugadorB primeraParda: true.
	
	rondaDeTruco jugar.
	
	self assert: (rondaDeTruco rondasJugadas) equals: 3.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorA) equals: 2.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorB) equals: 1.
	self assert: (rondaDeTruco ganador) equals: jugadorA .
	
	! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 21:41:57' prior: 50917653!
test07
	| rondaDeTruco |
	
	rondaDeTruco _ RondaDeTrucoSinRefactor
		entreJugador: jugadorA
		vs: jugadorB primeraParda: true
		.
	
	rondaDeTruco enfrentamientoEntre: (CartaDeTruco copaCon: 2) vs:  (CartaDeTruco oroCon: 2).
	rondaDeTruco enfrentamientoEntre: CartaDeTruco anchoDeEspada vs: CartaDeTruco anchoDeBasto.
	
	self assert: (rondaDeTruco rondasJugadas) equals: 2.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorA) equals: 1.
	self assert: (rondaDeTruco enfretamientosGanadosPor: jugadorB) equals: 0.
	self assert: (rondaDeTruco ganador) equals: jugadorA .! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 21:41:57' prior: 50917348!
test01
	| rondaDeTruco |

	rondaDeTruco _ RondaDeTrucoSinRefactor
		entreJugador: jugadorA
		vs: jugadorB primeraParda: true
		.
	
	self assert: rondaDeTruco rondasJugadas equals: 0! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 21:41:57' prior: 50917567!
test10
	| rondaDeTruco |

	rondaDeTruco _ RondaDeTrucoSinRefactor
		entreJugador: jugadorA
		vs: jugadorB primeraParda: true.
	
	rondaDeTruco enfrentamientoEntre: (CartaDeTruco espadaCon: 3) vs: (CartaDeTruco espadaCon:1 ).
	
	self 
		should: [rondaDeTruco ganador]
		raise: Error -MessageNotUnderstood 
		withExceptionDo: [:anError|
			self assert: RondaDeTrucoSinRefactor noTerminoLaRondaTodavia equals: anError messageText .
			self assert: (rondaDeTruco rondasJugadas) equals: 1.
			].
	! !

!testRun: #CartaDeTrucoTest #test01SonIgualesConMismoPaloYNumero stamp: 'pc 7/5/2021 21:42:13'!
PASSED!

!testRun: #CartaDeTrucoTest #test02SonDistintasConDistintoPalo stamp: 'pc 7/5/2021 21:42:13'!
PASSED!

!testRun: #CartaDeTrucoTest #test03SonDistintasConNumeroAunqueIgualPalo stamp: 'pc 7/5/2021 21:42:13'!
PASSED!

!testRun: #CartaDeTrucoTest #test04CartasIgualesTienenElMismoHash stamp: 'pc 7/5/2021 21:42:13'!
PASSED!

!testRun: #CartaDeTrucoTest #test05UnaCartaEsDistintaACualquierObjetoQueNoSeaCarta stamp: 'pc 7/5/2021 21:42:13'!
PASSED!

!testRun: #CartaDeTrucoTest #test07NoHayCartaDeTrucoConNumeroOcho stamp: 'pc 7/5/2021 21:42:13'!
PASSED!

!testRun: #CartaDeTrucoTest #test08NoHayCartaDeTrucoConNumeroNueve stamp: 'pc 7/5/2021 21:42:13'!
PASSED!

!testRun: #CartaDeTrucoTest #test09LosPalosDeLaCartaDeTrucoSonBastoOroEspadaYCopa stamp: 'pc 7/5/2021 21:42:13'!
PASSED!

!testRun: #CartaDeTrucoTest #test10NoSePuedeCrearCartaConNumeroMenorAUno stamp: 'pc 7/5/2021 21:42:13'!
PASSED!

!testRun: #CartaDeTrucoTest #test11NoSePuedeCrearCartaConNumeroMayorADoce stamp: 'pc 7/5/2021 21:42:13'!
PASSED!

!testRun: #CartaDeTrucoTest #test12ElNumeroDeLaCartaDebeSerEntero stamp: 'pc 7/5/2021 21:42:13'!
PASSED!

!testRun: #CartaDeTrucoTest #test13LaTablaDeValoresEsCorrecta stamp: 'pc 7/5/2021 21:42:13'!
PASSED!

!testRun: #CartaDeTrucoTest #test14HayCartasQueNoSonPardas stamp: 'pc 7/5/2021 21:42:13'!
PASSED!

!testRun: #CartaDeTrucoTest #test15HayCartasQuePierdenConOtras stamp: 'pc 7/5/2021 21:42:13'!
PASSED!

!testRun: #CartaDeTrucoTest #test16SieteDeCopasYDeBastoEsSieteFalso stamp: 'pc 7/5/2021 21:42:13'!
PASSED!

!testRun: #CartaDeTrucoTest #test17SieteDeOroYDeEspadaNoSonSieteFalso stamp: 'pc 7/5/2021 21:42:13'!
PASSED!

!testRun: #CartaDeTrucoTest #test18AnchoDeOroYDeCopaSonAnchoFalsos stamp: 'pc 7/5/2021 21:42:13'!
PASSED!

!testRun: #CartaDeTrucoTest #test19AnchoDeEspadaYDeBastosNoSonAnchoFalsos stamp: 'pc 7/5/2021 21:42:13'!
PASSED!

!testRun: #CartaDeTrucoTest #test20FallaBuscandoValorDeCartaInv�lida stamp: 'pc 7/5/2021 21:42:13'!
PASSED!

!testRun: #RondaDeTrucoTest #test01 stamp: 'pc 7/5/2021 21:42:13'!
PASSED!

!testRun: #RondaDeTrucoTest #test02 stamp: 'pc 7/5/2021 21:42:13'!
PASSED!

!testRun: #RondaDeTrucoTest #test03 stamp: 'pc 7/5/2021 21:42:13'!
PASSED!

!testRun: #RondaDeTrucoTest #test04 stamp: 'pc 7/5/2021 21:42:13'!
PASSED!

!testRun: #RondaDeTrucoTest #test05 stamp: 'pc 7/5/2021 21:42:13'!
PASSED!

!testRun: #RondaDeTrucoTest #test06 stamp: 'pc 7/5/2021 21:42:13'!
PASSED!

!testRun: #RondaDeTrucoTest #test07 stamp: 'pc 7/5/2021 21:42:13'!
PASSED!

!testRun: #RondaDeTrucoTest #test08 stamp: 'pc 7/5/2021 21:42:13'!
PASSED!

!testRun: #RondaDeTrucoTest #test09 stamp: 'pc 7/5/2021 21:42:13'!
PASSED!

!testRun: #RondaDeTrucoTest #test10 stamp: 'pc 7/5/2021 21:42:13'!
PASSED!

!testRun: #RondaDeTrucoTest #test11 stamp: 'pc 7/5/2021 21:42:14'!
PASSED!

!testRun: #RondaDeTrucoTest #test12 stamp: 'pc 7/5/2021 21:42:14'!
PASSED!

!testRun: #RondaDeTrucoTest #test13 stamp: 'pc 7/5/2021 21:42:14'!
PASSED!
!Ronda2 methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 21:47:31' prior: 50918771!
enfrentamientoEntre: cartaDeTrucoA vs: cartaDeTrucoB
	
	self revisarFinalizacionDeRonda.
	
	self revisarCartasRepetidasEntre: cartaDeTrucoA y: cartaDeTrucoB.
	
	cartasUsadas add: cartaDeTrucoA.
	cartasUsadas add: cartaDeTrucoB.

	(cartaDeTrucoA mataA: cartaDeTrucoB) ifTrue: [^jugadorA nombre]. 
	(cartaDeTrucoB mataA: cartaDeTrucoA) ifTrue: [^jugadorB nombre].
	((cartaDeTrucoB empardaCon: cartaDeTrucoA) and: primerRondaParda) ifTrue: [jugadores add: self jugadorMano].
	(cartaDeTrucoB empardaCon: cartaDeTrucoA) ifTrue: [primerRondaParda := true].
! !
!NumeroRondaDeTruco methodsFor: 'as yet unclassified' stamp: 'pc 7/5/2021 21:49:06' prior: 50918547!
ganador
	
	ronda ganador.! !
!Ronda1 methodsFor: 'initialization' stamp: 'pc 7/5/2021 21:49:48' overrides: 50919734!
ganador
	^self error: partida class noTerminoLaRondaTodavia.! !