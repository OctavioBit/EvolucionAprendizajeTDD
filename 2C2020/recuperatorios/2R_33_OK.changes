----End fileIn of C:\Users\FACU PC\Downloads\ISW1-2020-2C-Recuperatorio-2doParcial.st----!

TestCase subclass: #DoorTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!

!classDefinition: #DoorTest category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 17:21:06'!
TestCase subclass: #DoorTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!

!classDefinition: #Door category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 17:38:05'!
Object subclass: #Door
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!
!DoorTest methodsFor: 'no messages' stamp: 'FG 12/17/2020 17:37:56'!
test01DoorCanNotBeInTheSameRoomTwice

	| door room |
	
	room := Room ofWidth: 10 andHeight: 10. 
	
	door := Door in: room and: room.
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 17:38:20' prior: 50894598!
test01DoorCanNotBeInTheSameRoomTwice

	| door room |
	
	room := Room ofWidth: 10 andHeight: 10. 
	
	door := Door in: room and: room.
	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 17:39:50'!
test01DoorCannotBeInTheSameRoomTwice

	| door room |
	
	room := Room ofWidth: 10 andHeight: 10. 
	
	self 
		should: [ Door in: room and: room ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Door doorCannotBeInTheSameRoomTwice
	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 17:40:04' prior: 50894613!
test01DoorCannotBeInTheSameRoomTwice

	| room |
	
	room := Room ofWidth: 10 andHeight: 10. 
	
	self 
		should: [ Door in: room and: room ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Door doorCannotBeInTheSameRoomTwice
	
	! !

!methodRemoval: DoorTest #test01DoorCanNotBeInTheSameRoomTwice stamp: 'FG 12/17/2020 17:40:06'!
test01DoorCanNotBeInTheSameRoomTwice

	| door room |
	
	room := Room ofWidth: 10 andHeight: 10. 
	
	door := Door in: room and: room.
	
	!

!testRun: #DoorTest #test01DoorCannotBeInTheSameRoomTwice stamp: 'FG 12/17/2020 17:40:15'!
ERROR!
!Door class methodsFor: 'exceptions' stamp: 'FG 12/17/2020 17:40:30'!
doorCannotBeInTheSameRoomTwice
	self shouldBeImplemented.! !
!Door class methodsFor: 'exceptions' stamp: 'FG 12/17/2020 17:41:28' prior: 50894645!
doorCannotBeInTheSameRoomTwice
	^ 'Error - Cannot create door that leads to the same room that its in'.! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 17:41:38' prior: 50894624!
test01DoorCannotBeInTheSameRoomTwice

	| room |
	
	room := Room ofWidth: 10 andHeight: 10. 
	
	self 
		should: [ Door in: room and: room ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Door doorCannotBeInTheSameRoomTwice.
	
	! !
!Door class methodsFor: 'nil' stamp: 'FG 12/17/2020 17:42:38'!
in: aRoom and: anotherRoom
	
	^ self basicNew initializeIn: aRoom and: anotherRoom.! !
!Door methodsFor: 'no messages' stamp: 'FG 12/17/2020 17:43:16'!
initializeIn: aRoom and: anotherRoom
! !

!testRun: #DoorTest #test01DoorCannotBeInTheSameRoomTwice stamp: 'FG 12/17/2020 17:43:30'!
FAILURE!

!testRun: #DoorTest #test01DoorCannotBeInTheSameRoomTwice stamp: 'FG 12/17/2020 17:43:30'!
FAILURE!
!Door methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 17:45:09' prior: 50894672!
initializeIn: aRoom and: anotherRoom
	
	(aRoom = anotherRoom) ifTrue: [ self error: Door doorCannotBeInTheSameRoomTwice ].! !

!testRun: #DoorTest #test01DoorCannotBeInTheSameRoomTwice stamp: 'FG 12/17/2020 17:45:13'!
PASSED!
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 17:53:41'!
test02CannotPlaceDoorInInvalidPositionInAnyOfTheRooms

	| room1 room2 |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
	
	self 
		should: [ Door in: room1 at: -1@0 and: room2 at: 1@1 ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Room invalidPositionErrorDescription.
	
	! !
!Door class methodsFor: 'initialization' stamp: 'FG 12/17/2020 17:54:33'!
in: aRoom at: aPosition and: anotherRoom at: anotherPosition
	
	^ self basicNew initializeIn: aRoom at: aPosition and: anotherRoom at: anotherPosition.! !

!methodRemoval: Door class #in:and: stamp: 'FG 12/17/2020 17:54:38'!
in: aRoom and: anotherRoom
	
	^ self basicNew initializeIn: aRoom and: anotherRoom.!
!Door methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 17:55:33'!
initializeIn: aRoom at: aPosition and: anotherRoom at: anotherPosition
	
	(aRoom = anotherRoom) ifTrue: [ self error: Door doorCannotBeInTheSameRoomTwice ].
	
	aRoom put: self at: aPosition.! !

!methodRemoval: Door #initializeIn:and: stamp: 'FG 12/17/2020 17:55:47'!
initializeIn: aRoom and: anotherRoom
	
	(aRoom = anotherRoom) ifTrue: [ self error: Door doorCannotBeInTheSameRoomTwice ].!
!Door methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 17:56:50' prior: 50894718!
initializeIn: aRoom at: aPosition and: anotherRoom at: anotherPosition
	
	(aRoom = anotherRoom) ifTrue: [ self error: Door doorCannotBeInTheSameRoomTwice ].
	
	aRoom at: aPosition put: self.
	aRoom at: aPosition put: self.! !
!Door methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 17:58:12' prior: 50894734!
initializeIn: aRoom at: aPosition and: anotherRoom at: anotherPosition
	
	(aRoom = anotherRoom) ifTrue: [ self error: Door doorCannotBeInTheSameRoomTwice ].
	
	aRoom at: aPosition put: self.
	anotherRoom at: anotherPosition put: self.! !

!testRun: #DoorTest #test02CannotPlaceDoorInInvalidPositionInAnyOfTheRooms stamp: 'FG 12/17/2020 17:58:23'!
PASSED!
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 18:02:32' prior: 50894693!
test02CannotPlaceDoorInInvalidPositionInAnyOfTheRooms

	| room1 room2 |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
	
	self 
		should: [ Door in: room1 at: -1@0 and: room2 at: 1@1 ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Room invalidPositionErrorDescription.
		
	self 
		should: [ Door in: room1 at: 1@0 and: room2 at: -1@1 ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Room invalidPositionErrorDescription.
	
	! !

!testRun: #DoorTest #test02CannotPlaceDoorInInvalidPositionInAnyOfTheRooms stamp: 'FG 12/17/2020 18:02:35'!
PASSED!
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 18:03:06'!
test03CannotPlaceDoorInOcupiedPositionInAnyOfTheRooms

	| room1 room2 |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
	
	self 
		should: [ Door in: room1 at: -1@0 and: room2 at: 1@1 ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Room invalidPositionErrorDescription.
		
	self 
		should: [ Door in: room1 at: 1@0 and: room2 at: -1@1 ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Room invalidPositionErrorDescription.
	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 18:03:21'!
paper

	^ PointsPortableObject named: 'paper' weighing: 1 worth: 1! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 18:04:34' prior: 50894780!
test03CannotPlaceDoorInOcupiedPositionInAnyOfTheRooms

	| room1 room2 |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
	
	room1 at: 1@1 put: self paper.
	room2 at: 1@1 put: self paper. 
	
	self 
		should: [ Door in: room1 at: 1@1 and: room2 at: 0@1 ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Room invalidPositionErrorDescription.
		
	self 
		should: [ Door in: room1 at: 1@0 and: room2 at: 1@1 ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Room invalidPositionErrorDescription.
	
	! !

!testRun: #DoorTest #test03CannotPlaceDoorInOcupiedPositionInAnyOfTheRooms stamp: 'FG 12/17/2020 18:04:40'!
FAILURE!

!testRun: #DoorTest #test03CannotPlaceDoorInOcupiedPositionInAnyOfTheRooms stamp: 'FG 12/17/2020 18:04:40'!
FAILURE!
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 18:05:29' prior: 50894804!
test03CannotPlaceDoorInOcupiedPositionInAnyOfTheRooms

	| room1 room2 |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
	
	room1 at: 1@1 put: self paper.
	room2 at: 1@1 put: self paper. 
	
	self 
		should: [ Door in: room1 at: 1@1 and: room2 at: 0@1 ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Room positionIsNotEmptyErrorDescription.
		
	self 
		should: [ Door in: room1 at: 1@0 and: room2 at: 1@1 ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Room positionIsNotEmptyErrorDescription.
	
	! !

!testRun: #DoorTest #test03CannotPlaceDoorInOcupiedPositionInAnyOfTheRooms stamp: 'FG 12/17/2020 18:05:32'!
PASSED!
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 18:06:59'!
test04DoorIsBothRooms

	| room1 room2 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1.	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 18:09:21' prior: 50894856!
test04DoorIsBothRooms

	| room1 room2 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1.	
	
	self deny: (room1 isEmptyAt: 1@1).
	self deny: (room2 isEmptyAt: 0@1).
	self assert: (room1 at: 1@1) equals: door.
	self assert: (room2 at: 0@1) equals: door.  
	! !

!testRun: #DoorTest #test04DoorIsBothRooms stamp: 'FG 12/17/2020 18:09:24'!
PASSED!
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 18:09:51'!
test04DoorIsInBothRooms

	| room1 room2 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1.	
	
	self deny: (room1 isEmptyAt: 1@1).
	self deny: (room2 isEmptyAt: 0@1).
	self assert: (room1 at: 1@1) equals: door.
	self assert: (room2 at: 0@1) equals: door.  
	! !

!methodRemoval: DoorTest #test04DoorIsBothRooms stamp: 'FG 12/17/2020 18:09:53'!
test04DoorIsBothRooms

	| room1 room2 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1.	
	
	self deny: (room1 isEmptyAt: 1@1).
	self deny: (room2 isEmptyAt: 0@1).
	self assert: (room1 at: 1@1) equals: door.
	self assert: (room2 at: 0@1) equals: door.  
	!
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 18:10:36'!
test01DoorShouldBeInDifferentRooms

	| room |
	
	room := Room ofWidth: 10 andHeight: 10. 
	
	self 
		should: [ Door in: room and: room ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Door doorCannotBeInTheSameRoomTwice.
	
	! !

!methodRemoval: DoorTest #test01DoorCannotBeInTheSameRoomTwice stamp: 'FG 12/17/2020 18:10:39'!
test01DoorCannotBeInTheSameRoomTwice

	| room |
	
	room := Room ofWidth: 10 andHeight: 10. 
	
	self 
		should: [ Door in: room and: room ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Door doorCannotBeInTheSameRoomTwice.
	
	!
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 18:10:57' prior: 50894910!
test01DoorShouldBeInDifferentRooms

	| room |
	
	room := Room ofWidth: 10 andHeight: 10. 
	
	self 
		should: [ Door in: room at: 1@1 and: room at:1@1]
		raise: Error - MessageNotUnderstood 
		withMessageText: Door doorCannotBeInTheSameRoomTwice.
	
	! !

!testRun: #DoorTest #test01DoorShouldBeInDifferentRooms stamp: 'FG 12/17/2020 18:11:00'!
PASSED!

!testRun: #DoorTest #test02CannotPlaceDoorInInvalidPositionInAnyOfTheRooms stamp: 'FG 12/17/2020 18:11:01'!
PASSED!

!testRun: #DoorTest #test04DoorIsInBothRooms stamp: 'FG 12/17/2020 18:11:03'!
PASSED!
!Door methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 18:18:56' prior: 50894744!
initializeIn: aRoom at: aPosition and: anotherRoom at: anotherPosition
	
	(aRoom = anotherRoom) ifTrue: [ self error: Door doorCannotBeInTheSameRoomTwice ].
	
	aRoom at: aPosition put: self.
	anotherRoom at: anotherPosition put: self.! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 18:30:36'!
test05DoorLeadFromOneRoomToTheOther

	| room1 room2 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1.	
	
	self assert: (door moveFrom: room1) equals: room2.
	self assert: (door moveFrom: room2) equals: room2. ! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 18:30:39' prior: 50894962!
test05DoorLeadFromOneRoomToTheOther

	| room1 room2 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1.	
	
	self assert: (door moveFrom: room1) equals: room2.
	self assert: (door moveFrom: room2) equals: room1. ! !

!testRun: #DoorTest #test05DoorLeadFromOneRoomToTheOther stamp: 'FG 12/17/2020 18:30:42'!
ERROR!

!testRun: #DoorTest #test05DoorLeadFromOneRoomToTheOther stamp: 'FG 12/17/2020 18:30:42'!
ERROR!
!Door methodsFor: 'accessing' stamp: 'FG 12/17/2020 18:30:56'!
moveFrom: aRoom 
	self shouldBeImplemented.! !

!classDefinition: #Door category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 18:32:43'!
Object subclass: #Door
	instanceVariableNames: 'firstRoom'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!

!classDefinition: #Door category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 18:32:44'!
Object subclass: #Door
	instanceVariableNames: 'firstRoom secondRoom'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!
!Door methodsFor: 'accessing' stamp: 'FG 12/17/2020 18:32:39' prior: 50894993!
moveFrom: aRoom 
	(aRoom = firstRoom) ifTrue: [^ secondRoom].
	(aRoom = secondRoom) ifTrue: [^ firstRoom].! !
!Door methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 18:33:28' prior: 50894952!
initializeIn: aRoom at: aPosition and: anotherRoom at: anotherPosition
	
	(aRoom = anotherRoom) ifTrue: [ self error: Door doorCannotBeInTheSameRoomTwice ].
	
	aRoom at: aPosition put: self.
	anotherRoom at: anotherPosition put: self.
	
	firstRoom := aRoom.
	secondRoom := anotherRoom.! !

!testRun: #DoorTest #test05DoorLeadFromOneRoomToTheOther stamp: 'FG 12/17/2020 18:33:31'!
PASSED!
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 18:39:08'!
test06CannotMoveFromARoomWhichDoesntHasTheDoor

	| room1 room2 room3 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
	room3 := Room 	ofWidth: 10 andHeight: 10.
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1.	
	
	self assert: (door moveFrom: room1) equals: room2.
	self assert: (door moveFrom: room2) equals: room1. ! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 18:40:45' prior: 50895036!
test06CannotMoveFromARoomWhichDoesntHasTheDoor

	| room1 room2 room3 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
	room3 := Room 	ofWidth: 10 andHeight: 10.
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1.	
	
	self 
		should: [ door moveFrom: room3]
		raise: Error - MessageNotUnderstood 
		withMessageText: (Door cannotMoveFrom: room3).! !

!testRun: #DoorTest #test06CannotMoveFromARoomWhichDoesntHasTheDoor stamp: 'FG 12/17/2020 18:40:52'!
ERROR!
!Door class methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 18:41:01'!
cannotMoveFrom: aRoom 
	self shouldBeImplemented.! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 18:43:01' prior: 50895051!
test06CannotMoveFromARoomWhichDoesntHasTheDoor

	| room1 room2 room3 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
	room3 := Room 	ofWidth: 10 andHeight: 10.
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1.	
	
	self 
		should: [ door moveFrom: room3]
		raise: Error - MessageNotUnderstood 
		withMessageText: (Door cannotMoveFromARoomWithoutThisDoor).! !

!testRun: #DoorTest #test06CannotMoveFromARoomWhichDoesntHasTheDoor stamp: 'FG 12/17/2020 18:43:05'!
ERROR!
!Door class methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 18:43:13'!
cannotMoveFromARoomWithoutThisDoor
	self shouldBeImplemented.! !
!Door class methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 18:43:36' prior: 50895094!
cannotMoveFromARoomWithoutThisDoor
	^ 'Error - Cannot move from a room without this door'.! !

!testRun: #DoorTest #test06CannotMoveFromARoomWhichDoesntHasTheDoor stamp: 'FG 12/17/2020 18:43:58'!
FAILURE!

!testRun: #DoorTest #test06CannotMoveFromARoomWhichDoesntHasTheDoor stamp: 'FG 12/17/2020 18:43:58'!
FAILURE!
!Door methodsFor: 'accessing' stamp: 'FG 12/17/2020 18:44:22' prior: 50895014!
moveFrom: aRoom 
	(aRoom = firstRoom) ifTrue: [^ secondRoom].
	(aRoom = secondRoom) ifTrue: [^ firstRoom].
	self error: Door cannotMoveFromARoomWithoutThisDoor.! !

!testRun: #DoorTest #test06CannotMoveFromARoomWhichDoesntHasTheDoor stamp: 'FG 12/17/2020 18:44:30'!
PASSED!

Object subclass: #Door
	instanceVariableNames: 'firstRoom secondRoom state'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!

!classDefinition: #Door category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 18:48:30'!
Object subclass: #Door
	instanceVariableNames: 'firstRoom secondRoom state'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!

!classDefinition: #ClosedDoor category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 18:54:03'!
Object subclass: #ClosedDoor
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 18:53:54'!
test07DoorStartsClosed

	| room1 room2 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1.	
	
	self assert: (door state isKindaOf: 
	ClosedDoor).! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 18:54:16' prior: 50895146!
test07DoorStartsClosed

	| room1 room2 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1.	
	
	self assert: (door state isKindOf: ClosedDoor).! !

!classDefinition: #DoorState category: 'Unknown' stamp: 'FG 12/17/2020 18:54:57'!
Object subclass: #DoorState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Unknown'!

DoorState subclass: #ClosedDoor
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!

!classDefinition: #ClosedDoor category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 18:54:57'!
DoorState subclass: #ClosedDoor
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!

Object subclass: #DoorState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!

!classDefinition: #DoorState category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 18:55:28'!
Object subclass: #DoorState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!
!Door methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 18:55:59' prior: 50895021!
initializeIn: aRoom at: aPosition and: anotherRoom at: anotherPosition
	
	(aRoom = anotherRoom) ifTrue: [ self error: Door doorCannotBeInTheSameRoomTwice ].
	
	aRoom at: aPosition put: self.
	anotherRoom at: anotherPosition put: self.
	
	state := ClosedDoor new.
	firstRoom := aRoom.
	secondRoom := anotherRoom.! !
!Door methodsFor: 'accessing' stamp: 'FG 12/17/2020 18:57:04'!
isClosed
	state isClosed: self.! !
!ClosedDoor methodsFor: 'no messages' stamp: 'FG 12/17/2020 18:57:22'!
isClosed: door
	^ true.! !
!ClosedDoor methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 18:57:27'!
isClosed
	^ true.! !

!methodRemoval: ClosedDoor #isClosed: stamp: 'FG 12/17/2020 18:57:30'!
isClosed: door
	^ true.!
!Door methodsFor: 'accessing' stamp: 'FG 12/17/2020 18:57:39' prior: 50895213!
isClosed
	state isClosed.! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 18:58:00' prior: 50895157!
test07DoorStartsClosed

	| room1 room2 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1.	
	
	self assert: door isClosed.! !
!Door methodsFor: 'accessing' stamp: 'FG 12/17/2020 18:59:37'!
useFrom: aRoom 
	(aRoom = firstRoom) ifTrue: [^ secondRoom].
	(aRoom = secondRoom) ifTrue: [^ firstRoom].
	self error: Door cannotMoveFromARoomWithoutThisDoor.! !

!methodRemoval: Door #moveFrom: stamp: 'FG 12/17/2020 18:59:37'!
moveFrom: aRoom 
	(aRoom = firstRoom) ifTrue: [^ secondRoom].
	(aRoom = secondRoom) ifTrue: [^ firstRoom].
	self error: Door cannotMoveFromARoomWithoutThisDoor.!
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 18:59:54' prior: 50894975!
test05DoorLeadFromOneRoomToTheOther

	| room1 room2 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1.	
	
	self assert: (door useFrom: room1) equals: room2.
	self assert: (door useFrom: room2) equals: room1. ! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:00:00' prior: 50895075!
test06CannotMoveFromARoomWhichDoesntHasTheDoor

	| room1 room2 room3 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
	room3 := Room 	ofWidth: 10 andHeight: 10.
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1.	
	
	self 
		should: [ door useFrom: room3]
		raise: Error - MessageNotUnderstood 
		withMessageText: (Door cannotMoveFromARoomWithoutThisDoor).! !

!testRun: #DoorTest #test01DoorShouldBeInDifferentRooms stamp: 'FG 12/17/2020 19:00:09'!
PASSED!

!testRun: #DoorTest #test02CannotPlaceDoorInInvalidPositionInAnyOfTheRooms stamp: 'FG 12/17/2020 19:00:09'!
PASSED!

!testRun: #DoorTest #test03CannotPlaceDoorInOcupiedPositionInAnyOfTheRooms stamp: 'FG 12/17/2020 19:00:10'!
PASSED!

!testRun: #DoorTest #test04DoorIsInBothRooms stamp: 'FG 12/17/2020 19:00:10'!
PASSED!

!testRun: #DoorTest #test05DoorLeadFromOneRoomToTheOther stamp: 'FG 12/17/2020 19:00:10'!
PASSED!

!testRun: #DoorTest #test06CannotMoveFromARoomWhichDoesntHasTheDoor stamp: 'FG 12/17/2020 19:00:10'!
PASSED!

!testRun: #DoorTest #test07DoorStartsClosed stamp: 'FG 12/17/2020 19:00:10'!
ERROR!

!testRun: #DoorTest #test07DoorStartsClosed stamp: 'FG 12/17/2020 19:00:10'!
ERROR!

!testRun: #DoorTest #test07DoorStartsClosed stamp: 'FG 12/17/2020 19:00:45'!
ERROR!

!testRun: #DoorTest #test07DoorStartsClosed stamp: 'FG 12/17/2020 19:00:45'!
ERROR!

!testRun: #DoorTest #test07DoorStartsClosed stamp: 'FG 12/17/2020 19:01:07'!
ERROR!

!testRun: #DoorTest #test07DoorStartsClosed stamp: 'FG 12/17/2020 19:01:07'!
ERROR!
!Door methodsFor: 'accessing' stamp: 'FG 12/17/2020 19:01:42' prior: 50895228!
isClosed
	^ state isClosed.! !

!testRun: #DoorTest #test01DoorShouldBeInDifferentRooms stamp: 'FG 12/17/2020 19:01:46'!
PASSED!

!testRun: #DoorTest #test02CannotPlaceDoorInInvalidPositionInAnyOfTheRooms stamp: 'FG 12/17/2020 19:01:46'!
PASSED!

!testRun: #DoorTest #test03CannotPlaceDoorInOcupiedPositionInAnyOfTheRooms stamp: 'FG 12/17/2020 19:01:46'!
PASSED!

!testRun: #DoorTest #test04DoorIsInBothRooms stamp: 'FG 12/17/2020 19:01:46'!
PASSED!

!testRun: #DoorTest #test05DoorLeadFromOneRoomToTheOther stamp: 'FG 12/17/2020 19:01:46'!
PASSED!

!testRun: #DoorTest #test06CannotMoveFromARoomWhichDoesntHasTheDoor stamp: 'FG 12/17/2020 19:01:46'!
PASSED!

!testRun: #DoorTest #test07DoorStartsClosed stamp: 'FG 12/17/2020 19:01:46'!
PASSED!
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:03:51'!
test08CannotUseAClosedDoor

	| room1 room2 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1.	
	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:04:33' prior: 50895347!
test08CannotUseAClosedDoor

	| room1 room2 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1.	
	
	self 
		should: [ door useFrom: room1]
		raise: Error - MessageNotUnderstood 
		withMessageText: (Door cannotUseClosedDoor).
	
	! !
!Door methodsFor: 'accessing' stamp: 'FG 12/17/2020 19:05:53' prior: 50895241!
useFrom: aRoom 

	state useDoor: self.! !
!Door methodsFor: 'accessing' stamp: 'FG 12/17/2020 19:06:14'!
useOpenDoorFrom: aRoom 

	(aRoom = firstRoom) ifTrue: [^ secondRoom].
	(aRoom = secondRoom) ifTrue: [^ firstRoom].
	self error: Door cannotMoveFromARoomWithoutThisDoor.! !
!ClosedDoor methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:06:51'!
useDoor: aDoor

	aDoor useClosedDoor.! !
!Door methodsFor: 'accessing' stamp: 'FG 12/17/2020 19:07:30'!
useClosedDoorFrom

	self error: Door.! !
!Door methodsFor: 'accessing' stamp: 'FG 12/17/2020 19:07:46' prior: 50895370!
useFrom: aRoom 

	state useDoor: self from: aRoom.! !
!ClosedDoor methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:07:58'!
useDoor: aDoor from: aRoom

	aDoor useClosedDoor.! !

!methodRemoval: ClosedDoor #useDoor: stamp: 'FG 12/17/2020 19:08:02'!
useDoor: aDoor

	aDoor useClosedDoor.!
!Door methodsFor: 'accessing' stamp: 'FG 12/17/2020 19:08:14'!
useClosedDoor

	self error: Door.! !

!methodRemoval: Door #useClosedDoorFrom stamp: 'FG 12/17/2020 19:08:16'!
useClosedDoorFrom

	self error: Door.!

!methodRemoval: Door class #cannotMoveFrom: stamp: 'FG 12/17/2020 19:08:39'!
cannotMoveFrom: aRoom 
	self shouldBeImplemented.!
!Door class methodsFor: 'exceptions' stamp: 'FG 12/17/2020 19:09:17'!
cannotUseClosedDoor
	^ 'Error - The door is closed. You cannot use it'.! !

!testRun: #DoorTest #test08CannotUseAClosedDoor stamp: 'FG 12/17/2020 19:09:28'!
FAILURE!

!testRun: #DoorTest #test08CannotUseAClosedDoor stamp: 'FG 12/17/2020 19:09:28'!
FAILURE!
!Door methodsFor: 'use' stamp: 'FG 12/17/2020 19:11:07' prior: 50895390!
useFrom: aRoom 

	^ state useDoor: self from: aRoom.! !
!Door methodsFor: 'use - private' stamp: 'FG 12/17/2020 19:11:56' prior: 50895403!
useClosedDoor

	self error: Door cannotUseClosedDoor .! !

!testRun: #DoorTest #test08CannotUseAClosedDoor stamp: 'FG 12/17/2020 19:11:59'!
PASSED!

!testRun: #DoorTest #test01DoorShouldBeInDifferentRooms stamp: 'FG 12/17/2020 19:12:01'!
PASSED!

!testRun: #DoorTest #test02CannotPlaceDoorInInvalidPositionInAnyOfTheRooms stamp: 'FG 12/17/2020 19:12:01'!
PASSED!

!testRun: #DoorTest #test03CannotPlaceDoorInOcupiedPositionInAnyOfTheRooms stamp: 'FG 12/17/2020 19:12:01'!
PASSED!

!testRun: #DoorTest #test04DoorIsInBothRooms stamp: 'FG 12/17/2020 19:12:01'!
PASSED!

!testRun: #DoorTest #test05DoorLeadFromOneRoomToTheOther stamp: 'FG 12/17/2020 19:12:01'!
ERROR!

!testRun: #DoorTest #test06CannotMoveFromARoomWhichDoesntHasTheDoor stamp: 'FG 12/17/2020 19:12:01'!
FAILURE!

!testRun: #DoorTest #test07DoorStartsClosed stamp: 'FG 12/17/2020 19:12:01'!
PASSED!

!testRun: #DoorTest #test08CannotUseAClosedDoor stamp: 'FG 12/17/2020 19:12:01'!
PASSED!

!testRun: #DoorTest #test06CannotMoveFromARoomWhichDoesntHasTheDoor stamp: 'FG 12/17/2020 19:12:07'!
FAILURE!

!testRun: #DoorTest #test06CannotMoveFromARoomWhichDoesntHasTheDoor stamp: 'FG 12/17/2020 19:12:07'!
FAILURE!
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:13:05'!
test08CannotOpenDoorWithWrongKey

	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:13:09'!
test09CannotOpenDoorWithWrongKey

	
	! !

!methodRemoval: DoorTest #test08CannotOpenDoorWithWrongKey stamp: 'FG 12/17/2020 19:13:12'!
test08CannotOpenDoorWithWrongKey

	
	!

!classDefinition: #Door category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 19:13:58'!
Object subclass: #Door
	instanceVariableNames: 'firstRoom secondRoom state key'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!
!Door methodsFor: 'initialization' stamp: 'FG 12/17/2020 19:13:55'!
initializeIn: aRoom at: aPosition and: anotherRoom at: anotherPosition thatOpensWith: aKey
	
	(aRoom = anotherRoom) ifTrue: [ self error: Door doorCannotBeInTheSameRoomTwice ].
	
	aRoom at: aPosition put: self.
	anotherRoom at: anotherPosition put: self.
	
	key := aKey.
	state := ClosedDoor new.
	firstRoom := aRoom.
	secondRoom := anotherRoom.! !

!methodRemoval: Door #initializeIn:at:and:at:thatOpensWith: stamp: 'FG 12/17/2020 19:14:45'!
initializeIn: aRoom at: aPosition and: anotherRoom at: anotherPosition thatOpensWith: aKey
	
	(aRoom = anotherRoom) ifTrue: [ self error: Door doorCannotBeInTheSameRoomTwice ].
	
	aRoom at: aPosition put: self.
	anotherRoom at: anotherPosition put: self.
	
	key := aKey.
	state := ClosedDoor new.
	firstRoom := aRoom.
	secondRoom := anotherRoom.!
!Door methodsFor: 'initialization' stamp: 'FG 12/17/2020 19:15:27'!
initializeIn: aRoom at: aPosition and: anotherRoom at: anotherPosition thatOpensWith: aKey 
	
	(aRoom = anotherRoom) ifTrue: [ self error: Door doorCannotBeInTheSameRoomTwice ].
	
	aRoom at: aPosition put: self.
	anotherRoom at: anotherPosition put: self.
	
	state := ClosedDoor new.
	firstRoom := aRoom.
	secondRoom := anotherRoom.! !
!Door class methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:15:27' prior: 50894706!
in: aRoom at: aPosition and: anotherRoom at: anotherPosition
	
	^ self basicNew initializeIn: aRoom at: aPosition and: anotherRoom at: anotherPosition thatOpensWith: aKey.! !

!methodRemoval: Door #initializeIn:at:and:at: stamp: 'FG 12/17/2020 19:15:27'!
initializeIn: aRoom at: aPosition and: anotherRoom at: anotherPosition
	
	(aRoom = anotherRoom) ifTrue: [ self error: Door doorCannotBeInTheSameRoomTwice ].
	
	aRoom at: aPosition put: self.
	anotherRoom at: anotherPosition put: self.
	
	state := ClosedDoor new.
	firstRoom := aRoom.
	secondRoom := anotherRoom.!
!Door methodsFor: 'initialization' stamp: 'FG 12/17/2020 19:15:43' prior: 50895518!
initializeIn: aRoom at: aPosition and: anotherRoom at: anotherPosition thatOpensWith: aKey 
	
	(aRoom = anotherRoom) ifTrue: [ self error: Door doorCannotBeInTheSameRoomTwice ].
	
	aRoom at: aPosition put: self.
	anotherRoom at: anotherPosition put: self.
	
	key := aKey.
	state := ClosedDoor new.
	firstRoom := aRoom.
	secondRoom := anotherRoom.! !
!Door methodsFor: 'nil' stamp: 'FG 12/17/2020 19:17:59'!
openWith: aKey

	(key = aKey) ifFalse: [ self error: Door cannotOpenWithWrongKey].
	 ! !
!Door class methodsFor: 'exceptions' stamp: 'FG 12/17/2020 19:18:28'!
cannotOpenWithWrongKey
	^ 'Error - Cannot open door with a wrong key'.! !

PortableObject subclass: #Keys
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!

!classDefinition: #Keys category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 19:19:58'!
PortableObject subclass: #Keys
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!
!Keys methodsFor: 'no messages' stamp: 'FG 12/17/2020 19:20:45'!
initializeNamed: aName weighing: aWeight
	
	name := aName.
	weight := aWeight.! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:21:08'!
wrongKey

	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:21:35' prior: 50895594!
wrongKey

	^ Keys ! !
!Keys class methodsFor: 'no messages' stamp: 'FG 12/17/2020 19:21:51'!
named: aName weighing: aWeight
	
	^ self new initializeNamed: aName weighing: aWeight. ! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:22:20' prior: 50895598!
wrongKey

	^ Keys named: 'Wrong Key' weighing: 5 ! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:22:29' prior: 50895474!
test09CannotOpenDoorWithWrongKey

	

	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:22:59'!
correctKey

	^ Keys named: 'Correct Key' weighing: 5 ! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:23:07' prior: 50895612!
test09CannotOpenDoorWithWrongKey

	

	

	
	! !
!Door class methodsFor: 'initialization' stamp: 'FG 12/17/2020 19:24:00'!
in: aRoom at: aPosition and: anotherRoom at: anotherPosition thatOpensWith: aKey 
	
	^ self basicNew initializeIn: aRoom at: aPosition and: anotherRoom at: anotherPosition thatOpensWith: aKey.! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:24:00' prior: 50894832!
test03CannotPlaceDoorInOcupiedPositionInAnyOfTheRooms

	| room1 room2 |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
	
	room1 at: 1@1 put: self paper.
	room2 at: 1@1 put: self paper. 
	
	self 
		should: [ Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: self correctKey ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Room positionIsNotEmptyErrorDescription.
		
	self 
		should: [ Door in: room1 at: 1@0 and: room2 at: 1@1 thatOpensWith: self correctKey ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Room positionIsNotEmptyErrorDescription.
	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:24:00' prior: 50895257!
test05DoorLeadFromOneRoomToTheOther

	| room1 room2 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: self correctKey.	
	
	self assert: (door useFrom: room1) equals: room2.
	self assert: (door useFrom: room2) equals: room1. ! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:24:00' prior: 50894931!
test01DoorShouldBeInDifferentRooms

	| room |
	
	room := Room ofWidth: 10 andHeight: 10. 
	
	self 
		should: [ Door in: room at: 1@1 and: room at:1@1 thatOpensWith: self correctKey]
		raise: Error - MessageNotUnderstood 
		withMessageText: Door doorCannotBeInTheSameRoomTwice.
	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:24:00' prior: 50895232!
test07DoorStartsClosed

	| room1 room2 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: self correctKey.	
	
	self assert: door isClosed.! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:24:00' prior: 50895357!
test08CannotUseAClosedDoor

	| room1 room2 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: self correctKey.	
	
	self 
		should: [ door useFrom: room1]
		raise: Error - MessageNotUnderstood 
		withMessageText: (Door cannotUseClosedDoor).
	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:24:00' prior: 50894758!
test02CannotPlaceDoorInInvalidPositionInAnyOfTheRooms

	| room1 room2 |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
	
	self 
		should: [ Door in: room1 at: -1@0 and: room2 at: 1@1 thatOpensWith: self correctKey ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Room invalidPositionErrorDescription.
		
	self 
		should: [ Door in: room1 at: 1@0 and: room2 at: -1@1 thatOpensWith: self correctKey ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Room invalidPositionErrorDescription.
	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:24:00' prior: 50894882!
test04DoorIsInBothRooms

	| room1 room2 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: self correctKey.	
	
	self deny: (room1 isEmptyAt: 1@1).
	self deny: (room2 isEmptyAt: 0@1).
	self assert: (room1 at: 1@1) equals: door.
	self assert: (room2 at: 0@1) equals: door.  
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:24:00' prior: 50895270!
test06CannotMoveFromARoomWhichDoesntHasTheDoor

	| room1 room2 room3 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
	room3 := Room 	ofWidth: 10 andHeight: 10.
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: self correctKey.	
	
	self 
		should: [ door useFrom: room3]
		raise: Error - MessageNotUnderstood 
		withMessageText: (Door cannotMoveFromARoomWithoutThisDoor).! !

!methodRemoval: Door class #in:at:and:at: stamp: 'FG 12/17/2020 19:24:01'!
in: aRoom at: aPosition and: anotherRoom at: anotherPosition
	
	^ self basicNew initializeIn: aRoom at: aPosition and: anotherRoom at: anotherPosition thatOpensWith: aKey.!
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:25:22' prior: 50895621!
test09CannotOpenDoorWithWrongKey

	| room1 room2 door |

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: self correctKey.	

	

	

	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:25:58' prior: 50895772!
test09CannotOpenDoorWithWrongKey

	| room1 room2 door |

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: self correctKey.	
	
	self 
		should: [ door openWith: self wrongKey ]
		raise: Error - MessageNotUnderstood 
		withMessageText: (Door cannotOpenWithWrongKey).
	

	

	

	
	! !

!testRun: #DoorTest #test09CannotOpenDoorWithWrongKey stamp: 'FG 12/17/2020 19:26:00'!
PASSED!

!testRun: #DoorTest #test08CannotUseAClosedDoor stamp: 'FG 12/17/2020 19:26:02'!
PASSED!
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:27:26'!
test09DoorOpensWithTheCorrectKey

	| room1 room2 door key |

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 

	key := self correctKey.	
			
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: key.	
	
	door openWith: key.
	
	self deny: door isClosed.	

	

	

	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:27:32'!
test10DoorOpensWithTheCorrectKey

	| room1 room2 door key |

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 

	key := self correctKey.	
			
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: key.	
	
	door openWith: key.
	
	self deny: door isClosed.	

	

	

	
	! !

!methodRemoval: DoorTest #test09DoorOpensWithTheCorrectKey stamp: 'FG 12/17/2020 19:27:35'!
test09DoorOpensWithTheCorrectKey

	| room1 room2 door key |

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 

	key := self correctKey.	
			
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: key.	
	
	door openWith: key.
	
	self deny: door isClosed.	

	

	

	
	!

!testRun: #DoorTest #test10DoorOpensWithTheCorrectKey stamp: 'FG 12/17/2020 19:28:41'!
FAILURE!

!testRun: #DoorTest #test10DoorOpensWithTheCorrectKey stamp: 'FG 12/17/2020 19:28:41'!
FAILURE!

!classDefinition: #OpenDoor category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 19:29:42'!
DoorState subclass: #OpenDoor
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!
!Door methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:29:27' prior: 50895566!
openWith: aKey

	(key = aKey) ifFalse: [ self error: Door cannotOpenWithWrongKey].
	
	state := OpenDoor new.
	 ! !
!OpenDoor methodsFor: 'no messages' stamp: 'FG 12/17/2020 19:30:01'!
isClosed
	^ false.! !
!OpenDoor methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:30:56'!
useDoor: aDoor from: aRoom
	^ aDoor useOpenDoorFrom: aRoom. ! !

!testRun: #DoorTest #test10DoorOpensWithTheCorrectKey stamp: 'FG 12/17/2020 19:31:03'!
PASSED!

!testRun: #DoorTest #test01DoorShouldBeInDifferentRooms stamp: 'FG 12/17/2020 19:31:06'!
PASSED!

!testRun: #DoorTest #test02CannotPlaceDoorInInvalidPositionInAnyOfTheRooms stamp: 'FG 12/17/2020 19:31:06'!
PASSED!

!testRun: #DoorTest #test03CannotPlaceDoorInOcupiedPositionInAnyOfTheRooms stamp: 'FG 12/17/2020 19:31:06'!
PASSED!

!testRun: #DoorTest #test04DoorIsInBothRooms stamp: 'FG 12/17/2020 19:31:06'!
PASSED!

!testRun: #DoorTest #test05DoorLeadFromOneRoomToTheOther stamp: 'FG 12/17/2020 19:31:06'!
ERROR!

!testRun: #DoorTest #test06CannotMoveFromARoomWhichDoesntHasTheDoor stamp: 'FG 12/17/2020 19:31:06'!
FAILURE!

!testRun: #DoorTest #test07DoorStartsClosed stamp: 'FG 12/17/2020 19:31:06'!
PASSED!

!testRun: #DoorTest #test08CannotUseAClosedDoor stamp: 'FG 12/17/2020 19:31:06'!
PASSED!

!testRun: #DoorTest #test09CannotOpenDoorWithWrongKey stamp: 'FG 12/17/2020 19:31:06'!
PASSED!

!testRun: #DoorTest #test10DoorOpensWithTheCorrectKey stamp: 'FG 12/17/2020 19:31:06'!
PASSED!
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:32:05' prior: 50895658!
test05DoorLeadFromOneRoomToTheOther

	| room1 room2 door key |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	key := self correctKey.
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: key.
	door openWith: key.	
	
	self assert: (door useFrom: room1) equals: room2.
	self assert: (door useFrom: room2) equals: room1. ! !

!testRun: #DoorTest #test05DoorLeadFromOneRoomToTheOther stamp: 'FG 12/17/2020 19:32:08'!
PASSED!
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:33:02' prior: 50895747!
test06CannotMoveFromARoomWhichDoesntHasTheDoor

	| room1 room2 room3 door key |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
	room3 := Room 	ofWidth: 10 andHeight: 10.
	
	key := self correctKey.	
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: self key.
	door openWith: key.	
	
	self 
		should: [ door useFrom: room3]
		raise: Error - MessageNotUnderstood 
		withMessageText: (Door cannotMoveFromARoomWithoutThisDoor).! !

!testRun: #DoorTest #test06CannotMoveFromARoomWhichDoesntHasTheDoor stamp: 'FG 12/17/2020 19:33:09'!
ERROR!

!testRun: #DoorTest #test06CannotMoveFromARoomWhichDoesntHasTheDoor stamp: 'FG 12/17/2020 19:33:09'!
ERROR!
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:33:23' prior: 50895925!
test06CannotMoveFromARoomWhichDoesntHasTheDoor

	| room1 room2 room3 door key |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
	room3 := Room 	ofWidth: 10 andHeight: 10.
	
	key := self correctKey.	
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: key.
	door openWith: key.	
	
	self 
		should: [ door useFrom: room3]
		raise: Error - MessageNotUnderstood 
		withMessageText: (Door cannotMoveFromARoomWithoutThisDoor).! !

!testRun: #DoorTest #test06CannotMoveFromARoomWhichDoesntHasTheDoor stamp: 'FG 12/17/2020 19:33:24'!
PASSED!

!testRun: #DoorTest #test01DoorShouldBeInDifferentRooms stamp: 'FG 12/17/2020 19:33:26'!
PASSED!

!testRun: #DoorTest #test02CannotPlaceDoorInInvalidPositionInAnyOfTheRooms stamp: 'FG 12/17/2020 19:33:26'!
PASSED!

!testRun: #DoorTest #test03CannotPlaceDoorInOcupiedPositionInAnyOfTheRooms stamp: 'FG 12/17/2020 19:33:26'!
PASSED!

!testRun: #DoorTest #test04DoorIsInBothRooms stamp: 'FG 12/17/2020 19:33:27'!
PASSED!

!testRun: #DoorTest #test05DoorLeadFromOneRoomToTheOther stamp: 'FG 12/17/2020 19:33:27'!
PASSED!

!testRun: #DoorTest #test06CannotMoveFromARoomWhichDoesntHasTheDoor stamp: 'FG 12/17/2020 19:33:27'!
PASSED!

!testRun: #DoorTest #test07DoorStartsClosed stamp: 'FG 12/17/2020 19:33:27'!
PASSED!

!testRun: #DoorTest #test08CannotUseAClosedDoor stamp: 'FG 12/17/2020 19:33:27'!
PASSED!

!testRun: #DoorTest #test09CannotOpenDoorWithWrongKey stamp: 'FG 12/17/2020 19:33:27'!
PASSED!

!testRun: #DoorTest #test10DoorOpensWithTheCorrectKey stamp: 'FG 12/17/2020 19:33:27'!
PASSED!
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:33:52'!
test11CannotOpenAnAlreadyOpenDoor

	| room1 room2 door key |

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 

	key := self correctKey.	
			
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: key.	
	
	door openWith: key.
	
	self deny: door isClosed.	

	

	

	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:34:37' prior: 50896002!
test11CannotOpenAnAlreadyOpenDoor

	| room1 room2 door key |

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 

	key := self correctKey.	
			
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: key.	
	
	door openWith: key.
	
	self 
		should: [ door openWith: key ]
		raise: Error - MessageNotUnderstood 
		withMessageText: (Door doorAlreadyOpen).

	

	

	
	! !
!Door methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:35:52' prior: 50895857!
openWith: aKey

	(key = aKey) ifFalse: [ self error: Door cannotOpenWithWrongKey].
	
	state openDoor: self.
	 ! !
!ClosedDoor methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:36:18'!
openDoor: aDoor

	aDoor openClosedDoor.
	! !
!OpenDoor methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:36:37'!
openDoor: aDoor
	
	aDoor openOpenedDoor.! !
!Door methodsFor: 'open - private' stamp: 'FG 12/17/2020 19:37:42'!
openClosedDoor

	! !
!Door methodsFor: 'open - private' stamp: 'FG 12/17/2020 19:38:37'!
openOpenedDoor

	self error: Door doorAlreadyOpen.! !
!Door methodsFor: 'open - private' stamp: 'FG 12/17/2020 19:39:00' prior: 50896046!
openClosedDoor

	state := OpenDoor new.

	! !
!Door class methodsFor: 'exceptions' stamp: 'FG 12/17/2020 19:39:38'!
doorAlreadyOpen

	^ 'Error - Door is already open' ! !

!testRun: #DoorTest #test11CannotOpenAnAlreadyOpenDoor stamp: 'FG 12/17/2020 19:40:01'!
PASSED!
!Keys methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:42:15'!
isAKey
	^ true.! !
!NoPointsPortableObject methodsFor: 'nil' stamp: 'FG 12/17/2020 19:42:29'!
isAKey
	^ false.! !
!PointsPortableObject methodsFor: 'nil' stamp: 'FG 12/17/2020 19:42:42'!
isAKey
	^ false.! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:45:53'!
test12ADoorCannotBeLockedWithAnyObjectThatIsNotAKey

	| room1 room2 door paper |

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 

	
	

	

	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:47:47' prior: 50896076!
test12ADoorCannotBeLockedWithAnyObjectThatIsNotAKey

	| room1 room2 |

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 	
		
	self 
		should: [ Door in: room1 at: 1@1  and: room2  at: 1@1  thatOpensWith: self paper ]
		raise: Error - MessageNotUnderstood 
		withMessageText: (Door cannotBeLockedWithANonKeyObject).

	
	

	

	
	! !
!Door class methodsFor: 'exceptions' stamp: 'FG 12/17/2020 19:48:24'!
cannotBeLockedWithANonKeyObject
	^ 'Error - Door Cannot Be Locked With Non Key Object'.! !
!Door methodsFor: 'initialization' stamp: 'FG 12/17/2020 19:48:56' prior: 50895553!
initializeIn: aRoom at: aPosition and: anotherRoom at: anotherPosition thatOpensWith: aKey 
	
	(aRoom = anotherRoom) ifTrue: [ self error: Door doorCannotBeInTheSameRoomTwice ].
	(aKey isAKey) ifFalse: [ self error: Door cannotBeLockedWithANonKeyObject ].
	
	aRoom at: aPosition put: self.
	anotherRoom at: anotherPosition put: self.
	
	key := aKey.
	state := ClosedDoor new.
	firstRoom := aRoom.
	secondRoom := anotherRoom.! !

!testRun: #DoorTest #test12ADoorCannotBeLockedWithAnyObjectThatIsNotAKey stamp: 'FG 12/17/2020 19:49:14'!
PASSED!
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:53:03'!
test13CannotCloseDoorWithANonKeyObject

	| room1 room2 door key|

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 	
		
	key := self correctKey.	
	door := Door in: room1 at: 1@1  and: room2  at: 1@1  thatOpensWith: key.
	door openWith:	 key.
		
	self 
		should: [ door closeWith: self paper ]
		raise: Error - MessageNotUnderstood 
		withMessageText: (Door cannotBeLockedWithANonKeyObject).

	
	

	

	
	! !
!Door methodsFor: 'nil' stamp: 'FG 12/17/2020 19:54:00'!
closeWith: aKey

	(key isAKey) ifFalse: [self error: Door cannotBeLockedWithANonKeyObject ].
	 ! !

!testRun: #DoorTest #test13CannotCloseDoorWithANonKeyObject stamp: 'FG 12/17/2020 19:54:06'!
FAILURE!

!testRun: #DoorTest #test13CannotCloseDoorWithANonKeyObject stamp: 'FG 12/17/2020 19:54:06'!
FAILURE!

!testRun: #DoorTest #test13CannotCloseDoorWithANonKeyObject stamp: 'FG 12/17/2020 19:54:15'!
FAILURE!

!testRun: #DoorTest #test13CannotCloseDoorWithANonKeyObject stamp: 'FG 12/17/2020 19:54:15'!
FAILURE!
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:54:37' prior: 50896125!
test13CannotCloseDoorWithANonKeyObject

	| room1 room2 door key|

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 	
		
	key := self correctKey.	
	door := Door in: room1 at: 1@1  and: room2  at: 1@1  thatOpensWith: key.
	door openWith:	 key.
		
	self 
		should: [ door closeWith: self paper ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Door cannotBeLockedWithANonKeyObject.

	
	

	

	
	! !
!Door methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:55:06' prior: 50896141!
closeWith: aKey

	(aKey isAKey) ifFalse: [self error: Door cannotBeLockedWithANonKeyObject ].
	 ! !

!testRun: #DoorTest #test13CannotCloseDoorWithANonKeyObject stamp: 'FG 12/17/2020 19:55:17'!
PASSED!
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:56:25'!
test13CannotCloseAClosedDoor

	| room1 room2 door key|

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 	
		
	key := self correctKey.	
	door := Door in: room1 at: 1@1  and: room2  at: 1@1  thatOpensWith: key.
		
	self 
		should: [ door closeWith: self correctKey ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Door cannotCloseAnAlreadyClosedDoor.

	
	

	

	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:56:31'!
test14CannotCloseAClosedDoor

	| room1 room2 door key|

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 	
		
	key := self correctKey.	
	door := Door in: room1 at: 1@1  and: room2  at: 1@1  thatOpensWith: key.
		
	self 
		should: [ door closeWith: self correctKey ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Door cannotCloseAnAlreadyClosedDoor.

	
	

	

	
	! !

!methodRemoval: DoorTest #test13CannotCloseAClosedDoor stamp: 'FG 12/17/2020 19:56:33'!
test13CannotCloseAClosedDoor

	| room1 room2 door key|

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 	
		
	key := self correctKey.	
	door := Door in: room1 at: 1@1  and: room2  at: 1@1  thatOpensWith: key.
		
	self 
		should: [ door closeWith: self correctKey ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Door cannotCloseAnAlreadyClosedDoor.

	
	

	

	
	!
!Door methodsFor: 'close' stamp: 'FG 12/17/2020 19:57:25' prior: 50896177!
closeWith: aKey

	(aKey isAKey) ifFalse: [self error: Door cannotBeLockedWithANonKeyObject ].
	
	state closeDoor: self with: aKey.
	 ! !
!ClosedDoor methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:57:56'!
closeDoor: aDoor with: aKey

	aDoor closeClosedDoor.! !
!Door methodsFor: 'nil' stamp: 'FG 12/17/2020 19:58:31'!
closeClosedDoor

	self error: Door doorAlreadyClosed.! !
!Door class methodsFor: 'exceptions' stamp: 'FG 12/17/2020 19:58:43'!
doorAlreadyClosed

	^ 'Error - Door is already closed' ! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:59:08' prior: 50896202!
test14CannotCloseAClosedDoor

	| room1 room2 door key|

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 	
		
	key := self correctKey.	
	door := Door in: room1 at: 1@1  and: room2  at: 1@1  thatOpensWith: key.
		
	self 
		should: [ door closeWith: self correctKey ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Door doorAlreadyClosed.

	
	

	

	
	! !

!testRun: #DoorTest #test14CannotCloseAClosedDoor stamp: 'FG 12/17/2020 19:59:11'!
PASSED!
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:02:24'!
test15DoorCanBeClosedWithAKey

	| room1 room2 door key newKey|

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 	
		
	key := self correctKey.	
	door := Door in: room1 at: 1@1  and: room2  at: 1@1  thatOpensWith: key.
	door openWith: key.

	newKey := self wrongKey.
	door closeWith: newKey.
	
	self assert: door isClosed.
	
	door openWith: newKey.
	
	self deny: door isClosed	.
	
		
	

	

	
	! !

!testRun: #DoorTest #test15DoorCanBeClosedWithAKey stamp: 'FG 12/17/2020 20:02:29'!
ERROR!

!testRun: #DoorTest #test15DoorCanBeClosedWithAKey stamp: 'FG 12/17/2020 20:02:29'!
ERROR!
!OpenDoor methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:03:13'!
closeDoor: aDoor with: aKey

	aDoor closeOpenedDoorWith: aKey.! !
!Door methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:03:38'!
closeOpenedDoorWith: aKey

	state := ClosedDoor new.
	key := aKey.! !

!testRun: #DoorTest #test15DoorCanBeClosedWithAKey stamp: 'FG 12/17/2020 20:04:21'!
PASSED!
!Door methodsFor: 'initialization' stamp: 'FG 12/17/2020 20:05:43'!
assertThat: aRoom isDifferentFrom: anotherRoom

	^ (aRoom = anotherRoom) ifTrue: [ self error: Door doorCannotBeInTheSameRoomTwice ]! !
!Door methodsFor: 'initialization' stamp: 'FG 12/17/2020 20:05:43' prior: 50896105!
initializeIn: aRoom at: aPosition and: anotherRoom at: anotherPosition thatOpensWith: aKey 
	
	self assertThat: aRoom isDifferentFrom: anotherRoom.
	(aKey isAKey) ifFalse: [ self error: Door cannotBeLockedWithANonKeyObject ].
	
	aRoom at: aPosition put: self.
	anotherRoom at: anotherPosition put: self.
	
	key := aKey.
	state := ClosedDoor new.
	firstRoom := aRoom.
	secondRoom := anotherRoom.! !
!Door methodsFor: 'initialization' stamp: 'FG 12/17/2020 20:06:42'!
assertIsValidKey: aKey

	^ (aKey isAKey) ifFalse: [ self error: Door cannotBeLockedWithANonKeyObject ]! !
!Door methodsFor: 'initialization' stamp: 'FG 12/17/2020 20:06:42' prior: 50896313!
initializeIn: aRoom at: aPosition and: anotherRoom at: anotherPosition thatOpensWith: aKey 
	
	self assertThat: aRoom isDifferentFrom: anotherRoom.
	self assertIsValidKey: aKey.
	
	aRoom at: aPosition put: self.
	anotherRoom at: anotherPosition put: self.
	
	key := aKey.
	state := ClosedDoor new.
	firstRoom := aRoom.
	secondRoom := anotherRoom.! !
!Door methodsFor: 'open' stamp: 'FG 12/17/2020 20:10:12'!
assertThatIsTheCorrectKey: aKey

	^ (key = aKey) ifFalse: [ self error: Door cannotOpenWithWrongKey]! !
!Door methodsFor: 'open' stamp: 'FG 12/17/2020 20:10:12' prior: 50896031!
openWith: aKey

	self assertThatIsTheCorrectKey: aKey.
	
	state openDoor: self.
	 ! !
!Door methodsFor: 'close' stamp: 'FG 12/17/2020 20:10:31' prior: 50896233!
closeWith: aKey

	self assertIsValidKey: aKey.
	
	state closeDoor: self with: aKey.
	 ! !
!DoorState methodsFor: 'nil' stamp: 'FG 12/17/2020 20:11:15'!
closeDoor: aDoor with: aKey
	self subclassResponsibility.! !
!DoorState methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:11:33'!
isClosed
	self subclassResponsibility.! !
!DoorState methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:11:47'!
openDoor: aDoor with: aKey
	self subclassResponsibility.! !
!DoorState methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:12:30'!
openDoor: aDoor
	self subclassResponsibility.! !

!methodRemoval: DoorState #openDoor:with: stamp: 'FG 12/17/2020 20:12:33'!
openDoor: aDoor with: aKey
	self subclassResponsibility.!
!DoorState methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:12:47'!
useDoor: aDoor from: aRoom
	self subclassResponsibility ! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:14:15' overrides: 16927572!
setUp
	
	||! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:14:48' prior: 50896392 overrides: 16927572!
setUp
	
	| room anotherRoom|
	
	room := Room ofWidth: 10 andHeight: 10.
	anotherRoom := Room ofWidth: 10 andHeight: 10. ! !

TestCase subclass: #DoorTest
	instanceVariableNames: 'room anotherRoom'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!

TestCase subclass: #DoorTest
	instanceVariableNames: 'aRoom anotherRoom'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!

TestCase subclass: #DoorTest
	instanceVariableNames: 'asd asda'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!

!classDefinition: #DoorTest category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 20:18:25'!
TestCase subclass: #DoorTest
	instanceVariableNames: 'asd asda'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:18:38' prior: 50896396 overrides: 16927572!
setUp
	
	asd := Room ofWidth: 10 andHeight: 10.
	asda := Room ofWidth: 10 andHeight: 10. ! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:18:44' prior: 50895672!
test01DoorShouldBeInDifferentRooms

	| room |
	
	asd := Room ofWidth: 10 andHeight: 10. 
	
	self 
		should: [ Door in: room at: 1@1 and: room at:1@1 thatOpensWith: self correctKey]
		raise: Error - MessageNotUnderstood 
		withMessageText: Door doorCannotBeInTheSameRoomTwice.
	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:18:59' prior: 50896434!
test01DoorShouldBeInDifferentRooms

	| room |
	
	self 
		should: [ Door in: room at: 1@1 and: asd at:1@1 thatOpensWith: self correctKey]
		raise: Error - MessageNotUnderstood 
		withMessageText: Door doorCannotBeInTheSameRoomTwice.
	
	! !

!testRun: #DoorTest #test01DoorShouldBeInDifferentRooms stamp: 'FG 12/17/2020 20:19:03'!
FAILURE!

!testRun: #DoorTest #test01DoorShouldBeInDifferentRooms stamp: 'FG 12/17/2020 20:19:03'!
FAILURE!

!methodRemoval: DoorTest #setUp stamp: 'FG 12/17/2020 20:19:18'!
setUp
	
	asd := Room ofWidth: 10 andHeight: 10.
	asda := Room ofWidth: 10 andHeight: 10. !

TestCase subclass: #DoorTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!

!classDefinition: #DoorTest category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 20:19:24'!
TestCase subclass: #DoorTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!

!testRun: #DoorTest #test01DoorShouldBeInDifferentRooms stamp: 'FG 12/17/2020 20:19:28'!
PASSED!
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:19:52' prior: 50896446!
test01DoorShouldBeInDifferentRooms

	| room |
	
	room := Room ofWidth: 10 andHeight: 10. 
	
	self 
		should: [ Door in: room at: 1@1 and: room at:1@1 thatOpensWith: self correctKey]
		raise: Error - MessageNotUnderstood 
		withMessageText: Door doorCannotBeInTheSameRoomTwice.
	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:20:11'!
room

	^ Room ofWidth: 10 andHeight: 10 ! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:20:19' prior: 50896484!
test01DoorShouldBeInDifferentRooms

	| room |
	
	room := self room. 
	
	self 
		should: [ Door in: room at: 1@1 and: room at:1@1 thatOpensWith: self correctKey]
		raise: Error - MessageNotUnderstood 
		withMessageText: Door doorCannotBeInTheSameRoomTwice.
	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:21:04' prior: 50896501!
test01DoorShouldBeInDifferentRooms

       |sameRoom|

	sameRoom := self room.

	self 
		should: [ Door in: sameRoom  at: 1@1 and: sameRoom at:1@1 thatOpensWith: self correctKey]
		raise: Error - MessageNotUnderstood 
		withMessageText: Door doorCannotBeInTheSameRoomTwice.
	
	! !

!testRun: #DoorTest #test01DoorShouldBeInDifferentRooms stamp: 'FG 12/17/2020 20:21:07'!
PASSED!
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:22:18'!
shouldDo: aBlock failingAndRaising: anErrorMessage

	self 
		should: aBlock
		raise: Error - MessageNotUnderstood 
		withMessageText: anErrorMessage.
	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:22:55' prior: 50896513!
test01DoorShouldBeInDifferentRooms

       |sameRoom|

	sameRoom := self room.

	self 
		shouldDo: [ Door in: sameRoom  at: 1@1 and: sameRoom at:1@1 thatOpensWith: self correctKey]
		failingAndRaising: Door doorCannotBeInTheSameRoomTwice.
	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:23:09' prior: 50895710!
test02CannotPlaceDoorInInvalidPositionInAnyOfTheRooms

	| room1 room2 |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
	
	self 
		should: [ Door in: room1 at: -1@0 and: room2 at: 1@1 thatOpensWith: self correctKey ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Room invalidPositionErrorDescription.
		
	self 
		should: [ Door in: room1 at: 1@0 and: room2 at: -1@1 thatOpensWith: self correctKey ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Room invalidPositionErrorDescription.
	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:23:18' prior: 50896547!
test02CannotPlaceDoorInInvalidPositionInAnyOfTheRooms

	| room room2 |
	
	room := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
	
	self 
		should: [ Door in: room at: -1@0 and: room2 at: 1@1 thatOpensWith: self correctKey ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Room invalidPositionErrorDescription.
		
	self 
		should: [ Door in: room at: 1@0 and: room2 at: -1@1 thatOpensWith: self correctKey ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Room invalidPositionErrorDescription.
	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:23:28' prior: 50896568!
test02CannotPlaceDoorInInvalidPositionInAnyOfTheRooms

	| room anotherRoom |
	
	room := Room ofWidth: 10 andHeight: 10.
	anotherRoom := Room ofWidth: 10 andHeight: 10. 
	
	self 
		should: [ Door in: room at: -1@0 and: anotherRoom at: 1@1 thatOpensWith: self correctKey ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Room invalidPositionErrorDescription.
		
	self 
		should: [ Door in: room at: 1@0 and: anotherRoom at: -1@1 thatOpensWith: self correctKey ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Room invalidPositionErrorDescription.
	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:24:33' prior: 50896589!
test02CannotPlaceDoorInInvalidPositionInAnyOfTheRooms

	| room anotherRoom |
	
	room := Room ofWidth: 10 andHeight: 10.
	anotherRoom := Room ofWidth: 10 andHeight: 10. 
	
	self 
		shouldDo:  [ Door in: room at: -1@0 and: anotherRoom at: 1@1 thatOpensWith: self correctKey ]
		failingAndRaising: Room invalidPositionErrorDescription.
		
		
	self 
		shouldDo:  [ Door in: room at: 1@0 and: anotherRoom at: -1@1 thatOpensWith: self correctKey ]
		failingAndRaising: Room invalidPositionErrorDescription.
	
	! !

!testRun: #DoorTest #test02CannotPlaceDoorInInvalidPositionInAnyOfTheRooms stamp: 'FG 12/17/2020 20:24:37'!
PASSED!

!testRun: #DoorTest #test01DoorShouldBeInDifferentRooms stamp: 'FG 12/17/2020 20:24:39'!
PASSED!

!methodRemoval: DoorTest #test02CannotPlaceDoorInInvalidPositionInAnyOfTheRooms stamp: 'FG 12/17/2020 20:24:44'!
test02CannotPlaceDoorInInvalidPositionInAnyOfTheRooms

	| room anotherRoom |
	
	room := Room ofWidth: 10 andHeight: 10.
	anotherRoom := Room ofWidth: 10 andHeight: 10. 
	
	self 
		shouldDo:  [ Door in: room at: -1@0 and: anotherRoom at: 1@1 thatOpensWith: self correctKey ]
		failingAndRaising: Room invalidPositionErrorDescription.
		
		
	self 
		shouldDo:  [ Door in: room at: 1@0 and: anotherRoom at: -1@1 thatOpensWith: self correctKey ]
		failingAndRaising: Room invalidPositionErrorDescription.
	
	!

!methodRemoval: DoorTest #test03CannotPlaceDoorInOcupiedPositionInAnyOfTheRooms stamp: 'FG 12/17/2020 20:24:46'!
test03CannotPlaceDoorInOcupiedPositionInAnyOfTheRooms

	| room1 room2 |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
	
	room1 at: 1@1 put: self paper.
	room2 at: 1@1 put: self paper. 
	
	self 
		should: [ Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: self correctKey ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Room positionIsNotEmptyErrorDescription.
		
	self 
		should: [ Door in: room1 at: 1@0 and: room2 at: 1@1 thatOpensWith: self correctKey ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Room positionIsNotEmptyErrorDescription.
	
	!
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:24:55'!
test03DoorIsInBothRooms

	| room1 room2 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: self correctKey.	
	
	self deny: (room1 isEmptyAt: 1@1).
	self deny: (room2 isEmptyAt: 0@1).
	self assert: (room1 at: 1@1) equals: door.
	self assert: (room2 at: 0@1) equals: door.  
	! !

!methodRemoval: DoorTest #test04DoorIsInBothRooms stamp: 'FG 12/17/2020 20:24:56'!
test04DoorIsInBothRooms

	| room1 room2 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: self correctKey.	
	
	self deny: (room1 isEmptyAt: 1@1).
	self deny: (room2 isEmptyAt: 0@1).
	self assert: (room1 at: 1@1) equals: door.
	self assert: (room2 at: 0@1) equals: door.  
	!
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:25:04'!
test04DoorLeadFromOneRoomToTheOther

	| room1 room2 door key |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	key := self correctKey.
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: key.
	door openWith: key.	
	
	self assert: (door useFrom: room1) equals: room2.
	self assert: (door useFrom: room2) equals: room1. ! !

!methodRemoval: DoorTest #test05DoorLeadFromOneRoomToTheOther stamp: 'FG 12/17/2020 20:25:05'!
test05DoorLeadFromOneRoomToTheOther

	| room1 room2 door key |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	key := self correctKey.
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: key.
	door openWith: key.	
	
	self assert: (door useFrom: room1) equals: room2.
	self assert: (door useFrom: room2) equals: room1. !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:25:16'!
test02DoorIsInBothRooms

	| room1 room2 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: self correctKey.	
	
	self deny: (room1 isEmptyAt: 1@1).
	self deny: (room2 isEmptyAt: 0@1).
	self assert: (room1 at: 1@1) equals: door.
	self assert: (room2 at: 0@1) equals: door.  
	! !

!methodRemoval: DoorTest #test03DoorIsInBothRooms stamp: 'FG 12/17/2020 20:25:16'!
test03DoorIsInBothRooms

	| room1 room2 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: self correctKey.	
	
	self deny: (room1 isEmptyAt: 1@1).
	self deny: (room2 isEmptyAt: 0@1).
	self assert: (room1 at: 1@1) equals: door.
	self assert: (room2 at: 0@1) equals: door.  
	!
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:25:22'!
test03DoorLeadFromOneRoomToTheOther

	| room1 room2 door key |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	key := self correctKey.
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: key.
	door openWith: key.	
	
	self assert: (door useFrom: room1) equals: room2.
	self assert: (door useFrom: room2) equals: room1. ! !

!methodRemoval: DoorTest #test04DoorLeadFromOneRoomToTheOther stamp: 'FG 12/17/2020 20:25:22'!
test04DoorLeadFromOneRoomToTheOther

	| room1 room2 door key |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	key := self correctKey.
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: key.
	door openWith: key.	
	
	self assert: (door useFrom: room1) equals: room2.
	self assert: (door useFrom: room2) equals: room1. !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:25:28'!
test04CannotMoveFromARoomWhichDoesntHasTheDoor

	| room1 room2 room3 door key |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
	room3 := Room 	ofWidth: 10 andHeight: 10.
	
	key := self correctKey.	
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: key.
	door openWith: key.	
	
	self 
		should: [ door useFrom: room3]
		raise: Error - MessageNotUnderstood 
		withMessageText: (Door cannotMoveFromARoomWithoutThisDoor).! !

!methodRemoval: DoorTest #test06CannotMoveFromARoomWhichDoesntHasTheDoor stamp: 'FG 12/17/2020 20:25:28'!
test06CannotMoveFromARoomWhichDoesntHasTheDoor

	| room1 room2 room3 door key |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
	room3 := Room 	ofWidth: 10 andHeight: 10.
	
	key := self correctKey.	
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: key.
	door openWith: key.	
	
	self 
		should: [ door useFrom: room3]
		raise: Error - MessageNotUnderstood 
		withMessageText: (Door cannotMoveFromARoomWithoutThisDoor).!
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:25:34'!
test05DoorStartsClosed

	| room1 room2 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: self correctKey.	
	
	self assert: door isClosed.! !

!methodRemoval: DoorTest #test07DoorStartsClosed stamp: 'FG 12/17/2020 20:25:34'!
test07DoorStartsClosed

	| room1 room2 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: self correctKey.	
	
	self assert: door isClosed.!
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:25:38'!
test06CannotUseAClosedDoor

	| room1 room2 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: self correctKey.	
	
	self 
		should: [ door useFrom: room1]
		raise: Error - MessageNotUnderstood 
		withMessageText: (Door cannotUseClosedDoor).
	
	! !

!methodRemoval: DoorTest #test08CannotUseAClosedDoor stamp: 'FG 12/17/2020 20:25:38'!
test08CannotUseAClosedDoor

	| room1 room2 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: self correctKey.	
	
	self 
		should: [ door useFrom: room1]
		raise: Error - MessageNotUnderstood 
		withMessageText: (Door cannotUseClosedDoor).
	
	!
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:25:47'!
test07CannotOpenDoorWithWrongKey

	| room1 room2 door |

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: self correctKey.	
	
	self 
		should: [ door openWith: self wrongKey ]
		raise: Error - MessageNotUnderstood 
		withMessageText: (Door cannotOpenWithWrongKey).
	

	

	

	
	! !

!methodRemoval: DoorTest #test09CannotOpenDoorWithWrongKey stamp: 'FG 12/17/2020 20:25:47'!
test09CannotOpenDoorWithWrongKey

	| room1 room2 door |

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: self correctKey.	
	
	self 
		should: [ door openWith: self wrongKey ]
		raise: Error - MessageNotUnderstood 
		withMessageText: (Door cannotOpenWithWrongKey).
	

	

	

	
	!
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:25:53'!
test08DoorOpensWithTheCorrectKey

	| room1 room2 door key |

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 

	key := self correctKey.	
			
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: key.	
	
	door openWith: key.
	
	self deny: door isClosed.	

	

	

	
	! !

!methodRemoval: DoorTest #test10DoorOpensWithTheCorrectKey stamp: 'FG 12/17/2020 20:25:53'!
test10DoorOpensWithTheCorrectKey

	| room1 room2 door key |

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 

	key := self correctKey.	
			
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: key.	
	
	door openWith: key.
	
	self deny: door isClosed.	

	

	

	
	!
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:25:58'!
test09CannotOpenAnAlreadyOpenDoor

	| room1 room2 door key |

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 

	key := self correctKey.	
			
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: key.	
	
	door openWith: key.
	
	self 
		should: [ door openWith: key ]
		raise: Error - MessageNotUnderstood 
		withMessageText: (Door doorAlreadyOpen).

	

	

	
	! !

!methodRemoval: DoorTest #test11CannotOpenAnAlreadyOpenDoor stamp: 'FG 12/17/2020 20:25:58'!
test11CannotOpenAnAlreadyOpenDoor

	| room1 room2 door key |

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 

	key := self correctKey.	
			
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: key.	
	
	door openWith: key.
	
	self 
		should: [ door openWith: key ]
		raise: Error - MessageNotUnderstood 
		withMessageText: (Door doorAlreadyOpen).

	

	

	
	!
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:26:03'!
test10ADoorCannotBeLockedWithAnyObjectThatIsNotAKey

	| room1 room2 |

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 	
		
	self 
		should: [ Door in: room1 at: 1@1  and: room2  at: 1@1  thatOpensWith: self paper ]
		raise: Error - MessageNotUnderstood 
		withMessageText: (Door cannotBeLockedWithANonKeyObject).

	
	

	

	
	! !

!methodRemoval: DoorTest #test12ADoorCannotBeLockedWithAnyObjectThatIsNotAKey stamp: 'FG 12/17/2020 20:26:03'!
test12ADoorCannotBeLockedWithAnyObjectThatIsNotAKey

	| room1 room2 |

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 	
		
	self 
		should: [ Door in: room1 at: 1@1  and: room2  at: 1@1  thatOpensWith: self paper ]
		raise: Error - MessageNotUnderstood 
		withMessageText: (Door cannotBeLockedWithANonKeyObject).

	
	

	

	
	!
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:26:08'!
test11CannotCloseDoorWithANonKeyObject

	| room1 room2 door key|

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 	
		
	key := self correctKey.	
	door := Door in: room1 at: 1@1  and: room2  at: 1@1  thatOpensWith: key.
	door openWith:	 key.
		
	self 
		should: [ door closeWith: self paper ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Door cannotBeLockedWithANonKeyObject.

	
	

	

	
	! !

!methodRemoval: DoorTest #test13CannotCloseDoorWithANonKeyObject stamp: 'FG 12/17/2020 20:26:08'!
test13CannotCloseDoorWithANonKeyObject

	| room1 room2 door key|

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 	
		
	key := self correctKey.	
	door := Door in: room1 at: 1@1  and: room2  at: 1@1  thatOpensWith: key.
	door openWith:	 key.
		
	self 
		should: [ door closeWith: self paper ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Door cannotBeLockedWithANonKeyObject.

	
	

	

	
	!
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:26:14'!
test12CannotCloseAClosedDoor

	| room1 room2 door key|

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 	
		
	key := self correctKey.	
	door := Door in: room1 at: 1@1  and: room2  at: 1@1  thatOpensWith: key.
		
	self 
		should: [ door closeWith: self correctKey ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Door doorAlreadyClosed.

	
	

	

	
	! !

!methodRemoval: DoorTest #test14CannotCloseAClosedDoor stamp: 'FG 12/17/2020 20:26:14'!
test14CannotCloseAClosedDoor

	| room1 room2 door key|

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 	
		
	key := self correctKey.	
	door := Door in: room1 at: 1@1  and: room2  at: 1@1  thatOpensWith: key.
		
	self 
		should: [ door closeWith: self correctKey ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Door doorAlreadyClosed.

	
	

	

	
	!
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:26:20'!
test13DoorCanBeClosedWithAKey

	| room1 room2 door key newKey|

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 	
		
	key := self correctKey.	
	door := Door in: room1 at: 1@1  and: room2  at: 1@1  thatOpensWith: key.
	door openWith: key.

	newKey := self wrongKey.
	door closeWith: newKey.
	
	self assert: door isClosed.
	
	door openWith: newKey.
	
	self deny: door isClosed	.
	
		
	

	

	
	! !

!methodRemoval: DoorTest #test15DoorCanBeClosedWithAKey stamp: 'FG 12/17/2020 20:26:20'!
test15DoorCanBeClosedWithAKey

	| room1 room2 door key newKey|

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 	
		
	key := self correctKey.	
	door := Door in: room1 at: 1@1  and: room2  at: 1@1  thatOpensWith: key.
	door openWith: key.

	newKey := self wrongKey.
	door closeWith: newKey.
	
	self assert: door isClosed.
	
	door openWith: newKey.
	
	self deny: door isClosed	.
	
		
	

	

	
	!
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:26:37' prior: 50896738!
test02DoorIsInBothRooms

	| room room2 door |
	
	room := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room at: 1@1 and: room2 at: 0@1 thatOpensWith: self correctKey.	
	
	self deny: (room isEmptyAt: 1@1).
	self deny: (room2 isEmptyAt: 0@1).
	self assert: (room at: 1@1) equals: door.
	self assert: (room2 at: 0@1) equals: door.  
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:26:57' prior: 50897095!
test02DoorIsInBothRooms

	| room anotherRoom door |
	
	room := Room ofWidth: 10 andHeight: 10.
	anotherRoom := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room at: 1@1 and: anotherRoom at: 0@1 thatOpensWith: self correctKey.	
	
	self deny: (room isEmptyAt: 1@1).
	self deny: (anotherRoom isEmptyAt: 0@1).
	self assert: (room at: 1@1) equals: door.
	self assert: (anotherRoom at: 0@1) equals: door.  
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:27:47' prior: 50896768!
test03DoorLeadFromOneRoomToTheOther

	| room anotherRoom door key |
	
	room := Room ofWidth: 10 andHeight: 10.
	anotherRoom := Room ofWidth: 10 andHeight: 10. 
		
	key := self correctKey.
	door := Door in: room at: 1@1 and: anotherRoom at: 0@1 thatOpensWith: key.
	door openWith: key.	
	
	self assert: (door useFrom: room) equals: anotherRoom.
	self assert: (door useFrom: anotherRoom) equals: room. ! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:28:20'!
openedDoor

	| room anotherRoom door key |
	
	room := Room ofWidth: 10 andHeight: 10.
	anotherRoom := Room ofWidth: 10 andHeight: 10. 
		
	key := self correctKey.
	door := Door in: room at: 1@1 and: anotherRoom at: 0@1 thatOpensWith: key.
	door openWith: key.	
	
	^ door! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:29:54' prior: 50896798!
test04CannotMoveFromARoomWhichDoesntHasTheDoor

	| room door |
	
	room := Room ofWidth: 10 andHeight: 10.
	
	door := self openedDoor.
	self 
		should: [ door useFrom: room]
		raise: Error - MessageNotUnderstood 
		withMessageText: (Door cannotMoveFromARoomWithoutThisDoor).! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:30:41' prior: 50897154!
test04CannotMoveFromARoomWhichDoesntHasTheDoor

	| room door |
	
	room := Room ofWidth: 10 andHeight: 10.
	
	door := self openedDoor.
	
	self 
		shouldDo: [ door useFrom: room] 
		failingAndRaising: Door cannotMoveFromARoomWithoutThisDoor
! !

!testRun: #DoorTest #test04CannotMoveFromARoomWhichDoesntHasTheDoor stamp: 'FG 12/17/2020 20:30:45'!
PASSED!
!Room methodsFor: 'contents' stamp: 'FG 12/17/2020 20:36:04' prior: 50894235!
moveFrom: aSourcePosition to: aTargetPosition

	| toMove |
	
	((self at: aTargetPosition) isKindOf: Door) 
	ifTrue:[
	
	]
	ifFalse: [
		toMove := self at: aSourcePosition.
		self at: aTargetPosition put: toMove.
		contents removeKey: aSourcePosition.
	].
	! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'FG 12/17/2020 20:40:19'!
test21_playerShouldMoveFromRoomsWhenPassThroughADoor

	| room anotherRoom player box paper anotherPaper |

	room := self defaultRoom.
	anotherRoom := self defaultRoom.
	Door in: room at:  0@1 and: anotherRoom at: 0@1  thatOpensWith: self correctKey .
	player := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 0@0 heading: #North in: room.
	
	player moveForward.
	
	! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'FG 12/17/2020 20:42:03' prior: 50897191!
test21_playerShouldMoveFromRoomsWhenPassThroughADoor

	| room anotherRoom player box paper anotherPaper |

	room := self defaultRoom.
	anotherRoom := self defaultRoom.
	Door in: room at:  0@1 and: anotherRoom at: 0@1  thatOpensWith: self correctKey .
	player := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 0@0 heading: #North in: room.
	
	player moveForward.
	
	self assert: (anotherRoom at: 0@2) equals: player. 
	! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'FG 12/17/2020 20:42:13' prior: 50897206!
test21_playerShouldMoveFromRoomsWhenPassThroughADoor

	| room anotherRoom player |

	room := self defaultRoom.
	anotherRoom := self defaultRoom.
	Door in: room at:  0@1 and: anotherRoom at: 0@1  thatOpensWith: self correctKey .
	player := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 0@0 heading: #North in: room.
	
	player moveForward.
	
	self assert: (anotherRoom at: 0@2) equals: player. 
	! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'FG 12/17/2020 20:42:37'!
correctKey

	^ Keys named: 'Correct Key' weighing: 5 ! !
!Room methodsFor: 'contents' stamp: 'FG 12/17/2020 20:47:06' prior: 50897180!
moveFrom: aSourcePosition to: aTargetPosition

	| toMove |
	
		toMove := self at: aSourcePosition.
		self at: aTargetPosition put: toMove.
		contents removeKey: aSourcePosition.
	! !
!Room methodsFor: 'contents' stamp: 'FG 12/17/2020 20:50:22'!
moveAt: aPosition to: anotherRoom at: anotherPosition

	anotherRoom at: anotherPosition put: (self at: aPosition).
	contents removeKey: aPosition.! !
!PlayableCharacter methodsFor: 'moving' stamp: 'FG 12/17/2020 20:52:08' prior: 50894007!
moveForward
	
	self moveTo: self forwardPosition ! !
!PlayableCharacter methodsFor: 'moving' stamp: 'FG 12/17/2020 20:54:01' prior: 50894011!
moveTo: aNewPosition
	
	((room at: aNewPosition) isKindOf: Door)
	ifTrue:[
		room 
	]
	ifFalse:[
		room moveFrom: self position to: aNewPosition.
	] ! !
!PlayableCharacter methodsFor: 'moving' stamp: 'FG 12/17/2020 20:56:21' prior: 50897265!
moveTo: aNewPosition
	
	((room at: aNewPosition) isKindOf: Door)
	ifTrue:[
		room moveAt: (room positionOf: self) to: ((room at: aNewPosition) useFrom: room) at:  room
	]
	ifFalse:[
		room moveFrom: self position to: aNewPosition.
	] ! !
!PlayableCharacter methodsFor: 'moving' stamp: 'FG 12/17/2020 21:00:54' prior: 50897273!
moveTo: aNewPosition
	
	|newRoom|
	
	((room at: aNewPosition) isKindOf: Door)
	ifTrue:[
		newRoom := 	(room at: aNewPosition) useFrom: room.
		room moveAt: self position to: newRoom at: (newRoom positionOf: (room at: aNewPosition)).
	]
	ifFalse:[
		room moveFrom: self position to: aNewPosition.
	] ! !
!PlayableCharacter methodsFor: 'moving' stamp: 'FG 12/17/2020 21:01:19' prior: 50897284!
moveTo: aNewPosition
	
	|newRoom|
	
	((room at: aNewPosition) isKindOf: Door)
	ifTrue:[
		newRoom := 	(room at: aNewPosition) useFrom: room.
		room moveAt: self position to: newRoom at: (newRoom positionOf: (room at: aNewPosition) + heading forwardPoint).
	]
	ifFalse:[
		room moveFrom: self position to: aNewPosition.
	] ! !

!testRun: #PlayableCharacterTest #test21_playerShouldMoveFromRoomsWhenPassThroughADoor stamp: 'FG 12/17/2020 21:02:14'!
ERROR!

!testRun: #PlayableCharacterTest #test21_playerShouldMoveFromRoomsWhenPassThroughADoor stamp: 'FG 12/17/2020 21:02:14'!
ERROR!
!PlayableCharacterTest methodsFor: 'tests' stamp: 'FG 12/17/2020 21:02:53'!
openedDoor

	| room anotherRoom door key |
	
	room := Room ofWidth: 10 andHeight: 10.
	anotherRoom := Room ofWidth: 10 andHeight: 10. 
		
	key := self correctKey.
	door := Door in: room at: 1@1 and: anotherRoom at: 0@1 thatOpensWith: key.
	door openWith: key.	
	
	^ door! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'FG 12/17/2020 21:03:06' prior: 50897318!
openedDoor

	| room anotherRoom door key |
	
	room := Room ofWidth: 10 andHeight: 10.
	anotherRoom := Room ofWidth: 10 andHeight: 10. 
		
	key := self correctKey.
	door := self openedDoor.
	door openWith: key.	
	
	^ door! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'FG 12/17/2020 21:03:44' prior: 50897223!
test21_playerShouldMoveFromRoomsWhenPassThroughADoor

	| room anotherRoom player |

	room := self defaultRoom.
	anotherRoom := self defaultRoom.
	self openedDoor.
	player := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 0@0 heading: #North in: room.
	
	player moveForward.
	
	self assert: (anotherRoom at: 0@2) equals: player. 
	! !

----STARTUP---- (17 December 2020 21:08:06) as C:\Users\FACU PC\Documents\Clases Virtuales\Cosas IS 1\Cuis University\CuisUniversity-4384.image!


!classDefinition: #BackpackTest category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:08:09'!
TestCase subclass: #BackpackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classDefinition: #BackpackTest category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:08:09'!
TestCase subclass: #BackpackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:29:03'!
assertShouldAddAll: portableObjects withPoints: expectedTotalPoints

	| aBackpack |
	
	aBackpack := Backpack containingUpTo: self backpackWeight limitingPointsTo: 100.

	portableObjects do: [ :aPortableObject | aBackpack add: aPortableObject ].
	
	self assert: aBackpack size equals: portableObjects size.
	self assert: aBackpack totalWeight equals: (portableObjects sum: [ :aPortableObject | aPortableObject weight ]).
	self assert: aBackpack totalPoints equals: expectedTotalPoints.
! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:28:32'!
assertShouldNotAddPortableObjectIfWeightExceeded: aPortableObject

	| aBackpack |
	aBackpack := Backpack containingUpTo: self backpackWeight limitingPointsTo: 100.

	self
		should: [ aBackpack add: aPortableObject ]
		raise: Error
		withMessageText: Backpack maxWeightExceededErrorDescription.
		
	self assert: aBackpack isEmpty. 
! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:28:32'!
backpackWeight

	^ 42! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:28:41'!
test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded

	self assertShouldNotAddPortableObjectIfWeightExceeded: 
		(NoPointsPortableObject named: 'help-wanted sign' weighing: self backpackWeight + 1)
! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:28:47'!
test08ShouldNotAddPointsPortableObjectIfWeightExceeded

	self assertShouldNotAddPortableObjectIfWeightExceeded: 
		(PointsPortableObject named: 'left-handed hammer' weighing: self backpackWeight + 6 worth: 5) ! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:26:42'!
test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity

	self 
		assertShouldAddAll: self twoPortableObjects
		withPoints: 5.
! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:27:27'!
test10ShouldAddPortableObjectsIfWeightEqualsMaxWeightCapacity

	self 
		assertShouldAddAll:  self twoPortableObjects, {(PointsPortableObject named: 'letter' weighing: 1 worth: 5)}
		withPoints: 10.
! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:27:39'!
twoPortableObjects

	^ {
		(PointsPortableObject named: 'left-handed hammer' weighing: 40 worth: 5).
		(NoPointsPortableObject named: 'help-wanted sign' weighing: 1) }! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04'!
test01CanNotCreateBackpackWithZeroMaxWeight

	self
		should: [ Backpack containingUpTo: 0 limitingPointsTo: 100 ]
		raise: Error
		withMessageText: Backpack invalidWeightCapacityErrorDescription.
! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04'!
test02CanNotCreateBackpackWithNegativeMaxWeight

	self
		should: [ Backpack containingUpTo: -1 limitingPointsTo: 100 ]
		raise: Error
		withMessageText: Backpack invalidWeightCapacityErrorDescription.! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04'!
test03CanNotCreateBackpackWithZeroMaxPoints

	self
		should: [ Backpack containingUpTo: 10 limitingPointsTo: 0 ]
		raise: Error
		withMessageText: Backpack invalidPointsCapacityErrorDescription.
! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04'!
test04CanNotCreateBackpackWithNegativeMaxPoints

	self
		should: [ Backpack containingUpTo: 10 limitingPointsTo: -1 ]
		raise: Error
		withMessageText: Backpack invalidPointsCapacityErrorDescription.! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04'!
test05CanNotCreateBackpackWithNoIntegerMaxWeight

	self
		should: [ Backpack containingUpTo: 1.0 limitingPointsTo: 100 ]
		raise: Error
		withMessageText: Backpack weightCapacityMustBeIntegerErrorDescription.
! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04'!
test06CanNotCreateBackpackWithNoIntegerMaxPoints

	self
		should: [ Backpack containingUpTo: 100 limitingPointsTo: 1.0 ]
		raise: Error
		withMessageText: Backpack pointsCapacityMustBeIntegerErrorDescription.
! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:49:20'!
test11ShouldAddZeroWeightWhenEmpty

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	self assert: aBackpack totalWeight equals: 0.
	self assert: aBackpack isEmpty
! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:35:57'!
test12ShouldAddWeightWhenAddingPortableObjects

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	aBackpack add: (PointsPortableObject named: 'left-handed hammer' weighing: 10 worth: 5).
	aBackpack add: (NoPointsPortableObject named: 'help-wanted sign' weighing: 10).
	
	self assert: aBackpack size equals: 2.
	self assert: aBackpack totalWeight equals: 20.

! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:49:31'!
test13ShouldAddZeroPointsWhenEmpty

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	self assert: aBackpack totalPoints equals: 0.
	self assert: aBackpack isEmpty.
! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:35:57'!
test14ShouldAddPointsWhenAddingPointsPortableObjects

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	aBackpack add: (PointsPortableObject named: 'left-handed hammer' weighing: 10 worth: 5).
	aBackpack add: (PointsPortableObject named: 'car key' weighing: 10 worth: 20).
	
	self assert: aBackpack size equals: 2.
	self assert: aBackpack totalPoints equals: 25.

! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:35:57'!
test15ShouldNotAddPointsWhenAddingNoPointsPortableObjects

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	aBackpack add: (PointsPortableObject named: 'left-handed hammer' weighing: 10 worth: 5).
	aBackpack add: (NoPointsPortableObject named: 'help-wanted sign' weighing: 10).
	aBackpack add: (NoPointsPortableObject named: 'help-wanted sign' weighing: 10).
	
	self assert: aBackpack size equals: 3.
	self assert: aBackpack totalPoints equals: 5.

! !

!classDefinition: #PlayableCharacterTest category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:08:11'!
TestCase subclass: #PlayableCharacterTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classDefinition: #PlayableCharacterTest category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:08:11'!
TestCase subclass: #PlayableCharacterTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/9/2020 19:36:13'!
test01_forwardWhenHeadingNorthIncrementsYCoordinate

	| playableCharacter |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 1@2 heading: #North .

	playableCharacter moveForward.

	self assert: (playableCharacter isAt: 1@3 heading: #North)! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/9/2020 19:36:13'!
test02_backwardWhenHeadingNorthDecrementsYCoordinate

	| playableCharacter |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 1@2 heading: #North .

	playableCharacter moveBackward.

	self assert: (playableCharacter isAt: 1@1 heading: #North)! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/9/2020 19:36:13'!
test03_rotateRightWhenHeadingNorthHeadsEast

	| playableCharacter |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 1@2 heading: #North .

	playableCharacter rotateRight.

	self assert: (playableCharacter isAt: 1@2 heading: #East)! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/9/2020 19:36:13'!
test04_rotateLeftWhenHeadingNorthHeadsWest

	| playableCharacter |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 1@2 heading: #North .

	playableCharacter rotateLeft.

	self assert: (playableCharacter isAt: 1@2 heading: #West)! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/9/2020 19:36:13'!
test05_movingWhenHeadingEastWorksAsExpected

	| playableCharacter |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 1@2 heading: #East .

	playableCharacter
		moveForward;
		moveForward;
		moveBackward;
		rotateRight;
		rotateLeft;
		rotateLeft.

	self assert: (playableCharacter isAt: 2@2 heading: #North)! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/9/2020 19:36:13'!
test06_movingWhenHeadingSouthWorksAsExpected

	| playableCharacter |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 1@2 heading: #South .

	playableCharacter
		moveForward;
		moveForward;
		moveBackward;
		rotateRight;
		rotateLeft;
		rotateLeft.

	self assert: (playableCharacter isAt: 1@1 heading: #East)! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/9/2020 19:36:13'!
test07_movingWhenHeadingWestWorksAsExpected

	| playableCharacter |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 2@2 heading: #West .

	playableCharacter
		moveForward;
		moveForward;
		moveBackward;
		rotateRight;
		rotateLeft;
		rotateLeft.

	self assert: (playableCharacter isAt: 1@2 heading: #South)! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/9/2020 19:36:13'!
test08_canNotCreatePlayableCharacterWhenHeadingIsNotValid

	self
		should: [PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 1@2 heading: #X ]
		raise: Error
		withExceptionDo: [:anError |
			self assert: PlayableCharacter invalidCardinalPointErrorDescription equals: anError messageText ]! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/9/2020 19:43:14'!
test09_canTakePortableObjects

	| playableCharacter paper |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 2@2 heading: #West .
	paper := NoPointsPortableObject named: 'Paper' weighing: 1.
	
	playableCharacter take: paper.
	
	self assert: (playableCharacter backpackIncludes: paper)! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/9/2020 19:47:21'!
test10_canNotTakeMoreObjectsThanTheBackpackCanCarry

	| playableCharacter paper key |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 2@2 heading: #West .
	paper := NoPointsPortableObject named: 'Paper' weighing: 100.
	key := NoPointsPortableObject named: 'Key' weighing: 1.
	
	playableCharacter take: paper.
	self 
		should: [ playableCharacter take: key ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [:anError |
			self assert: Backpack maxWeightExceededErrorDescription equals: anError messageText.
			self assert: (playableCharacter backpackIncludes: paper).
			self deny: (playableCharacter backpackIncludes: key) ]
	
	! !
!PlayableCharacterTest methodsFor: 'as yet unclassified' stamp: 'HAW 12/9/2020 13:53:29'!
defaultBackpack

	^ Backpack containingUpTo: 100 limitingPointsTo: 100 ! !

!classDefinition: #Backpack category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:08:13'!
Object subclass: #Backpack
	instanceVariableNames: 'weightCapacity gamePointsCapacity container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classDefinition: #Backpack category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:08:13'!
Object subclass: #Backpack
	instanceVariableNames: 'weightCapacity gamePointsCapacity container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!
!Backpack methodsFor: 'exceptions' stamp: 'FRT 10/8/2020 18:02:29'!
signalMaxPointsExceeded

	self error: self class maxPointsExceededErrorDescription ! !
!Backpack methodsFor: 'exceptions' stamp: 'FRT 10/8/2020 18:02:47'!
signalMaxWeightExceeded

	self error: self class maxWeightExceededErrorDescription ! !
!Backpack methodsFor: 'initialization' stamp: 'HAW 10/14/2020 14:31:56'!
initializeContainingUpTo: aWeightCapacity limitingPointsTo: pointsCapacity

	weightCapacity := aWeightCapacity.
	gamePointsCapacity := pointsCapacity.
	
	container := OrderedCollection new.
	
	
	! !
!Backpack methodsFor: 'accessing' stamp: 'FRT 10/11/2020 19:14:47' overrides: 16880927!
size

	^ container size.! !
!Backpack methodsFor: 'accessing' stamp: 'HAW 10/18/2020 12:20:52'!
totalPoints
		
	^(container select: [ :portableObject | portableObject doesItAddPoints ])	
		sum: [ :portableObject | portableObject points ]
		ifEmpty: [ 0 ]! !
!Backpack methodsFor: 'accessing' stamp: 'HAW 10/18/2020 12:20:20'!
totalWeight
	
	^container 
		sum: [ :portableObject | portableObject weight ]
		ifEmpty: [ 0 ]
		! !
!Backpack methodsFor: 'assertions' stamp: 'FRT 10/12/2020 14:12:36'!
assertPointsAdding: aPointsPortableObject

	(self totalPoints + aPointsPortableObject points) > gamePointsCapacity ifTrue: [ self signalMaxPointsExceeded ]! !
!Backpack methodsFor: 'assertions' stamp: 'FRT 10/15/2020 12:22:34'!
assertWeightAdding: aPortableObject tolerating: aThreshold

	(self totalWeight + aPortableObject weight - weightCapacity) > aThreshold ifTrue: [ self signalMaxWeightExceeded ]! !
!Backpack methodsFor: 'adding' stamp: 'HAW 10/18/2020 12:28:24'!
add: aPortableObject
	
	aPortableObject assertCanAddTo: self.
	
	container add: aPortableObject.
	! !
!Backpack methodsFor: 'testing' stamp: 'HAW 12/9/2020 19:44:17'!
includes: aPortableObject 
	
	^container includes: aPortableObject ! !
!Backpack methodsFor: 'testing' stamp: 'FRT 10/11/2020 18:38:38'!
isEmpty

	^ container isEmpty.! !
!Backpack methodsFor: 'adding - private' stamp: 'HAW 10/18/2020 12:28:48'!
assertCanAddNoPointsPortableObject: aNoPointsPortableObject 
	
	self assertWeightAdding: aNoPointsPortableObject tolerating: 0.
	! !
!Backpack methodsFor: 'adding - private' stamp: 'HAW 10/18/2020 12:29:07'!
assertCanAddPointPortableObject: aPointsPortableObject 
	
	self assertWeightAdding: aPointsPortableObject tolerating: 5.
	self assertPointsAdding: aPointsPortableObject.
	! !

!classDefinition: 'Backpack class' category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:08:14'!
Backpack class
	instanceVariableNames: ''!

!classDefinition: 'Backpack class' category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:08:14'!
Backpack class
	instanceVariableNames: ''!
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 18:27:33'!
invalidPointsCapacityErrorDescription

	^ 'Points capacity must be positive'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 18:21:04'!
invalidWeightCapacityErrorDescription

	^ 'Weight capacity must be positive'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/8/2020 17:36:29'!
maxPointsExceededErrorDescription

	^ 'Maximum points has been exceeded'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/8/2020 17:36:17'!
maxWeightExceededErrorDescription

	^ 'Maximum weight has been exceeded'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/8/2020 17:43:00'!
pointsCapacityMustBeIntegerErrorDescription

	^ 'Points capacity must be integer'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/8/2020 17:42:48'!
weightCapacityMustBeIntegerErrorDescription

	^ 'Weight capacity must be integer'! !
!Backpack class methodsFor: 'exceptions' stamp: 'FRT 10/11/2020 18:27:16'!
signalInvalidPointsCapacity

	self error: self invalidPointsCapacityErrorDescription 
! !
!Backpack class methodsFor: 'exceptions' stamp: 'FRT 10/11/2020 18:21:51'!
signalInvalidWeightCapacity

	self error: self invalidWeightCapacityErrorDescription 
! !
!Backpack class methodsFor: 'exceptions' stamp: 'FRT 10/8/2020 17:41:06'!
signalPointsCapacityMustBeInteger

	self error: self pointsCapacityMustBeIntegerErrorDescription
! !
!Backpack class methodsFor: 'exceptions' stamp: 'FRT 10/8/2020 17:40:47'!
signalWeightCapacityMustBeInteger

	self error: self weightCapacityMustBeIntegerErrorDescription
! !
!Backpack class methodsFor: 'instance creation' stamp: 'HAW 10/14/2020 14:31:56'!
containingUpTo: aWeightCapacity limitingPointsTo: pointsCapacity

	aWeightCapacity strictlyPositive  ifFalse: [ self signalInvalidWeightCapacity ].
	pointsCapacity strictlyPositive ifFalse: [ self signalInvalidPointsCapacity ].
	
	aWeightCapacity isInteger ifFalse: [ self signalWeightCapacityMustBeInteger ].
	pointsCapacity isInteger ifFalse: [ self signalPointsCapacityMustBeInteger ].
	
	^ self new initializeContainingUpTo: aWeightCapacity limitingPointsTo: pointsCapacity.
! !

!classDefinition: #PlayableCharacter category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:08:15'!
Object subclass: #PlayableCharacter
	instanceVariableNames: 'position heading backpack name'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classDefinition: #PlayableCharacter category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:08:15'!
Object subclass: #PlayableCharacter
	instanceVariableNames: 'position heading backpack name'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!
!PlayableCharacter methodsFor: 'initialization' stamp: 'HAW 12/9/2020 19:35:22'!
initializeNamed: aName using: aBackpack at: aPosition heading: aMarsRoverHeading 

	name := aName.
	backpack := aBackpack.
	position := aPosition.
	heading := aMarsRoverHeading! !
!PlayableCharacter methodsFor: 'testing' stamp: 'HAW 12/9/2020 19:43:44'!
backpackIncludes: aPortableObject 
	
	^backpack includes: aPortableObject ! !
!PlayableCharacter methodsFor: 'testing' stamp: 'HAW 7/1/2018 14:25:05'!
isAt: aPosition heading: aCardinalPoint

	^position = aPosition and: [ heading cardinalPoint = aCardinalPoint ]! !
!PlayableCharacter methodsFor: 'moving' stamp: 'HAW 10/11/2019 08:22:42'!
moveBackward
	
	position := position - heading forwardPoint ! !
!PlayableCharacter methodsFor: 'moving' stamp: 'HAW 10/11/2019 08:21:58'!
moveForward
	
	position := position + heading forwardPoint! !
!PlayableCharacter methodsFor: 'rotating' stamp: 'HAW 10/11/2019 08:31:55'!
rotateLeft
	
	heading := heading leftHeading! !
!PlayableCharacter methodsFor: 'rotating' stamp: 'HAW 10/11/2019 08:32:04'!
rotateRight
	
	heading := heading rightHeading! !
!PlayableCharacter methodsFor: 'taking objects' stamp: 'HAW 12/9/2020 19:28:57'!
take: aPortableObject

	backpack add: aPortableObject.! !

!classDefinition: 'PlayableCharacter class' category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:08:16'!
PlayableCharacter class
	instanceVariableNames: 'headings'!

!classDefinition: 'PlayableCharacter class' category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:08:16'!
PlayableCharacter class
	instanceVariableNames: 'headings'!
!PlayableCharacter class methodsFor: 'heading' stamp: 'HAW 7/2/2018 16:28:16'!
headingFor: aCardinalPoint
	
	^headings at: aCardinalPoint ifAbsent: [ self error: self invalidCardinalPointErrorDescription ]! !
!PlayableCharacter class methodsFor: 'heading' stamp: 'HAW 7/2/2018 16:26:14'!
invalidCardinalPointErrorDescription
	
	^'Invalid cardinal point'! !
!PlayableCharacter class methodsFor: 'instance creation' stamp: 'HAW 12/9/2020 19:36:13'!
named: aName using: aBackpack at: aPosition heading: aCardinalPoint 
	
	| newHeading |

	newHeading := self headingFor: aCardinalPoint.
	
	^self new initializeNamed: aName using: aBackpack at: aPosition heading: newHeading ! !
!PlayableCharacter class methodsFor: 'initialization' stamp: 'HAW 10/11/2019 08:37:25'!
forHeadingAt: aCardinalPoint leftIs: aLeftCardinalPoint rightIs: aRightCardinalPoint
	
	(headings at: aCardinalPoint) leftHeading: (headings at: aLeftCardinalPoint) rightHeading: (headings at: aRightCardinalPoint).
	! !
!PlayableCharacter class methodsFor: 'initialization' stamp: 'HAW 7/2/2018 15:27:41' overrides: 16883149!
initialize

	self initializeHeadings! !
!PlayableCharacter class methodsFor: 'initialization' stamp: 'HAW 12/9/2020 19:31:43'!
initializeHeadings

	headings := Dictionary new.
	
	(OrderedCollection 
		with: (PlayableCharacterHeading for: #North forwardWith: 0@1 )	
		with: (PlayableCharacterHeading for: #East forwardWith: 1@0 )
		with: (PlayableCharacterHeading for: #South forwardWith: 0@-1 )
		with: (PlayableCharacterHeading for: #West forwardWith: -1@0 ))
			do: [ :heading | headings at: heading cardinalPoint put: heading ].
	
	self 
		forHeadingAt: #North leftIs: #West rightIs: #East;
		forHeadingAt: #South leftIs: #East rightIs: #West;
		forHeadingAt: #East leftIs: #North rightIs: #South;
		forHeadingAt: #West leftIs: #South rightIs: #North.
	! !

!classDefinition: #PlayableCharacterHeading category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:08:16'!
Object subclass: #PlayableCharacterHeading
	instanceVariableNames: 'cardinalPoint forwardPoint rightHeading leftHeading'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classDefinition: #PlayableCharacterHeading category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:08:16'!
Object subclass: #PlayableCharacterHeading
	instanceVariableNames: 'cardinalPoint forwardPoint rightHeading leftHeading'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!
!PlayableCharacterHeading methodsFor: 'accessing' stamp: 'HAW 7/2/2018 15:29:44'!
cardinalPoint
	
	^cardinalPoint! !
!PlayableCharacterHeading methodsFor: 'accessing' stamp: 'HAW 7/2/2018 15:30:39'!
forwardPoint
	
	^forwardPoint! !
!PlayableCharacterHeading methodsFor: 'accessing' stamp: 'HAW 10/11/2019 08:31:33'!
leftHeading
	
	^leftHeading! !
!PlayableCharacterHeading methodsFor: 'accessing' stamp: 'HAW 10/11/2019 08:31:27'!
rightHeading
	
	^rightHeading! !
!PlayableCharacterHeading methodsFor: 'initialization' stamp: 'HAW 10/11/2019 08:27:25'!
initializeFor: aCardinalPoint forwardWith: aForwardPoint  
	
	cardinalPoint := aCardinalPoint.
	forwardPoint := aForwardPoint.
! !
!PlayableCharacterHeading methodsFor: 'initialization' stamp: 'HAW 10/11/2019 08:31:33'!
leftHeading: aLeftHeading rightHeading: aRightHeading
 
	leftHeading := aLeftHeading.
	rightHeading := aRightHeading ! !

!classDefinition: 'PlayableCharacterHeading class' category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:08:17'!
PlayableCharacterHeading class
	instanceVariableNames: ''!

!classDefinition: 'PlayableCharacterHeading class' category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:08:17'!
PlayableCharacterHeading class
	instanceVariableNames: ''!
!PlayableCharacterHeading class methodsFor: 'instance creation' stamp: 'HAW 10/11/2019 08:27:46'!
for: aCardinalPoint forwardWith: aForwardPoint  

	^self new initializeFor: aCardinalPoint forwardWith: aForwardPoint ! !

!classDefinition: #StageObject category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:08:17'!
Object subclass: #StageObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classDefinition: #StageObject category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:08:17'!
Object subclass: #StageObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classDefinition: #PortableObject category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:08:17'!
StageObject subclass: #PortableObject
	instanceVariableNames: 'name weight'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classDefinition: #PortableObject category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:08:17'!
StageObject subclass: #PortableObject
	instanceVariableNames: 'name weight'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!
!PortableObject methodsFor: 'testing' stamp: 'FRT 10/11/2020 17:54:20'!
doesItAddPoints

	self subclassResponsibility	! !
!PortableObject methodsFor: 'adding' stamp: 'HAW 10/18/2020 12:28:24'!
assertCanAddTo: aBackpack

	self subclassResponsibility	! !
!PortableObject methodsFor: 'accessing' stamp: 'FRT 10/11/2020 18:53:51'!
weight

	^ weight! !

!classDefinition: #NoPointsPortableObject category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:08:18'!
PortableObject subclass: #NoPointsPortableObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classDefinition: #NoPointsPortableObject category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:08:18'!
PortableObject subclass: #NoPointsPortableObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!
!NoPointsPortableObject methodsFor: 'initialization' stamp: 'HAW 10/14/2020 14:34:36'!
initializeNamed: aName weighing: aWeight
	
	name := aName.
	weight := aWeight.! !
!NoPointsPortableObject methodsFor: 'testing' stamp: 'FRT 10/11/2020 17:54:20' overrides: 50898145!
doesItAddPoints	

	^ false! !
!NoPointsPortableObject methodsFor: 'adding' stamp: 'HAW 10/18/2020 12:28:48' overrides: 50898149!
assertCanAddTo: aBackpack 
	
	^aBackpack assertCanAddNoPointsPortableObject: self! !

!classDefinition: 'NoPointsPortableObject class' category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:08:18'!
NoPointsPortableObject class
	instanceVariableNames: ''!

!classDefinition: 'NoPointsPortableObject class' category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:08:18'!
NoPointsPortableObject class
	instanceVariableNames: ''!
!NoPointsPortableObject class methodsFor: 'instance creation' stamp: 'HAW 10/14/2020 14:34:36'!
named: aName weighing: aWeight
	
	^ self new initializeNamed: aName weighing: aWeight. ! !

!classDefinition: #PointsPortableObject category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:08:18'!
PortableObject subclass: #PointsPortableObject
	instanceVariableNames: 'points'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classDefinition: #PointsPortableObject category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:08:18'!
PortableObject subclass: #PointsPortableObject
	instanceVariableNames: 'points'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!
!PointsPortableObject methodsFor: 'testing' stamp: 'FRT 10/11/2020 17:54:20' overrides: 50898145!
doesItAddPoints

	^ true! !
!PointsPortableObject methodsFor: 'initialization' stamp: 'HAW 10/14/2020 14:36:26'!
initializeNamed: aName weighing: aWeight worth: gamePoints
	
	name := aName.
	weight := aWeight.
	points := gamePoints.! !
!PointsPortableObject methodsFor: 'accessing' stamp: 'FRT 10/11/2020 19:06:57'!
points

	^ points! !
!PointsPortableObject methodsFor: 'adding' stamp: 'HAW 10/18/2020 12:29:07' overrides: 50898149!
assertCanAddTo: aBackpack 
	
	^aBackpack assertCanAddPointPortableObject: self! !

!classDefinition: 'PointsPortableObject class' category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:08:18'!
PointsPortableObject class
	instanceVariableNames: ''!

!classDefinition: 'PointsPortableObject class' category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:08:18'!
PointsPortableObject class
	instanceVariableNames: ''!
!PointsPortableObject class methodsFor: 'instance creation' stamp: 'HAW 10/14/2020 14:36:26'!
named: aName weighing: aWeight worth: gamePoints
	
	^ self new initializeNamed: aName weighing: aWeight worth: gamePoints.! !

!classDefinition: #BackpackTest category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:08:19'!
TestCase subclass: #BackpackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classDefinition: #BackpackTest category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:08:19'!
TestCase subclass: #BackpackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:29:03' prior: 50897374!
assertShouldAddAll: portableObjects withPoints: expectedTotalPoints

	| aBackpack |
	
	aBackpack := Backpack containingUpTo: self backpackWeight limitingPointsTo: 100.

	portableObjects do: [ :aPortableObject | aBackpack add: aPortableObject ].
	
	self assert: aBackpack size equals: portableObjects size.
	self assert: aBackpack totalWeight equals: (portableObjects sum: [ :aPortableObject | aPortableObject weight ]).
	self assert: aBackpack totalPoints equals: expectedTotalPoints.
! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:28:32' prior: 50897392!
assertShouldNotAddPortableObjectIfWeightExceeded: aPortableObject

	| aBackpack |
	aBackpack := Backpack containingUpTo: self backpackWeight limitingPointsTo: 100.

	self
		should: [ aBackpack add: aPortableObject ]
		raise: Error
		withMessageText: Backpack maxWeightExceededErrorDescription.
		
	self assert: aBackpack isEmpty. 
! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:28:32' prior: 50897405!
backpackWeight

	^ 42! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:28:41' prior: 50897408!
test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded

	self assertShouldNotAddPortableObjectIfWeightExceeded: 
		(NoPointsPortableObject named: 'help-wanted sign' weighing: self backpackWeight + 1)
! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:28:47' prior: 50897417!
test08ShouldNotAddPointsPortableObjectIfWeightExceeded

	self assertShouldNotAddPortableObjectIfWeightExceeded: 
		(PointsPortableObject named: 'left-handed hammer' weighing: self backpackWeight + 6 worth: 5) ! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:26:42' prior: 50897426!
test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity

	self 
		assertShouldAddAll: self twoPortableObjects
		withPoints: 5.
! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:27:27' prior: 50897433!
test10ShouldAddPortableObjectsIfWeightEqualsMaxWeightCapacity

	self 
		assertShouldAddAll:  self twoPortableObjects, {(PointsPortableObject named: 'letter' weighing: 1 worth: 5)}
		withPoints: 10.
! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:27:39' prior: 50897442!
twoPortableObjects

	^ {
		(PointsPortableObject named: 'left-handed hammer' weighing: 40 worth: 5).
		(NoPointsPortableObject named: 'help-wanted sign' weighing: 1) }! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04' prior: 50897450!
test01CanNotCreateBackpackWithZeroMaxWeight

	self
		should: [ Backpack containingUpTo: 0 limitingPointsTo: 100 ]
		raise: Error
		withMessageText: Backpack invalidWeightCapacityErrorDescription.
! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04' prior: 50897459!
test02CanNotCreateBackpackWithNegativeMaxWeight

	self
		should: [ Backpack containingUpTo: -1 limitingPointsTo: 100 ]
		raise: Error
		withMessageText: Backpack invalidWeightCapacityErrorDescription.! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04' prior: 50897468!
test03CanNotCreateBackpackWithZeroMaxPoints

	self
		should: [ Backpack containingUpTo: 10 limitingPointsTo: 0 ]
		raise: Error
		withMessageText: Backpack invalidPointsCapacityErrorDescription.
! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04' prior: 50897477!
test04CanNotCreateBackpackWithNegativeMaxPoints

	self
		should: [ Backpack containingUpTo: 10 limitingPointsTo: -1 ]
		raise: Error
		withMessageText: Backpack invalidPointsCapacityErrorDescription.! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04' prior: 50897486!
test05CanNotCreateBackpackWithNoIntegerMaxWeight

	self
		should: [ Backpack containingUpTo: 1.0 limitingPointsTo: 100 ]
		raise: Error
		withMessageText: Backpack weightCapacityMustBeIntegerErrorDescription.
! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04' prior: 50897495!
test06CanNotCreateBackpackWithNoIntegerMaxPoints

	self
		should: [ Backpack containingUpTo: 100 limitingPointsTo: 1.0 ]
		raise: Error
		withMessageText: Backpack pointsCapacityMustBeIntegerErrorDescription.
! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:49:20' prior: 50897504!
test11ShouldAddZeroWeightWhenEmpty

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	self assert: aBackpack totalWeight equals: 0.
	self assert: aBackpack isEmpty
! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:35:57' prior: 50897513!
test12ShouldAddWeightWhenAddingPortableObjects

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	aBackpack add: (PointsPortableObject named: 'left-handed hammer' weighing: 10 worth: 5).
	aBackpack add: (NoPointsPortableObject named: 'help-wanted sign' weighing: 10).
	
	self assert: aBackpack size equals: 2.
	self assert: aBackpack totalWeight equals: 20.

! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:49:31' prior: 50897528!
test13ShouldAddZeroPointsWhenEmpty

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	self assert: aBackpack totalPoints equals: 0.
	self assert: aBackpack isEmpty.
! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:35:57' prior: 50897537!
test14ShouldAddPointsWhenAddingPointsPortableObjects

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	aBackpack add: (PointsPortableObject named: 'left-handed hammer' weighing: 10 worth: 5).
	aBackpack add: (PointsPortableObject named: 'car key' weighing: 10 worth: 20).
	
	self assert: aBackpack size equals: 2.
	self assert: aBackpack totalPoints equals: 25.

! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:35:57' prior: 50897552!
test15ShouldNotAddPointsWhenAddingNoPointsPortableObjects

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	aBackpack add: (PointsPortableObject named: 'left-handed hammer' weighing: 10 worth: 5).
	aBackpack add: (NoPointsPortableObject named: 'help-wanted sign' weighing: 10).
	aBackpack add: (NoPointsPortableObject named: 'help-wanted sign' weighing: 10).
	
	self assert: aBackpack size equals: 3.
	self assert: aBackpack totalPoints equals: 5.

! !

!classDefinition: #PlayableCharacterTest category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:08:20'!
TestCase subclass: #PlayableCharacterTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classDefinition: #PlayableCharacterTest category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:08:20'!
TestCase subclass: #PlayableCharacterTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/9/2020 19:36:13' prior: 50897587!
test01_forwardWhenHeadingNorthIncrementsYCoordinate

	| playableCharacter |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 1@2 heading: #North .

	playableCharacter moveForward.

	self assert: (playableCharacter isAt: 1@3 heading: #North)! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/9/2020 19:36:13' prior: 50897599!
test02_backwardWhenHeadingNorthDecrementsYCoordinate

	| playableCharacter |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 1@2 heading: #North .

	playableCharacter moveBackward.

	self assert: (playableCharacter isAt: 1@1 heading: #North)! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/9/2020 19:36:13' prior: 50897611!
test03_rotateRightWhenHeadingNorthHeadsEast

	| playableCharacter |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 1@2 heading: #North .

	playableCharacter rotateRight.

	self assert: (playableCharacter isAt: 1@2 heading: #East)! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/9/2020 19:36:13' prior: 50897622!
test04_rotateLeftWhenHeadingNorthHeadsWest

	| playableCharacter |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 1@2 heading: #North .

	playableCharacter rotateLeft.

	self assert: (playableCharacter isAt: 1@2 heading: #West)! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/9/2020 19:36:13' prior: 50897633!
test05_movingWhenHeadingEastWorksAsExpected

	| playableCharacter |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 1@2 heading: #East .

	playableCharacter
		moveForward;
		moveForward;
		moveBackward;
		rotateRight;
		rotateLeft;
		rotateLeft.

	self assert: (playableCharacter isAt: 2@2 heading: #North)! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/9/2020 19:36:13' prior: 50897647!
test06_movingWhenHeadingSouthWorksAsExpected

	| playableCharacter |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 1@2 heading: #South .

	playableCharacter
		moveForward;
		moveForward;
		moveBackward;
		rotateRight;
		rotateLeft;
		rotateLeft.

	self assert: (playableCharacter isAt: 1@1 heading: #East)! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/9/2020 19:36:13' prior: 50897661!
test07_movingWhenHeadingWestWorksAsExpected

	| playableCharacter |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 2@2 heading: #West .

	playableCharacter
		moveForward;
		moveForward;
		moveBackward;
		rotateRight;
		rotateLeft;
		rotateLeft.

	self assert: (playableCharacter isAt: 1@2 heading: #South)! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/9/2020 19:36:13' prior: 50897675!
test08_canNotCreatePlayableCharacterWhenHeadingIsNotValid

	self
		should: [PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 1@2 heading: #X ]
		raise: Error
		withExceptionDo: [:anError |
			self assert: PlayableCharacter invalidCardinalPointErrorDescription equals: anError messageText ]! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/9/2020 19:43:14' prior: 50897688!
test09_canTakePortableObjects

	| playableCharacter paper |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 2@2 heading: #West .
	paper := NoPointsPortableObject named: 'Paper' weighing: 1.
	
	playableCharacter take: paper.
	
	self assert: (playableCharacter backpackIncludes: paper)! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/9/2020 19:47:21' prior: 50897701!
test10_canNotTakeMoreObjectsThanTheBackpackCanCarry

	| playableCharacter paper key |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 2@2 heading: #West .
	paper := NoPointsPortableObject named: 'Paper' weighing: 100.
	key := NoPointsPortableObject named: 'Key' weighing: 1.
	
	playableCharacter take: paper.
	self 
		should: [ playableCharacter take: key ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [:anError |
			self assert: Backpack maxWeightExceededErrorDescription equals: anError messageText.
			self assert: (playableCharacter backpackIncludes: paper).
			self deny: (playableCharacter backpackIncludes: key) ]
	
	! !
!PlayableCharacterTest methodsFor: 'as yet unclassified' stamp: 'HAW 12/9/2020 13:53:29' prior: 50897726!
defaultBackpack

	^ Backpack containingUpTo: 100 limitingPointsTo: 100 ! !

!classDefinition: #Backpack category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:08:20'!
Object subclass: #Backpack
	instanceVariableNames: 'weightCapacity gamePointsCapacity container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classDefinition: #Backpack category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:08:20'!
Object subclass: #Backpack
	instanceVariableNames: 'weightCapacity gamePointsCapacity container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!
!Backpack methodsFor: 'exceptions' stamp: 'FRT 10/8/2020 18:02:29' prior: 50897748!
signalMaxPointsExceeded

	self error: self class maxPointsExceededErrorDescription ! !
!Backpack methodsFor: 'exceptions' stamp: 'FRT 10/8/2020 18:02:47' prior: 50897753!
signalMaxWeightExceeded

	self error: self class maxWeightExceededErrorDescription ! !
!Backpack methodsFor: 'initialization' stamp: 'HAW 10/14/2020 14:31:56' prior: 50897758!
initializeContainingUpTo: aWeightCapacity limitingPointsTo: pointsCapacity

	weightCapacity := aWeightCapacity.
	gamePointsCapacity := pointsCapacity.
	
	container := OrderedCollection new.
	
	
	! !
!Backpack methodsFor: 'accessing' stamp: 'FRT 10/11/2020 19:14:47' prior: 50897767 overrides: 16880927!
size

	^ container size.! !
!Backpack methodsFor: 'accessing' stamp: 'HAW 10/18/2020 12:20:52' prior: 50897770!
totalPoints
		
	^(container select: [ :portableObject | portableObject doesItAddPoints ])	
		sum: [ :portableObject | portableObject points ]
		ifEmpty: [ 0 ]! !
!Backpack methodsFor: 'accessing' stamp: 'HAW 10/18/2020 12:20:20' prior: 50897778!
totalWeight
	
	^container 
		sum: [ :portableObject | portableObject weight ]
		ifEmpty: [ 0 ]
		! !
!Backpack methodsFor: 'assertions' stamp: 'FRT 10/12/2020 14:12:36' prior: 50897784!
assertPointsAdding: aPointsPortableObject

	(self totalPoints + aPointsPortableObject points) > gamePointsCapacity ifTrue: [ self signalMaxPointsExceeded ]! !
!Backpack methodsFor: 'assertions' stamp: 'FRT 10/15/2020 12:22:34' prior: 50897792!
assertWeightAdding: aPortableObject tolerating: aThreshold

	(self totalWeight + aPortableObject weight - weightCapacity) > aThreshold ifTrue: [ self signalMaxWeightExceeded ]! !
!Backpack methodsFor: 'adding' stamp: 'HAW 10/18/2020 12:28:24' prior: 50897800!
add: aPortableObject
	
	aPortableObject assertCanAddTo: self.
	
	container add: aPortableObject.
	! !
!Backpack methodsFor: 'testing' stamp: 'HAW 12/9/2020 19:44:17' prior: 50897806!
includes: aPortableObject 
	
	^container includes: aPortableObject ! !
!Backpack methodsFor: 'testing' stamp: 'FRT 10/11/2020 18:38:38' prior: 50897811!
isEmpty

	^ container isEmpty.! !
!Backpack methodsFor: 'adding - private' stamp: 'HAW 10/18/2020 12:28:48' prior: 50897815!
assertCanAddNoPointsPortableObject: aNoPointsPortableObject 
	
	self assertWeightAdding: aNoPointsPortableObject tolerating: 0.
	! !
!Backpack methodsFor: 'adding - private' stamp: 'HAW 10/18/2020 12:29:07' prior: 50897822!
assertCanAddPointPortableObject: aPointsPortableObject 
	
	self assertWeightAdding: aPointsPortableObject tolerating: 5.
	self assertPointsAdding: aPointsPortableObject.
	! !

!classDefinition: 'Backpack class' category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:08:21'!
Backpack class
	instanceVariableNames: ''!

!classDefinition: 'Backpack class' category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:08:21'!
Backpack class
	instanceVariableNames: ''!
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 18:27:33' prior: 50897840!
invalidPointsCapacityErrorDescription

	^ 'Points capacity must be positive'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 18:21:04' prior: 50897845!
invalidWeightCapacityErrorDescription

	^ 'Weight capacity must be positive'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/8/2020 17:36:29' prior: 50897850!
maxPointsExceededErrorDescription

	^ 'Maximum points has been exceeded'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/8/2020 17:36:17' prior: 50897855!
maxWeightExceededErrorDescription

	^ 'Maximum weight has been exceeded'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/8/2020 17:43:00' prior: 50897860!
pointsCapacityMustBeIntegerErrorDescription

	^ 'Points capacity must be integer'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/8/2020 17:42:48' prior: 50897866!
weightCapacityMustBeIntegerErrorDescription

	^ 'Weight capacity must be integer'! !
!Backpack class methodsFor: 'exceptions' stamp: 'FRT 10/11/2020 18:27:16' prior: 50897871!
signalInvalidPointsCapacity

	self error: self invalidPointsCapacityErrorDescription 
! !
!Backpack class methodsFor: 'exceptions' stamp: 'FRT 10/11/2020 18:21:51' prior: 50897877!
signalInvalidWeightCapacity

	self error: self invalidWeightCapacityErrorDescription 
! !
!Backpack class methodsFor: 'exceptions' stamp: 'FRT 10/8/2020 17:41:06' prior: 50897883!
signalPointsCapacityMustBeInteger

	self error: self pointsCapacityMustBeIntegerErrorDescription
! !
!Backpack class methodsFor: 'exceptions' stamp: 'FRT 10/8/2020 17:40:47' prior: 50897889!
signalWeightCapacityMustBeInteger

	self error: self weightCapacityMustBeIntegerErrorDescription
! !
!Backpack class methodsFor: 'instance creation' stamp: 'HAW 10/14/2020 14:31:56' prior: 50897895!
containingUpTo: aWeightCapacity limitingPointsTo: pointsCapacity

	aWeightCapacity strictlyPositive  ifFalse: [ self signalInvalidWeightCapacity ].
	pointsCapacity strictlyPositive ifFalse: [ self signalInvalidPointsCapacity ].
	
	aWeightCapacity isInteger ifFalse: [ self signalWeightCapacityMustBeInteger ].
	pointsCapacity isInteger ifFalse: [ self signalPointsCapacityMustBeInteger ].
	
	^ self new initializeContainingUpTo: aWeightCapacity limitingPointsTo: pointsCapacity.
! !

!classDefinition: #PlayableCharacter category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:08:22'!
Object subclass: #PlayableCharacter
	instanceVariableNames: 'position heading backpack name'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classDefinition: #PlayableCharacter category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:08:22'!
Object subclass: #PlayableCharacter
	instanceVariableNames: 'position heading backpack name'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!
!PlayableCharacter methodsFor: 'initialization' stamp: 'HAW 12/9/2020 19:35:22' prior: 50897931!
initializeNamed: aName using: aBackpack at: aPosition heading: aMarsRoverHeading 

	name := aName.
	backpack := aBackpack.
	position := aPosition.
	heading := aMarsRoverHeading! !
!PlayableCharacter methodsFor: 'testing' stamp: 'HAW 12/9/2020 19:43:44' prior: 50897939!
backpackIncludes: aPortableObject 
	
	^backpack includes: aPortableObject ! !
!PlayableCharacter methodsFor: 'testing' stamp: 'HAW 7/1/2018 14:25:05' prior: 50897944!
isAt: aPosition heading: aCardinalPoint

	^position = aPosition and: [ heading cardinalPoint = aCardinalPoint ]! !
!PlayableCharacter methodsFor: 'moving' stamp: 'HAW 10/11/2019 08:22:42' prior: 50897950!
moveBackward
	
	position := position - heading forwardPoint ! !
!PlayableCharacter methodsFor: 'moving' stamp: 'HAW 10/11/2019 08:21:58' prior: 50897955!
moveForward
	
	position := position + heading forwardPoint! !
!PlayableCharacter methodsFor: 'rotating' stamp: 'HAW 10/11/2019 08:31:55' prior: 50897960!
rotateLeft
	
	heading := heading leftHeading! !
!PlayableCharacter methodsFor: 'rotating' stamp: 'HAW 10/11/2019 08:32:04' prior: 50897964!
rotateRight
	
	heading := heading rightHeading! !
!PlayableCharacter methodsFor: 'taking objects' stamp: 'HAW 12/9/2020 19:28:57' prior: 50897969!
take: aPortableObject

	backpack add: aPortableObject.! !

!classDefinition: 'PlayableCharacter class' category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:08:23'!
PlayableCharacter class
	instanceVariableNames: 'headings'!

!classDefinition: 'PlayableCharacter class' category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:08:23'!
PlayableCharacter class
	instanceVariableNames: 'headings'!
!PlayableCharacter class methodsFor: 'heading' stamp: 'HAW 7/2/2018 16:28:16' prior: 50897985!
headingFor: aCardinalPoint
	
	^headings at: aCardinalPoint ifAbsent: [ self error: self invalidCardinalPointErrorDescription ]! !
!PlayableCharacter class methodsFor: 'heading' stamp: 'HAW 7/2/2018 16:26:14' prior: 50897992!
invalidCardinalPointErrorDescription
	
	^'Invalid cardinal point'! !
!PlayableCharacter class methodsFor: 'instance creation' stamp: 'HAW 12/9/2020 19:36:13' prior: 50897997!
named: aName using: aBackpack at: aPosition heading: aCardinalPoint 
	
	| newHeading |

	newHeading := self headingFor: aCardinalPoint.
	
	^self new initializeNamed: aName using: aBackpack at: aPosition heading: newHeading ! !
!PlayableCharacter class methodsFor: 'initialization' stamp: 'HAW 10/11/2019 08:37:25' prior: 50898007!
forHeadingAt: aCardinalPoint leftIs: aLeftCardinalPoint rightIs: aRightCardinalPoint
	
	(headings at: aCardinalPoint) leftHeading: (headings at: aLeftCardinalPoint) rightHeading: (headings at: aRightCardinalPoint).
	! !
!PlayableCharacter class methodsFor: 'initialization' stamp: 'HAW 7/2/2018 15:27:41' prior: 50898018 overrides: 16883149!
initialize

	self initializeHeadings! !
!PlayableCharacter class methodsFor: 'initialization' stamp: 'HAW 12/9/2020 19:31:43' prior: 50898022!
initializeHeadings

	headings := Dictionary new.
	
	(OrderedCollection 
		with: (PlayableCharacterHeading for: #North forwardWith: 0@1 )	
		with: (PlayableCharacterHeading for: #East forwardWith: 1@0 )
		with: (PlayableCharacterHeading for: #South forwardWith: 0@-1 )
		with: (PlayableCharacterHeading for: #West forwardWith: -1@0 ))
			do: [ :heading | headings at: heading cardinalPoint put: heading ].
	
	self 
		forHeadingAt: #North leftIs: #West rightIs: #East;
		forHeadingAt: #South leftIs: #East rightIs: #West;
		forHeadingAt: #East leftIs: #North rightIs: #South;
		forHeadingAt: #West leftIs: #South rightIs: #North.
	! !

!classDefinition: #PlayableCharacterHeading category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:08:23'!
Object subclass: #PlayableCharacterHeading
	instanceVariableNames: 'cardinalPoint forwardPoint rightHeading leftHeading'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classDefinition: #PlayableCharacterHeading category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:08:23'!
Object subclass: #PlayableCharacterHeading
	instanceVariableNames: 'cardinalPoint forwardPoint rightHeading leftHeading'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!
!PlayableCharacterHeading methodsFor: 'accessing' stamp: 'HAW 7/2/2018 15:29:44' prior: 50898065!
cardinalPoint
	
	^cardinalPoint! !
!PlayableCharacterHeading methodsFor: 'accessing' stamp: 'HAW 7/2/2018 15:30:39' prior: 50898069!
forwardPoint
	
	^forwardPoint! !
!PlayableCharacterHeading methodsFor: 'accessing' stamp: 'HAW 10/11/2019 08:31:33' prior: 50898073!
leftHeading
	
	^leftHeading! !
!PlayableCharacterHeading methodsFor: 'accessing' stamp: 'HAW 10/11/2019 08:31:27' prior: 50898077!
rightHeading
	
	^rightHeading! !
!PlayableCharacterHeading methodsFor: 'initialization' stamp: 'HAW 10/11/2019 08:27:25' prior: 50898081!
initializeFor: aCardinalPoint forwardWith: aForwardPoint  
	
	cardinalPoint := aCardinalPoint.
	forwardPoint := aForwardPoint.
! !
!PlayableCharacterHeading methodsFor: 'initialization' stamp: 'HAW 10/11/2019 08:31:33' prior: 50898088!
leftHeading: aLeftHeading rightHeading: aRightHeading
 
	leftHeading := aLeftHeading.
	rightHeading := aRightHeading ! !

!classDefinition: 'PlayableCharacterHeading class' category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:08:23'!
PlayableCharacterHeading class
	instanceVariableNames: ''!

!classDefinition: 'PlayableCharacterHeading class' category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:08:23'!
PlayableCharacterHeading class
	instanceVariableNames: ''!
!PlayableCharacterHeading class methodsFor: 'instance creation' stamp: 'HAW 10/11/2019 08:27:46' prior: 50898107!
for: aCardinalPoint forwardWith: aForwardPoint  

	^self new initializeFor: aCardinalPoint forwardWith: aForwardPoint ! !

!classDefinition: #StageObject category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:08:24'!
Object subclass: #StageObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classDefinition: #StageObject category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:08:24'!
Object subclass: #StageObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classDefinition: #PortableObject category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:08:24'!
StageObject subclass: #PortableObject
	instanceVariableNames: 'name weight'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classDefinition: #PortableObject category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:08:24'!
StageObject subclass: #PortableObject
	instanceVariableNames: 'name weight'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!
!PortableObject methodsFor: 'testing' stamp: 'FRT 10/11/2020 17:54:20' prior: 50898145!
doesItAddPoints

	self subclassResponsibility	! !
!PortableObject methodsFor: 'adding' stamp: 'HAW 10/18/2020 12:28:24' prior: 50898149!
assertCanAddTo: aBackpack

	self subclassResponsibility	! !
!PortableObject methodsFor: 'accessing' stamp: 'FRT 10/11/2020 18:53:51' prior: 50898154!
weight

	^ weight! !

!classDefinition: #NoPointsPortableObject category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:08:24'!
PortableObject subclass: #NoPointsPortableObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classDefinition: #NoPointsPortableObject category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:08:24'!
PortableObject subclass: #NoPointsPortableObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!
!NoPointsPortableObject methodsFor: 'initialization' stamp: 'HAW 10/14/2020 14:34:36' prior: 50898175!
initializeNamed: aName weighing: aWeight
	
	name := aName.
	weight := aWeight.! !
!NoPointsPortableObject methodsFor: 'testing' stamp: 'FRT 10/11/2020 17:54:20' prior: 50898181 overrides: 50899093!
doesItAddPoints	

	^ false! !
!NoPointsPortableObject methodsFor: 'adding' stamp: 'HAW 10/18/2020 12:28:48' prior: 50898186 overrides: 50899098!
assertCanAddTo: aBackpack 
	
	^aBackpack assertCanAddNoPointsPortableObject: self! !

!classDefinition: 'NoPointsPortableObject class' category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:08:24'!
NoPointsPortableObject class
	instanceVariableNames: ''!

!classDefinition: 'NoPointsPortableObject class' category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:08:24'!
NoPointsPortableObject class
	instanceVariableNames: ''!
!NoPointsPortableObject class methodsFor: 'instance creation' stamp: 'HAW 10/14/2020 14:34:36' prior: 50898203!
named: aName weighing: aWeight
	
	^ self new initializeNamed: aName weighing: aWeight. ! !

!classDefinition: #PointsPortableObject category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:08:24'!
PortableObject subclass: #PointsPortableObject
	instanceVariableNames: 'points'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classDefinition: #PointsPortableObject category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:08:24'!
PortableObject subclass: #PointsPortableObject
	instanceVariableNames: 'points'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!
!PointsPortableObject methodsFor: 'testing' stamp: 'FRT 10/11/2020 17:54:20' prior: 50898227 overrides: 50899093!
doesItAddPoints

	^ true! !
!PointsPortableObject methodsFor: 'initialization' stamp: 'HAW 10/14/2020 14:36:26' prior: 50898231!
initializeNamed: aName weighing: aWeight worth: gamePoints
	
	name := aName.
	weight := aWeight.
	points := gamePoints.! !
!PointsPortableObject methodsFor: 'accessing' stamp: 'FRT 10/11/2020 19:06:57' prior: 50898238!
points

	^ points! !
!PointsPortableObject methodsFor: 'adding' stamp: 'HAW 10/18/2020 12:29:07' prior: 50898242 overrides: 50899098!
assertCanAddTo: aBackpack 
	
	^aBackpack assertCanAddPointPortableObject: self! !

!classDefinition: 'PointsPortableObject class' category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:08:25'!
PointsPortableObject class
	instanceVariableNames: ''!

!classDefinition: 'PointsPortableObject class' category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:08:25'!
PointsPortableObject class
	instanceVariableNames: ''!
!PointsPortableObject class methodsFor: 'instance creation' stamp: 'HAW 10/14/2020 14:36:26' prior: 50898259!
named: aName weighing: aWeight worth: gamePoints
	
	^ self new initializeNamed: aName weighing: aWeight worth: gamePoints.! !

!classRemoval: #PointsPortableObject stamp: 'FG 12/17/2020 21:08:25'!
PortableObject subclass: #PointsPortableObject
	instanceVariableNames: 'points'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classRemoval: #NoPointsPortableObject stamp: 'FG 12/17/2020 21:08:25'!
PortableObject subclass: #NoPointsPortableObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classRemoval: #PortableObject stamp: 'FG 12/17/2020 21:08:26'!
StageObject subclass: #PortableObject
	instanceVariableNames: 'name weight'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classRemoval: #StageObject stamp: 'FG 12/17/2020 21:08:26'!
Object subclass: #StageObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classRemoval: #PlayableCharacterHeading stamp: 'FG 12/17/2020 21:08:26'!
Object subclass: #PlayableCharacterHeading
	instanceVariableNames: 'cardinalPoint forwardPoint rightHeading leftHeading'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classRemoval: #PlayableCharacter stamp: 'FG 12/17/2020 21:08:27'!
Object subclass: #PlayableCharacter
	instanceVariableNames: 'position heading backpack name'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classRemoval: #Backpack stamp: 'FG 12/17/2020 21:08:27'!
Object subclass: #Backpack
	instanceVariableNames: 'weightCapacity gamePointsCapacity container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classRemoval: #PlayableCharacterTest stamp: 'FG 12/17/2020 21:08:28'!
TestCase subclass: #PlayableCharacterTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classRemoval: #BackpackTest stamp: 'FG 12/17/2020 21:08:28'!
TestCase subclass: #BackpackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classDefinition: #BackpackTest category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:08:28'!
TestCase subclass: #BackpackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classDefinition: #BackpackTest category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:08:28'!
TestCase subclass: #BackpackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:29:03'!
assertShouldAddAll: portableObjects withPoints: expectedTotalPoints

	| aBackpack |
	
	aBackpack := Backpack containingUpTo: self backpackWeight limitingPointsTo: 100.

	portableObjects do: [ :aPortableObject | aBackpack add: aPortableObject ].
	
	self assert: aBackpack size equals: portableObjects size.
	self assert: aBackpack totalWeight equals: (portableObjects sum: [ :aPortableObject | aPortableObject weight ]).
	self assert: aBackpack totalPoints equals: expectedTotalPoints.
! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:28:32'!
assertShouldNotAddPortableObjectIfWeightExceeded: aPortableObject

	| aBackpack |
	aBackpack := Backpack containingUpTo: self backpackWeight limitingPointsTo: 100.

	self
		should: [ aBackpack add: aPortableObject ]
		raise: Error
		withMessageText: Backpack maxWeightExceededErrorDescription.
		
	self assert: aBackpack isEmpty. 
! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:28:32'!
backpackWeight

	^ 42! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:28:41'!
test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded

	self assertShouldNotAddPortableObjectIfWeightExceeded: 
		(NoPointsPortableObject named: 'help-wanted sign' weighing: self backpackWeight + 1)
! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:28:47'!
test08ShouldNotAddPointsPortableObjectIfWeightExceeded

	self assertShouldNotAddPortableObjectIfWeightExceeded: 
		(PointsPortableObject named: 'left-handed hammer' weighing: self backpackWeight + 6 worth: 5) ! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:26:42'!
test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity

	self 
		assertShouldAddAll: self twoPortableObjects
		withPoints: 5.
! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:27:27'!
test10ShouldAddPortableObjectsIfWeightEqualsMaxWeightCapacity

	self 
		assertShouldAddAll:  self twoPortableObjects, {(PointsPortableObject named: 'letter' weighing: 1 worth: 5)}
		withPoints: 10.
! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:27:39'!
twoPortableObjects

	^ {
		(PointsPortableObject named: 'left-handed hammer' weighing: 40 worth: 5).
		(NoPointsPortableObject named: 'help-wanted sign' weighing: 1) }! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04'!
test01CanNotCreateBackpackWithZeroMaxWeight

	self
		should: [ Backpack containingUpTo: 0 limitingPointsTo: 100 ]
		raise: Error
		withMessageText: Backpack invalidWeightCapacityErrorDescription.
! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04'!
test02CanNotCreateBackpackWithNegativeMaxWeight

	self
		should: [ Backpack containingUpTo: -1 limitingPointsTo: 100 ]
		raise: Error
		withMessageText: Backpack invalidWeightCapacityErrorDescription.! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04'!
test03CanNotCreateBackpackWithZeroMaxPoints

	self
		should: [ Backpack containingUpTo: 10 limitingPointsTo: 0 ]
		raise: Error
		withMessageText: Backpack invalidPointsCapacityErrorDescription.
! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04'!
test04CanNotCreateBackpackWithNegativeMaxPoints

	self
		should: [ Backpack containingUpTo: 10 limitingPointsTo: -1 ]
		raise: Error
		withMessageText: Backpack invalidPointsCapacityErrorDescription.! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04'!
test05CanNotCreateBackpackWithNoIntegerMaxWeight

	self
		should: [ Backpack containingUpTo: 1.0 limitingPointsTo: 100 ]
		raise: Error
		withMessageText: Backpack weightCapacityMustBeIntegerErrorDescription.
! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04'!
test06CanNotCreateBackpackWithNoIntegerMaxPoints

	self
		should: [ Backpack containingUpTo: 100 limitingPointsTo: 1.0 ]
		raise: Error
		withMessageText: Backpack pointsCapacityMustBeIntegerErrorDescription.
! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:49:20'!
test11ShouldAddZeroWeightWhenEmpty

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	self assert: aBackpack totalWeight equals: 0.
	self assert: aBackpack isEmpty
! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:35:57'!
test12ShouldAddWeightWhenAddingPortableObjects

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	aBackpack add: (PointsPortableObject named: 'left-handed hammer' weighing: 10 worth: 5).
	aBackpack add: (NoPointsPortableObject named: 'help-wanted sign' weighing: 10).
	
	self assert: aBackpack size equals: 2.
	self assert: aBackpack totalWeight equals: 20.

! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:49:31'!
test13ShouldAddZeroPointsWhenEmpty

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	self assert: aBackpack totalPoints equals: 0.
	self assert: aBackpack isEmpty.
! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:35:57'!
test14ShouldAddPointsWhenAddingPointsPortableObjects

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	aBackpack add: (PointsPortableObject named: 'left-handed hammer' weighing: 10 worth: 5).
	aBackpack add: (PointsPortableObject named: 'car key' weighing: 10 worth: 20).
	
	self assert: aBackpack size equals: 2.
	self assert: aBackpack totalPoints equals: 25.

! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:35:57'!
test15ShouldNotAddPointsWhenAddingNoPointsPortableObjects

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	aBackpack add: (PointsPortableObject named: 'left-handed hammer' weighing: 10 worth: 5).
	aBackpack add: (NoPointsPortableObject named: 'help-wanted sign' weighing: 10).
	aBackpack add: (NoPointsPortableObject named: 'help-wanted sign' weighing: 10).
	
	self assert: aBackpack size equals: 3.
	self assert: aBackpack totalPoints equals: 5.

! !

!classDefinition: #PlayableCharacterTest category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:08:30'!
TestCase subclass: #PlayableCharacterTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classDefinition: #PlayableCharacterTest category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:08:30'!
TestCase subclass: #PlayableCharacterTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:05:24'!
paper

	^ NoPointsPortableObject named: 'Paper' weighing: 100! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:00:16'!
test01_forwardWhenHeadingNorthIncrementsYCoordinate

	| playableCharacter |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 1@2 heading: #North in: self defaultRoom .

	playableCharacter moveForward.

	self assert: (playableCharacter isAt: 1@3 heading: #North)! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:00:16'!
test02_backwardWhenHeadingNorthDecrementsYCoordinate

	| playableCharacter |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 1@2 heading: #North in: self defaultRoom .

	playableCharacter moveBackward.

	self assert: (playableCharacter isAt: 1@1 heading: #North)! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:00:16'!
test03_rotateRightWhenHeadingNorthHeadsEast

	| playableCharacter |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 1@2 heading: #North in: self defaultRoom .

	playableCharacter rotateRight.

	self assert: (playableCharacter isAt: 1@2 heading: #East)! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:00:16'!
test04_rotateLeftWhenHeadingNorthHeadsWest

	| playableCharacter |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 1@2 heading: #North in: self defaultRoom .

	playableCharacter rotateLeft.

	self assert: (playableCharacter isAt: 1@2 heading: #West)! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:00:16'!
test05_movingWhenHeadingEastWorksAsExpected

	| playableCharacter |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 1@2 heading: #East in: self defaultRoom .

	playableCharacter
		moveForward;
		moveForward;
		moveBackward;
		rotateRight;
		rotateLeft;
		rotateLeft.

	self assert: (playableCharacter isAt: 2@2 heading: #North)! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:00:16'!
test06_movingWhenHeadingSouthWorksAsExpected

	| playableCharacter |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 1@2 heading: #South in: self defaultRoom .

	playableCharacter
		moveForward;
		moveForward;
		moveBackward;
		rotateRight;
		rotateLeft;
		rotateLeft.

	self assert: (playableCharacter isAt: 1@1 heading: #East)! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:00:16'!
test07_movingWhenHeadingWestWorksAsExpected

	| playableCharacter |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 2@2 heading: #West in: self defaultRoom .

	playableCharacter
		moveForward;
		moveForward;
		moveBackward;
		rotateRight;
		rotateLeft;
		rotateLeft.

	self assert: (playableCharacter isAt: 1@2 heading: #South)! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:00:16'!
test08_canNotCreatePlayableCharacterWhenHeadingIsNotValid

	self
		should: [PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 1@2 heading: #X in: self defaultRoom ]
		raise: Error
		withExceptionDo: [:anError |
			self assert: PlayableCharacter invalidCardinalPointErrorDescription equals: anError messageText ]! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:00:16'!
test09_canTakePortableObjects

	| playableCharacter paper |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 2@2 heading: #West in: self defaultRoom .
	paper := NoPointsPortableObject named: 'Paper' weighing: 1.
	
	playableCharacter take: paper.
	
	self assert: (playableCharacter backpackIncludes: paper)! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:05:24'!
test10_canNotTakeMoreObjectsThanTheBackpackCanCarry

	| playableCharacter paper key |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 2@2 heading: #West in: self defaultRoom .
	paper := self paper.
	key := NoPointsPortableObject named: 'Key' weighing: 1.
	
	playableCharacter take: paper.
	self 
		should: [ playableCharacter take: key ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [:anError |
			self assert: Backpack maxWeightExceededErrorDescription equals: anError messageText.
			self assert: (playableCharacter backpackIncludes: paper).
			self deny: (playableCharacter backpackIncludes: key) ]
	
	! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:43:14'!
test11_CanNotCreateCharacterWithInvalidPosition

	| room |

	room := self defaultRoom.
	self 
		should: [ PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 1@-1 heading: #West in: room ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [:anError |
			self assert: Room invalidPositionErrorDescription equals: anError messageText.
			self assert: room isEmpty ]! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:09:38'!
test12_CanNotCreateCharacterOnNotEmptyPosition

	| room paperPosition paper |

	room := self defaultRoom.
	paperPosition := 1@1.
	paper := self paper.
	room at: paperPosition put: paper.
	
	self 
		should: [ PlayableCharacter named: 'Luigi' using: self defaultBackpack at: paperPosition heading: #West in: room ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [:anError |
			self assert: Room positionIsNotEmptyErrorDescription equals: anError messageText.
			self assert: paper equals: (room at: paperPosition)]! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:16:13'!
test13_moveForwardModifiesPositionInRoom

	| room  player |

	room := self defaultRoom.
	
	player := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 1@1 heading: #West in: room.
	player moveForward.
	
	self assert: (player isAt: 0@1 heading: #West).
	self assert: player equals: (room at: 0@1).
	self assert: (room isEmptyAt: 1@1).! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:17:08'!
test14_moveBackwardModifiesPositionInRoom

	| room  player |

	room := self defaultRoom.
	
	player := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 1@1 heading: #West in: room.
	player moveBackward.
	
	self assert: (player isAt: 2@1 heading: #West).
	self assert: player equals: (room at: 2@1).
	self assert: (room isEmptyAt: 1@1).! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:43:14'!
test15_canNotMoveToInvalidPosition

	| room  player |

	room := self defaultRoom.
	
	player := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 0@1 heading: #West in: room.
	
	self 
		should: [ player moveForward ]
		raise: Error 
		withExceptionDo: [:anError |
			self assert: Room invalidPositionErrorDescription equals: anError messageText.
			self assert: player equals: (room at: 0@1). ]
			
! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:44:47'!
test16_canNotTakeFromAnEmptyOrInvalidPosition

	| room  player |

	room := self defaultRoom.
	
	player := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 0@0 heading: #North in: room.
	
	self 
		should: [ player take ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [:anError |
			self assert: Room objectNotInRoomErrorDescription equals: anError messageText.
			self assert: player backpackIsEmpty ]
			
! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:46:11'!
test17_canTakeAPortableObject

	| room  player paper |

	room := self defaultRoom.
	paper := self paper.
	room at: 0@1 put: paper.
	player := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 0@0 heading: #North in: room.
	
	player take.
	
	self assert: (room isEmptyAt: 0@1).
	self assert: (player backpackIncludes: paper).! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:50:54'!
test18_emptyNonPortableObjectDoesNotAddObjectsToBackpack

	| room  player box |

	room := self defaultRoom.
	box := NonPortableObject named: 'Box'.
	room at: 0@1 put: box.
	player := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 0@0 heading: #North in: room.
	
	player take.
	
	self assert: box equals: (room at: 0@1).
	self assert: player backpackIsEmpty.! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:56:03'!
test19_portableInNonPortableObjectIsAddedToBackpack

	| room  player box paper |

	room := self defaultRoom.
	paper := self paper.
	box := NonPortableObject named: 'Box' withAll: { paper }.
	room at: 0@1 put: box.
	player := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 0@0 heading: #North in: room.
	
	player take.
	
	self assert: box equals: (room at: 0@1).
	self assert: box isEmpty.
	self assert: (player backpackIncludes: paper).! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 19:19:55'!
test20_takeFromNonPortableObjectsIsRecursive

	| room  player box paper anotherPaper |

	room := self defaultRoom.
	paper := self paper.
	anotherPaper := self paper.
	box := NonPortableObject named: 'Box' withAll: { paper. anotherPaper }.
	room at: 0@1 put: box.
	player := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 0@0 heading: #North in: room.
	
	self 
		should: [ player take ]
		raise: Error
		withMessageText: Backpack maxWeightExceededErrorDescription.
	
	self assert: box equals: (room at: 0@1).
	self deny: box isEmpty.
	self assert: (box includes: anotherPaper).
	self assert: (player backpackIncludes: paper).
	self assert: 1 equals: player backpackSize! !
!PlayableCharacterTest methodsFor: 'defaults' stamp: 'HAW 12/9/2020 13:53:29'!
defaultBackpack

	^ Backpack containingUpTo: 100 limitingPointsTo: 100 ! !
!PlayableCharacterTest methodsFor: 'defaults' stamp: 'HAW 12/14/2020 18:02:57'!
defaultRoom
	
	^Room ofWidth: 10 andHeight: 10! !

!classDefinition: #RoomTest category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:08:32'!
TestCase subclass: #RoomTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classDefinition: #RoomTest category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:08:32'!
TestCase subclass: #RoomTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!
!RoomTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 17:20:02'!
test01_WidthMustBeStrictlyPositive

	self assertInvalidSizeWith: 0 and: 1
	! !
!RoomTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 17:20:13'!
test02_HeightMustBeStrictlyPositive

	self assertInvalidSizeWith: 1 and: 0
	! !
!RoomTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 17:20:25'!
test03_WidthMustBeInteger

	self assertInvalidSizeWith: 1.1 and: 1
	! !
!RoomTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 17:20:36'!
test04_HeightMustBeInteger

	self assertInvalidSizeWith: 1 and: 1.1
		! !
!RoomTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 17:39:43'!
test05_CanNotPutAStageObjectWithXLessThanCero

	self assertCanNotPutAt: -1@1
		! !
!RoomTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 17:39:49'!
test06_CanNotPutAStageObjectWithXGreaterOrEqualToWidth

	self assertCanNotPutAt: 10@1! !
!RoomTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 17:39:56'!
test07_CanNotPutAStageObjectWithANonIntegerX

	self assertCanNotPutAt: 1.1@1! !
!RoomTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 17:40:04'!
test08_CanNotPutAStageObjectWithYLessThanCero

	self assertCanNotPutAt: 1@-1
		! !
!RoomTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 17:40:25'!
test09_CanNotPutAStageObjectWithYGreaterOrEqualToHeight

	self assertCanNotPutAt: 1@10! !
!RoomTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 17:41:13'!
test10_CanNotPutAStageObjectWithANonIntegerY

	self assertCanNotPutAt: 1@1.1! !
!RoomTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 17:46:46'!
test11_StageObjectsAreKeept

	| room |
	
	room := Room ofWidth: 10 andHeight: 10.
	
	room at: 0@0 put: self paper.
	
	self deny: room isEmpty.! !
!RoomTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:30:22'!
test12_canNotGetPositionOfNonPutObject

	| room |
	
	room := Room ofWidth: 10 andHeight: 10.
	self
		should: [ room positionOf: self paper ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Room objectNotInRoomErrorDescription! !
!RoomTest methodsFor: 'test objects' stamp: 'HAW 12/14/2020 17:36:15'!
paper

	^ PointsPortableObject named: 'paper' weighing: 1 worth: 1! !
!RoomTest methodsFor: 'assertions' stamp: 'HAW 12/14/2020 18:43:14'!
assertCanNotPutAt: aPosition

	| room width |
	
	width := 10.
	room := Room ofWidth: width andHeight: 10.
	
	self 
		should: [ room at: aPosition put: self paper ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: Room invalidPositionErrorDescription equals: anError messageText.
			self assert: room isEmpty ].! !
!RoomTest methodsFor: 'assertions' stamp: 'HAW 12/14/2020 17:19:50'!
assertInvalidSizeWith: aWitdh and: aHeight

	self 
		should: [ Room ofWidth: aWitdh andHeight: aHeight ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Room invalidSizeErrorDescription! !

!classDefinition: #Backpack category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:08:33'!
Object subclass: #Backpack
	instanceVariableNames: 'weightCapacity gamePointsCapacity container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classDefinition: #Backpack category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:08:33'!
Object subclass: #Backpack
	instanceVariableNames: 'weightCapacity gamePointsCapacity container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!
!Backpack methodsFor: 'exceptions' stamp: 'FRT 10/8/2020 18:02:29'!
signalMaxPointsExceeded

	self error: self class maxPointsExceededErrorDescription ! !
!Backpack methodsFor: 'exceptions' stamp: 'FRT 10/8/2020 18:02:47'!
signalMaxWeightExceeded

	self error: self class maxWeightExceededErrorDescription ! !
!Backpack methodsFor: 'initialization' stamp: 'HAW 10/14/2020 14:31:56'!
initializeContainingUpTo: aWeightCapacity limitingPointsTo: pointsCapacity

	weightCapacity := aWeightCapacity.
	gamePointsCapacity := pointsCapacity.
	
	container := OrderedCollection new.
	
	
	! !
!Backpack methodsFor: 'accessing' stamp: 'FRT 10/11/2020 19:14:47' overrides: 16880927!
size

	^ container size.! !
!Backpack methodsFor: 'accessing' stamp: 'HAW 10/18/2020 12:20:52'!
totalPoints
		
	^(container select: [ :portableObject | portableObject doesItAddPoints ])	
		sum: [ :portableObject | portableObject points ]
		ifEmpty: [ 0 ]! !
!Backpack methodsFor: 'accessing' stamp: 'HAW 10/18/2020 12:20:20'!
totalWeight
	
	^container 
		sum: [ :portableObject | portableObject weight ]
		ifEmpty: [ 0 ]
		! !
!Backpack methodsFor: 'assertions' stamp: 'FRT 10/12/2020 14:12:36'!
assertPointsAdding: aPointsPortableObject

	(self totalPoints + aPointsPortableObject points) > gamePointsCapacity ifTrue: [ self signalMaxPointsExceeded ]! !
!Backpack methodsFor: 'assertions' stamp: 'FRT 10/15/2020 12:22:34'!
assertWeightAdding: aPortableObject tolerating: aThreshold

	(self totalWeight + aPortableObject weight - weightCapacity) > aThreshold ifTrue: [ self signalMaxWeightExceeded ]! !
!Backpack methodsFor: 'adding' stamp: 'HAW 10/18/2020 12:28:24'!
add: aPortableObject
	
	aPortableObject assertCanAddTo: self.
	
	container add: aPortableObject.
	! !
!Backpack methodsFor: 'testing' stamp: 'HAW 12/9/2020 19:44:17'!
includes: aPortableObject 
	
	^container includes: aPortableObject ! !
!Backpack methodsFor: 'testing' stamp: 'FRT 10/11/2020 18:38:38'!
isEmpty

	^ container isEmpty.! !
!Backpack methodsFor: 'adding - private' stamp: 'HAW 10/18/2020 12:28:48'!
assertCanAddNoPointsPortableObject: aNoPointsPortableObject 
	
	self assertWeightAdding: aNoPointsPortableObject tolerating: 0.
	! !
!Backpack methodsFor: 'adding - private' stamp: 'HAW 10/18/2020 12:29:07'!
assertCanAddPointPortableObject: aPointsPortableObject 
	
	self assertWeightAdding: aPointsPortableObject tolerating: 5.
	self assertPointsAdding: aPointsPortableObject.
	! !

!classDefinition: 'Backpack class' category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:08:34'!
Backpack class
	instanceVariableNames: ''!

!classDefinition: 'Backpack class' category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:08:34'!
Backpack class
	instanceVariableNames: ''!
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 18:27:33'!
invalidPointsCapacityErrorDescription

	^ 'Points capacity must be positive'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 18:21:04'!
invalidWeightCapacityErrorDescription

	^ 'Weight capacity must be positive'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/8/2020 17:36:29'!
maxPointsExceededErrorDescription

	^ 'Maximum points has been exceeded'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/8/2020 17:36:17'!
maxWeightExceededErrorDescription

	^ 'Maximum weight has been exceeded'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/8/2020 17:43:00'!
pointsCapacityMustBeIntegerErrorDescription

	^ 'Points capacity must be integer'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/8/2020 17:42:48'!
weightCapacityMustBeIntegerErrorDescription

	^ 'Weight capacity must be integer'! !
!Backpack class methodsFor: 'exceptions' stamp: 'FRT 10/11/2020 18:27:16'!
signalInvalidPointsCapacity

	self error: self invalidPointsCapacityErrorDescription 
! !
!Backpack class methodsFor: 'exceptions' stamp: 'FRT 10/11/2020 18:21:51'!
signalInvalidWeightCapacity

	self error: self invalidWeightCapacityErrorDescription 
! !
!Backpack class methodsFor: 'exceptions' stamp: 'FRT 10/8/2020 17:41:06'!
signalPointsCapacityMustBeInteger

	self error: self pointsCapacityMustBeIntegerErrorDescription
! !
!Backpack class methodsFor: 'exceptions' stamp: 'FRT 10/8/2020 17:40:47'!
signalWeightCapacityMustBeInteger

	self error: self weightCapacityMustBeIntegerErrorDescription
! !
!Backpack class methodsFor: 'instance creation' stamp: 'HAW 10/14/2020 14:31:56'!
containingUpTo: aWeightCapacity limitingPointsTo: pointsCapacity

	aWeightCapacity strictlyPositive  ifFalse: [ self signalInvalidWeightCapacity ].
	pointsCapacity strictlyPositive ifFalse: [ self signalInvalidPointsCapacity ].
	
	aWeightCapacity isInteger ifFalse: [ self signalWeightCapacityMustBeInteger ].
	pointsCapacity isInteger ifFalse: [ self signalPointsCapacityMustBeInteger ].
	
	^ self new initializeContainingUpTo: aWeightCapacity limitingPointsTo: pointsCapacity.
! !

!classDefinition: #PlayableCharacter category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:08:35'!
Object subclass: #PlayableCharacter
	instanceVariableNames: 'heading backpack name room'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classDefinition: #PlayableCharacter category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:08:35'!
Object subclass: #PlayableCharacter
	instanceVariableNames: 'heading backpack name room'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!
!PlayableCharacter methodsFor: 'initialization' stamp: 'HAW 12/14/2020 18:27:11'!
initializeNamed: aName using: aBackpack at: aPosition heading: aMarsRoverHeading in: aRoom  

	name := aName.
	backpack := aBackpack.
	heading := aMarsRoverHeading.
	room := aRoom.
	room at: aPosition put: self! !
!PlayableCharacter methodsFor: 'testing' stamp: 'HAW 12/14/2020 18:25:08'!
isAt: aPosition heading: aCardinalPoint

	^self position = aPosition and: [ heading cardinalPoint = aCardinalPoint ]! !
!PlayableCharacter methodsFor: 'moving' stamp: 'HAW 12/14/2020 19:09:28'!
forwardPosition

	^ self position + heading forwardPoint! !
!PlayableCharacter methodsFor: 'moving' stamp: 'HAW 12/14/2020 18:25:13'!
moveBackward
	
	self moveTo: self position - heading forwardPoint.
	! !
!PlayableCharacter methodsFor: 'moving' stamp: 'HAW 12/14/2020 19:09:36'!
moveForward
	
	self moveTo: self forwardPosition ! !
!PlayableCharacter methodsFor: 'moving' stamp: 'HAW 12/14/2020 18:27:14'!
moveTo: aNewPosition
	
	room moveFrom: self position to: aNewPosition.
		! !
!PlayableCharacter methodsFor: 'moving' stamp: 'HAW 12/14/2020 18:25:48'!
position

	^room positionOf: self! !
!PlayableCharacter methodsFor: 'rotating' stamp: 'HAW 10/11/2019 08:31:55'!
rotateLeft
	
	heading := heading leftHeading! !
!PlayableCharacter methodsFor: 'rotating' stamp: 'HAW 10/11/2019 08:32:04'!
rotateRight
	
	heading := heading rightHeading! !
!PlayableCharacter methodsFor: 'taking objects' stamp: 'HAW 12/14/2020 19:09:28'!
take
	
	| toTake |
	
	toTake := room at: self forwardPosition.
	toTake takenBy: self 
	! !
!PlayableCharacter methodsFor: 'taking objects' stamp: 'HAW 12/9/2020 19:28:57'!
take: aPortableObject

	backpack add: aPortableObject.! !
!PlayableCharacter methodsFor: 'taking - private' stamp: 'HAW 12/14/2020 18:58:05'!
takeNonPortableObject: aNonPortableObject 
	
	aNonPortableObject putAllTo: self! !
!PlayableCharacter methodsFor: 'taking - private' stamp: 'HAW 12/14/2020 19:09:51'!
takePortableObject: aPortableObject 
	
	self take: aPortableObject.
	room removeAt: self forwardPosition ! !
!PlayableCharacter methodsFor: 'backpack' stamp: 'HAW 12/9/2020 19:43:44'!
backpackIncludes: aPortableObject 
	
	^backpack includes: aPortableObject ! !
!PlayableCharacter methodsFor: 'backpack' stamp: 'HAW 12/14/2020 18:42:40'!
backpackIsEmpty
	
	^backpack isEmpty ! !
!PlayableCharacter methodsFor: 'backpack' stamp: 'HAW 12/14/2020 19:09:03'!
backpackSize
	
	^backpack size! !

!classDefinition: 'PlayableCharacter class' category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:08:36'!
PlayableCharacter class
	instanceVariableNames: 'headings'!

!classDefinition: 'PlayableCharacter class' category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:08:36'!
PlayableCharacter class
	instanceVariableNames: 'headings'!
!PlayableCharacter class methodsFor: 'heading' stamp: 'HAW 7/2/2018 16:28:16'!
headingFor: aCardinalPoint
	
	^headings at: aCardinalPoint ifAbsent: [ self error: self invalidCardinalPointErrorDescription ]! !
!PlayableCharacter class methodsFor: 'heading' stamp: 'HAW 7/2/2018 16:26:14'!
invalidCardinalPointErrorDescription
	
	^'Invalid cardinal point'! !
!PlayableCharacter class methodsFor: 'instance creation' stamp: 'HAW 12/14/2020 18:01:51'!
named: aName using: aBackpack at: aPosition heading: aCardinalPoint in: aRoom  
	
	| newHeading |

	newHeading := self headingFor: aCardinalPoint.
	
	^self new initializeNamed: aName using: aBackpack at: aPosition heading: newHeading in: aRoom ! !
!PlayableCharacter class methodsFor: 'initialization' stamp: 'HAW 10/11/2019 08:37:25'!
forHeadingAt: aCardinalPoint leftIs: aLeftCardinalPoint rightIs: aRightCardinalPoint
	
	(headings at: aCardinalPoint) leftHeading: (headings at: aLeftCardinalPoint) rightHeading: (headings at: aRightCardinalPoint).
	! !
!PlayableCharacter class methodsFor: 'initialization' stamp: 'HAW 7/2/2018 15:27:41' overrides: 16883149!
initialize

	self initializeHeadings! !
!PlayableCharacter class methodsFor: 'initialization' stamp: 'HAW 12/9/2020 19:31:43'!
initializeHeadings

	headings := Dictionary new.
	
	(OrderedCollection 
		with: (PlayableCharacterHeading for: #North forwardWith: 0@1 )	
		with: (PlayableCharacterHeading for: #East forwardWith: 1@0 )
		with: (PlayableCharacterHeading for: #South forwardWith: 0@-1 )
		with: (PlayableCharacterHeading for: #West forwardWith: -1@0 ))
			do: [ :heading | headings at: heading cardinalPoint put: heading ].
	
	self 
		forHeadingAt: #North leftIs: #West rightIs: #East;
		forHeadingAt: #South leftIs: #East rightIs: #West;
		forHeadingAt: #East leftIs: #North rightIs: #South;
		forHeadingAt: #West leftIs: #South rightIs: #North.
	! !

!classDefinition: #PlayableCharacterHeading category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:08:37'!
Object subclass: #PlayableCharacterHeading
	instanceVariableNames: 'cardinalPoint forwardPoint rightHeading leftHeading'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classDefinition: #PlayableCharacterHeading category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:08:37'!
Object subclass: #PlayableCharacterHeading
	instanceVariableNames: 'cardinalPoint forwardPoint rightHeading leftHeading'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!
!PlayableCharacterHeading methodsFor: 'accessing' stamp: 'HAW 7/2/2018 15:29:44'!
cardinalPoint
	
	^cardinalPoint! !
!PlayableCharacterHeading methodsFor: 'accessing' stamp: 'HAW 7/2/2018 15:30:39'!
forwardPoint
	
	^forwardPoint! !
!PlayableCharacterHeading methodsFor: 'accessing' stamp: 'HAW 10/11/2019 08:31:33'!
leftHeading
	
	^leftHeading! !
!PlayableCharacterHeading methodsFor: 'accessing' stamp: 'HAW 10/11/2019 08:31:27'!
rightHeading
	
	^rightHeading! !
!PlayableCharacterHeading methodsFor: 'initialization' stamp: 'HAW 10/11/2019 08:27:25'!
initializeFor: aCardinalPoint forwardWith: aForwardPoint  
	
	cardinalPoint := aCardinalPoint.
	forwardPoint := aForwardPoint.
! !
!PlayableCharacterHeading methodsFor: 'initialization' stamp: 'HAW 10/11/2019 08:31:33'!
leftHeading: aLeftHeading rightHeading: aRightHeading
 
	leftHeading := aLeftHeading.
	rightHeading := aRightHeading ! !

!classDefinition: 'PlayableCharacterHeading class' category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:08:37'!
PlayableCharacterHeading class
	instanceVariableNames: ''!

!classDefinition: 'PlayableCharacterHeading class' category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:08:37'!
PlayableCharacterHeading class
	instanceVariableNames: ''!
!PlayableCharacterHeading class methodsFor: 'instance creation' stamp: 'HAW 10/11/2019 08:27:46'!
for: aCardinalPoint forwardWith: aForwardPoint  

	^self new initializeFor: aCardinalPoint forwardWith: aForwardPoint ! !

!classDefinition: #Room category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:08:37'!
Object subclass: #Room
	instanceVariableNames: 'width height contents'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classDefinition: #Room category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:08:37'!
Object subclass: #Room
	instanceVariableNames: 'width height contents'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!
!Room methodsFor: 'initialization' stamp: 'HAW 12/14/2020 17:47:16'!
initializeOfWidth: aWidth andHeight: aHeight 
	
	width := aWidth.
	height := aHeight.
	contents := Dictionary new.! !
!Room methodsFor: 'contents' stamp: 'HAW 12/14/2020 18:42:28' overrides: 16880774!
at: aPosition

	^contents at: aPosition ifAbsent: [self error: self class objectNotInRoomErrorDescription ]! !
!Room methodsFor: 'contents' stamp: 'HAW 12/14/2020 18:07:24' overrides: 16880792!
at: aPosition put: aStageObject

	self assertPositionIsValid: aPosition.
	self assertIsEmpty: aPosition.
	
	contents at: aPosition put: aStageObject ! !
!Room methodsFor: 'contents' stamp: 'HAW 12/14/2020 18:23:18'!
moveFrom: aSourcePosition to: aTargetPosition

	| toMove |
	
	toMove := self at: aSourcePosition.
	self at: aTargetPosition put: toMove.
	contents removeKey: aSourcePosition.
	! !
!Room methodsFor: 'contents' stamp: 'HAW 12/14/2020 18:30:58'!
positionOf: anObject

	contents keysAndValuesDo: [ :aPosition :aPlacedObject |
		aPlacedObject = anObject ifTrue: [ ^aPosition  ]].
	
	self error: self class objectNotInRoomErrorDescription ! !
!Room methodsFor: 'contents' stamp: 'HAW 12/14/2020 18:47:43'!
removeAt: aPosition

	^contents removeKey: aPosition ! !
!Room methodsFor: 'assertions' stamp: 'HAW 12/14/2020 18:09:38'!
assertIsEmpty: aPosition

	^(self isEmptyAt: aPosition) ifFalse: [ self error: self class positionIsNotEmptyErrorDescription ]! !
!Room methodsFor: 'assertions' stamp: 'HAW 12/14/2020 18:43:14'!
assertPositionComponentIsValid: aPositionComponent withLimit: limit 

	^ (aPositionComponent < 0 or: [aPositionComponent >= limit or: [ aPositionComponent isInteger not]]) 
		ifTrue: [self error: self class invalidPositionErrorDescription ]! !
!Room methodsFor: 'assertions' stamp: 'HAW 12/14/2020 17:44:04'!
assertPositionIsValid: aPosition

	self assertPositionComponentIsValid: aPosition x withLimit: width.
	self assertPositionComponentIsValid: aPosition y withLimit: height.
	! !
!Room methodsFor: 'testing' stamp: 'HAW 12/14/2020 17:47:56'!
isEmpty
	
	^contents isEmpty ! !
!Room methodsFor: 'testing' stamp: 'HAW 12/14/2020 18:08:47'!
isEmptyAt: aPosition

	^ (contents includesKey: aPosition) not! !

!classDefinition: 'Room class' category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:08:38'!
Room class
	instanceVariableNames: ''!

!classDefinition: 'Room class' category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:08:38'!
Room class
	instanceVariableNames: ''!
!Room class methodsFor: 'error descriptions' stamp: 'HAW 12/14/2020 18:43:14'!
invalidPositionErrorDescription
	
	^'Invalid position'! !
!Room class methodsFor: 'error descriptions' stamp: 'HAW 12/14/2020 17:16:22'!
invalidSizeErrorDescription
	
	^'Invalid size'! !
!Room class methodsFor: 'error descriptions' stamp: 'HAW 12/14/2020 18:30:38'!
objectNotInRoomErrorDescription
	
	^'Object not in room'! !
!Room class methodsFor: 'error descriptions' stamp: 'HAW 12/14/2020 18:09:38'!
positionIsNotEmptyErrorDescription
	
	^'Position not empty'! !
!Room class methodsFor: 'instance creation' stamp: 'HAW 12/14/2020 19:27:12'!
ofWidth: aWidth andHeight: aHeight 
	
	self assertIsValidWitdth: aWidth andHeight: aHeight .
	
	^self new initializeOfWidth: aWidth andHeight: aHeight ! !
!Room class methodsFor: 'assertions' stamp: 'HAW 12/14/2020 17:22:01'!
assertIsValidSizeComponent: aSizeComponent

	^ (aSizeComponent < 1 or: [aSizeComponent isInteger not ]) ifTrue: [self error: self invalidSizeErrorDescription ]! !
!Room class methodsFor: 'assertions' stamp: 'HAW 12/14/2020 19:27:12'!
assertIsValidWitdth: aWidth andHeight: aHeight

	self assertIsValidSizeComponent: aWidth.
	self assertIsValidSizeComponent: aHeight! !

!classDefinition: #StageObject category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:08:39'!
Object subclass: #StageObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classDefinition: #StageObject category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:08:39'!
Object subclass: #StageObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!
!StageObject methodsFor: 'taken' stamp: 'HAW 12/14/2020 19:30:06'!
putAllTo: aPlayableCharacter

	self subclassResponsibility 
	! !
!StageObject methodsFor: 'taken' stamp: 'HAW 12/14/2020 19:30:18'!
takenBy: aPlayableCharacter 

	self subclassResponsibility 
	! !

!classDefinition: #NonPortableObject category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:08:39'!
StageObject subclass: #NonPortableObject
	instanceVariableNames: 'name stageObjects'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classDefinition: #NonPortableObject category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:08:39'!
StageObject subclass: #NonPortableObject
	instanceVariableNames: 'name stageObjects'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!
!NonPortableObject methodsFor: 'initialization' stamp: 'HAW 12/14/2020 19:00:02'!
initializeNamed: aName withAll: aCollectionOfStageObjects 
	
	name := aName.
	stageObjects := aCollectionOfStageObjects asOrderedCollection .! !
!NonPortableObject methodsFor: 'taken' stamp: 'HAW 12/14/2020 19:24:52' overrides: 50900527!
putAllTo: aPlayableCharacter 
	
	| toRemove |
	
	toRemove := OrderedCollection new.
	[ stageObjects do: [ :aStageObject | (aStageObject putAllTo: aPlayableCharacter) ifTrue: [ toRemove add: aStageObject ]]]
		ensure: [ stageObjects removeAll: toRemove ].
	
	^false! !
!NonPortableObject methodsFor: 'taken' stamp: 'HAW 12/14/2020 18:53:21' overrides: 50900532!
takenBy: aPlayableCharacter 
	
	aPlayableCharacter takeNonPortableObject: self! !
!NonPortableObject methodsFor: 'testing' stamp: 'HAW 12/14/2020 19:08:45'!
includes: aStageObject

	^stageObjects includes: aStageObject ! !
!NonPortableObject methodsFor: 'testing' stamp: 'HAW 12/14/2020 18:57:19'!
isEmpty
	
	^stageObjects isEmpty ! !

!classDefinition: 'NonPortableObject class' category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:08:40'!
NonPortableObject class
	instanceVariableNames: ''!

!classDefinition: 'NonPortableObject class' category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:08:40'!
NonPortableObject class
	instanceVariableNames: ''!
!NonPortableObject class methodsFor: 'instance creation' stamp: 'HAW 12/14/2020 19:00:27'!
named: aName 
	
	^self named: aName withAll: #()! !
!NonPortableObject class methodsFor: 'instance creation' stamp: 'HAW 12/14/2020 18:56:40'!
named: aName withAll: aCollectionOfStageObjects 
	
	^self new initializeNamed: aName withAll: aCollectionOfStageObjects ! !

!classDefinition: #PortableObject category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:08:40'!
StageObject subclass: #PortableObject
	instanceVariableNames: 'name weight'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classDefinition: #PortableObject category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:08:40'!
StageObject subclass: #PortableObject
	instanceVariableNames: 'name weight'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!
!PortableObject methodsFor: 'testing' stamp: 'FRT 10/11/2020 17:54:20'!
doesItAddPoints

	self subclassResponsibility	! !
!PortableObject methodsFor: 'adding' stamp: 'HAW 10/18/2020 12:28:24'!
assertCanAddTo: aBackpack

	self subclassResponsibility	! !
!PortableObject methodsFor: 'accessing' stamp: 'FRT 10/11/2020 18:53:51'!
weight

	^ weight! !
!PortableObject methodsFor: 'taken' stamp: 'HAW 12/14/2020 19:15:12' overrides: 50900527!
putAllTo: aPlayableCharacter

	aPlayableCharacter take: self.
	^true! !
!PortableObject methodsFor: 'taken' stamp: 'HAW 12/14/2020 18:53:53' overrides: 50900532!
takenBy: aPlayableCharacter 
	
	aPlayableCharacter takePortableObject: self! !

!classDefinition: #NoPointsPortableObject category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:08:40'!
PortableObject subclass: #NoPointsPortableObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classDefinition: #NoPointsPortableObject category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:08:40'!
PortableObject subclass: #NoPointsPortableObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!
!NoPointsPortableObject methodsFor: 'initialization' stamp: 'HAW 10/14/2020 14:34:36'!
initializeNamed: aName weighing: aWeight
	
	name := aName.
	weight := aWeight.! !
!NoPointsPortableObject methodsFor: 'testing' stamp: 'FRT 10/11/2020 17:54:20' overrides: 50900627!
doesItAddPoints	

	^ false! !
!NoPointsPortableObject methodsFor: 'adding' stamp: 'HAW 10/18/2020 12:28:48' overrides: 50900631!
assertCanAddTo: aBackpack 
	
	^aBackpack assertCanAddNoPointsPortableObject: self! !

!classDefinition: 'NoPointsPortableObject class' category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:08:41'!
NoPointsPortableObject class
	instanceVariableNames: ''!

!classDefinition: 'NoPointsPortableObject class' category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:08:41'!
NoPointsPortableObject class
	instanceVariableNames: ''!
!NoPointsPortableObject class methodsFor: 'instance creation' stamp: 'HAW 10/14/2020 14:34:36'!
named: aName weighing: aWeight
	
	^ self new initializeNamed: aName weighing: aWeight. ! !

!classDefinition: #PointsPortableObject category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:08:41'!
PortableObject subclass: #PointsPortableObject
	instanceVariableNames: 'points'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classDefinition: #PointsPortableObject category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:08:41'!
PortableObject subclass: #PointsPortableObject
	instanceVariableNames: 'points'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!
!PointsPortableObject methodsFor: 'testing' stamp: 'FRT 10/11/2020 17:54:20' overrides: 50900627!
doesItAddPoints

	^ true! !
!PointsPortableObject methodsFor: 'initialization' stamp: 'HAW 10/14/2020 14:36:26'!
initializeNamed: aName weighing: aWeight worth: gamePoints
	
	name := aName.
	weight := aWeight.
	points := gamePoints.! !
!PointsPortableObject methodsFor: 'accessing' stamp: 'FRT 10/11/2020 19:06:57'!
points

	^ points! !
!PointsPortableObject methodsFor: 'adding' stamp: 'HAW 10/18/2020 12:29:07' overrides: 50900631!
assertCanAddTo: aBackpack 
	
	^aBackpack assertCanAddPointPortableObject: self! !

!classDefinition: 'PointsPortableObject class' category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:08:41'!
PointsPortableObject class
	instanceVariableNames: ''!

!classDefinition: 'PointsPortableObject class' category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:08:41'!
PointsPortableObject class
	instanceVariableNames: ''!
!PointsPortableObject class methodsFor: 'instance creation' stamp: 'HAW 10/14/2020 14:36:26'!
named: aName weighing: aWeight worth: gamePoints
	
	^ self new initializeNamed: aName weighing: aWeight worth: gamePoints.! !

!classRemoval: #PointsPortableObject stamp: 'FG 12/17/2020 21:08:42'!
PortableObject subclass: #PointsPortableObject
	instanceVariableNames: 'points'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classRemoval: #NoPointsPortableObject stamp: 'FG 12/17/2020 21:08:42'!
PortableObject subclass: #NoPointsPortableObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classRemoval: #PortableObject stamp: 'FG 12/17/2020 21:08:43'!
StageObject subclass: #PortableObject
	instanceVariableNames: 'name weight'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classRemoval: #NonPortableObject stamp: 'FG 12/17/2020 21:08:43'!
StageObject subclass: #NonPortableObject
	instanceVariableNames: 'name stageObjects'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classRemoval: #StageObject stamp: 'FG 12/17/2020 21:08:43'!
Object subclass: #StageObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classRemoval: #Room stamp: 'FG 12/17/2020 21:08:44'!
Object subclass: #Room
	instanceVariableNames: 'width height contents'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classRemoval: #PlayableCharacterHeading stamp: 'FG 12/17/2020 21:08:44'!
Object subclass: #PlayableCharacterHeading
	instanceVariableNames: 'cardinalPoint forwardPoint rightHeading leftHeading'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classRemoval: #PlayableCharacter stamp: 'FG 12/17/2020 21:08:44'!
Object subclass: #PlayableCharacter
	instanceVariableNames: 'heading backpack name room'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classRemoval: #Backpack stamp: 'FG 12/17/2020 21:08:45'!
Object subclass: #Backpack
	instanceVariableNames: 'weightCapacity gamePointsCapacity container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classRemoval: #RoomTest stamp: 'FG 12/17/2020 21:08:45'!
TestCase subclass: #RoomTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classRemoval: #PlayableCharacterTest stamp: 'FG 12/17/2020 21:08:46'!
TestCase subclass: #PlayableCharacterTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classRemoval: #BackpackTest stamp: 'FG 12/17/2020 21:08:46'!
TestCase subclass: #BackpackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classDefinition: #BackpackTest category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:08:46'!
TestCase subclass: #BackpackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!

!classDefinition: #BackpackTest category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:08:46'!
TestCase subclass: #BackpackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:29:03'!
assertShouldAddAll: portableObjects withPoints: expectedTotalPoints

	| aBackpack |
	
	aBackpack := Backpack containingUpTo: self backpackWeight limitingPointsTo: 100.

	portableObjects do: [ :aPortableObject | aBackpack add: aPortableObject ].
	
	self assert: aBackpack size equals: portableObjects size.
	self assert: aBackpack totalWeight equals: (portableObjects sum: [ :aPortableObject | aPortableObject weight ]).
	self assert: aBackpack totalPoints equals: expectedTotalPoints.
! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:28:32'!
assertShouldNotAddPortableObjectIfWeightExceeded: aPortableObject

	| aBackpack |
	aBackpack := Backpack containingUpTo: self backpackWeight limitingPointsTo: 100.

	self
		should: [ aBackpack add: aPortableObject ]
		raise: Error
		withMessageText: Backpack maxWeightExceededErrorDescription.
		
	self assert: aBackpack isEmpty. 
! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:28:32'!
backpackWeight

	^ 42! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:28:41'!
test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded

	self assertShouldNotAddPortableObjectIfWeightExceeded: 
		(NoPointsPortableObject named: 'help-wanted sign' weighing: self backpackWeight + 1)
! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:28:47'!
test08ShouldNotAddPointsPortableObjectIfWeightExceeded

	self assertShouldNotAddPortableObjectIfWeightExceeded: 
		(PointsPortableObject named: 'left-handed hammer' weighing: self backpackWeight + 6 worth: 5) ! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:26:42'!
test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity

	self 
		assertShouldAddAll: self twoPortableObjects
		withPoints: 5.
! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:27:27'!
test10ShouldAddPortableObjectsIfWeightEqualsMaxWeightCapacity

	self 
		assertShouldAddAll:  self twoPortableObjects, {(PointsPortableObject named: 'letter' weighing: 1 worth: 5)}
		withPoints: 10.
! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:27:39'!
twoPortableObjects

	^ {
		(PointsPortableObject named: 'left-handed hammer' weighing: 40 worth: 5).
		(NoPointsPortableObject named: 'help-wanted sign' weighing: 1) }! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04'!
test01CanNotCreateBackpackWithZeroMaxWeight

	self
		should: [ Backpack containingUpTo: 0 limitingPointsTo: 100 ]
		raise: Error
		withMessageText: Backpack invalidWeightCapacityErrorDescription.
! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04'!
test02CanNotCreateBackpackWithNegativeMaxWeight

	self
		should: [ Backpack containingUpTo: -1 limitingPointsTo: 100 ]
		raise: Error
		withMessageText: Backpack invalidWeightCapacityErrorDescription.! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04'!
test03CanNotCreateBackpackWithZeroMaxPoints

	self
		should: [ Backpack containingUpTo: 10 limitingPointsTo: 0 ]
		raise: Error
		withMessageText: Backpack invalidPointsCapacityErrorDescription.
! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04'!
test04CanNotCreateBackpackWithNegativeMaxPoints

	self
		should: [ Backpack containingUpTo: 10 limitingPointsTo: -1 ]
		raise: Error
		withMessageText: Backpack invalidPointsCapacityErrorDescription.! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04'!
test05CanNotCreateBackpackWithNoIntegerMaxWeight

	self
		should: [ Backpack containingUpTo: 1.0 limitingPointsTo: 100 ]
		raise: Error
		withMessageText: Backpack weightCapacityMustBeIntegerErrorDescription.
! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04'!
test06CanNotCreateBackpackWithNoIntegerMaxPoints

	self
		should: [ Backpack containingUpTo: 100 limitingPointsTo: 1.0 ]
		raise: Error
		withMessageText: Backpack pointsCapacityMustBeIntegerErrorDescription.
! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:49:20'!
test11ShouldAddZeroWeightWhenEmpty

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	self assert: aBackpack totalWeight equals: 0.
	self assert: aBackpack isEmpty
! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:35:57'!
test12ShouldAddWeightWhenAddingPortableObjects

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	aBackpack add: (PointsPortableObject named: 'left-handed hammer' weighing: 10 worth: 5).
	aBackpack add: (NoPointsPortableObject named: 'help-wanted sign' weighing: 10).
	
	self assert: aBackpack size equals: 2.
	self assert: aBackpack totalWeight equals: 20.

! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:49:31'!
test13ShouldAddZeroPointsWhenEmpty

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	self assert: aBackpack totalPoints equals: 0.
	self assert: aBackpack isEmpty.
! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:35:57'!
test14ShouldAddPointsWhenAddingPointsPortableObjects

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	aBackpack add: (PointsPortableObject named: 'left-handed hammer' weighing: 10 worth: 5).
	aBackpack add: (PointsPortableObject named: 'car key' weighing: 10 worth: 20).
	
	self assert: aBackpack size equals: 2.
	self assert: aBackpack totalPoints equals: 25.

! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:35:57'!
test15ShouldNotAddPointsWhenAddingNoPointsPortableObjects

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	aBackpack add: (PointsPortableObject named: 'left-handed hammer' weighing: 10 worth: 5).
	aBackpack add: (NoPointsPortableObject named: 'help-wanted sign' weighing: 10).
	aBackpack add: (NoPointsPortableObject named: 'help-wanted sign' weighing: 10).
	
	self assert: aBackpack size equals: 3.
	self assert: aBackpack totalPoints equals: 5.

! !

!classDefinition: #PlayableCharacterTest category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:08:48'!
TestCase subclass: #PlayableCharacterTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!

!classDefinition: #PlayableCharacterTest category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:08:48'!
TestCase subclass: #PlayableCharacterTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:05:24'!
paper

	^ NoPointsPortableObject named: 'Paper' weighing: 100! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:00:16'!
test01_forwardWhenHeadingNorthIncrementsYCoordinate

	| playableCharacter |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 1@2 heading: #North in: self defaultRoom .

	playableCharacter moveForward.

	self assert: (playableCharacter isAt: 1@3 heading: #North)! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:00:16'!
test02_backwardWhenHeadingNorthDecrementsYCoordinate

	| playableCharacter |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 1@2 heading: #North in: self defaultRoom .

	playableCharacter moveBackward.

	self assert: (playableCharacter isAt: 1@1 heading: #North)! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:00:16'!
test03_rotateRightWhenHeadingNorthHeadsEast

	| playableCharacter |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 1@2 heading: #North in: self defaultRoom .

	playableCharacter rotateRight.

	self assert: (playableCharacter isAt: 1@2 heading: #East)! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:00:16'!
test04_rotateLeftWhenHeadingNorthHeadsWest

	| playableCharacter |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 1@2 heading: #North in: self defaultRoom .

	playableCharacter rotateLeft.

	self assert: (playableCharacter isAt: 1@2 heading: #West)! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:00:16'!
test05_movingWhenHeadingEastWorksAsExpected

	| playableCharacter |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 1@2 heading: #East in: self defaultRoom .

	playableCharacter
		moveForward;
		moveForward;
		moveBackward;
		rotateRight;
		rotateLeft;
		rotateLeft.

	self assert: (playableCharacter isAt: 2@2 heading: #North)! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:00:16'!
test06_movingWhenHeadingSouthWorksAsExpected

	| playableCharacter |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 1@2 heading: #South in: self defaultRoom .

	playableCharacter
		moveForward;
		moveForward;
		moveBackward;
		rotateRight;
		rotateLeft;
		rotateLeft.

	self assert: (playableCharacter isAt: 1@1 heading: #East)! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:00:16'!
test07_movingWhenHeadingWestWorksAsExpected

	| playableCharacter |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 2@2 heading: #West in: self defaultRoom .

	playableCharacter
		moveForward;
		moveForward;
		moveBackward;
		rotateRight;
		rotateLeft;
		rotateLeft.

	self assert: (playableCharacter isAt: 1@2 heading: #South)! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:00:16'!
test08_canNotCreatePlayableCharacterWhenHeadingIsNotValid

	self
		should: [PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 1@2 heading: #X in: self defaultRoom ]
		raise: Error
		withExceptionDo: [:anError |
			self assert: PlayableCharacter invalidCardinalPointErrorDescription equals: anError messageText ]! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:00:16'!
test09_canTakePortableObjects

	| playableCharacter paper |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 2@2 heading: #West in: self defaultRoom .
	paper := NoPointsPortableObject named: 'Paper' weighing: 1.
	
	playableCharacter take: paper.
	
	self assert: (playableCharacter backpackIncludes: paper)! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:05:24'!
test10_canNotTakeMoreObjectsThanTheBackpackCanCarry

	| playableCharacter paper key |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 2@2 heading: #West in: self defaultRoom .
	paper := self paper.
	key := NoPointsPortableObject named: 'Key' weighing: 1.
	
	playableCharacter take: paper.
	self 
		should: [ playableCharacter take: key ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [:anError |
			self assert: Backpack maxWeightExceededErrorDescription equals: anError messageText.
			self assert: (playableCharacter backpackIncludes: paper).
			self deny: (playableCharacter backpackIncludes: key) ]
	
	! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:43:14'!
test11_CanNotCreateCharacterWithInvalidPosition

	| room |

	room := self defaultRoom.
	self 
		should: [ PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 1@-1 heading: #West in: room ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [:anError |
			self assert: Room invalidPositionErrorDescription equals: anError messageText.
			self assert: room isEmpty ]! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:09:38'!
test12_CanNotCreateCharacterOnNotEmptyPosition

	| room paperPosition paper |

	room := self defaultRoom.
	paperPosition := 1@1.
	paper := self paper.
	room at: paperPosition put: paper.
	
	self 
		should: [ PlayableCharacter named: 'Luigi' using: self defaultBackpack at: paperPosition heading: #West in: room ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [:anError |
			self assert: Room positionIsNotEmptyErrorDescription equals: anError messageText.
			self assert: paper equals: (room at: paperPosition)]! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:16:13'!
test13_moveForwardModifiesPositionInRoom

	| room  player |

	room := self defaultRoom.
	
	player := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 1@1 heading: #West in: room.
	player moveForward.
	
	self assert: (player isAt: 0@1 heading: #West).
	self assert: player equals: (room at: 0@1).
	self assert: (room isEmptyAt: 1@1).! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:17:08'!
test14_moveBackwardModifiesPositionInRoom

	| room  player |

	room := self defaultRoom.
	
	player := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 1@1 heading: #West in: room.
	player moveBackward.
	
	self assert: (player isAt: 2@1 heading: #West).
	self assert: player equals: (room at: 2@1).
	self assert: (room isEmptyAt: 1@1).! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:43:14'!
test15_canNotMoveToInvalidPosition

	| room  player |

	room := self defaultRoom.
	
	player := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 0@1 heading: #West in: room.
	
	self 
		should: [ player moveForward ]
		raise: Error 
		withExceptionDo: [:anError |
			self assert: Room invalidPositionErrorDescription equals: anError messageText.
			self assert: player equals: (room at: 0@1). ]
			
! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:44:47'!
test16_canNotTakeFromAnEmptyOrInvalidPosition

	| room  player |

	room := self defaultRoom.
	
	player := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 0@0 heading: #North in: room.
	
	self 
		should: [ player take ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [:anError |
			self assert: Room objectNotInRoomErrorDescription equals: anError messageText.
			self assert: player backpackIsEmpty ]
			
! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:46:11'!
test17_canTakeAPortableObject

	| room  player paper |

	room := self defaultRoom.
	paper := self paper.
	room at: 0@1 put: paper.
	player := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 0@0 heading: #North in: room.
	
	player take.
	
	self assert: (room isEmptyAt: 0@1).
	self assert: (player backpackIncludes: paper).! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:50:54'!
test18_emptyNonPortableObjectDoesNotAddObjectsToBackpack

	| room  player box |

	room := self defaultRoom.
	box := NonPortableObject named: 'Box'.
	room at: 0@1 put: box.
	player := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 0@0 heading: #North in: room.
	
	player take.
	
	self assert: box equals: (room at: 0@1).
	self assert: player backpackIsEmpty.! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:56:03'!
test19_portableInNonPortableObjectIsAddedToBackpack

	| room  player box paper |

	room := self defaultRoom.
	paper := self paper.
	box := NonPortableObject named: 'Box' withAll: { paper }.
	room at: 0@1 put: box.
	player := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 0@0 heading: #North in: room.
	
	player take.
	
	self assert: box equals: (room at: 0@1).
	self assert: box isEmpty.
	self assert: (player backpackIncludes: paper).! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 19:19:55'!
test20_takeFromNonPortableObjectsIsRecursive

	| room  player box paper anotherPaper |

	room := self defaultRoom.
	paper := self paper.
	anotherPaper := self paper.
	box := NonPortableObject named: 'Box' withAll: { paper. anotherPaper }.
	room at: 0@1 put: box.
	player := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 0@0 heading: #North in: room.
	
	self 
		should: [ player take ]
		raise: Error
		withMessageText: Backpack maxWeightExceededErrorDescription.
	
	self assert: box equals: (room at: 0@1).
	self deny: box isEmpty.
	self assert: (box includes: anotherPaper).
	self assert: (player backpackIncludes: paper).
	self assert: 1 equals: player backpackSize! !
!PlayableCharacterTest methodsFor: 'defaults' stamp: 'HAW 12/9/2020 13:53:29'!
defaultBackpack

	^ Backpack containingUpTo: 100 limitingPointsTo: 100 ! !
!PlayableCharacterTest methodsFor: 'defaults' stamp: 'HAW 12/14/2020 18:02:57'!
defaultRoom
	
	^Room ofWidth: 10 andHeight: 10! !

!classDefinition: #RoomTest category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:08:50'!
TestCase subclass: #RoomTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!

!classDefinition: #RoomTest category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:08:50'!
TestCase subclass: #RoomTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!
!RoomTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 17:20:02'!
test01_WidthMustBeStrictlyPositive

	self assertInvalidSizeWith: 0 and: 1
	! !
!RoomTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 17:20:13'!
test02_HeightMustBeStrictlyPositive

	self assertInvalidSizeWith: 1 and: 0
	! !
!RoomTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 17:20:25'!
test03_WidthMustBeInteger

	self assertInvalidSizeWith: 1.1 and: 1
	! !
!RoomTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 17:20:36'!
test04_HeightMustBeInteger

	self assertInvalidSizeWith: 1 and: 1.1
		! !
!RoomTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 17:39:43'!
test05_CanNotPutAStageObjectWithXLessThanCero

	self assertCanNotPutAt: -1@1
		! !
!RoomTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 17:39:49'!
test06_CanNotPutAStageObjectWithXGreaterOrEqualToWidth

	self assertCanNotPutAt: 10@1! !
!RoomTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 17:39:56'!
test07_CanNotPutAStageObjectWithANonIntegerX

	self assertCanNotPutAt: 1.1@1! !
!RoomTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 17:40:04'!
test08_CanNotPutAStageObjectWithYLessThanCero

	self assertCanNotPutAt: 1@-1
		! !
!RoomTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 17:40:25'!
test09_CanNotPutAStageObjectWithYGreaterOrEqualToHeight

	self assertCanNotPutAt: 1@10! !
!RoomTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 17:41:13'!
test10_CanNotPutAStageObjectWithANonIntegerY

	self assertCanNotPutAt: 1@1.1! !
!RoomTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 17:46:46'!
test11_StageObjectsAreKeept

	| room |
	
	room := Room ofWidth: 10 andHeight: 10.
	
	room at: 0@0 put: self paper.
	
	self deny: room isEmpty.! !
!RoomTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:30:22'!
test12_canNotGetPositionOfNonPutObject

	| room |
	
	room := Room ofWidth: 10 andHeight: 10.
	self
		should: [ room positionOf: self paper ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Room objectNotInRoomErrorDescription! !
!RoomTest methodsFor: 'test objects' stamp: 'HAW 12/14/2020 17:36:15'!
paper

	^ PointsPortableObject named: 'paper' weighing: 1 worth: 1! !
!RoomTest methodsFor: 'assertions' stamp: 'HAW 12/14/2020 18:43:14'!
assertCanNotPutAt: aPosition

	| room width |
	
	width := 10.
	room := Room ofWidth: width andHeight: 10.
	
	self 
		should: [ room at: aPosition put: self paper ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: Room invalidPositionErrorDescription equals: anError messageText.
			self assert: room isEmpty ].! !
!RoomTest methodsFor: 'assertions' stamp: 'HAW 12/14/2020 17:19:50'!
assertInvalidSizeWith: aWitdh and: aHeight

	self 
		should: [ Room ofWidth: aWitdh andHeight: aHeight ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Room invalidSizeErrorDescription! !

!classDefinition: #Backpack category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:08:51'!
Object subclass: #Backpack
	instanceVariableNames: 'weightCapacity gamePointsCapacity container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!

!classDefinition: #Backpack category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:08:51'!
Object subclass: #Backpack
	instanceVariableNames: 'weightCapacity gamePointsCapacity container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!
!Backpack methodsFor: 'exceptions' stamp: 'FRT 10/8/2020 18:02:29'!
signalMaxPointsExceeded

	self error: self class maxPointsExceededErrorDescription ! !
!Backpack methodsFor: 'exceptions' stamp: 'FRT 10/8/2020 18:02:47'!
signalMaxWeightExceeded

	self error: self class maxWeightExceededErrorDescription ! !
!Backpack methodsFor: 'initialization' stamp: 'HAW 10/14/2020 14:31:56'!
initializeContainingUpTo: aWeightCapacity limitingPointsTo: pointsCapacity

	weightCapacity := aWeightCapacity.
	gamePointsCapacity := pointsCapacity.
	
	container := OrderedCollection new.
	
	
	! !
!Backpack methodsFor: 'accessing' stamp: 'FRT 10/11/2020 19:14:47' overrides: 16880927!
size

	^ container size.! !
!Backpack methodsFor: 'accessing' stamp: 'HAW 10/18/2020 12:20:52'!
totalPoints
		
	^(container select: [ :portableObject | portableObject doesItAddPoints ])	
		sum: [ :portableObject | portableObject points ]
		ifEmpty: [ 0 ]! !
!Backpack methodsFor: 'accessing' stamp: 'HAW 10/18/2020 12:20:20'!
totalWeight
	
	^container 
		sum: [ :portableObject | portableObject weight ]
		ifEmpty: [ 0 ]
		! !
!Backpack methodsFor: 'assertions' stamp: 'FRT 10/12/2020 14:12:36'!
assertPointsAdding: aPointsPortableObject

	(self totalPoints + aPointsPortableObject points) > gamePointsCapacity ifTrue: [ self signalMaxPointsExceeded ]! !
!Backpack methodsFor: 'assertions' stamp: 'FRT 10/15/2020 12:22:34'!
assertWeightAdding: aPortableObject tolerating: aThreshold

	(self totalWeight + aPortableObject weight - weightCapacity) > aThreshold ifTrue: [ self signalMaxWeightExceeded ]! !
!Backpack methodsFor: 'adding' stamp: 'HAW 10/18/2020 12:28:24'!
add: aPortableObject
	
	aPortableObject assertCanAddTo: self.
	
	container add: aPortableObject.
	! !
!Backpack methodsFor: 'testing' stamp: 'HAW 12/9/2020 19:44:17'!
includes: aPortableObject 
	
	^container includes: aPortableObject ! !
!Backpack methodsFor: 'testing' stamp: 'FRT 10/11/2020 18:38:38'!
isEmpty

	^ container isEmpty.! !
!Backpack methodsFor: 'adding - private' stamp: 'HAW 10/18/2020 12:28:48'!
assertCanAddNoPointsPortableObject: aNoPointsPortableObject 
	
	self assertWeightAdding: aNoPointsPortableObject tolerating: 0.
	! !
!Backpack methodsFor: 'adding - private' stamp: 'HAW 10/18/2020 12:29:07'!
assertCanAddPointPortableObject: aPointsPortableObject 
	
	self assertWeightAdding: aPointsPortableObject tolerating: 5.
	self assertPointsAdding: aPointsPortableObject.
	! !

!classDefinition: 'Backpack class' category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:08:52'!
Backpack class
	instanceVariableNames: ''!

!classDefinition: 'Backpack class' category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:08:52'!
Backpack class
	instanceVariableNames: ''!
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 18:27:33'!
invalidPointsCapacityErrorDescription

	^ 'Points capacity must be positive'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 18:21:04'!
invalidWeightCapacityErrorDescription

	^ 'Weight capacity must be positive'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/8/2020 17:36:29'!
maxPointsExceededErrorDescription

	^ 'Maximum points has been exceeded'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/8/2020 17:36:17'!
maxWeightExceededErrorDescription

	^ 'Maximum weight has been exceeded'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/8/2020 17:43:00'!
pointsCapacityMustBeIntegerErrorDescription

	^ 'Points capacity must be integer'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/8/2020 17:42:48'!
weightCapacityMustBeIntegerErrorDescription

	^ 'Weight capacity must be integer'! !
!Backpack class methodsFor: 'exceptions' stamp: 'FRT 10/11/2020 18:27:16'!
signalInvalidPointsCapacity

	self error: self invalidPointsCapacityErrorDescription 
! !
!Backpack class methodsFor: 'exceptions' stamp: 'FRT 10/11/2020 18:21:51'!
signalInvalidWeightCapacity

	self error: self invalidWeightCapacityErrorDescription 
! !
!Backpack class methodsFor: 'exceptions' stamp: 'FRT 10/8/2020 17:41:06'!
signalPointsCapacityMustBeInteger

	self error: self pointsCapacityMustBeIntegerErrorDescription
! !
!Backpack class methodsFor: 'exceptions' stamp: 'FRT 10/8/2020 17:40:47'!
signalWeightCapacityMustBeInteger

	self error: self weightCapacityMustBeIntegerErrorDescription
! !
!Backpack class methodsFor: 'instance creation' stamp: 'HAW 10/14/2020 14:31:56'!
containingUpTo: aWeightCapacity limitingPointsTo: pointsCapacity

	aWeightCapacity strictlyPositive  ifFalse: [ self signalInvalidWeightCapacity ].
	pointsCapacity strictlyPositive ifFalse: [ self signalInvalidPointsCapacity ].
	
	aWeightCapacity isInteger ifFalse: [ self signalWeightCapacityMustBeInteger ].
	pointsCapacity isInteger ifFalse: [ self signalPointsCapacityMustBeInteger ].
	
	^ self new initializeContainingUpTo: aWeightCapacity limitingPointsTo: pointsCapacity.
! !

!classDefinition: #PlayableCharacter category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:08:53'!
Object subclass: #PlayableCharacter
	instanceVariableNames: 'heading backpack name room'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!

!classDefinition: #PlayableCharacter category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:08:53'!
Object subclass: #PlayableCharacter
	instanceVariableNames: 'heading backpack name room'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!
!PlayableCharacter methodsFor: 'initialization' stamp: 'HAW 12/14/2020 18:27:11'!
initializeNamed: aName using: aBackpack at: aPosition heading: aMarsRoverHeading in: aRoom  

	name := aName.
	backpack := aBackpack.
	heading := aMarsRoverHeading.
	room := aRoom.
	room at: aPosition put: self! !
!PlayableCharacter methodsFor: 'testing' stamp: 'HAW 12/14/2020 18:25:08'!
isAt: aPosition heading: aCardinalPoint

	^self position = aPosition and: [ heading cardinalPoint = aCardinalPoint ]! !
!PlayableCharacter methodsFor: 'moving' stamp: 'HAW 12/14/2020 19:09:28'!
forwardPosition

	^ self position + heading forwardPoint! !
!PlayableCharacter methodsFor: 'moving' stamp: 'HAW 12/14/2020 18:25:13'!
moveBackward
	
	self moveTo: self position - heading forwardPoint.
	! !
!PlayableCharacter methodsFor: 'moving' stamp: 'HAW 12/14/2020 19:09:36'!
moveForward
	
	self moveTo: self forwardPosition ! !
!PlayableCharacter methodsFor: 'moving' stamp: 'HAW 12/14/2020 18:27:14'!
moveTo: aNewPosition
	
	room moveFrom: self position to: aNewPosition.
		! !
!PlayableCharacter methodsFor: 'moving' stamp: 'HAW 12/14/2020 18:25:48'!
position

	^room positionOf: self! !
!PlayableCharacter methodsFor: 'rotating' stamp: 'HAW 10/11/2019 08:31:55'!
rotateLeft
	
	heading := heading leftHeading! !
!PlayableCharacter methodsFor: 'rotating' stamp: 'HAW 10/11/2019 08:32:04'!
rotateRight
	
	heading := heading rightHeading! !
!PlayableCharacter methodsFor: 'taking objects' stamp: 'HAW 12/14/2020 19:09:28'!
take
	
	| toTake |
	
	toTake := room at: self forwardPosition.
	toTake takenBy: self 
	! !
!PlayableCharacter methodsFor: 'taking objects' stamp: 'HAW 12/9/2020 19:28:57'!
take: aPortableObject

	backpack add: aPortableObject.! !
!PlayableCharacter methodsFor: 'taking - private' stamp: 'HAW 12/14/2020 18:58:05'!
takeNonPortableObject: aNonPortableObject 
	
	aNonPortableObject putAllTo: self! !
!PlayableCharacter methodsFor: 'taking - private' stamp: 'HAW 12/14/2020 19:09:51'!
takePortableObject: aPortableObject 
	
	self take: aPortableObject.
	room removeAt: self forwardPosition ! !
!PlayableCharacter methodsFor: 'backpack' stamp: 'HAW 12/9/2020 19:43:44'!
backpackIncludes: aPortableObject 
	
	^backpack includes: aPortableObject ! !
!PlayableCharacter methodsFor: 'backpack' stamp: 'HAW 12/14/2020 18:42:40'!
backpackIsEmpty
	
	^backpack isEmpty ! !
!PlayableCharacter methodsFor: 'backpack' stamp: 'HAW 12/14/2020 19:09:03'!
backpackSize
	
	^backpack size! !

!classDefinition: 'PlayableCharacter class' category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:08:54'!
PlayableCharacter class
	instanceVariableNames: 'headings'!

!classDefinition: 'PlayableCharacter class' category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:08:54'!
PlayableCharacter class
	instanceVariableNames: 'headings'!
!PlayableCharacter class methodsFor: 'heading' stamp: 'HAW 7/2/2018 16:28:16'!
headingFor: aCardinalPoint
	
	^headings at: aCardinalPoint ifAbsent: [ self error: self invalidCardinalPointErrorDescription ]! !
!PlayableCharacter class methodsFor: 'heading' stamp: 'HAW 7/2/2018 16:26:14'!
invalidCardinalPointErrorDescription
	
	^'Invalid cardinal point'! !
!PlayableCharacter class methodsFor: 'instance creation' stamp: 'HAW 12/14/2020 18:01:51'!
named: aName using: aBackpack at: aPosition heading: aCardinalPoint in: aRoom  
	
	| newHeading |

	newHeading := self headingFor: aCardinalPoint.
	
	^self new initializeNamed: aName using: aBackpack at: aPosition heading: newHeading in: aRoom ! !
!PlayableCharacter class methodsFor: 'initialization' stamp: 'HAW 10/11/2019 08:37:25'!
forHeadingAt: aCardinalPoint leftIs: aLeftCardinalPoint rightIs: aRightCardinalPoint
	
	(headings at: aCardinalPoint) leftHeading: (headings at: aLeftCardinalPoint) rightHeading: (headings at: aRightCardinalPoint).
	! !
!PlayableCharacter class methodsFor: 'initialization' stamp: 'HAW 7/2/2018 15:27:41' overrides: 16883149!
initialize

	self initializeHeadings! !
!PlayableCharacter class methodsFor: 'initialization' stamp: 'HAW 12/9/2020 19:31:43'!
initializeHeadings

	headings := Dictionary new.
	
	(OrderedCollection 
		with: (PlayableCharacterHeading for: #North forwardWith: 0@1 )	
		with: (PlayableCharacterHeading for: #East forwardWith: 1@0 )
		with: (PlayableCharacterHeading for: #South forwardWith: 0@-1 )
		with: (PlayableCharacterHeading for: #West forwardWith: -1@0 ))
			do: [ :heading | headings at: heading cardinalPoint put: heading ].
	
	self 
		forHeadingAt: #North leftIs: #West rightIs: #East;
		forHeadingAt: #South leftIs: #East rightIs: #West;
		forHeadingAt: #East leftIs: #North rightIs: #South;
		forHeadingAt: #West leftIs: #South rightIs: #North.
	! !

!classDefinition: #PlayableCharacterHeading category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:08:54'!
Object subclass: #PlayableCharacterHeading
	instanceVariableNames: 'cardinalPoint forwardPoint rightHeading leftHeading'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!

!classDefinition: #PlayableCharacterHeading category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:08:54'!
Object subclass: #PlayableCharacterHeading
	instanceVariableNames: 'cardinalPoint forwardPoint rightHeading leftHeading'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!
!PlayableCharacterHeading methodsFor: 'accessing' stamp: 'HAW 7/2/2018 15:29:44'!
cardinalPoint
	
	^cardinalPoint! !
!PlayableCharacterHeading methodsFor: 'accessing' stamp: 'HAW 7/2/2018 15:30:39'!
forwardPoint
	
	^forwardPoint! !
!PlayableCharacterHeading methodsFor: 'accessing' stamp: 'HAW 10/11/2019 08:31:33'!
leftHeading
	
	^leftHeading! !
!PlayableCharacterHeading methodsFor: 'accessing' stamp: 'HAW 10/11/2019 08:31:27'!
rightHeading
	
	^rightHeading! !
!PlayableCharacterHeading methodsFor: 'initialization' stamp: 'HAW 10/11/2019 08:27:25'!
initializeFor: aCardinalPoint forwardWith: aForwardPoint  
	
	cardinalPoint := aCardinalPoint.
	forwardPoint := aForwardPoint.
! !
!PlayableCharacterHeading methodsFor: 'initialization' stamp: 'HAW 10/11/2019 08:31:33'!
leftHeading: aLeftHeading rightHeading: aRightHeading
 
	leftHeading := aLeftHeading.
	rightHeading := aRightHeading ! !

!classDefinition: 'PlayableCharacterHeading class' category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:08:55'!
PlayableCharacterHeading class
	instanceVariableNames: ''!

!classDefinition: 'PlayableCharacterHeading class' category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:08:55'!
PlayableCharacterHeading class
	instanceVariableNames: ''!
!PlayableCharacterHeading class methodsFor: 'instance creation' stamp: 'HAW 10/11/2019 08:27:46'!
for: aCardinalPoint forwardWith: aForwardPoint  

	^self new initializeFor: aCardinalPoint forwardWith: aForwardPoint ! !

!classDefinition: #Room category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:08:55'!
Object subclass: #Room
	instanceVariableNames: 'width height contents'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!

!classDefinition: #Room category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:08:55'!
Object subclass: #Room
	instanceVariableNames: 'width height contents'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!
!Room methodsFor: 'initialization' stamp: 'HAW 12/14/2020 17:47:16'!
initializeOfWidth: aWidth andHeight: aHeight 
	
	width := aWidth.
	height := aHeight.
	contents := Dictionary new.! !
!Room methodsFor: 'contents' stamp: 'HAW 12/14/2020 18:42:28' overrides: 16880774!
at: aPosition

	^contents at: aPosition ifAbsent: [self error: self class objectNotInRoomErrorDescription ]! !
!Room methodsFor: 'contents' stamp: 'HAW 12/14/2020 18:07:24' overrides: 16880792!
at: aPosition put: aStageObject

	self assertPositionIsValid: aPosition.
	self assertIsEmpty: aPosition.
	
	contents at: aPosition put: aStageObject ! !
!Room methodsFor: 'contents' stamp: 'HAW 12/14/2020 18:23:18'!
moveFrom: aSourcePosition to: aTargetPosition

	| toMove |
	
	toMove := self at: aSourcePosition.
	self at: aTargetPosition put: toMove.
	contents removeKey: aSourcePosition.
	! !
!Room methodsFor: 'contents' stamp: 'HAW 12/14/2020 18:30:58'!
positionOf: anObject

	contents keysAndValuesDo: [ :aPosition :aPlacedObject |
		aPlacedObject = anObject ifTrue: [ ^aPosition  ]].
	
	self error: self class objectNotInRoomErrorDescription ! !
!Room methodsFor: 'contents' stamp: 'HAW 12/14/2020 18:47:43'!
removeAt: aPosition

	^contents removeKey: aPosition ! !
!Room methodsFor: 'assertions' stamp: 'HAW 12/14/2020 18:09:38'!
assertIsEmpty: aPosition

	^(self isEmptyAt: aPosition) ifFalse: [ self error: self class positionIsNotEmptyErrorDescription ]! !
!Room methodsFor: 'assertions' stamp: 'HAW 12/14/2020 18:43:14'!
assertPositionComponentIsValid: aPositionComponent withLimit: limit 

	^ (aPositionComponent < 0 or: [aPositionComponent >= limit or: [ aPositionComponent isInteger not]]) 
		ifTrue: [self error: self class invalidPositionErrorDescription ]! !
!Room methodsFor: 'assertions' stamp: 'HAW 12/14/2020 17:44:04'!
assertPositionIsValid: aPosition

	self assertPositionComponentIsValid: aPosition x withLimit: width.
	self assertPositionComponentIsValid: aPosition y withLimit: height.
	! !
!Room methodsFor: 'testing' stamp: 'HAW 12/14/2020 17:47:56'!
isEmpty
	
	^contents isEmpty ! !
!Room methodsFor: 'testing' stamp: 'HAW 12/14/2020 18:08:47'!
isEmptyAt: aPosition

	^ (contents includesKey: aPosition) not! !

!classDefinition: 'Room class' category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:08:56'!
Room class
	instanceVariableNames: ''!

!classDefinition: 'Room class' category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:08:56'!
Room class
	instanceVariableNames: ''!
!Room class methodsFor: 'error descriptions' stamp: 'HAW 12/14/2020 18:43:14'!
invalidPositionErrorDescription
	
	^'Invalid position'! !
!Room class methodsFor: 'error descriptions' stamp: 'HAW 12/14/2020 17:16:22'!
invalidSizeErrorDescription
	
	^'Invalid size'! !
!Room class methodsFor: 'error descriptions' stamp: 'HAW 12/14/2020 18:30:38'!
objectNotInRoomErrorDescription
	
	^'Object not in room'! !
!Room class methodsFor: 'error descriptions' stamp: 'HAW 12/14/2020 18:09:38'!
positionIsNotEmptyErrorDescription
	
	^'Position not empty'! !
!Room class methodsFor: 'instance creation' stamp: 'HAW 12/14/2020 19:27:12'!
ofWidth: aWidth andHeight: aHeight 
	
	self assertIsValidWitdth: aWidth andHeight: aHeight .
	
	^self new initializeOfWidth: aWidth andHeight: aHeight ! !
!Room class methodsFor: 'assertions' stamp: 'HAW 12/14/2020 17:22:01'!
assertIsValidSizeComponent: aSizeComponent

	^ (aSizeComponent < 1 or: [aSizeComponent isInteger not ]) ifTrue: [self error: self invalidSizeErrorDescription ]! !
!Room class methodsFor: 'assertions' stamp: 'HAW 12/14/2020 19:27:12'!
assertIsValidWitdth: aWidth andHeight: aHeight

	self assertIsValidSizeComponent: aWidth.
	self assertIsValidSizeComponent: aHeight! !

!classDefinition: #StageObject category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:08:56'!
Object subclass: #StageObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!

!classDefinition: #StageObject category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:08:56'!
Object subclass: #StageObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!
!StageObject methodsFor: 'taken' stamp: 'HAW 12/14/2020 19:30:06'!
putAllTo: aPlayableCharacter

	self subclassResponsibility 
	! !
!StageObject methodsFor: 'taken' stamp: 'HAW 12/14/2020 19:30:18'!
takenBy: aPlayableCharacter 

	self subclassResponsibility 
	! !

!classDefinition: #NonPortableObject category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:08:56'!
StageObject subclass: #NonPortableObject
	instanceVariableNames: 'name stageObjects'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!

!classDefinition: #NonPortableObject category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:08:56'!
StageObject subclass: #NonPortableObject
	instanceVariableNames: 'name stageObjects'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!
!NonPortableObject methodsFor: 'initialization' stamp: 'HAW 12/14/2020 19:00:02'!
initializeNamed: aName withAll: aCollectionOfStageObjects 
	
	name := aName.
	stageObjects := aCollectionOfStageObjects asOrderedCollection .! !
!NonPortableObject methodsFor: 'taken' stamp: 'HAW 12/14/2020 19:24:52' overrides: 50902105!
putAllTo: aPlayableCharacter 
	
	| toRemove |
	
	toRemove := OrderedCollection new.
	[ stageObjects do: [ :aStageObject | (aStageObject putAllTo: aPlayableCharacter) ifTrue: [ toRemove add: aStageObject ]]]
		ensure: [ stageObjects removeAll: toRemove ].
	
	^false! !
!NonPortableObject methodsFor: 'taken' stamp: 'HAW 12/14/2020 18:53:21' overrides: 50902110!
takenBy: aPlayableCharacter 
	
	aPlayableCharacter takeNonPortableObject: self! !
!NonPortableObject methodsFor: 'testing' stamp: 'HAW 12/14/2020 19:08:45'!
includes: aStageObject

	^stageObjects includes: aStageObject ! !
!NonPortableObject methodsFor: 'testing' stamp: 'HAW 12/14/2020 18:57:19'!
isEmpty
	
	^stageObjects isEmpty ! !

!classDefinition: 'NonPortableObject class' category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:08:57'!
NonPortableObject class
	instanceVariableNames: ''!

!classDefinition: 'NonPortableObject class' category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:08:57'!
NonPortableObject class
	instanceVariableNames: ''!
!NonPortableObject class methodsFor: 'instance creation' stamp: 'HAW 12/14/2020 19:00:27'!
named: aName 
	
	^self named: aName withAll: #()! !
!NonPortableObject class methodsFor: 'instance creation' stamp: 'HAW 12/14/2020 18:56:40'!
named: aName withAll: aCollectionOfStageObjects 
	
	^self new initializeNamed: aName withAll: aCollectionOfStageObjects ! !

!classDefinition: #PortableObject category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:08:57'!
StageObject subclass: #PortableObject
	instanceVariableNames: 'name weight'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!

!classDefinition: #PortableObject category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:08:57'!
StageObject subclass: #PortableObject
	instanceVariableNames: 'name weight'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!
!PortableObject methodsFor: 'testing' stamp: 'FRT 10/11/2020 17:54:20'!
doesItAddPoints

	self subclassResponsibility	! !
!PortableObject methodsFor: 'adding' stamp: 'HAW 10/18/2020 12:28:24'!
assertCanAddTo: aBackpack

	self subclassResponsibility	! !
!PortableObject methodsFor: 'accessing' stamp: 'FRT 10/11/2020 18:53:51'!
weight

	^ weight! !
!PortableObject methodsFor: 'taken' stamp: 'HAW 12/14/2020 19:15:12' overrides: 50902105!
putAllTo: aPlayableCharacter

	aPlayableCharacter take: self.
	^true! !
!PortableObject methodsFor: 'taken' stamp: 'HAW 12/14/2020 18:53:53' overrides: 50902110!
takenBy: aPlayableCharacter 
	
	aPlayableCharacter takePortableObject: self! !

!classDefinition: #NoPointsPortableObject category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:08:57'!
PortableObject subclass: #NoPointsPortableObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!

!classDefinition: #NoPointsPortableObject category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:08:57'!
PortableObject subclass: #NoPointsPortableObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!
!NoPointsPortableObject methodsFor: 'initialization' stamp: 'HAW 10/14/2020 14:34:36'!
initializeNamed: aName weighing: aWeight
	
	name := aName.
	weight := aWeight.! !
!NoPointsPortableObject methodsFor: 'testing' stamp: 'FRT 10/11/2020 17:54:20' overrides: 50902210!
doesItAddPoints	

	^ false! !
!NoPointsPortableObject methodsFor: 'adding' stamp: 'HAW 10/18/2020 12:28:48' overrides: 50902214!
assertCanAddTo: aBackpack 
	
	^aBackpack assertCanAddNoPointsPortableObject: self! !

!classDefinition: 'NoPointsPortableObject class' category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:08:58'!
NoPointsPortableObject class
	instanceVariableNames: ''!

!classDefinition: 'NoPointsPortableObject class' category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:08:58'!
NoPointsPortableObject class
	instanceVariableNames: ''!
!NoPointsPortableObject class methodsFor: 'instance creation' stamp: 'HAW 10/14/2020 14:34:36'!
named: aName weighing: aWeight
	
	^ self new initializeNamed: aName weighing: aWeight. ! !

!classDefinition: #PointsPortableObject category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:08:58'!
PortableObject subclass: #PointsPortableObject
	instanceVariableNames: 'points'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!

!classDefinition: #PointsPortableObject category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:08:58'!
PortableObject subclass: #PointsPortableObject
	instanceVariableNames: 'points'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!
!PointsPortableObject methodsFor: 'testing' stamp: 'FRT 10/11/2020 17:54:20' overrides: 50902210!
doesItAddPoints

	^ true! !
!PointsPortableObject methodsFor: 'initialization' stamp: 'HAW 10/14/2020 14:36:26'!
initializeNamed: aName weighing: aWeight worth: gamePoints
	
	name := aName.
	weight := aWeight.
	points := gamePoints.! !
!PointsPortableObject methodsFor: 'accessing' stamp: 'FRT 10/11/2020 19:06:57'!
points

	^ points! !
!PointsPortableObject methodsFor: 'adding' stamp: 'HAW 10/18/2020 12:29:07' overrides: 50902214!
assertCanAddTo: aBackpack 
	
	^aBackpack assertCanAddPointPortableObject: self! !

!classDefinition: 'PointsPortableObject class' category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:08:58'!
PointsPortableObject class
	instanceVariableNames: ''!

!classDefinition: 'PointsPortableObject class' category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:08:58'!
PointsPortableObject class
	instanceVariableNames: ''!
!PointsPortableObject class methodsFor: 'instance creation' stamp: 'HAW 10/14/2020 14:36:26'!
named: aName weighing: aWeight worth: gamePoints
	
	^ self new initializeNamed: aName weighing: aWeight worth: gamePoints.! !

!classDefinition: #DoorTest category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:08:58'!
TestCase subclass: #DoorTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!

!classDefinition: #DoorTest category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:08:58'!
TestCase subclass: #DoorTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!

!classDefinition: #Door category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:08:58'!
Object subclass: #Door
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!
!DoorTest methodsFor: 'no messages' stamp: 'FG 12/17/2020 17:37:56'!
test01DoorCanNotBeInTheSameRoomTwice

	| door room |
	
	room := Room ofWidth: 10 andHeight: 10. 
	
	door := Door in: room and: room.
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 17:38:20' prior: 50902371!
test01DoorCanNotBeInTheSameRoomTwice

	| door room |
	
	room := Room ofWidth: 10 andHeight: 10. 
	
	door := Door in: room and: room.
	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 17:39:50'!
test01DoorCannotBeInTheSameRoomTwice

	| door room |
	
	room := Room ofWidth: 10 andHeight: 10. 
	
	self 
		should: [ Door in: room and: room ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Door doorCannotBeInTheSameRoomTwice
	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 17:40:04' prior: 50902386!
test01DoorCannotBeInTheSameRoomTwice

	| room |
	
	room := Room ofWidth: 10 andHeight: 10. 
	
	self 
		should: [ Door in: room and: room ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Door doorCannotBeInTheSameRoomTwice
	
	! !

!methodRemoval: DoorTest #test01DoorCanNotBeInTheSameRoomTwice stamp: 'FG 12/17/2020 21:08:59'!
test01DoorCanNotBeInTheSameRoomTwice

	| door room |
	
	room := Room ofWidth: 10 andHeight: 10. 
	
	door := Door in: room and: room.
	
	!
!Door class methodsFor: 'exceptions' stamp: 'FG 12/17/2020 17:40:30'!
doorCannotBeInTheSameRoomTwice
	self shouldBeImplemented.! !
!Door class methodsFor: 'exceptions' stamp: 'FG 12/17/2020 17:41:28' prior: 50902415!
doorCannotBeInTheSameRoomTwice
	^ 'Error - Cannot create door that leads to the same room that its in'.! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 17:41:38' prior: 50902397!
test01DoorCannotBeInTheSameRoomTwice

	| room |
	
	room := Room ofWidth: 10 andHeight: 10. 
	
	self 
		should: [ Door in: room and: room ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Door doorCannotBeInTheSameRoomTwice.
	
	! !
!Door class methodsFor: 'nil' stamp: 'FG 12/17/2020 17:42:38'!
in: aRoom and: anotherRoom
	
	^ self basicNew initializeIn: aRoom and: anotherRoom.! !
!Door methodsFor: 'no messages' stamp: 'FG 12/17/2020 17:43:16'!
initializeIn: aRoom and: anotherRoom
! !
!Door methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 17:45:09' prior: 50902442!
initializeIn: aRoom and: anotherRoom
	
	(aRoom = anotherRoom) ifTrue: [ self error: Door doorCannotBeInTheSameRoomTwice ].! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 17:53:41'!
test02CannotPlaceDoorInInvalidPositionInAnyOfTheRooms

	| room1 room2 |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
	
	self 
		should: [ Door in: room1 at: -1@0 and: room2 at: 1@1 ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Room invalidPositionErrorDescription.
	
	! !
!Door class methodsFor: 'initialization' stamp: 'FG 12/17/2020 17:54:33'!
in: aRoom at: aPosition and: anotherRoom at: anotherPosition
	
	^ self basicNew initializeIn: aRoom at: aPosition and: anotherRoom at: anotherPosition.! !

!methodRemoval: Door class #in:and: stamp: 'FG 12/17/2020 21:08:59'!
in: aRoom and: anotherRoom
	
	^ self basicNew initializeIn: aRoom and: anotherRoom.!
!Door methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 17:55:33'!
initializeIn: aRoom at: aPosition and: anotherRoom at: anotherPosition
	
	(aRoom = anotherRoom) ifTrue: [ self error: Door doorCannotBeInTheSameRoomTwice ].
	
	aRoom put: self at: aPosition.! !

!methodRemoval: Door #initializeIn:and: stamp: 'FG 12/17/2020 21:08:59'!
initializeIn: aRoom and: anotherRoom
	
	(aRoom = anotherRoom) ifTrue: [ self error: Door doorCannotBeInTheSameRoomTwice ].!
!Door methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 17:56:50' prior: 50902479!
initializeIn: aRoom at: aPosition and: anotherRoom at: anotherPosition
	
	(aRoom = anotherRoom) ifTrue: [ self error: Door doorCannotBeInTheSameRoomTwice ].
	
	aRoom at: aPosition put: self.
	aRoom at: aPosition put: self.! !
!Door methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 17:58:12' prior: 50902495!
initializeIn: aRoom at: aPosition and: anotherRoom at: anotherPosition
	
	(aRoom = anotherRoom) ifTrue: [ self error: Door doorCannotBeInTheSameRoomTwice ].
	
	aRoom at: aPosition put: self.
	anotherRoom at: anotherPosition put: self.! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 18:02:32' prior: 50902454!
test02CannotPlaceDoorInInvalidPositionInAnyOfTheRooms

	| room1 room2 |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
	
	self 
		should: [ Door in: room1 at: -1@0 and: room2 at: 1@1 ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Room invalidPositionErrorDescription.
		
	self 
		should: [ Door in: room1 at: 1@0 and: room2 at: -1@1 ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Room invalidPositionErrorDescription.
	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 18:03:06'!
test03CannotPlaceDoorInOcupiedPositionInAnyOfTheRooms

	| room1 room2 |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
	
	self 
		should: [ Door in: room1 at: -1@0 and: room2 at: 1@1 ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Room invalidPositionErrorDescription.
		
	self 
		should: [ Door in: room1 at: 1@0 and: room2 at: -1@1 ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Room invalidPositionErrorDescription.
	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 18:03:21'!
paper

	^ PointsPortableObject named: 'paper' weighing: 1 worth: 1! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 18:04:34' prior: 50902534!
test03CannotPlaceDoorInOcupiedPositionInAnyOfTheRooms

	| room1 room2 |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
	
	room1 at: 1@1 put: self paper.
	room2 at: 1@1 put: self paper. 
	
	self 
		should: [ Door in: room1 at: 1@1 and: room2 at: 0@1 ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Room invalidPositionErrorDescription.
		
	self 
		should: [ Door in: room1 at: 1@0 and: room2 at: 1@1 ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Room invalidPositionErrorDescription.
	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 18:05:29' prior: 50902558!
test03CannotPlaceDoorInOcupiedPositionInAnyOfTheRooms

	| room1 room2 |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
	
	room1 at: 1@1 put: self paper.
	room2 at: 1@1 put: self paper. 
	
	self 
		should: [ Door in: room1 at: 1@1 and: room2 at: 0@1 ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Room positionIsNotEmptyErrorDescription.
		
	self 
		should: [ Door in: room1 at: 1@0 and: room2 at: 1@1 ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Room positionIsNotEmptyErrorDescription.
	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 18:06:59'!
test04DoorIsBothRooms

	| room1 room2 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1.	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 18:09:21' prior: 50902599!
test04DoorIsBothRooms

	| room1 room2 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1.	
	
	self deny: (room1 isEmptyAt: 1@1).
	self deny: (room2 isEmptyAt: 0@1).
	self assert: (room1 at: 1@1) equals: door.
	self assert: (room2 at: 0@1) equals: door.  
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 18:09:51'!
test04DoorIsInBothRooms

	| room1 room2 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1.	
	
	self deny: (room1 isEmptyAt: 1@1).
	self deny: (room2 isEmptyAt: 0@1).
	self assert: (room1 at: 1@1) equals: door.
	self assert: (room2 at: 0@1) equals: door.  
	! !

!methodRemoval: DoorTest #test04DoorIsBothRooms stamp: 'FG 12/17/2020 21:09:00'!
test04DoorIsBothRooms

	| room1 room2 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1.	
	
	self deny: (room1 isEmptyAt: 1@1).
	self deny: (room2 isEmptyAt: 0@1).
	self assert: (room1 at: 1@1) equals: door.
	self assert: (room2 at: 0@1) equals: door.  
	!
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 18:10:36'!
test01DoorShouldBeInDifferentRooms

	| room |
	
	room := Room ofWidth: 10 andHeight: 10. 
	
	self 
		should: [ Door in: room and: room ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Door doorCannotBeInTheSameRoomTwice.
	
	! !

!methodRemoval: DoorTest #test01DoorCannotBeInTheSameRoomTwice stamp: 'FG 12/17/2020 21:09:00'!
test01DoorCannotBeInTheSameRoomTwice

	| room |
	
	room := Room ofWidth: 10 andHeight: 10. 
	
	self 
		should: [ Door in: room and: room ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Door doorCannotBeInTheSameRoomTwice.
	
	!
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 18:10:57' prior: 50902650!
test01DoorShouldBeInDifferentRooms

	| room |
	
	room := Room ofWidth: 10 andHeight: 10. 
	
	self 
		should: [ Door in: room at: 1@1 and: room at:1@1]
		raise: Error - MessageNotUnderstood 
		withMessageText: Door doorCannotBeInTheSameRoomTwice.
	
	! !
!Door methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 18:18:56' prior: 50902505!
initializeIn: aRoom at: aPosition and: anotherRoom at: anotherPosition
	
	(aRoom = anotherRoom) ifTrue: [ self error: Door doorCannotBeInTheSameRoomTwice ].
	
	aRoom at: aPosition put: self.
	anotherRoom at: anotherPosition put: self.! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 18:30:36'!
test05DoorLeadFromOneRoomToTheOther

	| room1 room2 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1.	
	
	self assert: (door moveFrom: room1) equals: room2.
	self assert: (door moveFrom: room2) equals: room2. ! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 18:30:39' prior: 50902692!
test05DoorLeadFromOneRoomToTheOther

	| room1 room2 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1.	
	
	self assert: (door moveFrom: room1) equals: room2.
	self assert: (door moveFrom: room2) equals: room1. ! !
!Door methodsFor: 'accessing' stamp: 'FG 12/17/2020 18:30:56'!
moveFrom: aRoom 
	self shouldBeImplemented.! !

!classDefinition: #Door category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:09:01'!
Object subclass: #Door
	instanceVariableNames: 'firstRoom'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!

!classDefinition: #Door category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:09:01'!
Object subclass: #Door
	instanceVariableNames: 'firstRoom secondRoom'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!
!Door methodsFor: 'accessing' stamp: 'FG 12/17/2020 18:32:39' prior: 50902717!
moveFrom: aRoom 
	(aRoom = firstRoom) ifTrue: [^ secondRoom].
	(aRoom = secondRoom) ifTrue: [^ firstRoom].! !
!Door methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 18:33:28' prior: 50902682!
initializeIn: aRoom at: aPosition and: anotherRoom at: anotherPosition
	
	(aRoom = anotherRoom) ifTrue: [ self error: Door doorCannotBeInTheSameRoomTwice ].
	
	aRoom at: aPosition put: self.
	anotherRoom at: anotherPosition put: self.
	
	firstRoom := aRoom.
	secondRoom := anotherRoom.! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 18:39:08'!
test06CannotMoveFromARoomWhichDoesntHasTheDoor

	| room1 room2 room3 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
	room3 := Room 	ofWidth: 10 andHeight: 10.
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1.	
	
	self assert: (door moveFrom: room1) equals: room2.
	self assert: (door moveFrom: room2) equals: room1. ! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 18:40:45' prior: 50902757!
test06CannotMoveFromARoomWhichDoesntHasTheDoor

	| room1 room2 room3 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
	room3 := Room 	ofWidth: 10 andHeight: 10.
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1.	
	
	self 
		should: [ door moveFrom: room3]
		raise: Error - MessageNotUnderstood 
		withMessageText: (Door cannotMoveFrom: room3).! !
!Door class methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 18:41:01'!
cannotMoveFrom: aRoom 
	self shouldBeImplemented.! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 18:43:01' prior: 50902772!
test06CannotMoveFromARoomWhichDoesntHasTheDoor

	| room1 room2 room3 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
	room3 := Room 	ofWidth: 10 andHeight: 10.
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1.	
	
	self 
		should: [ door moveFrom: room3]
		raise: Error - MessageNotUnderstood 
		withMessageText: (Door cannotMoveFromARoomWithoutThisDoor).! !
!Door class methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 18:43:13'!
cannotMoveFromARoomWithoutThisDoor
	self shouldBeImplemented.! !
!Door class methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 18:43:36' prior: 50902808!
cannotMoveFromARoomWithoutThisDoor
	^ 'Error - Cannot move from a room without this door'.! !
!Door methodsFor: 'accessing' stamp: 'FG 12/17/2020 18:44:22' prior: 50902738!
moveFrom: aRoom 
	(aRoom = firstRoom) ifTrue: [^ secondRoom].
	(aRoom = secondRoom) ifTrue: [^ firstRoom].
	self error: Door cannotMoveFromARoomWithoutThisDoor.! !

!classDefinition: #Door category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:09:01'!
Object subclass: #Door
	instanceVariableNames: 'firstRoom secondRoom state'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!

!classDefinition: #Door category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:09:01'!
Object subclass: #Door
	instanceVariableNames: 'firstRoom secondRoom state'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!

!classDefinition: #ClosedDoor category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:09:02'!
Object subclass: #ClosedDoor
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 18:53:54'!
test07DoorStartsClosed

	| room1 room2 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1.	
	
	self assert: (door state isKindaOf: 
	ClosedDoor).! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 18:54:16' prior: 50902853!
test07DoorStartsClosed

	| room1 room2 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1.	
	
	self assert: (door state isKindOf: ClosedDoor).! !

!classDefinition: #DoorState category: 'Unknown' stamp: 'FG 12/17/2020 21:09:02'!
Object subclass: #DoorState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Unknown'!

!classDefinition: #ClosedDoor category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:09:02'!
DoorState subclass: #ClosedDoor
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!

!classDefinition: #ClosedDoor category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:09:02'!
DoorState subclass: #ClosedDoor
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!

!classDefinition: #DoorState category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:09:02'!
Object subclass: #DoorState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!

!classDefinition: #DoorState category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:09:02'!
Object subclass: #DoorState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!
!Door methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 18:55:59' prior: 50902745!
initializeIn: aRoom at: aPosition and: anotherRoom at: anotherPosition
	
	(aRoom = anotherRoom) ifTrue: [ self error: Door doorCannotBeInTheSameRoomTwice ].
	
	aRoom at: aPosition put: self.
	anotherRoom at: anotherPosition put: self.
	
	state := ClosedDoor new.
	firstRoom := aRoom.
	secondRoom := anotherRoom.! !
!Door methodsFor: 'accessing' stamp: 'FG 12/17/2020 18:57:04'!
isClosed
	state isClosed: self.! !
!ClosedDoor methodsFor: 'no messages' stamp: 'FG 12/17/2020 18:57:22'!
isClosed: door
	^ true.! !
!ClosedDoor methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 18:57:27'!
isClosed
	^ true.! !

!methodRemoval: ClosedDoor #isClosed: stamp: 'FG 12/17/2020 21:09:02'!
isClosed: door
	^ true.!
!Door methodsFor: 'accessing' stamp: 'FG 12/17/2020 18:57:39' prior: 50902927!
isClosed
	state isClosed.! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 18:58:00' prior: 50902864!
test07DoorStartsClosed

	| room1 room2 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1.	
	
	self assert: door isClosed.! !
!Door methodsFor: 'accessing' stamp: 'FG 12/17/2020 18:59:37'!
useFrom: aRoom 
	(aRoom = firstRoom) ifTrue: [^ secondRoom].
	(aRoom = secondRoom) ifTrue: [^ firstRoom].
	self error: Door cannotMoveFromARoomWithoutThisDoor.! !

!methodRemoval: Door #moveFrom: stamp: 'FG 12/17/2020 21:09:02'!
moveFrom: aRoom 
	(aRoom = firstRoom) ifTrue: [^ secondRoom].
	(aRoom = secondRoom) ifTrue: [^ firstRoom].
	self error: Door cannotMoveFromARoomWithoutThisDoor.!
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 18:59:54' prior: 50902705!
test05DoorLeadFromOneRoomToTheOther

	| room1 room2 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1.	
	
	self assert: (door useFrom: room1) equals: room2.
	self assert: (door useFrom: room2) equals: room1. ! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:00:00' prior: 50902792!
test06CannotMoveFromARoomWhichDoesntHasTheDoor

	| room1 room2 room3 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
	room3 := Room 	ofWidth: 10 andHeight: 10.
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1.	
	
	self 
		should: [ door useFrom: room3]
		raise: Error - MessageNotUnderstood 
		withMessageText: (Door cannotMoveFromARoomWithoutThisDoor).! !
!Door methodsFor: 'accessing' stamp: 'FG 12/17/2020 19:01:42' prior: 50902942!
isClosed
	^ state isClosed.! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:03:51'!
test08CannotUseAClosedDoor

	| room1 room2 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1.	
	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:04:33' prior: 50903004!
test08CannotUseAClosedDoor

	| room1 room2 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1.	
	
	self 
		should: [ door useFrom: room1]
		raise: Error - MessageNotUnderstood 
		withMessageText: (Door cannotUseClosedDoor).
	
	! !
!Door methodsFor: 'accessing' stamp: 'FG 12/17/2020 19:05:53' prior: 50902955!
useFrom: aRoom 

	state useDoor: self.! !
!Door methodsFor: 'accessing' stamp: 'FG 12/17/2020 19:06:14'!
useOpenDoorFrom: aRoom 

	(aRoom = firstRoom) ifTrue: [^ secondRoom].
	(aRoom = secondRoom) ifTrue: [^ firstRoom].
	self error: Door cannotMoveFromARoomWithoutThisDoor.! !
!ClosedDoor methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:06:51'!
useDoor: aDoor

	aDoor useClosedDoor.! !
!Door methodsFor: 'accessing' stamp: 'FG 12/17/2020 19:07:30'!
useClosedDoorFrom

	self error: Door.! !
!Door methodsFor: 'accessing' stamp: 'FG 12/17/2020 19:07:46' prior: 50903027!
useFrom: aRoom 

	state useDoor: self from: aRoom.! !
!ClosedDoor methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:07:58'!
useDoor: aDoor from: aRoom

	aDoor useClosedDoor.! !

!methodRemoval: ClosedDoor #useDoor: stamp: 'FG 12/17/2020 21:09:03'!
useDoor: aDoor

	aDoor useClosedDoor.!
!Door methodsFor: 'accessing' stamp: 'FG 12/17/2020 19:08:14'!
useClosedDoor

	self error: Door.! !

!methodRemoval: Door #useClosedDoorFrom stamp: 'FG 12/17/2020 21:09:03'!
useClosedDoorFrom

	self error: Door.!

!methodRemoval: Door class #cannotMoveFrom: stamp: 'FG 12/17/2020 21:09:03'!
cannotMoveFrom: aRoom 
	self shouldBeImplemented.!
!Door class methodsFor: 'exceptions' stamp: 'FG 12/17/2020 19:09:17'!
cannotUseClosedDoor
	^ 'Error - The door is closed. You cannot use it'.! !
!Door methodsFor: 'use' stamp: 'FG 12/17/2020 19:11:07' prior: 50903047!
useFrom: aRoom 

	^ state useDoor: self from: aRoom.! !
!Door methodsFor: 'use - private' stamp: 'FG 12/17/2020 19:11:56' prior: 50903060!
useClosedDoor

	self error: Door cannotUseClosedDoor .! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:13:05'!
test08CannotOpenDoorWithWrongKey

	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:13:09'!
test09CannotOpenDoorWithWrongKey

	
	! !

!methodRemoval: DoorTest #test08CannotOpenDoorWithWrongKey stamp: 'FG 12/17/2020 21:09:04'!
test08CannotOpenDoorWithWrongKey

	
	!

!classDefinition: #Door category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:09:04'!
Object subclass: #Door
	instanceVariableNames: 'firstRoom secondRoom state key'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!
!Door methodsFor: 'initialization' stamp: 'FG 12/17/2020 19:13:55'!
initializeIn: aRoom at: aPosition and: anotherRoom at: anotherPosition thatOpensWith: aKey
	
	(aRoom = anotherRoom) ifTrue: [ self error: Door doorCannotBeInTheSameRoomTwice ].
	
	aRoom at: aPosition put: self.
	anotherRoom at: anotherPosition put: self.
	
	key := aKey.
	state := ClosedDoor new.
	firstRoom := aRoom.
	secondRoom := anotherRoom.! !

!methodRemoval: Door #initializeIn:at:and:at:thatOpensWith: stamp: 'FG 12/17/2020 21:09:04'!
initializeIn: aRoom at: aPosition and: anotherRoom at: anotherPosition thatOpensWith: aKey
	
	(aRoom = anotherRoom) ifTrue: [ self error: Door doorCannotBeInTheSameRoomTwice ].
	
	aRoom at: aPosition put: self.
	anotherRoom at: anotherPosition put: self.
	
	key := aKey.
	state := ClosedDoor new.
	firstRoom := aRoom.
	secondRoom := anotherRoom.!
!Door methodsFor: 'initialization' stamp: 'FG 12/17/2020 19:15:27'!
initializeIn: aRoom at: aPosition and: anotherRoom at: anotherPosition thatOpensWith: aKey 
	
	(aRoom = anotherRoom) ifTrue: [ self error: Door doorCannotBeInTheSameRoomTwice ].
	
	aRoom at: aPosition put: self.
	anotherRoom at: anotherPosition put: self.
	
	state := ClosedDoor new.
	firstRoom := aRoom.
	secondRoom := anotherRoom.! !
!Door class methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:15:27' prior: 50902467!
in: aRoom at: aPosition and: anotherRoom at: anotherPosition
	
	^ self basicNew initializeIn: aRoom at: aPosition and: anotherRoom at: anotherPosition thatOpensWith: aKey.! !

!methodRemoval: Door #initializeIn:at:and:at: stamp: 'FG 12/17/2020 21:09:04'!
initializeIn: aRoom at: aPosition and: anotherRoom at: anotherPosition
	
	(aRoom = anotherRoom) ifTrue: [ self error: Door doorCannotBeInTheSameRoomTwice ].
	
	aRoom at: aPosition put: self.
	anotherRoom at: anotherPosition put: self.
	
	state := ClosedDoor new.
	firstRoom := aRoom.
	secondRoom := anotherRoom.!
!Door methodsFor: 'initialization' stamp: 'FG 12/17/2020 19:15:43' prior: 50903134!
initializeIn: aRoom at: aPosition and: anotherRoom at: anotherPosition thatOpensWith: aKey 
	
	(aRoom = anotherRoom) ifTrue: [ self error: Door doorCannotBeInTheSameRoomTwice ].
	
	aRoom at: aPosition put: self.
	anotherRoom at: anotherPosition put: self.
	
	key := aKey.
	state := ClosedDoor new.
	firstRoom := aRoom.
	secondRoom := anotherRoom.! !
!Door methodsFor: 'nil' stamp: 'FG 12/17/2020 19:17:59'!
openWith: aKey

	(key = aKey) ifFalse: [ self error: Door cannotOpenWithWrongKey].
	 ! !
!Door class methodsFor: 'exceptions' stamp: 'FG 12/17/2020 19:18:28'!
cannotOpenWithWrongKey
	^ 'Error - Cannot open door with a wrong key'.! !

!classDefinition: #Keys category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:09:04'!
PortableObject subclass: #Keys
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!

!classDefinition: #Keys category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:09:05'!
PortableObject subclass: #Keys
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!
!Keys methodsFor: 'no messages' stamp: 'FG 12/17/2020 19:20:45'!
initializeNamed: aName weighing: aWeight
	
	name := aName.
	weight := aWeight.! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:21:08'!
wrongKey

	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:21:35' prior: 50903213!
wrongKey

	^ Keys ! !
!Keys class methodsFor: 'no messages' stamp: 'FG 12/17/2020 19:21:51'!
named: aName weighing: aWeight
	
	^ self new initializeNamed: aName weighing: aWeight. ! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:22:20' prior: 50903217!
wrongKey

	^ Keys named: 'Wrong Key' weighing: 5 ! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:22:29' prior: 50903090!
test09CannotOpenDoorWithWrongKey

	

	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:22:59'!
correctKey

	^ Keys named: 'Correct Key' weighing: 5 ! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:23:07' prior: 50903231!
test09CannotOpenDoorWithWrongKey

	

	

	
	! !
!Door class methodsFor: 'initialization' stamp: 'FG 12/17/2020 19:24:00'!
in: aRoom at: aPosition and: anotherRoom at: anotherPosition thatOpensWith: aKey 
	
	^ self basicNew initializeIn: aRoom at: aPosition and: anotherRoom at: anotherPosition thatOpensWith: aKey.! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:24:00' prior: 50902579!
test03CannotPlaceDoorInOcupiedPositionInAnyOfTheRooms

	| room1 room2 |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
	
	room1 at: 1@1 put: self paper.
	room2 at: 1@1 put: self paper. 
	
	self 
		should: [ Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: self correctKey ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Room positionIsNotEmptyErrorDescription.
		
	self 
		should: [ Door in: room1 at: 1@0 and: room2 at: 1@1 thatOpensWith: self correctKey ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Room positionIsNotEmptyErrorDescription.
	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:24:00' prior: 50902971!
test05DoorLeadFromOneRoomToTheOther

	| room1 room2 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: self correctKey.	
	
	self assert: (door useFrom: room1) equals: room2.
	self assert: (door useFrom: room2) equals: room1. ! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:24:00' prior: 50902671!
test01DoorShouldBeInDifferentRooms

	| room |
	
	room := Room ofWidth: 10 andHeight: 10. 
	
	self 
		should: [ Door in: room at: 1@1 and: room at:1@1 thatOpensWith: self correctKey]
		raise: Error - MessageNotUnderstood 
		withMessageText: Door doorCannotBeInTheSameRoomTwice.
	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:24:00' prior: 50902946!
test07DoorStartsClosed

	| room1 room2 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: self correctKey.	
	
	self assert: door isClosed.! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:24:00' prior: 50903014!
test08CannotUseAClosedDoor

	| room1 room2 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: self correctKey.	
	
	self 
		should: [ door useFrom: room1]
		raise: Error - MessageNotUnderstood 
		withMessageText: (Door cannotUseClosedDoor).
	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:24:00' prior: 50902516!
test02CannotPlaceDoorInInvalidPositionInAnyOfTheRooms

	| room1 room2 |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
	
	self 
		should: [ Door in: room1 at: -1@0 and: room2 at: 1@1 thatOpensWith: self correctKey ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Room invalidPositionErrorDescription.
		
	self 
		should: [ Door in: room1 at: 1@0 and: room2 at: -1@1 thatOpensWith: self correctKey ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Room invalidPositionErrorDescription.
	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:24:00' prior: 50902622!
test04DoorIsInBothRooms

	| room1 room2 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: self correctKey.	
	
	self deny: (room1 isEmptyAt: 1@1).
	self deny: (room2 isEmptyAt: 0@1).
	self assert: (room1 at: 1@1) equals: door.
	self assert: (room2 at: 0@1) equals: door.  
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:24:00' prior: 50902984!
test06CannotMoveFromARoomWhichDoesntHasTheDoor

	| room1 room2 room3 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
	room3 := Room 	ofWidth: 10 andHeight: 10.
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: self correctKey.	
	
	self 
		should: [ door useFrom: room3]
		raise: Error - MessageNotUnderstood 
		withMessageText: (Door cannotMoveFromARoomWithoutThisDoor).! !

!methodRemoval: Door class #in:at:and:at: stamp: 'FG 12/17/2020 21:09:06'!
in: aRoom at: aPosition and: anotherRoom at: anotherPosition
	
	^ self basicNew initializeIn: aRoom at: aPosition and: anotherRoom at: anotherPosition thatOpensWith: aKey.!
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:25:22' prior: 50903240!
test09CannotOpenDoorWithWrongKey

	| room1 room2 door |

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: self correctKey.	

	

	

	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:25:58' prior: 50903391!
test09CannotOpenDoorWithWrongKey

	| room1 room2 door |

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: self correctKey.	
	
	self 
		should: [ door openWith: self wrongKey ]
		raise: Error - MessageNotUnderstood 
		withMessageText: (Door cannotOpenWithWrongKey).
	

	

	

	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:27:26'!
test09DoorOpensWithTheCorrectKey

	| room1 room2 door key |

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 

	key := self correctKey.	
			
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: key.	
	
	door openWith: key.
	
	self deny: door isClosed.	

	

	

	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:27:32'!
test10DoorOpensWithTheCorrectKey

	| room1 room2 door key |

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 

	key := self correctKey.	
			
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: key.	
	
	door openWith: key.
	
	self deny: door isClosed.	

	

	

	
	! !

!methodRemoval: DoorTest #test09DoorOpensWithTheCorrectKey stamp: 'FG 12/17/2020 21:09:06'!
test09DoorOpensWithTheCorrectKey

	| room1 room2 door key |

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 

	key := self correctKey.	
			
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: key.	
	
	door openWith: key.
	
	self deny: door isClosed.	

	

	

	
	!

!classDefinition: #OpenDoor category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:09:06'!
DoorState subclass: #OpenDoor
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!
!Door methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:29:27' prior: 50903182!
openWith: aKey

	(key = aKey) ifFalse: [ self error: Door cannotOpenWithWrongKey].
	
	state := OpenDoor new.
	 ! !
!OpenDoor methodsFor: 'no messages' stamp: 'FG 12/17/2020 19:30:01'!
isClosed
	^ false.! !
!OpenDoor methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:30:56'!
useDoor: aDoor from: aRoom
	^ aDoor useOpenDoorFrom: aRoom. ! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:32:05' prior: 50903277!
test05DoorLeadFromOneRoomToTheOther

	| room1 room2 door key |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	key := self correctKey.
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: key.
	door openWith: key.	
	
	self assert: (door useFrom: room1) equals: room2.
	self assert: (door useFrom: room2) equals: room1. ! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:33:02' prior: 50903366!
test06CannotMoveFromARoomWhichDoesntHasTheDoor

	| room1 room2 room3 door key |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
	room3 := Room 	ofWidth: 10 andHeight: 10.
	
	key := self correctKey.	
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: self key.
	door openWith: key.	
	
	self 
		should: [ door useFrom: room3]
		raise: Error - MessageNotUnderstood 
		withMessageText: (Door cannotMoveFromARoomWithoutThisDoor).! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:33:23' prior: 50903494!
test06CannotMoveFromARoomWhichDoesntHasTheDoor

	| room1 room2 room3 door key |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
	room3 := Room 	ofWidth: 10 andHeight: 10.
	
	key := self correctKey.	
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: key.
	door openWith: key.	
	
	self 
		should: [ door useFrom: room3]
		raise: Error - MessageNotUnderstood 
		withMessageText: (Door cannotMoveFromARoomWithoutThisDoor).! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:33:52'!
test11CannotOpenAnAlreadyOpenDoor

	| room1 room2 door key |

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 

	key := self correctKey.	
			
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: key.	
	
	door openWith: key.
	
	self deny: door isClosed.	

	

	

	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:34:37' prior: 50903530!
test11CannotOpenAnAlreadyOpenDoor

	| room1 room2 door key |

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 

	key := self correctKey.	
			
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: key.	
	
	door openWith: key.
	
	self 
		should: [ door openWith: key ]
		raise: Error - MessageNotUnderstood 
		withMessageText: (Door doorAlreadyOpen).

	

	

	
	! !
!Door methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:35:52' prior: 50903464!
openWith: aKey

	(key = aKey) ifFalse: [ self error: Door cannotOpenWithWrongKey].
	
	state openDoor: self.
	 ! !
!ClosedDoor methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:36:18'!
openDoor: aDoor

	aDoor openClosedDoor.
	! !
!OpenDoor methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:36:37'!
openDoor: aDoor
	
	aDoor openOpenedDoor.! !
!Door methodsFor: 'open - private' stamp: 'FG 12/17/2020 19:37:42'!
openClosedDoor

	! !
!Door methodsFor: 'open - private' stamp: 'FG 12/17/2020 19:38:37'!
openOpenedDoor

	self error: Door doorAlreadyOpen.! !
!Door methodsFor: 'open - private' stamp: 'FG 12/17/2020 19:39:00' prior: 50903574!
openClosedDoor

	state := OpenDoor new.

	! !
!Door class methodsFor: 'exceptions' stamp: 'FG 12/17/2020 19:39:38'!
doorAlreadyOpen

	^ 'Error - Door is already open' ! !
!Keys methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:42:15'!
isAKey
	^ true.! !
!NoPointsPortableObject methodsFor: 'nil' stamp: 'FG 12/17/2020 19:42:29'!
isAKey
	^ false.! !
!PointsPortableObject methodsFor: 'nil' stamp: 'FG 12/17/2020 19:42:42'!
isAKey
	^ false.! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:45:53'!
test12ADoorCannotBeLockedWithAnyObjectThatIsNotAKey

	| room1 room2 door paper |

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 

	
	

	

	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:47:47' prior: 50903600!
test12ADoorCannotBeLockedWithAnyObjectThatIsNotAKey

	| room1 room2 |

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 	
		
	self 
		should: [ Door in: room1 at: 1@1  and: room2  at: 1@1  thatOpensWith: self paper ]
		raise: Error - MessageNotUnderstood 
		withMessageText: (Door cannotBeLockedWithANonKeyObject).

	
	

	

	
	! !
!Door class methodsFor: 'exceptions' stamp: 'FG 12/17/2020 19:48:24'!
cannotBeLockedWithANonKeyObject
	^ 'Error - Door Cannot Be Locked With Non Key Object'.! !
!Door methodsFor: 'initialization' stamp: 'FG 12/17/2020 19:48:56' prior: 50903169!
initializeIn: aRoom at: aPosition and: anotherRoom at: anotherPosition thatOpensWith: aKey 
	
	(aRoom = anotherRoom) ifTrue: [ self error: Door doorCannotBeInTheSameRoomTwice ].
	(aKey isAKey) ifFalse: [ self error: Door cannotBeLockedWithANonKeyObject ].
	
	aRoom at: aPosition put: self.
	anotherRoom at: anotherPosition put: self.
	
	key := aKey.
	state := ClosedDoor new.
	firstRoom := aRoom.
	secondRoom := anotherRoom.! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:53:03'!
test13CannotCloseDoorWithANonKeyObject

	| room1 room2 door key|

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 	
		
	key := self correctKey.	
	door := Door in: room1 at: 1@1  and: room2  at: 1@1  thatOpensWith: key.
	door openWith:	 key.
		
	self 
		should: [ door closeWith: self paper ]
		raise: Error - MessageNotUnderstood 
		withMessageText: (Door cannotBeLockedWithANonKeyObject).

	
	

	

	
	! !
!Door methodsFor: 'nil' stamp: 'FG 12/17/2020 19:54:00'!
closeWith: aKey

	(key isAKey) ifFalse: [self error: Door cannotBeLockedWithANonKeyObject ].
	 ! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:54:37' prior: 50903645!
test13CannotCloseDoorWithANonKeyObject

	| room1 room2 door key|

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 	
		
	key := self correctKey.	
	door := Door in: room1 at: 1@1  and: room2  at: 1@1  thatOpensWith: key.
	door openWith:	 key.
		
	self 
		should: [ door closeWith: self paper ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Door cannotBeLockedWithANonKeyObject.

	
	

	

	
	! !
!Door methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:55:06' prior: 50903661!
closeWith: aKey

	(aKey isAKey) ifFalse: [self error: Door cannotBeLockedWithANonKeyObject ].
	 ! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:56:25'!
test13CannotCloseAClosedDoor

	| room1 room2 door key|

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 	
		
	key := self correctKey.	
	door := Door in: room1 at: 1@1  and: room2  at: 1@1  thatOpensWith: key.
		
	self 
		should: [ door closeWith: self correctKey ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Door cannotCloseAnAlreadyClosedDoor.

	
	

	

	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:56:31'!
test14CannotCloseAClosedDoor

	| room1 room2 door key|

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 	
		
	key := self correctKey.	
	door := Door in: room1 at: 1@1  and: room2  at: 1@1  thatOpensWith: key.
		
	self 
		should: [ door closeWith: self correctKey ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Door cannotCloseAnAlreadyClosedDoor.

	
	

	

	
	! !

!methodRemoval: DoorTest #test13CannotCloseAClosedDoor stamp: 'FG 12/17/2020 21:09:08'!
test13CannotCloseAClosedDoor

	| room1 room2 door key|

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 	
		
	key := self correctKey.	
	door := Door in: room1 at: 1@1  and: room2  at: 1@1  thatOpensWith: key.
		
	self 
		should: [ door closeWith: self correctKey ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Door cannotCloseAnAlreadyClosedDoor.

	
	

	

	
	!
!Door methodsFor: 'close' stamp: 'FG 12/17/2020 19:57:25' prior: 50903684!
closeWith: aKey

	(aKey isAKey) ifFalse: [self error: Door cannotBeLockedWithANonKeyObject ].
	
	state closeDoor: self with: aKey.
	 ! !
!ClosedDoor methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:57:56'!
closeDoor: aDoor with: aKey

	aDoor closeClosedDoor.! !
!Door methodsFor: 'nil' stamp: 'FG 12/17/2020 19:58:31'!
closeClosedDoor

	self error: Door doorAlreadyClosed.! !
!Door class methodsFor: 'exceptions' stamp: 'FG 12/17/2020 19:58:43'!
doorAlreadyClosed

	^ 'Error - Door is already closed' ! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:59:08' prior: 50903706!
test14CannotCloseAClosedDoor

	| room1 room2 door key|

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 	
		
	key := self correctKey.	
	door := Door in: room1 at: 1@1  and: room2  at: 1@1  thatOpensWith: key.
		
	self 
		should: [ door closeWith: self correctKey ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Door doorAlreadyClosed.

	
	

	

	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:02:24'!
test15DoorCanBeClosedWithAKey

	| room1 room2 door key newKey|

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 	
		
	key := self correctKey.	
	door := Door in: room1 at: 1@1  and: room2  at: 1@1  thatOpensWith: key.
	door openWith: key.

	newKey := self wrongKey.
	door closeWith: newKey.
	
	self assert: door isClosed.
	
	door openWith: newKey.
	
	self deny: door isClosed	.
	
		
	

	

	
	! !
!OpenDoor methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:03:13'!
closeDoor: aDoor with: aKey

	aDoor closeOpenedDoorWith: aKey.! !
!Door methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:03:38'!
closeOpenedDoorWith: aKey

	state := ClosedDoor new.
	key := aKey.! !
!Door methodsFor: 'initialization' stamp: 'FG 12/17/2020 20:05:43'!
assertThat: aRoom isDifferentFrom: anotherRoom

	^ (aRoom = anotherRoom) ifTrue: [ self error: Door doorCannotBeInTheSameRoomTwice ]! !
!Door methodsFor: 'initialization' stamp: 'FG 12/17/2020 20:05:43' prior: 50903629!
initializeIn: aRoom at: aPosition and: anotherRoom at: anotherPosition thatOpensWith: aKey 
	
	self assertThat: aRoom isDifferentFrom: anotherRoom.
	(aKey isAKey) ifFalse: [ self error: Door cannotBeLockedWithANonKeyObject ].
	
	aRoom at: aPosition put: self.
	anotherRoom at: anotherPosition put: self.
	
	key := aKey.
	state := ClosedDoor new.
	firstRoom := aRoom.
	secondRoom := anotherRoom.! !
!Door methodsFor: 'initialization' stamp: 'FG 12/17/2020 20:06:42'!
assertIsValidKey: aKey

	^ (aKey isAKey) ifFalse: [ self error: Door cannotBeLockedWithANonKeyObject ]! !
!Door methodsFor: 'initialization' stamp: 'FG 12/17/2020 20:06:42' prior: 50903805!
initializeIn: aRoom at: aPosition and: anotherRoom at: anotherPosition thatOpensWith: aKey 
	
	self assertThat: aRoom isDifferentFrom: anotherRoom.
	self assertIsValidKey: aKey.
	
	aRoom at: aPosition put: self.
	anotherRoom at: anotherPosition put: self.
	
	key := aKey.
	state := ClosedDoor new.
	firstRoom := aRoom.
	secondRoom := anotherRoom.! !
!Door methodsFor: 'open' stamp: 'FG 12/17/2020 20:10:12'!
assertThatIsTheCorrectKey: aKey

	^ (key = aKey) ifFalse: [ self error: Door cannotOpenWithWrongKey]! !
!Door methodsFor: 'open' stamp: 'FG 12/17/2020 20:10:12' prior: 50903559!
openWith: aKey

	self assertThatIsTheCorrectKey: aKey.
	
	state openDoor: self.
	 ! !
!Door methodsFor: 'close' stamp: 'FG 12/17/2020 20:10:31' prior: 50903737!
closeWith: aKey

	self assertIsValidKey: aKey.
	
	state closeDoor: self with: aKey.
	 ! !
!DoorState methodsFor: 'nil' stamp: 'FG 12/17/2020 20:11:15'!
closeDoor: aDoor with: aKey
	self subclassResponsibility.! !
!DoorState methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:11:33'!
isClosed
	self subclassResponsibility.! !
!DoorState methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:11:47'!
openDoor: aDoor with: aKey
	self subclassResponsibility.! !
!DoorState methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:12:30'!
openDoor: aDoor
	self subclassResponsibility.! !

!methodRemoval: DoorState #openDoor:with: stamp: 'FG 12/17/2020 21:09:09'!
openDoor: aDoor with: aKey
	self subclassResponsibility.!
!DoorState methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:12:47'!
useDoor: aDoor from: aRoom
	self subclassResponsibility ! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:14:15' overrides: 16927572!
setUp
	
	||! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:14:48' prior: 50903884 overrides: 16927572!
setUp
	
	| room anotherRoom|
	
	room := Room ofWidth: 10 andHeight: 10.
	anotherRoom := Room ofWidth: 10 andHeight: 10. ! !

!classDefinition: #DoorTest category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:09:10'!
TestCase subclass: #DoorTest
	instanceVariableNames: 'asd asda'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!

!classDefinition: #DoorTest category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:09:10'!
TestCase subclass: #DoorTest
	instanceVariableNames: 'asd asda'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:18:38' prior: 50903888 overrides: 16927572!
setUp
	
	asd := Room ofWidth: 10 andHeight: 10.
	asda := Room ofWidth: 10 andHeight: 10. ! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:18:44' prior: 50903291!
test01DoorShouldBeInDifferentRooms

	| room |
	
	asd := Room ofWidth: 10 andHeight: 10. 
	
	self 
		should: [ Door in: room at: 1@1 and: room at:1@1 thatOpensWith: self correctKey]
		raise: Error - MessageNotUnderstood 
		withMessageText: Door doorCannotBeInTheSameRoomTwice.
	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:18:59' prior: 50903919!
test01DoorShouldBeInDifferentRooms

	| room |
	
	self 
		should: [ Door in: room at: 1@1 and: asd at:1@1 thatOpensWith: self correctKey]
		raise: Error - MessageNotUnderstood 
		withMessageText: Door doorCannotBeInTheSameRoomTwice.
	
	! !

!methodRemoval: DoorTest #setUp stamp: 'FG 12/17/2020 21:09:10'!
setUp
	
	asd := Room ofWidth: 10 andHeight: 10.
	asda := Room ofWidth: 10 andHeight: 10. !

!classDefinition: #DoorTest category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:09:10'!
TestCase subclass: #DoorTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!

!classDefinition: #DoorTest category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:09:10'!
TestCase subclass: #DoorTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:19:52' prior: 50903931!
test01DoorShouldBeInDifferentRooms

	| room |
	
	room := Room ofWidth: 10 andHeight: 10. 
	
	self 
		should: [ Door in: room at: 1@1 and: room at:1@1 thatOpensWith: self correctKey]
		raise: Error - MessageNotUnderstood 
		withMessageText: Door doorCannotBeInTheSameRoomTwice.
	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:20:11'!
room

	^ Room ofWidth: 10 andHeight: 10 ! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:20:19' prior: 50903963!
test01DoorShouldBeInDifferentRooms

	| room |
	
	room := self room. 
	
	self 
		should: [ Door in: room at: 1@1 and: room at:1@1 thatOpensWith: self correctKey]
		raise: Error - MessageNotUnderstood 
		withMessageText: Door doorCannotBeInTheSameRoomTwice.
	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:21:04' prior: 50903980!
test01DoorShouldBeInDifferentRooms

       |sameRoom|

	sameRoom := self room.

	self 
		should: [ Door in: sameRoom  at: 1@1 and: sameRoom at:1@1 thatOpensWith: self correctKey]
		raise: Error - MessageNotUnderstood 
		withMessageText: Door doorCannotBeInTheSameRoomTwice.
	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:22:18'!
shouldDo: aBlock failingAndRaising: anErrorMessage

	self 
		should: aBlock
		raise: Error - MessageNotUnderstood 
		withMessageText: anErrorMessage.
	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:22:55' prior: 50903992!
test01DoorShouldBeInDifferentRooms

       |sameRoom|

	sameRoom := self room.

	self 
		shouldDo: [ Door in: sameRoom  at: 1@1 and: sameRoom at:1@1 thatOpensWith: self correctKey]
		failingAndRaising: Door doorCannotBeInTheSameRoomTwice.
	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:23:09' prior: 50903329!
test02CannotPlaceDoorInInvalidPositionInAnyOfTheRooms

	| room1 room2 |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
	
	self 
		should: [ Door in: room1 at: -1@0 and: room2 at: 1@1 thatOpensWith: self correctKey ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Room invalidPositionErrorDescription.
		
	self 
		should: [ Door in: room1 at: 1@0 and: room2 at: -1@1 thatOpensWith: self correctKey ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Room invalidPositionErrorDescription.
	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:23:18' prior: 50904023!
test02CannotPlaceDoorInInvalidPositionInAnyOfTheRooms

	| room room2 |
	
	room := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
	
	self 
		should: [ Door in: room at: -1@0 and: room2 at: 1@1 thatOpensWith: self correctKey ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Room invalidPositionErrorDescription.
		
	self 
		should: [ Door in: room at: 1@0 and: room2 at: -1@1 thatOpensWith: self correctKey ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Room invalidPositionErrorDescription.
	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:23:28' prior: 50904044!
test02CannotPlaceDoorInInvalidPositionInAnyOfTheRooms

	| room anotherRoom |
	
	room := Room ofWidth: 10 andHeight: 10.
	anotherRoom := Room ofWidth: 10 andHeight: 10. 
	
	self 
		should: [ Door in: room at: -1@0 and: anotherRoom at: 1@1 thatOpensWith: self correctKey ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Room invalidPositionErrorDescription.
		
	self 
		should: [ Door in: room at: 1@0 and: anotherRoom at: -1@1 thatOpensWith: self correctKey ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Room invalidPositionErrorDescription.
	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:24:33' prior: 50904065!
test02CannotPlaceDoorInInvalidPositionInAnyOfTheRooms

	| room anotherRoom |
	
	room := Room ofWidth: 10 andHeight: 10.
	anotherRoom := Room ofWidth: 10 andHeight: 10. 
	
	self 
		shouldDo:  [ Door in: room at: -1@0 and: anotherRoom at: 1@1 thatOpensWith: self correctKey ]
		failingAndRaising: Room invalidPositionErrorDescription.
		
		
	self 
		shouldDo:  [ Door in: room at: 1@0 and: anotherRoom at: -1@1 thatOpensWith: self correctKey ]
		failingAndRaising: Room invalidPositionErrorDescription.
	
	! !

!methodRemoval: DoorTest #test02CannotPlaceDoorInInvalidPositionInAnyOfTheRooms stamp: 'FG 12/17/2020 21:09:11'!
test02CannotPlaceDoorInInvalidPositionInAnyOfTheRooms

	| room anotherRoom |
	
	room := Room ofWidth: 10 andHeight: 10.
	anotherRoom := Room ofWidth: 10 andHeight: 10. 
	
	self 
		shouldDo:  [ Door in: room at: -1@0 and: anotherRoom at: 1@1 thatOpensWith: self correctKey ]
		failingAndRaising: Room invalidPositionErrorDescription.
		
		
	self 
		shouldDo:  [ Door in: room at: 1@0 and: anotherRoom at: -1@1 thatOpensWith: self correctKey ]
		failingAndRaising: Room invalidPositionErrorDescription.
	
	!

!methodRemoval: DoorTest #test03CannotPlaceDoorInOcupiedPositionInAnyOfTheRooms stamp: 'FG 12/17/2020 21:09:11'!
test03CannotPlaceDoorInOcupiedPositionInAnyOfTheRooms

	| room1 room2 |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
	
	room1 at: 1@1 put: self paper.
	room2 at: 1@1 put: self paper. 
	
	self 
		should: [ Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: self correctKey ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Room positionIsNotEmptyErrorDescription.
		
	self 
		should: [ Door in: room1 at: 1@0 and: room2 at: 1@1 thatOpensWith: self correctKey ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Room positionIsNotEmptyErrorDescription.
	
	!
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:24:55'!
test03DoorIsInBothRooms

	| room1 room2 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: self correctKey.	
	
	self deny: (room1 isEmptyAt: 1@1).
	self deny: (room2 isEmptyAt: 0@1).
	self assert: (room1 at: 1@1) equals: door.
	self assert: (room2 at: 0@1) equals: door.  
	! !

!methodRemoval: DoorTest #test04DoorIsInBothRooms stamp: 'FG 12/17/2020 21:09:11'!
test04DoorIsInBothRooms

	| room1 room2 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: self correctKey.	
	
	self deny: (room1 isEmptyAt: 1@1).
	self deny: (room2 isEmptyAt: 0@1).
	self assert: (room1 at: 1@1) equals: door.
	self assert: (room2 at: 0@1) equals: door.  
	!
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:25:04'!
test04DoorLeadFromOneRoomToTheOther

	| room1 room2 door key |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	key := self correctKey.
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: key.
	door openWith: key.	
	
	self assert: (door useFrom: room1) equals: room2.
	self assert: (door useFrom: room2) equals: room1. ! !

!methodRemoval: DoorTest #test05DoorLeadFromOneRoomToTheOther stamp: 'FG 12/17/2020 21:09:11'!
test05DoorLeadFromOneRoomToTheOther

	| room1 room2 door key |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	key := self correctKey.
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: key.
	door openWith: key.	
	
	self assert: (door useFrom: room1) equals: room2.
	self assert: (door useFrom: room2) equals: room1. !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:25:16'!
test02DoorIsInBothRooms

	| room1 room2 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: self correctKey.	
	
	self deny: (room1 isEmptyAt: 1@1).
	self deny: (room2 isEmptyAt: 0@1).
	self assert: (room1 at: 1@1) equals: door.
	self assert: (room2 at: 0@1) equals: door.  
	! !

!methodRemoval: DoorTest #test03DoorIsInBothRooms stamp: 'FG 12/17/2020 21:09:11'!
test03DoorIsInBothRooms

	| room1 room2 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: self correctKey.	
	
	self deny: (room1 isEmptyAt: 1@1).
	self deny: (room2 isEmptyAt: 0@1).
	self assert: (room1 at: 1@1) equals: door.
	self assert: (room2 at: 0@1) equals: door.  
	!
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:25:22'!
test03DoorLeadFromOneRoomToTheOther

	| room1 room2 door key |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	key := self correctKey.
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: key.
	door openWith: key.	
	
	self assert: (door useFrom: room1) equals: room2.
	self assert: (door useFrom: room2) equals: room1. ! !

!methodRemoval: DoorTest #test04DoorLeadFromOneRoomToTheOther stamp: 'FG 12/17/2020 21:09:11'!
test04DoorLeadFromOneRoomToTheOther

	| room1 room2 door key |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	key := self correctKey.
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: key.
	door openWith: key.	
	
	self assert: (door useFrom: room1) equals: room2.
	self assert: (door useFrom: room2) equals: room1. !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:25:28'!
test04CannotMoveFromARoomWhichDoesntHasTheDoor

	| room1 room2 room3 door key |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
	room3 := Room 	ofWidth: 10 andHeight: 10.
	
	key := self correctKey.	
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: key.
	door openWith: key.	
	
	self 
		should: [ door useFrom: room3]
		raise: Error - MessageNotUnderstood 
		withMessageText: (Door cannotMoveFromARoomWithoutThisDoor).! !

!methodRemoval: DoorTest #test06CannotMoveFromARoomWhichDoesntHasTheDoor stamp: 'FG 12/17/2020 21:09:11'!
test06CannotMoveFromARoomWhichDoesntHasTheDoor

	| room1 room2 room3 door key |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
	room3 := Room 	ofWidth: 10 andHeight: 10.
	
	key := self correctKey.	
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: key.
	door openWith: key.	
	
	self 
		should: [ door useFrom: room3]
		raise: Error - MessageNotUnderstood 
		withMessageText: (Door cannotMoveFromARoomWithoutThisDoor).!
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:25:34'!
test05DoorStartsClosed

	| room1 room2 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: self correctKey.	
	
	self assert: door isClosed.! !

!methodRemoval: DoorTest #test07DoorStartsClosed stamp: 'FG 12/17/2020 21:09:12'!
test07DoorStartsClosed

	| room1 room2 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: self correctKey.	
	
	self assert: door isClosed.!
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:25:38'!
test06CannotUseAClosedDoor

	| room1 room2 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: self correctKey.	
	
	self 
		should: [ door useFrom: room1]
		raise: Error - MessageNotUnderstood 
		withMessageText: (Door cannotUseClosedDoor).
	
	! !

!methodRemoval: DoorTest #test08CannotUseAClosedDoor stamp: 'FG 12/17/2020 21:09:12'!
test08CannotUseAClosedDoor

	| room1 room2 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: self correctKey.	
	
	self 
		should: [ door useFrom: room1]
		raise: Error - MessageNotUnderstood 
		withMessageText: (Door cannotUseClosedDoor).
	
	!
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:25:47'!
test07CannotOpenDoorWithWrongKey

	| room1 room2 door |

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: self correctKey.	
	
	self 
		should: [ door openWith: self wrongKey ]
		raise: Error - MessageNotUnderstood 
		withMessageText: (Door cannotOpenWithWrongKey).
	

	

	

	
	! !

!methodRemoval: DoorTest #test09CannotOpenDoorWithWrongKey stamp: 'FG 12/17/2020 21:09:12'!
test09CannotOpenDoorWithWrongKey

	| room1 room2 door |

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: self correctKey.	
	
	self 
		should: [ door openWith: self wrongKey ]
		raise: Error - MessageNotUnderstood 
		withMessageText: (Door cannotOpenWithWrongKey).
	

	

	

	
	!
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:25:53'!
test08DoorOpensWithTheCorrectKey

	| room1 room2 door key |

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 

	key := self correctKey.	
			
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: key.	
	
	door openWith: key.
	
	self deny: door isClosed.	

	

	

	
	! !

!methodRemoval: DoorTest #test10DoorOpensWithTheCorrectKey stamp: 'FG 12/17/2020 21:09:12'!
test10DoorOpensWithTheCorrectKey

	| room1 room2 door key |

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 

	key := self correctKey.	
			
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: key.	
	
	door openWith: key.
	
	self deny: door isClosed.	

	

	

	
	!
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:25:58'!
test09CannotOpenAnAlreadyOpenDoor

	| room1 room2 door key |

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 

	key := self correctKey.	
			
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: key.	
	
	door openWith: key.
	
	self 
		should: [ door openWith: key ]
		raise: Error - MessageNotUnderstood 
		withMessageText: (Door doorAlreadyOpen).

	

	

	
	! !

!methodRemoval: DoorTest #test11CannotOpenAnAlreadyOpenDoor stamp: 'FG 12/17/2020 21:09:12'!
test11CannotOpenAnAlreadyOpenDoor

	| room1 room2 door key |

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 

	key := self correctKey.	
			
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: key.	
	
	door openWith: key.
	
	self 
		should: [ door openWith: key ]
		raise: Error - MessageNotUnderstood 
		withMessageText: (Door doorAlreadyOpen).

	

	

	
	!
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:26:03'!
test10ADoorCannotBeLockedWithAnyObjectThatIsNotAKey

	| room1 room2 |

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 	
		
	self 
		should: [ Door in: room1 at: 1@1  and: room2  at: 1@1  thatOpensWith: self paper ]
		raise: Error - MessageNotUnderstood 
		withMessageText: (Door cannotBeLockedWithANonKeyObject).

	
	

	

	
	! !

!methodRemoval: DoorTest #test12ADoorCannotBeLockedWithAnyObjectThatIsNotAKey stamp: 'FG 12/17/2020 21:09:12'!
test12ADoorCannotBeLockedWithAnyObjectThatIsNotAKey

	| room1 room2 |

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 	
		
	self 
		should: [ Door in: room1 at: 1@1  and: room2  at: 1@1  thatOpensWith: self paper ]
		raise: Error - MessageNotUnderstood 
		withMessageText: (Door cannotBeLockedWithANonKeyObject).

	
	

	

	
	!
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:26:08'!
test11CannotCloseDoorWithANonKeyObject

	| room1 room2 door key|

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 	
		
	key := self correctKey.	
	door := Door in: room1 at: 1@1  and: room2  at: 1@1  thatOpensWith: key.
	door openWith:	 key.
		
	self 
		should: [ door closeWith: self paper ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Door cannotBeLockedWithANonKeyObject.

	
	

	

	
	! !

!methodRemoval: DoorTest #test13CannotCloseDoorWithANonKeyObject stamp: 'FG 12/17/2020 21:09:12'!
test13CannotCloseDoorWithANonKeyObject

	| room1 room2 door key|

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 	
		
	key := self correctKey.	
	door := Door in: room1 at: 1@1  and: room2  at: 1@1  thatOpensWith: key.
	door openWith:	 key.
		
	self 
		should: [ door closeWith: self paper ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Door cannotBeLockedWithANonKeyObject.

	
	

	

	
	!
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:26:14'!
test12CannotCloseAClosedDoor

	| room1 room2 door key|

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 	
		
	key := self correctKey.	
	door := Door in: room1 at: 1@1  and: room2  at: 1@1  thatOpensWith: key.
		
	self 
		should: [ door closeWith: self correctKey ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Door doorAlreadyClosed.

	
	

	

	
	! !

!methodRemoval: DoorTest #test14CannotCloseAClosedDoor stamp: 'FG 12/17/2020 21:09:12'!
test14CannotCloseAClosedDoor

	| room1 room2 door key|

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 	
		
	key := self correctKey.	
	door := Door in: room1 at: 1@1  and: room2  at: 1@1  thatOpensWith: key.
		
	self 
		should: [ door closeWith: self correctKey ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Door doorAlreadyClosed.

	
	

	

	
	!
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:26:20'!
test13DoorCanBeClosedWithAKey

	| room1 room2 door key newKey|

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 	
		
	key := self correctKey.	
	door := Door in: room1 at: 1@1  and: room2  at: 1@1  thatOpensWith: key.
	door openWith: key.

	newKey := self wrongKey.
	door closeWith: newKey.
	
	self assert: door isClosed.
	
	door openWith: newKey.
	
	self deny: door isClosed	.
	
		
	

	

	
	! !

!methodRemoval: DoorTest #test15DoorCanBeClosedWithAKey stamp: 'FG 12/17/2020 21:09:13'!
test15DoorCanBeClosedWithAKey

	| room1 room2 door key newKey|

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 	
		
	key := self correctKey.	
	door := Door in: room1 at: 1@1  and: room2  at: 1@1  thatOpensWith: key.
	door openWith: key.

	newKey := self wrongKey.
	door closeWith: newKey.
	
	self assert: door isClosed.
	
	door openWith: newKey.
	
	self deny: door isClosed	.
	
		
	

	

	
	!
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:26:37' prior: 50904207!
test02DoorIsInBothRooms

	| room room2 door |
	
	room := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room at: 1@1 and: room2 at: 0@1 thatOpensWith: self correctKey.	
	
	self deny: (room isEmptyAt: 1@1).
	self deny: (room2 isEmptyAt: 0@1).
	self assert: (room at: 1@1) equals: door.
	self assert: (room2 at: 0@1) equals: door.  
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:26:57' prior: 50904564!
test02DoorIsInBothRooms

	| room anotherRoom door |
	
	room := Room ofWidth: 10 andHeight: 10.
	anotherRoom := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room at: 1@1 and: anotherRoom at: 0@1 thatOpensWith: self correctKey.	
	
	self deny: (room isEmptyAt: 1@1).
	self deny: (anotherRoom isEmptyAt: 0@1).
	self assert: (room at: 1@1) equals: door.
	self assert: (anotherRoom at: 0@1) equals: door.  
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:27:47' prior: 50904237!
test03DoorLeadFromOneRoomToTheOther

	| room anotherRoom door key |
	
	room := Room ofWidth: 10 andHeight: 10.
	anotherRoom := Room ofWidth: 10 andHeight: 10. 
		
	key := self correctKey.
	door := Door in: room at: 1@1 and: anotherRoom at: 0@1 thatOpensWith: key.
	door openWith: key.	
	
	self assert: (door useFrom: room) equals: anotherRoom.
	self assert: (door useFrom: anotherRoom) equals: room. ! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:28:20'!
openedDoor

	| room anotherRoom door key |
	
	room := Room ofWidth: 10 andHeight: 10.
	anotherRoom := Room ofWidth: 10 andHeight: 10. 
		
	key := self correctKey.
	door := Door in: room at: 1@1 and: anotherRoom at: 0@1 thatOpensWith: key.
	door openWith: key.	
	
	^ door! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:29:54' prior: 50904267!
test04CannotMoveFromARoomWhichDoesntHasTheDoor

	| room door |
	
	room := Room ofWidth: 10 andHeight: 10.
	
	door := self openedDoor.
	self 
		should: [ door useFrom: room]
		raise: Error - MessageNotUnderstood 
		withMessageText: (Door cannotMoveFromARoomWithoutThisDoor).! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:30:41' prior: 50904623!
test04CannotMoveFromARoomWhichDoesntHasTheDoor

	| room door |
	
	room := Room ofWidth: 10 andHeight: 10.
	
	door := self openedDoor.
	
	self 
		shouldDo: [ door useFrom: room] 
		failingAndRaising: Door cannotMoveFromARoomWithoutThisDoor
! !
!Room methodsFor: 'contents' stamp: 'FG 12/17/2020 20:36:04' prior: 50901981!
moveFrom: aSourcePosition to: aTargetPosition

	| toMove |
	
	((self at: aTargetPosition) isKindOf: Door) 
	ifTrue:[
	
	]
	ifFalse: [
		toMove := self at: aSourcePosition.
		self at: aTargetPosition put: toMove.
		contents removeKey: aSourcePosition.
	].
	! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'FG 12/17/2020 20:40:19'!
test21_playerShouldMoveFromRoomsWhenPassThroughADoor

	| room anotherRoom player box paper anotherPaper |

	room := self defaultRoom.
	anotherRoom := self defaultRoom.
	Door in: room at:  0@1 and: anotherRoom at: 0@1  thatOpensWith: self correctKey .
	player := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 0@0 heading: #North in: room.
	
	player moveForward.
	
	! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'FG 12/17/2020 20:42:03' prior: 50904657!
test21_playerShouldMoveFromRoomsWhenPassThroughADoor

	| room anotherRoom player box paper anotherPaper |

	room := self defaultRoom.
	anotherRoom := self defaultRoom.
	Door in: room at:  0@1 and: anotherRoom at: 0@1  thatOpensWith: self correctKey .
	player := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 0@0 heading: #North in: room.
	
	player moveForward.
	
	self assert: (anotherRoom at: 0@2) equals: player. 
	! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'FG 12/17/2020 20:42:13' prior: 50904672!
test21_playerShouldMoveFromRoomsWhenPassThroughADoor

	| room anotherRoom player |

	room := self defaultRoom.
	anotherRoom := self defaultRoom.
	Door in: room at:  0@1 and: anotherRoom at: 0@1  thatOpensWith: self correctKey .
	player := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 0@0 heading: #North in: room.
	
	player moveForward.
	
	self assert: (anotherRoom at: 0@2) equals: player. 
	! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'FG 12/17/2020 20:42:37'!
correctKey

	^ Keys named: 'Correct Key' weighing: 5 ! !
!Room methodsFor: 'contents' stamp: 'FG 12/17/2020 20:47:06' prior: 50904646!
moveFrom: aSourcePosition to: aTargetPosition

	| toMove |
	
		toMove := self at: aSourcePosition.
		self at: aTargetPosition put: toMove.
		contents removeKey: aSourcePosition.
	! !
!Room methodsFor: 'contents' stamp: 'FG 12/17/2020 20:50:22'!
moveAt: aPosition to: anotherRoom at: anotherPosition

	anotherRoom at: anotherPosition put: (self at: aPosition).
	contents removeKey: aPosition.! !
!PlayableCharacter methodsFor: 'moving' stamp: 'FG 12/17/2020 20:52:08' prior: 50901741!
moveForward
	
	self moveTo: self forwardPosition ! !
!PlayableCharacter methodsFor: 'moving' stamp: 'FG 12/17/2020 20:54:01' prior: 50901745!
moveTo: aNewPosition
	
	((room at: aNewPosition) isKindOf: Door)
	ifTrue:[
		room 
	]
	ifFalse:[
		room moveFrom: self position to: aNewPosition.
	] ! !
!PlayableCharacter methodsFor: 'moving' stamp: 'FG 12/17/2020 20:56:21' prior: 50904731!
moveTo: aNewPosition
	
	((room at: aNewPosition) isKindOf: Door)
	ifTrue:[
		room moveAt: (room positionOf: self) to: ((room at: aNewPosition) useFrom: room) at:  room
	]
	ifFalse:[
		room moveFrom: self position to: aNewPosition.
	] ! !
!PlayableCharacter methodsFor: 'moving' stamp: 'FG 12/17/2020 21:00:54' prior: 50904739!
moveTo: aNewPosition
	
	|newRoom|
	
	((room at: aNewPosition) isKindOf: Door)
	ifTrue:[
		newRoom := 	(room at: aNewPosition) useFrom: room.
		room moveAt: self position to: newRoom at: (newRoom positionOf: (room at: aNewPosition)).
	]
	ifFalse:[
		room moveFrom: self position to: aNewPosition.
	] ! !
!PlayableCharacter methodsFor: 'moving' stamp: 'FG 12/17/2020 21:01:19' prior: 50904750!
moveTo: aNewPosition
	
	|newRoom|
	
	((room at: aNewPosition) isKindOf: Door)
	ifTrue:[
		newRoom := 	(room at: aNewPosition) useFrom: room.
		room moveAt: self position to: newRoom at: (newRoom positionOf: (room at: aNewPosition) + heading forwardPoint).
	]
	ifFalse:[
		room moveFrom: self position to: aNewPosition.
	] ! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'FG 12/17/2020 21:02:53'!
openedDoor

	| room anotherRoom door key |
	
	room := Room ofWidth: 10 andHeight: 10.
	anotherRoom := Room ofWidth: 10 andHeight: 10. 
		
	key := self correctKey.
	door := Door in: room at: 1@1 and: anotherRoom at: 0@1 thatOpensWith: key.
	door openWith: key.	
	
	^ door! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'FG 12/17/2020 21:03:06' prior: 50904776!
openedDoor

	| room anotherRoom door key |
	
	room := Room ofWidth: 10 andHeight: 10.
	anotherRoom := Room ofWidth: 10 andHeight: 10. 
		
	key := self correctKey.
	door := self openedDoor.
	door openWith: key.	
	
	^ door! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'FG 12/17/2020 21:03:44' prior: 50904689!
test21_playerShouldMoveFromRoomsWhenPassThroughADoor

	| room anotherRoom player |

	room := self defaultRoom.
	anotherRoom := self defaultRoom.
	self openedDoor.
	player := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 0@0 heading: #North in: room.
	
	player moveForward.
	
	self assert: (anotherRoom at: 0@2) equals: player. 
	! !

----STARTUP---- (17 December 2020 21:11:07) as C:\Users\FACU PC\Documents\Clases Virtuales\Cosas IS 1\Cuis University\CuisUniversity-4384.image!


!classDefinition: #BackpackTest category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:11:10'!
TestCase subclass: #BackpackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classDefinition: #BackpackTest category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:11:10'!
TestCase subclass: #BackpackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:29:03'!
assertShouldAddAll: portableObjects withPoints: expectedTotalPoints

	| aBackpack |
	
	aBackpack := Backpack containingUpTo: self backpackWeight limitingPointsTo: 100.

	portableObjects do: [ :aPortableObject | aBackpack add: aPortableObject ].
	
	self assert: aBackpack size equals: portableObjects size.
	self assert: aBackpack totalWeight equals: (portableObjects sum: [ :aPortableObject | aPortableObject weight ]).
	self assert: aBackpack totalPoints equals: expectedTotalPoints.
! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:28:32'!
assertShouldNotAddPortableObjectIfWeightExceeded: aPortableObject

	| aBackpack |
	aBackpack := Backpack containingUpTo: self backpackWeight limitingPointsTo: 100.

	self
		should: [ aBackpack add: aPortableObject ]
		raise: Error
		withMessageText: Backpack maxWeightExceededErrorDescription.
		
	self assert: aBackpack isEmpty. 
! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:28:32'!
backpackWeight

	^ 42! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:28:41'!
test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded

	self assertShouldNotAddPortableObjectIfWeightExceeded: 
		(NoPointsPortableObject named: 'help-wanted sign' weighing: self backpackWeight + 1)
! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:28:47'!
test08ShouldNotAddPointsPortableObjectIfWeightExceeded

	self assertShouldNotAddPortableObjectIfWeightExceeded: 
		(PointsPortableObject named: 'left-handed hammer' weighing: self backpackWeight + 6 worth: 5) ! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:26:42'!
test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity

	self 
		assertShouldAddAll: self twoPortableObjects
		withPoints: 5.
! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:27:27'!
test10ShouldAddPortableObjectsIfWeightEqualsMaxWeightCapacity

	self 
		assertShouldAddAll:  self twoPortableObjects, {(PointsPortableObject named: 'letter' weighing: 1 worth: 5)}
		withPoints: 10.
! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:27:39'!
twoPortableObjects

	^ {
		(PointsPortableObject named: 'left-handed hammer' weighing: 40 worth: 5).
		(NoPointsPortableObject named: 'help-wanted sign' weighing: 1) }! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04'!
test01CanNotCreateBackpackWithZeroMaxWeight

	self
		should: [ Backpack containingUpTo: 0 limitingPointsTo: 100 ]
		raise: Error
		withMessageText: Backpack invalidWeightCapacityErrorDescription.
! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04'!
test02CanNotCreateBackpackWithNegativeMaxWeight

	self
		should: [ Backpack containingUpTo: -1 limitingPointsTo: 100 ]
		raise: Error
		withMessageText: Backpack invalidWeightCapacityErrorDescription.! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04'!
test03CanNotCreateBackpackWithZeroMaxPoints

	self
		should: [ Backpack containingUpTo: 10 limitingPointsTo: 0 ]
		raise: Error
		withMessageText: Backpack invalidPointsCapacityErrorDescription.
! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04'!
test04CanNotCreateBackpackWithNegativeMaxPoints

	self
		should: [ Backpack containingUpTo: 10 limitingPointsTo: -1 ]
		raise: Error
		withMessageText: Backpack invalidPointsCapacityErrorDescription.! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04'!
test05CanNotCreateBackpackWithNoIntegerMaxWeight

	self
		should: [ Backpack containingUpTo: 1.0 limitingPointsTo: 100 ]
		raise: Error
		withMessageText: Backpack weightCapacityMustBeIntegerErrorDescription.
! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04'!
test06CanNotCreateBackpackWithNoIntegerMaxPoints

	self
		should: [ Backpack containingUpTo: 100 limitingPointsTo: 1.0 ]
		raise: Error
		withMessageText: Backpack pointsCapacityMustBeIntegerErrorDescription.
! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:49:20'!
test11ShouldAddZeroWeightWhenEmpty

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	self assert: aBackpack totalWeight equals: 0.
	self assert: aBackpack isEmpty
! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:35:57'!
test12ShouldAddWeightWhenAddingPortableObjects

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	aBackpack add: (PointsPortableObject named: 'left-handed hammer' weighing: 10 worth: 5).
	aBackpack add: (NoPointsPortableObject named: 'help-wanted sign' weighing: 10).
	
	self assert: aBackpack size equals: 2.
	self assert: aBackpack totalWeight equals: 20.

! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:49:31'!
test13ShouldAddZeroPointsWhenEmpty

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	self assert: aBackpack totalPoints equals: 0.
	self assert: aBackpack isEmpty.
! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:35:57'!
test14ShouldAddPointsWhenAddingPointsPortableObjects

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	aBackpack add: (PointsPortableObject named: 'left-handed hammer' weighing: 10 worth: 5).
	aBackpack add: (PointsPortableObject named: 'car key' weighing: 10 worth: 20).
	
	self assert: aBackpack size equals: 2.
	self assert: aBackpack totalPoints equals: 25.

! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:35:57'!
test15ShouldNotAddPointsWhenAddingNoPointsPortableObjects

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	aBackpack add: (PointsPortableObject named: 'left-handed hammer' weighing: 10 worth: 5).
	aBackpack add: (NoPointsPortableObject named: 'help-wanted sign' weighing: 10).
	aBackpack add: (NoPointsPortableObject named: 'help-wanted sign' weighing: 10).
	
	self assert: aBackpack size equals: 3.
	self assert: aBackpack totalPoints equals: 5.

! !

!classDefinition: #PlayableCharacterTest category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:11:12'!
TestCase subclass: #PlayableCharacterTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classDefinition: #PlayableCharacterTest category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:11:12'!
TestCase subclass: #PlayableCharacterTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/9/2020 19:36:13'!
test01_forwardWhenHeadingNorthIncrementsYCoordinate

	| playableCharacter |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 1@2 heading: #North .

	playableCharacter moveForward.

	self assert: (playableCharacter isAt: 1@3 heading: #North)! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/9/2020 19:36:13'!
test02_backwardWhenHeadingNorthDecrementsYCoordinate

	| playableCharacter |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 1@2 heading: #North .

	playableCharacter moveBackward.

	self assert: (playableCharacter isAt: 1@1 heading: #North)! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/9/2020 19:36:13'!
test03_rotateRightWhenHeadingNorthHeadsEast

	| playableCharacter |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 1@2 heading: #North .

	playableCharacter rotateRight.

	self assert: (playableCharacter isAt: 1@2 heading: #East)! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/9/2020 19:36:13'!
test04_rotateLeftWhenHeadingNorthHeadsWest

	| playableCharacter |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 1@2 heading: #North .

	playableCharacter rotateLeft.

	self assert: (playableCharacter isAt: 1@2 heading: #West)! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/9/2020 19:36:13'!
test05_movingWhenHeadingEastWorksAsExpected

	| playableCharacter |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 1@2 heading: #East .

	playableCharacter
		moveForward;
		moveForward;
		moveBackward;
		rotateRight;
		rotateLeft;
		rotateLeft.

	self assert: (playableCharacter isAt: 2@2 heading: #North)! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/9/2020 19:36:13'!
test06_movingWhenHeadingSouthWorksAsExpected

	| playableCharacter |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 1@2 heading: #South .

	playableCharacter
		moveForward;
		moveForward;
		moveBackward;
		rotateRight;
		rotateLeft;
		rotateLeft.

	self assert: (playableCharacter isAt: 1@1 heading: #East)! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/9/2020 19:36:13'!
test07_movingWhenHeadingWestWorksAsExpected

	| playableCharacter |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 2@2 heading: #West .

	playableCharacter
		moveForward;
		moveForward;
		moveBackward;
		rotateRight;
		rotateLeft;
		rotateLeft.

	self assert: (playableCharacter isAt: 1@2 heading: #South)! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/9/2020 19:36:13'!
test08_canNotCreatePlayableCharacterWhenHeadingIsNotValid

	self
		should: [PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 1@2 heading: #X ]
		raise: Error
		withExceptionDo: [:anError |
			self assert: PlayableCharacter invalidCardinalPointErrorDescription equals: anError messageText ]! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/9/2020 19:43:14'!
test09_canTakePortableObjects

	| playableCharacter paper |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 2@2 heading: #West .
	paper := NoPointsPortableObject named: 'Paper' weighing: 1.
	
	playableCharacter take: paper.
	
	self assert: (playableCharacter backpackIncludes: paper)! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/9/2020 19:47:21'!
test10_canNotTakeMoreObjectsThanTheBackpackCanCarry

	| playableCharacter paper key |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 2@2 heading: #West .
	paper := NoPointsPortableObject named: 'Paper' weighing: 100.
	key := NoPointsPortableObject named: 'Key' weighing: 1.
	
	playableCharacter take: paper.
	self 
		should: [ playableCharacter take: key ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [:anError |
			self assert: Backpack maxWeightExceededErrorDescription equals: anError messageText.
			self assert: (playableCharacter backpackIncludes: paper).
			self deny: (playableCharacter backpackIncludes: key) ]
	
	! !
!PlayableCharacterTest methodsFor: 'as yet unclassified' stamp: 'HAW 12/9/2020 13:53:29'!
defaultBackpack

	^ Backpack containingUpTo: 100 limitingPointsTo: 100 ! !

!classDefinition: #Backpack category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:11:12'!
Object subclass: #Backpack
	instanceVariableNames: 'weightCapacity gamePointsCapacity container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classDefinition: #Backpack category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:11:12'!
Object subclass: #Backpack
	instanceVariableNames: 'weightCapacity gamePointsCapacity container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!
!Backpack methodsFor: 'exceptions' stamp: 'FRT 10/8/2020 18:02:29'!
signalMaxPointsExceeded

	self error: self class maxPointsExceededErrorDescription ! !
!Backpack methodsFor: 'exceptions' stamp: 'FRT 10/8/2020 18:02:47'!
signalMaxWeightExceeded

	self error: self class maxWeightExceededErrorDescription ! !
!Backpack methodsFor: 'initialization' stamp: 'HAW 10/14/2020 14:31:56'!
initializeContainingUpTo: aWeightCapacity limitingPointsTo: pointsCapacity

	weightCapacity := aWeightCapacity.
	gamePointsCapacity := pointsCapacity.
	
	container := OrderedCollection new.
	
	
	! !
!Backpack methodsFor: 'accessing' stamp: 'FRT 10/11/2020 19:14:47' overrides: 16880927!
size

	^ container size.! !
!Backpack methodsFor: 'accessing' stamp: 'HAW 10/18/2020 12:20:52'!
totalPoints
		
	^(container select: [ :portableObject | portableObject doesItAddPoints ])	
		sum: [ :portableObject | portableObject points ]
		ifEmpty: [ 0 ]! !
!Backpack methodsFor: 'accessing' stamp: 'HAW 10/18/2020 12:20:20'!
totalWeight
	
	^container 
		sum: [ :portableObject | portableObject weight ]
		ifEmpty: [ 0 ]
		! !
!Backpack methodsFor: 'assertions' stamp: 'FRT 10/12/2020 14:12:36'!
assertPointsAdding: aPointsPortableObject

	(self totalPoints + aPointsPortableObject points) > gamePointsCapacity ifTrue: [ self signalMaxPointsExceeded ]! !
!Backpack methodsFor: 'assertions' stamp: 'FRT 10/15/2020 12:22:34'!
assertWeightAdding: aPortableObject tolerating: aThreshold

	(self totalWeight + aPortableObject weight - weightCapacity) > aThreshold ifTrue: [ self signalMaxWeightExceeded ]! !
!Backpack methodsFor: 'adding' stamp: 'HAW 10/18/2020 12:28:24'!
add: aPortableObject
	
	aPortableObject assertCanAddTo: self.
	
	container add: aPortableObject.
	! !
!Backpack methodsFor: 'testing' stamp: 'HAW 12/9/2020 19:44:17'!
includes: aPortableObject 
	
	^container includes: aPortableObject ! !
!Backpack methodsFor: 'testing' stamp: 'FRT 10/11/2020 18:38:38'!
isEmpty

	^ container isEmpty.! !
!Backpack methodsFor: 'adding - private' stamp: 'HAW 10/18/2020 12:28:48'!
assertCanAddNoPointsPortableObject: aNoPointsPortableObject 
	
	self assertWeightAdding: aNoPointsPortableObject tolerating: 0.
	! !
!Backpack methodsFor: 'adding - private' stamp: 'HAW 10/18/2020 12:29:07'!
assertCanAddPointPortableObject: aPointsPortableObject 
	
	self assertWeightAdding: aPointsPortableObject tolerating: 5.
	self assertPointsAdding: aPointsPortableObject.
	! !

!classDefinition: 'Backpack class' category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:11:13'!
Backpack class
	instanceVariableNames: ''!

!classDefinition: 'Backpack class' category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:11:13'!
Backpack class
	instanceVariableNames: ''!
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 18:27:33'!
invalidPointsCapacityErrorDescription

	^ 'Points capacity must be positive'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 18:21:04'!
invalidWeightCapacityErrorDescription

	^ 'Weight capacity must be positive'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/8/2020 17:36:29'!
maxPointsExceededErrorDescription

	^ 'Maximum points has been exceeded'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/8/2020 17:36:17'!
maxWeightExceededErrorDescription

	^ 'Maximum weight has been exceeded'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/8/2020 17:43:00'!
pointsCapacityMustBeIntegerErrorDescription

	^ 'Points capacity must be integer'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/8/2020 17:42:48'!
weightCapacityMustBeIntegerErrorDescription

	^ 'Weight capacity must be integer'! !
!Backpack class methodsFor: 'exceptions' stamp: 'FRT 10/11/2020 18:27:16'!
signalInvalidPointsCapacity

	self error: self invalidPointsCapacityErrorDescription 
! !
!Backpack class methodsFor: 'exceptions' stamp: 'FRT 10/11/2020 18:21:51'!
signalInvalidWeightCapacity

	self error: self invalidWeightCapacityErrorDescription 
! !
!Backpack class methodsFor: 'exceptions' stamp: 'FRT 10/8/2020 17:41:06'!
signalPointsCapacityMustBeInteger

	self error: self pointsCapacityMustBeIntegerErrorDescription
! !
!Backpack class methodsFor: 'exceptions' stamp: 'FRT 10/8/2020 17:40:47'!
signalWeightCapacityMustBeInteger

	self error: self weightCapacityMustBeIntegerErrorDescription
! !
!Backpack class methodsFor: 'instance creation' stamp: 'HAW 10/14/2020 14:31:56'!
containingUpTo: aWeightCapacity limitingPointsTo: pointsCapacity

	aWeightCapacity strictlyPositive  ifFalse: [ self signalInvalidWeightCapacity ].
	pointsCapacity strictlyPositive ifFalse: [ self signalInvalidPointsCapacity ].
	
	aWeightCapacity isInteger ifFalse: [ self signalWeightCapacityMustBeInteger ].
	pointsCapacity isInteger ifFalse: [ self signalPointsCapacityMustBeInteger ].
	
	^ self new initializeContainingUpTo: aWeightCapacity limitingPointsTo: pointsCapacity.
! !

!classDefinition: #PlayableCharacter category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:11:14'!
Object subclass: #PlayableCharacter
	instanceVariableNames: 'position heading backpack name'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classDefinition: #PlayableCharacter category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:11:14'!
Object subclass: #PlayableCharacter
	instanceVariableNames: 'position heading backpack name'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!
!PlayableCharacter methodsFor: 'initialization' stamp: 'HAW 12/9/2020 19:35:22'!
initializeNamed: aName using: aBackpack at: aPosition heading: aMarsRoverHeading 

	name := aName.
	backpack := aBackpack.
	position := aPosition.
	heading := aMarsRoverHeading! !
!PlayableCharacter methodsFor: 'testing' stamp: 'HAW 12/9/2020 19:43:44'!
backpackIncludes: aPortableObject 
	
	^backpack includes: aPortableObject ! !
!PlayableCharacter methodsFor: 'testing' stamp: 'HAW 7/1/2018 14:25:05'!
isAt: aPosition heading: aCardinalPoint

	^position = aPosition and: [ heading cardinalPoint = aCardinalPoint ]! !
!PlayableCharacter methodsFor: 'moving' stamp: 'HAW 10/11/2019 08:22:42'!
moveBackward
	
	position := position - heading forwardPoint ! !
!PlayableCharacter methodsFor: 'moving' stamp: 'HAW 10/11/2019 08:21:58'!
moveForward
	
	position := position + heading forwardPoint! !
!PlayableCharacter methodsFor: 'rotating' stamp: 'HAW 10/11/2019 08:31:55'!
rotateLeft
	
	heading := heading leftHeading! !
!PlayableCharacter methodsFor: 'rotating' stamp: 'HAW 10/11/2019 08:32:04'!
rotateRight
	
	heading := heading rightHeading! !
!PlayableCharacter methodsFor: 'taking objects' stamp: 'HAW 12/9/2020 19:28:57'!
take: aPortableObject

	backpack add: aPortableObject.! !

!classDefinition: 'PlayableCharacter class' category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:11:14'!
PlayableCharacter class
	instanceVariableNames: 'headings'!

!classDefinition: 'PlayableCharacter class' category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:11:14'!
PlayableCharacter class
	instanceVariableNames: 'headings'!
!PlayableCharacter class methodsFor: 'heading' stamp: 'HAW 7/2/2018 16:28:16'!
headingFor: aCardinalPoint
	
	^headings at: aCardinalPoint ifAbsent: [ self error: self invalidCardinalPointErrorDescription ]! !
!PlayableCharacter class methodsFor: 'heading' stamp: 'HAW 7/2/2018 16:26:14'!
invalidCardinalPointErrorDescription
	
	^'Invalid cardinal point'! !
!PlayableCharacter class methodsFor: 'instance creation' stamp: 'HAW 12/9/2020 19:36:13'!
named: aName using: aBackpack at: aPosition heading: aCardinalPoint 
	
	| newHeading |

	newHeading := self headingFor: aCardinalPoint.
	
	^self new initializeNamed: aName using: aBackpack at: aPosition heading: newHeading ! !
!PlayableCharacter class methodsFor: 'initialization' stamp: 'HAW 10/11/2019 08:37:25'!
forHeadingAt: aCardinalPoint leftIs: aLeftCardinalPoint rightIs: aRightCardinalPoint
	
	(headings at: aCardinalPoint) leftHeading: (headings at: aLeftCardinalPoint) rightHeading: (headings at: aRightCardinalPoint).
	! !
!PlayableCharacter class methodsFor: 'initialization' stamp: 'HAW 7/2/2018 15:27:41' overrides: 16883149!
initialize

	self initializeHeadings! !
!PlayableCharacter class methodsFor: 'initialization' stamp: 'HAW 12/9/2020 19:31:43'!
initializeHeadings

	headings := Dictionary new.
	
	(OrderedCollection 
		with: (PlayableCharacterHeading for: #North forwardWith: 0@1 )	
		with: (PlayableCharacterHeading for: #East forwardWith: 1@0 )
		with: (PlayableCharacterHeading for: #South forwardWith: 0@-1 )
		with: (PlayableCharacterHeading for: #West forwardWith: -1@0 ))
			do: [ :heading | headings at: heading cardinalPoint put: heading ].
	
	self 
		forHeadingAt: #North leftIs: #West rightIs: #East;
		forHeadingAt: #South leftIs: #East rightIs: #West;
		forHeadingAt: #East leftIs: #North rightIs: #South;
		forHeadingAt: #West leftIs: #South rightIs: #North.
	! !

!classDefinition: #PlayableCharacterHeading category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:11:15'!
Object subclass: #PlayableCharacterHeading
	instanceVariableNames: 'cardinalPoint forwardPoint rightHeading leftHeading'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classDefinition: #PlayableCharacterHeading category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:11:15'!
Object subclass: #PlayableCharacterHeading
	instanceVariableNames: 'cardinalPoint forwardPoint rightHeading leftHeading'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!
!PlayableCharacterHeading methodsFor: 'accessing' stamp: 'HAW 7/2/2018 15:29:44'!
cardinalPoint
	
	^cardinalPoint! !
!PlayableCharacterHeading methodsFor: 'accessing' stamp: 'HAW 7/2/2018 15:30:39'!
forwardPoint
	
	^forwardPoint! !
!PlayableCharacterHeading methodsFor: 'accessing' stamp: 'HAW 10/11/2019 08:31:33'!
leftHeading
	
	^leftHeading! !
!PlayableCharacterHeading methodsFor: 'accessing' stamp: 'HAW 10/11/2019 08:31:27'!
rightHeading
	
	^rightHeading! !
!PlayableCharacterHeading methodsFor: 'initialization' stamp: 'HAW 10/11/2019 08:27:25'!
initializeFor: aCardinalPoint forwardWith: aForwardPoint  
	
	cardinalPoint := aCardinalPoint.
	forwardPoint := aForwardPoint.
! !
!PlayableCharacterHeading methodsFor: 'initialization' stamp: 'HAW 10/11/2019 08:31:33'!
leftHeading: aLeftHeading rightHeading: aRightHeading
 
	leftHeading := aLeftHeading.
	rightHeading := aRightHeading ! !

!classDefinition: 'PlayableCharacterHeading class' category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:11:15'!
PlayableCharacterHeading class
	instanceVariableNames: ''!

!classDefinition: 'PlayableCharacterHeading class' category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:11:15'!
PlayableCharacterHeading class
	instanceVariableNames: ''!
!PlayableCharacterHeading class methodsFor: 'instance creation' stamp: 'HAW 10/11/2019 08:27:46'!
for: aCardinalPoint forwardWith: aForwardPoint  

	^self new initializeFor: aCardinalPoint forwardWith: aForwardPoint ! !

!classDefinition: #StageObject category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:11:15'!
Object subclass: #StageObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classDefinition: #StageObject category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:11:15'!
Object subclass: #StageObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classDefinition: #PortableObject category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:11:15'!
StageObject subclass: #PortableObject
	instanceVariableNames: 'name weight'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classDefinition: #PortableObject category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:11:15'!
StageObject subclass: #PortableObject
	instanceVariableNames: 'name weight'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!
!PortableObject methodsFor: 'testing' stamp: 'FRT 10/11/2020 17:54:20'!
doesItAddPoints

	self subclassResponsibility	! !
!PortableObject methodsFor: 'adding' stamp: 'HAW 10/18/2020 12:28:24'!
assertCanAddTo: aBackpack

	self subclassResponsibility	! !
!PortableObject methodsFor: 'accessing' stamp: 'FRT 10/11/2020 18:53:51'!
weight

	^ weight! !

!classDefinition: #NoPointsPortableObject category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:11:16'!
PortableObject subclass: #NoPointsPortableObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classDefinition: #NoPointsPortableObject category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:11:16'!
PortableObject subclass: #NoPointsPortableObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!
!NoPointsPortableObject methodsFor: 'initialization' stamp: 'HAW 10/14/2020 14:34:36'!
initializeNamed: aName weighing: aWeight
	
	name := aName.
	weight := aWeight.! !
!NoPointsPortableObject methodsFor: 'testing' stamp: 'FRT 10/11/2020 17:54:20' overrides: 50905603!
doesItAddPoints	

	^ false! !
!NoPointsPortableObject methodsFor: 'adding' stamp: 'HAW 10/18/2020 12:28:48' overrides: 50905607!
assertCanAddTo: aBackpack 
	
	^aBackpack assertCanAddNoPointsPortableObject: self! !

!classDefinition: 'NoPointsPortableObject class' category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:11:16'!
NoPointsPortableObject class
	instanceVariableNames: ''!

!classDefinition: 'NoPointsPortableObject class' category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:11:16'!
NoPointsPortableObject class
	instanceVariableNames: ''!
!NoPointsPortableObject class methodsFor: 'instance creation' stamp: 'HAW 10/14/2020 14:34:36'!
named: aName weighing: aWeight
	
	^ self new initializeNamed: aName weighing: aWeight. ! !

!classDefinition: #PointsPortableObject category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:11:16'!
PortableObject subclass: #PointsPortableObject
	instanceVariableNames: 'points'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classDefinition: #PointsPortableObject category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:11:16'!
PortableObject subclass: #PointsPortableObject
	instanceVariableNames: 'points'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!
!PointsPortableObject methodsFor: 'testing' stamp: 'FRT 10/11/2020 17:54:20' overrides: 50905603!
doesItAddPoints

	^ true! !
!PointsPortableObject methodsFor: 'initialization' stamp: 'HAW 10/14/2020 14:36:26'!
initializeNamed: aName weighing: aWeight worth: gamePoints
	
	name := aName.
	weight := aWeight.
	points := gamePoints.! !
!PointsPortableObject methodsFor: 'accessing' stamp: 'FRT 10/11/2020 19:06:57'!
points

	^ points! !
!PointsPortableObject methodsFor: 'adding' stamp: 'HAW 10/18/2020 12:29:07' overrides: 50905607!
assertCanAddTo: aBackpack 
	
	^aBackpack assertCanAddPointPortableObject: self! !

!classDefinition: 'PointsPortableObject class' category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:11:16'!
PointsPortableObject class
	instanceVariableNames: ''!

!classDefinition: 'PointsPortableObject class' category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:11:16'!
PointsPortableObject class
	instanceVariableNames: ''!
!PointsPortableObject class methodsFor: 'instance creation' stamp: 'HAW 10/14/2020 14:36:26'!
named: aName weighing: aWeight worth: gamePoints
	
	^ self new initializeNamed: aName weighing: aWeight worth: gamePoints.! !

!classDefinition: #BackpackTest category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:11:16'!
TestCase subclass: #BackpackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classDefinition: #BackpackTest category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:11:16'!
TestCase subclass: #BackpackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:29:03' prior: 50904832!
assertShouldAddAll: portableObjects withPoints: expectedTotalPoints

	| aBackpack |
	
	aBackpack := Backpack containingUpTo: self backpackWeight limitingPointsTo: 100.

	portableObjects do: [ :aPortableObject | aBackpack add: aPortableObject ].
	
	self assert: aBackpack size equals: portableObjects size.
	self assert: aBackpack totalWeight equals: (portableObjects sum: [ :aPortableObject | aPortableObject weight ]).
	self assert: aBackpack totalPoints equals: expectedTotalPoints.
! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:28:32' prior: 50904850!
assertShouldNotAddPortableObjectIfWeightExceeded: aPortableObject

	| aBackpack |
	aBackpack := Backpack containingUpTo: self backpackWeight limitingPointsTo: 100.

	self
		should: [ aBackpack add: aPortableObject ]
		raise: Error
		withMessageText: Backpack maxWeightExceededErrorDescription.
		
	self assert: aBackpack isEmpty. 
! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:28:32' prior: 50904863!
backpackWeight

	^ 42! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:28:41' prior: 50904866!
test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded

	self assertShouldNotAddPortableObjectIfWeightExceeded: 
		(NoPointsPortableObject named: 'help-wanted sign' weighing: self backpackWeight + 1)
! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:28:47' prior: 50904875!
test08ShouldNotAddPointsPortableObjectIfWeightExceeded

	self assertShouldNotAddPortableObjectIfWeightExceeded: 
		(PointsPortableObject named: 'left-handed hammer' weighing: self backpackWeight + 6 worth: 5) ! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:26:42' prior: 50904884!
test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity

	self 
		assertShouldAddAll: self twoPortableObjects
		withPoints: 5.
! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:27:27' prior: 50904891!
test10ShouldAddPortableObjectsIfWeightEqualsMaxWeightCapacity

	self 
		assertShouldAddAll:  self twoPortableObjects, {(PointsPortableObject named: 'letter' weighing: 1 worth: 5)}
		withPoints: 10.
! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:27:39' prior: 50904900!
twoPortableObjects

	^ {
		(PointsPortableObject named: 'left-handed hammer' weighing: 40 worth: 5).
		(NoPointsPortableObject named: 'help-wanted sign' weighing: 1) }! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04' prior: 50904908!
test01CanNotCreateBackpackWithZeroMaxWeight

	self
		should: [ Backpack containingUpTo: 0 limitingPointsTo: 100 ]
		raise: Error
		withMessageText: Backpack invalidWeightCapacityErrorDescription.
! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04' prior: 50904917!
test02CanNotCreateBackpackWithNegativeMaxWeight

	self
		should: [ Backpack containingUpTo: -1 limitingPointsTo: 100 ]
		raise: Error
		withMessageText: Backpack invalidWeightCapacityErrorDescription.! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04' prior: 50904926!
test03CanNotCreateBackpackWithZeroMaxPoints

	self
		should: [ Backpack containingUpTo: 10 limitingPointsTo: 0 ]
		raise: Error
		withMessageText: Backpack invalidPointsCapacityErrorDescription.
! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04' prior: 50904935!
test04CanNotCreateBackpackWithNegativeMaxPoints

	self
		should: [ Backpack containingUpTo: 10 limitingPointsTo: -1 ]
		raise: Error
		withMessageText: Backpack invalidPointsCapacityErrorDescription.! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04' prior: 50904944!
test05CanNotCreateBackpackWithNoIntegerMaxWeight

	self
		should: [ Backpack containingUpTo: 1.0 limitingPointsTo: 100 ]
		raise: Error
		withMessageText: Backpack weightCapacityMustBeIntegerErrorDescription.
! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04' prior: 50904953!
test06CanNotCreateBackpackWithNoIntegerMaxPoints

	self
		should: [ Backpack containingUpTo: 100 limitingPointsTo: 1.0 ]
		raise: Error
		withMessageText: Backpack pointsCapacityMustBeIntegerErrorDescription.
! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:49:20' prior: 50904962!
test11ShouldAddZeroWeightWhenEmpty

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	self assert: aBackpack totalWeight equals: 0.
	self assert: aBackpack isEmpty
! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:35:57' prior: 50904971!
test12ShouldAddWeightWhenAddingPortableObjects

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	aBackpack add: (PointsPortableObject named: 'left-handed hammer' weighing: 10 worth: 5).
	aBackpack add: (NoPointsPortableObject named: 'help-wanted sign' weighing: 10).
	
	self assert: aBackpack size equals: 2.
	self assert: aBackpack totalWeight equals: 20.

! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:49:31' prior: 50904986!
test13ShouldAddZeroPointsWhenEmpty

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	self assert: aBackpack totalPoints equals: 0.
	self assert: aBackpack isEmpty.
! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:35:57' prior: 50904995!
test14ShouldAddPointsWhenAddingPointsPortableObjects

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	aBackpack add: (PointsPortableObject named: 'left-handed hammer' weighing: 10 worth: 5).
	aBackpack add: (PointsPortableObject named: 'car key' weighing: 10 worth: 20).
	
	self assert: aBackpack size equals: 2.
	self assert: aBackpack totalPoints equals: 25.

! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:35:57' prior: 50905010!
test15ShouldNotAddPointsWhenAddingNoPointsPortableObjects

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	aBackpack add: (PointsPortableObject named: 'left-handed hammer' weighing: 10 worth: 5).
	aBackpack add: (NoPointsPortableObject named: 'help-wanted sign' weighing: 10).
	aBackpack add: (NoPointsPortableObject named: 'help-wanted sign' weighing: 10).
	
	self assert: aBackpack size equals: 3.
	self assert: aBackpack totalPoints equals: 5.

! !

!classDefinition: #PlayableCharacterTest category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:11:17'!
TestCase subclass: #PlayableCharacterTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classDefinition: #PlayableCharacterTest category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:11:17'!
TestCase subclass: #PlayableCharacterTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/9/2020 19:36:13' prior: 50905045!
test01_forwardWhenHeadingNorthIncrementsYCoordinate

	| playableCharacter |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 1@2 heading: #North .

	playableCharacter moveForward.

	self assert: (playableCharacter isAt: 1@3 heading: #North)! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/9/2020 19:36:13' prior: 50905057!
test02_backwardWhenHeadingNorthDecrementsYCoordinate

	| playableCharacter |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 1@2 heading: #North .

	playableCharacter moveBackward.

	self assert: (playableCharacter isAt: 1@1 heading: #North)! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/9/2020 19:36:13' prior: 50905069!
test03_rotateRightWhenHeadingNorthHeadsEast

	| playableCharacter |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 1@2 heading: #North .

	playableCharacter rotateRight.

	self assert: (playableCharacter isAt: 1@2 heading: #East)! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/9/2020 19:36:13' prior: 50905080!
test04_rotateLeftWhenHeadingNorthHeadsWest

	| playableCharacter |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 1@2 heading: #North .

	playableCharacter rotateLeft.

	self assert: (playableCharacter isAt: 1@2 heading: #West)! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/9/2020 19:36:13' prior: 50905091!
test05_movingWhenHeadingEastWorksAsExpected

	| playableCharacter |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 1@2 heading: #East .

	playableCharacter
		moveForward;
		moveForward;
		moveBackward;
		rotateRight;
		rotateLeft;
		rotateLeft.

	self assert: (playableCharacter isAt: 2@2 heading: #North)! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/9/2020 19:36:13' prior: 50905105!
test06_movingWhenHeadingSouthWorksAsExpected

	| playableCharacter |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 1@2 heading: #South .

	playableCharacter
		moveForward;
		moveForward;
		moveBackward;
		rotateRight;
		rotateLeft;
		rotateLeft.

	self assert: (playableCharacter isAt: 1@1 heading: #East)! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/9/2020 19:36:13' prior: 50905119!
test07_movingWhenHeadingWestWorksAsExpected

	| playableCharacter |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 2@2 heading: #West .

	playableCharacter
		moveForward;
		moveForward;
		moveBackward;
		rotateRight;
		rotateLeft;
		rotateLeft.

	self assert: (playableCharacter isAt: 1@2 heading: #South)! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/9/2020 19:36:13' prior: 50905133!
test08_canNotCreatePlayableCharacterWhenHeadingIsNotValid

	self
		should: [PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 1@2 heading: #X ]
		raise: Error
		withExceptionDo: [:anError |
			self assert: PlayableCharacter invalidCardinalPointErrorDescription equals: anError messageText ]! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/9/2020 19:43:14' prior: 50905146!
test09_canTakePortableObjects

	| playableCharacter paper |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 2@2 heading: #West .
	paper := NoPointsPortableObject named: 'Paper' weighing: 1.
	
	playableCharacter take: paper.
	
	self assert: (playableCharacter backpackIncludes: paper)! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/9/2020 19:47:21' prior: 50905159!
test10_canNotTakeMoreObjectsThanTheBackpackCanCarry

	| playableCharacter paper key |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 2@2 heading: #West .
	paper := NoPointsPortableObject named: 'Paper' weighing: 100.
	key := NoPointsPortableObject named: 'Key' weighing: 1.
	
	playableCharacter take: paper.
	self 
		should: [ playableCharacter take: key ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [:anError |
			self assert: Backpack maxWeightExceededErrorDescription equals: anError messageText.
			self assert: (playableCharacter backpackIncludes: paper).
			self deny: (playableCharacter backpackIncludes: key) ]
	
	! !
!PlayableCharacterTest methodsFor: 'as yet unclassified' stamp: 'HAW 12/9/2020 13:53:29' prior: 50905184!
defaultBackpack

	^ Backpack containingUpTo: 100 limitingPointsTo: 100 ! !

!classDefinition: #Backpack category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:11:17'!
Object subclass: #Backpack
	instanceVariableNames: 'weightCapacity gamePointsCapacity container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classDefinition: #Backpack category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:11:18'!
Object subclass: #Backpack
	instanceVariableNames: 'weightCapacity gamePointsCapacity container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!
!Backpack methodsFor: 'exceptions' stamp: 'FRT 10/8/2020 18:02:29' prior: 50905206!
signalMaxPointsExceeded

	self error: self class maxPointsExceededErrorDescription ! !
!Backpack methodsFor: 'exceptions' stamp: 'FRT 10/8/2020 18:02:47' prior: 50905211!
signalMaxWeightExceeded

	self error: self class maxWeightExceededErrorDescription ! !
!Backpack methodsFor: 'initialization' stamp: 'HAW 10/14/2020 14:31:56' prior: 50905216!
initializeContainingUpTo: aWeightCapacity limitingPointsTo: pointsCapacity

	weightCapacity := aWeightCapacity.
	gamePointsCapacity := pointsCapacity.
	
	container := OrderedCollection new.
	
	
	! !
!Backpack methodsFor: 'accessing' stamp: 'FRT 10/11/2020 19:14:47' prior: 50905225 overrides: 16880927!
size

	^ container size.! !
!Backpack methodsFor: 'accessing' stamp: 'HAW 10/18/2020 12:20:52' prior: 50905228!
totalPoints
		
	^(container select: [ :portableObject | portableObject doesItAddPoints ])	
		sum: [ :portableObject | portableObject points ]
		ifEmpty: [ 0 ]! !
!Backpack methodsFor: 'accessing' stamp: 'HAW 10/18/2020 12:20:20' prior: 50905236!
totalWeight
	
	^container 
		sum: [ :portableObject | portableObject weight ]
		ifEmpty: [ 0 ]
		! !
!Backpack methodsFor: 'assertions' stamp: 'FRT 10/12/2020 14:12:36' prior: 50905242!
assertPointsAdding: aPointsPortableObject

	(self totalPoints + aPointsPortableObject points) > gamePointsCapacity ifTrue: [ self signalMaxPointsExceeded ]! !
!Backpack methodsFor: 'assertions' stamp: 'FRT 10/15/2020 12:22:34' prior: 50905250!
assertWeightAdding: aPortableObject tolerating: aThreshold

	(self totalWeight + aPortableObject weight - weightCapacity) > aThreshold ifTrue: [ self signalMaxWeightExceeded ]! !
!Backpack methodsFor: 'adding' stamp: 'HAW 10/18/2020 12:28:24' prior: 50905258!
add: aPortableObject
	
	aPortableObject assertCanAddTo: self.
	
	container add: aPortableObject.
	! !
!Backpack methodsFor: 'testing' stamp: 'HAW 12/9/2020 19:44:17' prior: 50905264!
includes: aPortableObject 
	
	^container includes: aPortableObject ! !
!Backpack methodsFor: 'testing' stamp: 'FRT 10/11/2020 18:38:38' prior: 50905269!
isEmpty

	^ container isEmpty.! !
!Backpack methodsFor: 'adding - private' stamp: 'HAW 10/18/2020 12:28:48' prior: 50905273!
assertCanAddNoPointsPortableObject: aNoPointsPortableObject 
	
	self assertWeightAdding: aNoPointsPortableObject tolerating: 0.
	! !
!Backpack methodsFor: 'adding - private' stamp: 'HAW 10/18/2020 12:29:07' prior: 50905280!
assertCanAddPointPortableObject: aPointsPortableObject 
	
	self assertWeightAdding: aPointsPortableObject tolerating: 5.
	self assertPointsAdding: aPointsPortableObject.
	! !

!classDefinition: 'Backpack class' category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:11:18'!
Backpack class
	instanceVariableNames: ''!

!classDefinition: 'Backpack class' category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:11:18'!
Backpack class
	instanceVariableNames: ''!
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 18:27:33' prior: 50905298!
invalidPointsCapacityErrorDescription

	^ 'Points capacity must be positive'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 18:21:04' prior: 50905303!
invalidWeightCapacityErrorDescription

	^ 'Weight capacity must be positive'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/8/2020 17:36:29' prior: 50905308!
maxPointsExceededErrorDescription

	^ 'Maximum points has been exceeded'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/8/2020 17:36:17' prior: 50905313!
maxWeightExceededErrorDescription

	^ 'Maximum weight has been exceeded'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/8/2020 17:43:00' prior: 50905318!
pointsCapacityMustBeIntegerErrorDescription

	^ 'Points capacity must be integer'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/8/2020 17:42:48' prior: 50905324!
weightCapacityMustBeIntegerErrorDescription

	^ 'Weight capacity must be integer'! !
!Backpack class methodsFor: 'exceptions' stamp: 'FRT 10/11/2020 18:27:16' prior: 50905329!
signalInvalidPointsCapacity

	self error: self invalidPointsCapacityErrorDescription 
! !
!Backpack class methodsFor: 'exceptions' stamp: 'FRT 10/11/2020 18:21:51' prior: 50905335!
signalInvalidWeightCapacity

	self error: self invalidWeightCapacityErrorDescription 
! !
!Backpack class methodsFor: 'exceptions' stamp: 'FRT 10/8/2020 17:41:06' prior: 50905341!
signalPointsCapacityMustBeInteger

	self error: self pointsCapacityMustBeIntegerErrorDescription
! !
!Backpack class methodsFor: 'exceptions' stamp: 'FRT 10/8/2020 17:40:47' prior: 50905347!
signalWeightCapacityMustBeInteger

	self error: self weightCapacityMustBeIntegerErrorDescription
! !
!Backpack class methodsFor: 'instance creation' stamp: 'HAW 10/14/2020 14:31:56' prior: 50905353!
containingUpTo: aWeightCapacity limitingPointsTo: pointsCapacity

	aWeightCapacity strictlyPositive  ifFalse: [ self signalInvalidWeightCapacity ].
	pointsCapacity strictlyPositive ifFalse: [ self signalInvalidPointsCapacity ].
	
	aWeightCapacity isInteger ifFalse: [ self signalWeightCapacityMustBeInteger ].
	pointsCapacity isInteger ifFalse: [ self signalPointsCapacityMustBeInteger ].
	
	^ self new initializeContainingUpTo: aWeightCapacity limitingPointsTo: pointsCapacity.
! !

!classDefinition: #PlayableCharacter category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:11:18'!
Object subclass: #PlayableCharacter
	instanceVariableNames: 'position heading backpack name'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classDefinition: #PlayableCharacter category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:11:18'!
Object subclass: #PlayableCharacter
	instanceVariableNames: 'position heading backpack name'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!
!PlayableCharacter methodsFor: 'initialization' stamp: 'HAW 12/9/2020 19:35:22' prior: 50905389!
initializeNamed: aName using: aBackpack at: aPosition heading: aMarsRoverHeading 

	name := aName.
	backpack := aBackpack.
	position := aPosition.
	heading := aMarsRoverHeading! !
!PlayableCharacter methodsFor: 'testing' stamp: 'HAW 12/9/2020 19:43:44' prior: 50905397!
backpackIncludes: aPortableObject 
	
	^backpack includes: aPortableObject ! !
!PlayableCharacter methodsFor: 'testing' stamp: 'HAW 7/1/2018 14:25:05' prior: 50905402!
isAt: aPosition heading: aCardinalPoint

	^position = aPosition and: [ heading cardinalPoint = aCardinalPoint ]! !
!PlayableCharacter methodsFor: 'moving' stamp: 'HAW 10/11/2019 08:22:42' prior: 50905408!
moveBackward
	
	position := position - heading forwardPoint ! !
!PlayableCharacter methodsFor: 'moving' stamp: 'HAW 10/11/2019 08:21:58' prior: 50905413!
moveForward
	
	position := position + heading forwardPoint! !
!PlayableCharacter methodsFor: 'rotating' stamp: 'HAW 10/11/2019 08:31:55' prior: 50905418!
rotateLeft
	
	heading := heading leftHeading! !
!PlayableCharacter methodsFor: 'rotating' stamp: 'HAW 10/11/2019 08:32:04' prior: 50905422!
rotateRight
	
	heading := heading rightHeading! !
!PlayableCharacter methodsFor: 'taking objects' stamp: 'HAW 12/9/2020 19:28:57' prior: 50905427!
take: aPortableObject

	backpack add: aPortableObject.! !

!classDefinition: 'PlayableCharacter class' category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:11:19'!
PlayableCharacter class
	instanceVariableNames: 'headings'!

!classDefinition: 'PlayableCharacter class' category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:11:19'!
PlayableCharacter class
	instanceVariableNames: 'headings'!
!PlayableCharacter class methodsFor: 'heading' stamp: 'HAW 7/2/2018 16:28:16' prior: 50905443!
headingFor: aCardinalPoint
	
	^headings at: aCardinalPoint ifAbsent: [ self error: self invalidCardinalPointErrorDescription ]! !
!PlayableCharacter class methodsFor: 'heading' stamp: 'HAW 7/2/2018 16:26:14' prior: 50905450!
invalidCardinalPointErrorDescription
	
	^'Invalid cardinal point'! !
!PlayableCharacter class methodsFor: 'instance creation' stamp: 'HAW 12/9/2020 19:36:13' prior: 50905455!
named: aName using: aBackpack at: aPosition heading: aCardinalPoint 
	
	| newHeading |

	newHeading := self headingFor: aCardinalPoint.
	
	^self new initializeNamed: aName using: aBackpack at: aPosition heading: newHeading ! !
!PlayableCharacter class methodsFor: 'initialization' stamp: 'HAW 10/11/2019 08:37:25' prior: 50905465!
forHeadingAt: aCardinalPoint leftIs: aLeftCardinalPoint rightIs: aRightCardinalPoint
	
	(headings at: aCardinalPoint) leftHeading: (headings at: aLeftCardinalPoint) rightHeading: (headings at: aRightCardinalPoint).
	! !
!PlayableCharacter class methodsFor: 'initialization' stamp: 'HAW 7/2/2018 15:27:41' prior: 50905476 overrides: 16883149!
initialize

	self initializeHeadings! !
!PlayableCharacter class methodsFor: 'initialization' stamp: 'HAW 12/9/2020 19:31:43' prior: 50905480!
initializeHeadings

	headings := Dictionary new.
	
	(OrderedCollection 
		with: (PlayableCharacterHeading for: #North forwardWith: 0@1 )	
		with: (PlayableCharacterHeading for: #East forwardWith: 1@0 )
		with: (PlayableCharacterHeading for: #South forwardWith: 0@-1 )
		with: (PlayableCharacterHeading for: #West forwardWith: -1@0 ))
			do: [ :heading | headings at: heading cardinalPoint put: heading ].
	
	self 
		forHeadingAt: #North leftIs: #West rightIs: #East;
		forHeadingAt: #South leftIs: #East rightIs: #West;
		forHeadingAt: #East leftIs: #North rightIs: #South;
		forHeadingAt: #West leftIs: #South rightIs: #North.
	! !

!classDefinition: #PlayableCharacterHeading category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:11:19'!
Object subclass: #PlayableCharacterHeading
	instanceVariableNames: 'cardinalPoint forwardPoint rightHeading leftHeading'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classDefinition: #PlayableCharacterHeading category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:11:19'!
Object subclass: #PlayableCharacterHeading
	instanceVariableNames: 'cardinalPoint forwardPoint rightHeading leftHeading'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!
!PlayableCharacterHeading methodsFor: 'accessing' stamp: 'HAW 7/2/2018 15:29:44' prior: 50905523!
cardinalPoint
	
	^cardinalPoint! !
!PlayableCharacterHeading methodsFor: 'accessing' stamp: 'HAW 7/2/2018 15:30:39' prior: 50905527!
forwardPoint
	
	^forwardPoint! !
!PlayableCharacterHeading methodsFor: 'accessing' stamp: 'HAW 10/11/2019 08:31:33' prior: 50905531!
leftHeading
	
	^leftHeading! !
!PlayableCharacterHeading methodsFor: 'accessing' stamp: 'HAW 10/11/2019 08:31:27' prior: 50905535!
rightHeading
	
	^rightHeading! !
!PlayableCharacterHeading methodsFor: 'initialization' stamp: 'HAW 10/11/2019 08:27:25' prior: 50905539!
initializeFor: aCardinalPoint forwardWith: aForwardPoint  
	
	cardinalPoint := aCardinalPoint.
	forwardPoint := aForwardPoint.
! !
!PlayableCharacterHeading methodsFor: 'initialization' stamp: 'HAW 10/11/2019 08:31:33' prior: 50905546!
leftHeading: aLeftHeading rightHeading: aRightHeading
 
	leftHeading := aLeftHeading.
	rightHeading := aRightHeading ! !

!classDefinition: 'PlayableCharacterHeading class' category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:11:19'!
PlayableCharacterHeading class
	instanceVariableNames: ''!

!classDefinition: 'PlayableCharacterHeading class' category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:11:19'!
PlayableCharacterHeading class
	instanceVariableNames: ''!
!PlayableCharacterHeading class methodsFor: 'instance creation' stamp: 'HAW 10/11/2019 08:27:46' prior: 50905565!
for: aCardinalPoint forwardWith: aForwardPoint  

	^self new initializeFor: aCardinalPoint forwardWith: aForwardPoint ! !

!classDefinition: #StageObject category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:11:19'!
Object subclass: #StageObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classDefinition: #StageObject category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:11:19'!
Object subclass: #StageObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classDefinition: #PortableObject category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:11:19'!
StageObject subclass: #PortableObject
	instanceVariableNames: 'name weight'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classDefinition: #PortableObject category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:11:19'!
StageObject subclass: #PortableObject
	instanceVariableNames: 'name weight'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!
!PortableObject methodsFor: 'testing' stamp: 'FRT 10/11/2020 17:54:20' prior: 50905603!
doesItAddPoints

	self subclassResponsibility	! !
!PortableObject methodsFor: 'adding' stamp: 'HAW 10/18/2020 12:28:24' prior: 50905607!
assertCanAddTo: aBackpack

	self subclassResponsibility	! !
!PortableObject methodsFor: 'accessing' stamp: 'FRT 10/11/2020 18:53:51' prior: 50905612!
weight

	^ weight! !

!classDefinition: #NoPointsPortableObject category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:11:20'!
PortableObject subclass: #NoPointsPortableObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classDefinition: #NoPointsPortableObject category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:11:20'!
PortableObject subclass: #NoPointsPortableObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!
!NoPointsPortableObject methodsFor: 'initialization' stamp: 'HAW 10/14/2020 14:34:36' prior: 50905633!
initializeNamed: aName weighing: aWeight
	
	name := aName.
	weight := aWeight.! !
!NoPointsPortableObject methodsFor: 'testing' stamp: 'FRT 10/11/2020 17:54:20' prior: 50905639 overrides: 50906551!
doesItAddPoints	

	^ false! !
!NoPointsPortableObject methodsFor: 'adding' stamp: 'HAW 10/18/2020 12:28:48' prior: 50905644 overrides: 50906556!
assertCanAddTo: aBackpack 
	
	^aBackpack assertCanAddNoPointsPortableObject: self! !

!classDefinition: 'NoPointsPortableObject class' category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:11:20'!
NoPointsPortableObject class
	instanceVariableNames: ''!

!classDefinition: 'NoPointsPortableObject class' category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:11:20'!
NoPointsPortableObject class
	instanceVariableNames: ''!
!NoPointsPortableObject class methodsFor: 'instance creation' stamp: 'HAW 10/14/2020 14:34:36' prior: 50905661!
named: aName weighing: aWeight
	
	^ self new initializeNamed: aName weighing: aWeight. ! !

!classDefinition: #PointsPortableObject category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:11:20'!
PortableObject subclass: #PointsPortableObject
	instanceVariableNames: 'points'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classDefinition: #PointsPortableObject category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:11:20'!
PortableObject subclass: #PointsPortableObject
	instanceVariableNames: 'points'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!
!PointsPortableObject methodsFor: 'testing' stamp: 'FRT 10/11/2020 17:54:20' prior: 50905685 overrides: 50906551!
doesItAddPoints

	^ true! !
!PointsPortableObject methodsFor: 'initialization' stamp: 'HAW 10/14/2020 14:36:26' prior: 50905689!
initializeNamed: aName weighing: aWeight worth: gamePoints
	
	name := aName.
	weight := aWeight.
	points := gamePoints.! !
!PointsPortableObject methodsFor: 'accessing' stamp: 'FRT 10/11/2020 19:06:57' prior: 50905696!
points

	^ points! !
!PointsPortableObject methodsFor: 'adding' stamp: 'HAW 10/18/2020 12:29:07' prior: 50905700 overrides: 50906556!
assertCanAddTo: aBackpack 
	
	^aBackpack assertCanAddPointPortableObject: self! !

!classDefinition: 'PointsPortableObject class' category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:11:20'!
PointsPortableObject class
	instanceVariableNames: ''!

!classDefinition: 'PointsPortableObject class' category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:11:20'!
PointsPortableObject class
	instanceVariableNames: ''!
!PointsPortableObject class methodsFor: 'instance creation' stamp: 'HAW 10/14/2020 14:36:26' prior: 50905717!
named: aName weighing: aWeight worth: gamePoints
	
	^ self new initializeNamed: aName weighing: aWeight worth: gamePoints.! !

!classRemoval: #PointsPortableObject stamp: 'FG 12/17/2020 21:11:20'!
PortableObject subclass: #PointsPortableObject
	instanceVariableNames: 'points'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classRemoval: #NoPointsPortableObject stamp: 'FG 12/17/2020 21:11:21'!
PortableObject subclass: #NoPointsPortableObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classRemoval: #PortableObject stamp: 'FG 12/17/2020 21:11:21'!
StageObject subclass: #PortableObject
	instanceVariableNames: 'name weight'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classRemoval: #StageObject stamp: 'FG 12/17/2020 21:11:21'!
Object subclass: #StageObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classRemoval: #PlayableCharacterHeading stamp: 'FG 12/17/2020 21:11:22'!
Object subclass: #PlayableCharacterHeading
	instanceVariableNames: 'cardinalPoint forwardPoint rightHeading leftHeading'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classRemoval: #PlayableCharacter stamp: 'FG 12/17/2020 21:11:22'!
Object subclass: #PlayableCharacter
	instanceVariableNames: 'position heading backpack name'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classRemoval: #Backpack stamp: 'FG 12/17/2020 21:11:22'!
Object subclass: #Backpack
	instanceVariableNames: 'weightCapacity gamePointsCapacity container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classRemoval: #PlayableCharacterTest stamp: 'FG 12/17/2020 21:11:23'!
TestCase subclass: #PlayableCharacterTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classRemoval: #BackpackTest stamp: 'FG 12/17/2020 21:11:23'!
TestCase subclass: #BackpackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classDefinition: #BackpackTest category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:11:23'!
TestCase subclass: #BackpackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classDefinition: #BackpackTest category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:11:23'!
TestCase subclass: #BackpackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:29:03'!
assertShouldAddAll: portableObjects withPoints: expectedTotalPoints

	| aBackpack |
	
	aBackpack := Backpack containingUpTo: self backpackWeight limitingPointsTo: 100.

	portableObjects do: [ :aPortableObject | aBackpack add: aPortableObject ].
	
	self assert: aBackpack size equals: portableObjects size.
	self assert: aBackpack totalWeight equals: (portableObjects sum: [ :aPortableObject | aPortableObject weight ]).
	self assert: aBackpack totalPoints equals: expectedTotalPoints.
! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:28:32'!
assertShouldNotAddPortableObjectIfWeightExceeded: aPortableObject

	| aBackpack |
	aBackpack := Backpack containingUpTo: self backpackWeight limitingPointsTo: 100.

	self
		should: [ aBackpack add: aPortableObject ]
		raise: Error
		withMessageText: Backpack maxWeightExceededErrorDescription.
		
	self assert: aBackpack isEmpty. 
! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:28:32'!
backpackWeight

	^ 42! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:28:41'!
test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded

	self assertShouldNotAddPortableObjectIfWeightExceeded: 
		(NoPointsPortableObject named: 'help-wanted sign' weighing: self backpackWeight + 1)
! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:28:47'!
test08ShouldNotAddPointsPortableObjectIfWeightExceeded

	self assertShouldNotAddPortableObjectIfWeightExceeded: 
		(PointsPortableObject named: 'left-handed hammer' weighing: self backpackWeight + 6 worth: 5) ! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:26:42'!
test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity

	self 
		assertShouldAddAll: self twoPortableObjects
		withPoints: 5.
! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:27:27'!
test10ShouldAddPortableObjectsIfWeightEqualsMaxWeightCapacity

	self 
		assertShouldAddAll:  self twoPortableObjects, {(PointsPortableObject named: 'letter' weighing: 1 worth: 5)}
		withPoints: 10.
! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:27:39'!
twoPortableObjects

	^ {
		(PointsPortableObject named: 'left-handed hammer' weighing: 40 worth: 5).
		(NoPointsPortableObject named: 'help-wanted sign' weighing: 1) }! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04'!
test01CanNotCreateBackpackWithZeroMaxWeight

	self
		should: [ Backpack containingUpTo: 0 limitingPointsTo: 100 ]
		raise: Error
		withMessageText: Backpack invalidWeightCapacityErrorDescription.
! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04'!
test02CanNotCreateBackpackWithNegativeMaxWeight

	self
		should: [ Backpack containingUpTo: -1 limitingPointsTo: 100 ]
		raise: Error
		withMessageText: Backpack invalidWeightCapacityErrorDescription.! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04'!
test03CanNotCreateBackpackWithZeroMaxPoints

	self
		should: [ Backpack containingUpTo: 10 limitingPointsTo: 0 ]
		raise: Error
		withMessageText: Backpack invalidPointsCapacityErrorDescription.
! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04'!
test04CanNotCreateBackpackWithNegativeMaxPoints

	self
		should: [ Backpack containingUpTo: 10 limitingPointsTo: -1 ]
		raise: Error
		withMessageText: Backpack invalidPointsCapacityErrorDescription.! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04'!
test05CanNotCreateBackpackWithNoIntegerMaxWeight

	self
		should: [ Backpack containingUpTo: 1.0 limitingPointsTo: 100 ]
		raise: Error
		withMessageText: Backpack weightCapacityMustBeIntegerErrorDescription.
! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04'!
test06CanNotCreateBackpackWithNoIntegerMaxPoints

	self
		should: [ Backpack containingUpTo: 100 limitingPointsTo: 1.0 ]
		raise: Error
		withMessageText: Backpack pointsCapacityMustBeIntegerErrorDescription.
! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:49:20'!
test11ShouldAddZeroWeightWhenEmpty

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	self assert: aBackpack totalWeight equals: 0.
	self assert: aBackpack isEmpty
! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:35:57'!
test12ShouldAddWeightWhenAddingPortableObjects

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	aBackpack add: (PointsPortableObject named: 'left-handed hammer' weighing: 10 worth: 5).
	aBackpack add: (NoPointsPortableObject named: 'help-wanted sign' weighing: 10).
	
	self assert: aBackpack size equals: 2.
	self assert: aBackpack totalWeight equals: 20.

! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:49:31'!
test13ShouldAddZeroPointsWhenEmpty

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	self assert: aBackpack totalPoints equals: 0.
	self assert: aBackpack isEmpty.
! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:35:57'!
test14ShouldAddPointsWhenAddingPointsPortableObjects

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	aBackpack add: (PointsPortableObject named: 'left-handed hammer' weighing: 10 worth: 5).
	aBackpack add: (PointsPortableObject named: 'car key' weighing: 10 worth: 20).
	
	self assert: aBackpack size equals: 2.
	self assert: aBackpack totalPoints equals: 25.

! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:35:57'!
test15ShouldNotAddPointsWhenAddingNoPointsPortableObjects

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	aBackpack add: (PointsPortableObject named: 'left-handed hammer' weighing: 10 worth: 5).
	aBackpack add: (NoPointsPortableObject named: 'help-wanted sign' weighing: 10).
	aBackpack add: (NoPointsPortableObject named: 'help-wanted sign' weighing: 10).
	
	self assert: aBackpack size equals: 3.
	self assert: aBackpack totalPoints equals: 5.

! !

!classDefinition: #PlayableCharacterTest category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:11:24'!
TestCase subclass: #PlayableCharacterTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classDefinition: #PlayableCharacterTest category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:11:24'!
TestCase subclass: #PlayableCharacterTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:05:24'!
paper

	^ NoPointsPortableObject named: 'Paper' weighing: 100! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:00:16'!
test01_forwardWhenHeadingNorthIncrementsYCoordinate

	| playableCharacter |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 1@2 heading: #North in: self defaultRoom .

	playableCharacter moveForward.

	self assert: (playableCharacter isAt: 1@3 heading: #North)! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:00:16'!
test02_backwardWhenHeadingNorthDecrementsYCoordinate

	| playableCharacter |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 1@2 heading: #North in: self defaultRoom .

	playableCharacter moveBackward.

	self assert: (playableCharacter isAt: 1@1 heading: #North)! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:00:16'!
test03_rotateRightWhenHeadingNorthHeadsEast

	| playableCharacter |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 1@2 heading: #North in: self defaultRoom .

	playableCharacter rotateRight.

	self assert: (playableCharacter isAt: 1@2 heading: #East)! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:00:16'!
test04_rotateLeftWhenHeadingNorthHeadsWest

	| playableCharacter |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 1@2 heading: #North in: self defaultRoom .

	playableCharacter rotateLeft.

	self assert: (playableCharacter isAt: 1@2 heading: #West)! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:00:16'!
test05_movingWhenHeadingEastWorksAsExpected

	| playableCharacter |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 1@2 heading: #East in: self defaultRoom .

	playableCharacter
		moveForward;
		moveForward;
		moveBackward;
		rotateRight;
		rotateLeft;
		rotateLeft.

	self assert: (playableCharacter isAt: 2@2 heading: #North)! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:00:16'!
test06_movingWhenHeadingSouthWorksAsExpected

	| playableCharacter |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 1@2 heading: #South in: self defaultRoom .

	playableCharacter
		moveForward;
		moveForward;
		moveBackward;
		rotateRight;
		rotateLeft;
		rotateLeft.

	self assert: (playableCharacter isAt: 1@1 heading: #East)! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:00:16'!
test07_movingWhenHeadingWestWorksAsExpected

	| playableCharacter |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 2@2 heading: #West in: self defaultRoom .

	playableCharacter
		moveForward;
		moveForward;
		moveBackward;
		rotateRight;
		rotateLeft;
		rotateLeft.

	self assert: (playableCharacter isAt: 1@2 heading: #South)! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:00:16'!
test08_canNotCreatePlayableCharacterWhenHeadingIsNotValid

	self
		should: [PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 1@2 heading: #X in: self defaultRoom ]
		raise: Error
		withExceptionDo: [:anError |
			self assert: PlayableCharacter invalidCardinalPointErrorDescription equals: anError messageText ]! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:00:16'!
test09_canTakePortableObjects

	| playableCharacter paper |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 2@2 heading: #West in: self defaultRoom .
	paper := NoPointsPortableObject named: 'Paper' weighing: 1.
	
	playableCharacter take: paper.
	
	self assert: (playableCharacter backpackIncludes: paper)! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:05:24'!
test10_canNotTakeMoreObjectsThanTheBackpackCanCarry

	| playableCharacter paper key |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 2@2 heading: #West in: self defaultRoom .
	paper := self paper.
	key := NoPointsPortableObject named: 'Key' weighing: 1.
	
	playableCharacter take: paper.
	self 
		should: [ playableCharacter take: key ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [:anError |
			self assert: Backpack maxWeightExceededErrorDescription equals: anError messageText.
			self assert: (playableCharacter backpackIncludes: paper).
			self deny: (playableCharacter backpackIncludes: key) ]
	
	! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:43:14'!
test11_CanNotCreateCharacterWithInvalidPosition

	| room |

	room := self defaultRoom.
	self 
		should: [ PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 1@-1 heading: #West in: room ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [:anError |
			self assert: Room invalidPositionErrorDescription equals: anError messageText.
			self assert: room isEmpty ]! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:09:38'!
test12_CanNotCreateCharacterOnNotEmptyPosition

	| room paperPosition paper |

	room := self defaultRoom.
	paperPosition := 1@1.
	paper := self paper.
	room at: paperPosition put: paper.
	
	self 
		should: [ PlayableCharacter named: 'Luigi' using: self defaultBackpack at: paperPosition heading: #West in: room ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [:anError |
			self assert: Room positionIsNotEmptyErrorDescription equals: anError messageText.
			self assert: paper equals: (room at: paperPosition)]! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:16:13'!
test13_moveForwardModifiesPositionInRoom

	| room  player |

	room := self defaultRoom.
	
	player := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 1@1 heading: #West in: room.
	player moveForward.
	
	self assert: (player isAt: 0@1 heading: #West).
	self assert: player equals: (room at: 0@1).
	self assert: (room isEmptyAt: 1@1).! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:17:08'!
test14_moveBackwardModifiesPositionInRoom

	| room  player |

	room := self defaultRoom.
	
	player := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 1@1 heading: #West in: room.
	player moveBackward.
	
	self assert: (player isAt: 2@1 heading: #West).
	self assert: player equals: (room at: 2@1).
	self assert: (room isEmptyAt: 1@1).! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:43:14'!
test15_canNotMoveToInvalidPosition

	| room  player |

	room := self defaultRoom.
	
	player := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 0@1 heading: #West in: room.
	
	self 
		should: [ player moveForward ]
		raise: Error 
		withExceptionDo: [:anError |
			self assert: Room invalidPositionErrorDescription equals: anError messageText.
			self assert: player equals: (room at: 0@1). ]
			
! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:44:47'!
test16_canNotTakeFromAnEmptyOrInvalidPosition

	| room  player |

	room := self defaultRoom.
	
	player := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 0@0 heading: #North in: room.
	
	self 
		should: [ player take ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [:anError |
			self assert: Room objectNotInRoomErrorDescription equals: anError messageText.
			self assert: player backpackIsEmpty ]
			
! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:46:11'!
test17_canTakeAPortableObject

	| room  player paper |

	room := self defaultRoom.
	paper := self paper.
	room at: 0@1 put: paper.
	player := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 0@0 heading: #North in: room.
	
	player take.
	
	self assert: (room isEmptyAt: 0@1).
	self assert: (player backpackIncludes: paper).! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:50:54'!
test18_emptyNonPortableObjectDoesNotAddObjectsToBackpack

	| room  player box |

	room := self defaultRoom.
	box := NonPortableObject named: 'Box'.
	room at: 0@1 put: box.
	player := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 0@0 heading: #North in: room.
	
	player take.
	
	self assert: box equals: (room at: 0@1).
	self assert: player backpackIsEmpty.! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:56:03'!
test19_portableInNonPortableObjectIsAddedToBackpack

	| room  player box paper |

	room := self defaultRoom.
	paper := self paper.
	box := NonPortableObject named: 'Box' withAll: { paper }.
	room at: 0@1 put: box.
	player := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 0@0 heading: #North in: room.
	
	player take.
	
	self assert: box equals: (room at: 0@1).
	self assert: box isEmpty.
	self assert: (player backpackIncludes: paper).! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 19:19:55'!
test20_takeFromNonPortableObjectsIsRecursive

	| room  player box paper anotherPaper |

	room := self defaultRoom.
	paper := self paper.
	anotherPaper := self paper.
	box := NonPortableObject named: 'Box' withAll: { paper. anotherPaper }.
	room at: 0@1 put: box.
	player := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 0@0 heading: #North in: room.
	
	self 
		should: [ player take ]
		raise: Error
		withMessageText: Backpack maxWeightExceededErrorDescription.
	
	self assert: box equals: (room at: 0@1).
	self deny: box isEmpty.
	self assert: (box includes: anotherPaper).
	self assert: (player backpackIncludes: paper).
	self assert: 1 equals: player backpackSize! !
!PlayableCharacterTest methodsFor: 'defaults' stamp: 'HAW 12/9/2020 13:53:29'!
defaultBackpack

	^ Backpack containingUpTo: 100 limitingPointsTo: 100 ! !
!PlayableCharacterTest methodsFor: 'defaults' stamp: 'HAW 12/14/2020 18:02:57'!
defaultRoom
	
	^Room ofWidth: 10 andHeight: 10! !

!classDefinition: #RoomTest category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:11:26'!
TestCase subclass: #RoomTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classDefinition: #RoomTest category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:11:26'!
TestCase subclass: #RoomTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!
!RoomTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 17:20:02'!
test01_WidthMustBeStrictlyPositive

	self assertInvalidSizeWith: 0 and: 1
	! !
!RoomTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 17:20:13'!
test02_HeightMustBeStrictlyPositive

	self assertInvalidSizeWith: 1 and: 0
	! !
!RoomTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 17:20:25'!
test03_WidthMustBeInteger

	self assertInvalidSizeWith: 1.1 and: 1
	! !
!RoomTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 17:20:36'!
test04_HeightMustBeInteger

	self assertInvalidSizeWith: 1 and: 1.1
		! !
!RoomTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 17:39:43'!
test05_CanNotPutAStageObjectWithXLessThanCero

	self assertCanNotPutAt: -1@1
		! !
!RoomTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 17:39:49'!
test06_CanNotPutAStageObjectWithXGreaterOrEqualToWidth

	self assertCanNotPutAt: 10@1! !
!RoomTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 17:39:56'!
test07_CanNotPutAStageObjectWithANonIntegerX

	self assertCanNotPutAt: 1.1@1! !
!RoomTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 17:40:04'!
test08_CanNotPutAStageObjectWithYLessThanCero

	self assertCanNotPutAt: 1@-1
		! !
!RoomTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 17:40:25'!
test09_CanNotPutAStageObjectWithYGreaterOrEqualToHeight

	self assertCanNotPutAt: 1@10! !
!RoomTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 17:41:13'!
test10_CanNotPutAStageObjectWithANonIntegerY

	self assertCanNotPutAt: 1@1.1! !
!RoomTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 17:46:46'!
test11_StageObjectsAreKeept

	| room |
	
	room := Room ofWidth: 10 andHeight: 10.
	
	room at: 0@0 put: self paper.
	
	self deny: room isEmpty.! !
!RoomTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:30:22'!
test12_canNotGetPositionOfNonPutObject

	| room |
	
	room := Room ofWidth: 10 andHeight: 10.
	self
		should: [ room positionOf: self paper ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Room objectNotInRoomErrorDescription! !
!RoomTest methodsFor: 'test objects' stamp: 'HAW 12/14/2020 17:36:15'!
paper

	^ PointsPortableObject named: 'paper' weighing: 1 worth: 1! !
!RoomTest methodsFor: 'assertions' stamp: 'HAW 12/14/2020 18:43:14'!
assertCanNotPutAt: aPosition

	| room width |
	
	width := 10.
	room := Room ofWidth: width andHeight: 10.
	
	self 
		should: [ room at: aPosition put: self paper ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: Room invalidPositionErrorDescription equals: anError messageText.
			self assert: room isEmpty ].! !
!RoomTest methodsFor: 'assertions' stamp: 'HAW 12/14/2020 17:19:50'!
assertInvalidSizeWith: aWitdh and: aHeight

	self 
		should: [ Room ofWidth: aWitdh andHeight: aHeight ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Room invalidSizeErrorDescription! !

!classDefinition: #Backpack category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:11:27'!
Object subclass: #Backpack
	instanceVariableNames: 'weightCapacity gamePointsCapacity container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classDefinition: #Backpack category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:11:27'!
Object subclass: #Backpack
	instanceVariableNames: 'weightCapacity gamePointsCapacity container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!
!Backpack methodsFor: 'exceptions' stamp: 'FRT 10/8/2020 18:02:29'!
signalMaxPointsExceeded

	self error: self class maxPointsExceededErrorDescription ! !
!Backpack methodsFor: 'exceptions' stamp: 'FRT 10/8/2020 18:02:47'!
signalMaxWeightExceeded

	self error: self class maxWeightExceededErrorDescription ! !
!Backpack methodsFor: 'initialization' stamp: 'HAW 10/14/2020 14:31:56'!
initializeContainingUpTo: aWeightCapacity limitingPointsTo: pointsCapacity

	weightCapacity := aWeightCapacity.
	gamePointsCapacity := pointsCapacity.
	
	container := OrderedCollection new.
	
	
	! !
!Backpack methodsFor: 'accessing' stamp: 'FRT 10/11/2020 19:14:47' overrides: 16880927!
size

	^ container size.! !
!Backpack methodsFor: 'accessing' stamp: 'HAW 10/18/2020 12:20:52'!
totalPoints
		
	^(container select: [ :portableObject | portableObject doesItAddPoints ])	
		sum: [ :portableObject | portableObject points ]
		ifEmpty: [ 0 ]! !
!Backpack methodsFor: 'accessing' stamp: 'HAW 10/18/2020 12:20:20'!
totalWeight
	
	^container 
		sum: [ :portableObject | portableObject weight ]
		ifEmpty: [ 0 ]
		! !
!Backpack methodsFor: 'assertions' stamp: 'FRT 10/12/2020 14:12:36'!
assertPointsAdding: aPointsPortableObject

	(self totalPoints + aPointsPortableObject points) > gamePointsCapacity ifTrue: [ self signalMaxPointsExceeded ]! !
!Backpack methodsFor: 'assertions' stamp: 'FRT 10/15/2020 12:22:34'!
assertWeightAdding: aPortableObject tolerating: aThreshold

	(self totalWeight + aPortableObject weight - weightCapacity) > aThreshold ifTrue: [ self signalMaxWeightExceeded ]! !
!Backpack methodsFor: 'adding' stamp: 'HAW 10/18/2020 12:28:24'!
add: aPortableObject
	
	aPortableObject assertCanAddTo: self.
	
	container add: aPortableObject.
	! !
!Backpack methodsFor: 'testing' stamp: 'HAW 12/9/2020 19:44:17'!
includes: aPortableObject 
	
	^container includes: aPortableObject ! !
!Backpack methodsFor: 'testing' stamp: 'FRT 10/11/2020 18:38:38'!
isEmpty

	^ container isEmpty.! !
!Backpack methodsFor: 'adding - private' stamp: 'HAW 10/18/2020 12:28:48'!
assertCanAddNoPointsPortableObject: aNoPointsPortableObject 
	
	self assertWeightAdding: aNoPointsPortableObject tolerating: 0.
	! !
!Backpack methodsFor: 'adding - private' stamp: 'HAW 10/18/2020 12:29:07'!
assertCanAddPointPortableObject: aPointsPortableObject 
	
	self assertWeightAdding: aPointsPortableObject tolerating: 5.
	self assertPointsAdding: aPointsPortableObject.
	! !

!classDefinition: 'Backpack class' category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:11:27'!
Backpack class
	instanceVariableNames: ''!

!classDefinition: 'Backpack class' category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:11:28'!
Backpack class
	instanceVariableNames: ''!
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 18:27:33'!
invalidPointsCapacityErrorDescription

	^ 'Points capacity must be positive'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 18:21:04'!
invalidWeightCapacityErrorDescription

	^ 'Weight capacity must be positive'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/8/2020 17:36:29'!
maxPointsExceededErrorDescription

	^ 'Maximum points has been exceeded'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/8/2020 17:36:17'!
maxWeightExceededErrorDescription

	^ 'Maximum weight has been exceeded'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/8/2020 17:43:00'!
pointsCapacityMustBeIntegerErrorDescription

	^ 'Points capacity must be integer'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/8/2020 17:42:48'!
weightCapacityMustBeIntegerErrorDescription

	^ 'Weight capacity must be integer'! !
!Backpack class methodsFor: 'exceptions' stamp: 'FRT 10/11/2020 18:27:16'!
signalInvalidPointsCapacity

	self error: self invalidPointsCapacityErrorDescription 
! !
!Backpack class methodsFor: 'exceptions' stamp: 'FRT 10/11/2020 18:21:51'!
signalInvalidWeightCapacity

	self error: self invalidWeightCapacityErrorDescription 
! !
!Backpack class methodsFor: 'exceptions' stamp: 'FRT 10/8/2020 17:41:06'!
signalPointsCapacityMustBeInteger

	self error: self pointsCapacityMustBeIntegerErrorDescription
! !
!Backpack class methodsFor: 'exceptions' stamp: 'FRT 10/8/2020 17:40:47'!
signalWeightCapacityMustBeInteger

	self error: self weightCapacityMustBeIntegerErrorDescription
! !
!Backpack class methodsFor: 'instance creation' stamp: 'HAW 10/14/2020 14:31:56'!
containingUpTo: aWeightCapacity limitingPointsTo: pointsCapacity

	aWeightCapacity strictlyPositive  ifFalse: [ self signalInvalidWeightCapacity ].
	pointsCapacity strictlyPositive ifFalse: [ self signalInvalidPointsCapacity ].
	
	aWeightCapacity isInteger ifFalse: [ self signalWeightCapacityMustBeInteger ].
	pointsCapacity isInteger ifFalse: [ self signalPointsCapacityMustBeInteger ].
	
	^ self new initializeContainingUpTo: aWeightCapacity limitingPointsTo: pointsCapacity.
! !

!classDefinition: #PlayableCharacter category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:11:28'!
Object subclass: #PlayableCharacter
	instanceVariableNames: 'heading backpack name room'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classDefinition: #PlayableCharacter category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:11:28'!
Object subclass: #PlayableCharacter
	instanceVariableNames: 'heading backpack name room'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!
!PlayableCharacter methodsFor: 'initialization' stamp: 'HAW 12/14/2020 18:27:11'!
initializeNamed: aName using: aBackpack at: aPosition heading: aMarsRoverHeading in: aRoom  

	name := aName.
	backpack := aBackpack.
	heading := aMarsRoverHeading.
	room := aRoom.
	room at: aPosition put: self! !
!PlayableCharacter methodsFor: 'testing' stamp: 'HAW 12/14/2020 18:25:08'!
isAt: aPosition heading: aCardinalPoint

	^self position = aPosition and: [ heading cardinalPoint = aCardinalPoint ]! !
!PlayableCharacter methodsFor: 'moving' stamp: 'HAW 12/14/2020 19:09:28'!
forwardPosition

	^ self position + heading forwardPoint! !
!PlayableCharacter methodsFor: 'moving' stamp: 'HAW 12/14/2020 18:25:13'!
moveBackward
	
	self moveTo: self position - heading forwardPoint.
	! !
!PlayableCharacter methodsFor: 'moving' stamp: 'HAW 12/14/2020 19:09:36'!
moveForward
	
	self moveTo: self forwardPosition ! !
!PlayableCharacter methodsFor: 'moving' stamp: 'HAW 12/14/2020 18:27:14'!
moveTo: aNewPosition
	
	room moveFrom: self position to: aNewPosition.
		! !
!PlayableCharacter methodsFor: 'moving' stamp: 'HAW 12/14/2020 18:25:48'!
position

	^room positionOf: self! !
!PlayableCharacter methodsFor: 'rotating' stamp: 'HAW 10/11/2019 08:31:55'!
rotateLeft
	
	heading := heading leftHeading! !
!PlayableCharacter methodsFor: 'rotating' stamp: 'HAW 10/11/2019 08:32:04'!
rotateRight
	
	heading := heading rightHeading! !
!PlayableCharacter methodsFor: 'taking objects' stamp: 'HAW 12/14/2020 19:09:28'!
take
	
	| toTake |
	
	toTake := room at: self forwardPosition.
	toTake takenBy: self 
	! !
!PlayableCharacter methodsFor: 'taking objects' stamp: 'HAW 12/9/2020 19:28:57'!
take: aPortableObject

	backpack add: aPortableObject.! !
!PlayableCharacter methodsFor: 'taking - private' stamp: 'HAW 12/14/2020 18:58:05'!
takeNonPortableObject: aNonPortableObject 
	
	aNonPortableObject putAllTo: self! !
!PlayableCharacter methodsFor: 'taking - private' stamp: 'HAW 12/14/2020 19:09:51'!
takePortableObject: aPortableObject 
	
	self take: aPortableObject.
	room removeAt: self forwardPosition ! !
!PlayableCharacter methodsFor: 'backpack' stamp: 'HAW 12/9/2020 19:43:44'!
backpackIncludes: aPortableObject 
	
	^backpack includes: aPortableObject ! !
!PlayableCharacter methodsFor: 'backpack' stamp: 'HAW 12/14/2020 18:42:40'!
backpackIsEmpty
	
	^backpack isEmpty ! !
!PlayableCharacter methodsFor: 'backpack' stamp: 'HAW 12/14/2020 19:09:03'!
backpackSize
	
	^backpack size! !

!classDefinition: 'PlayableCharacter class' category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:11:29'!
PlayableCharacter class
	instanceVariableNames: 'headings'!

!classDefinition: 'PlayableCharacter class' category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:11:29'!
PlayableCharacter class
	instanceVariableNames: 'headings'!
!PlayableCharacter class methodsFor: 'heading' stamp: 'HAW 7/2/2018 16:28:16'!
headingFor: aCardinalPoint
	
	^headings at: aCardinalPoint ifAbsent: [ self error: self invalidCardinalPointErrorDescription ]! !
!PlayableCharacter class methodsFor: 'heading' stamp: 'HAW 7/2/2018 16:26:14'!
invalidCardinalPointErrorDescription
	
	^'Invalid cardinal point'! !
!PlayableCharacter class methodsFor: 'instance creation' stamp: 'HAW 12/14/2020 18:01:51'!
named: aName using: aBackpack at: aPosition heading: aCardinalPoint in: aRoom  
	
	| newHeading |

	newHeading := self headingFor: aCardinalPoint.
	
	^self new initializeNamed: aName using: aBackpack at: aPosition heading: newHeading in: aRoom ! !
!PlayableCharacter class methodsFor: 'initialization' stamp: 'HAW 10/11/2019 08:37:25'!
forHeadingAt: aCardinalPoint leftIs: aLeftCardinalPoint rightIs: aRightCardinalPoint
	
	(headings at: aCardinalPoint) leftHeading: (headings at: aLeftCardinalPoint) rightHeading: (headings at: aRightCardinalPoint).
	! !
!PlayableCharacter class methodsFor: 'initialization' stamp: 'HAW 7/2/2018 15:27:41' overrides: 16883149!
initialize

	self initializeHeadings! !
!PlayableCharacter class methodsFor: 'initialization' stamp: 'HAW 12/9/2020 19:31:43'!
initializeHeadings

	headings := Dictionary new.
	
	(OrderedCollection 
		with: (PlayableCharacterHeading for: #North forwardWith: 0@1 )	
		with: (PlayableCharacterHeading for: #East forwardWith: 1@0 )
		with: (PlayableCharacterHeading for: #South forwardWith: 0@-1 )
		with: (PlayableCharacterHeading for: #West forwardWith: -1@0 ))
			do: [ :heading | headings at: heading cardinalPoint put: heading ].
	
	self 
		forHeadingAt: #North leftIs: #West rightIs: #East;
		forHeadingAt: #South leftIs: #East rightIs: #West;
		forHeadingAt: #East leftIs: #North rightIs: #South;
		forHeadingAt: #West leftIs: #South rightIs: #North.
	! !

!classDefinition: #PlayableCharacterHeading category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:11:29'!
Object subclass: #PlayableCharacterHeading
	instanceVariableNames: 'cardinalPoint forwardPoint rightHeading leftHeading'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classDefinition: #PlayableCharacterHeading category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:11:29'!
Object subclass: #PlayableCharacterHeading
	instanceVariableNames: 'cardinalPoint forwardPoint rightHeading leftHeading'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!
!PlayableCharacterHeading methodsFor: 'accessing' stamp: 'HAW 7/2/2018 15:29:44'!
cardinalPoint
	
	^cardinalPoint! !
!PlayableCharacterHeading methodsFor: 'accessing' stamp: 'HAW 7/2/2018 15:30:39'!
forwardPoint
	
	^forwardPoint! !
!PlayableCharacterHeading methodsFor: 'accessing' stamp: 'HAW 10/11/2019 08:31:33'!
leftHeading
	
	^leftHeading! !
!PlayableCharacterHeading methodsFor: 'accessing' stamp: 'HAW 10/11/2019 08:31:27'!
rightHeading
	
	^rightHeading! !
!PlayableCharacterHeading methodsFor: 'initialization' stamp: 'HAW 10/11/2019 08:27:25'!
initializeFor: aCardinalPoint forwardWith: aForwardPoint  
	
	cardinalPoint := aCardinalPoint.
	forwardPoint := aForwardPoint.
! !
!PlayableCharacterHeading methodsFor: 'initialization' stamp: 'HAW 10/11/2019 08:31:33'!
leftHeading: aLeftHeading rightHeading: aRightHeading
 
	leftHeading := aLeftHeading.
	rightHeading := aRightHeading ! !

!classDefinition: 'PlayableCharacterHeading class' category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:11:30'!
PlayableCharacterHeading class
	instanceVariableNames: ''!

!classDefinition: 'PlayableCharacterHeading class' category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:11:30'!
PlayableCharacterHeading class
	instanceVariableNames: ''!
!PlayableCharacterHeading class methodsFor: 'instance creation' stamp: 'HAW 10/11/2019 08:27:46'!
for: aCardinalPoint forwardWith: aForwardPoint  

	^self new initializeFor: aCardinalPoint forwardWith: aForwardPoint ! !

!classDefinition: #Room category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:11:30'!
Object subclass: #Room
	instanceVariableNames: 'width height contents'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classDefinition: #Room category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:11:30'!
Object subclass: #Room
	instanceVariableNames: 'width height contents'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!
!Room methodsFor: 'initialization' stamp: 'HAW 12/14/2020 17:47:16'!
initializeOfWidth: aWidth andHeight: aHeight 
	
	width := aWidth.
	height := aHeight.
	contents := Dictionary new.! !
!Room methodsFor: 'contents' stamp: 'HAW 12/14/2020 18:42:28' overrides: 16880774!
at: aPosition

	^contents at: aPosition ifAbsent: [self error: self class objectNotInRoomErrorDescription ]! !
!Room methodsFor: 'contents' stamp: 'HAW 12/14/2020 18:07:24' overrides: 16880792!
at: aPosition put: aStageObject

	self assertPositionIsValid: aPosition.
	self assertIsEmpty: aPosition.
	
	contents at: aPosition put: aStageObject ! !
!Room methodsFor: 'contents' stamp: 'HAW 12/14/2020 18:23:18'!
moveFrom: aSourcePosition to: aTargetPosition

	| toMove |
	
	toMove := self at: aSourcePosition.
	self at: aTargetPosition put: toMove.
	contents removeKey: aSourcePosition.
	! !
!Room methodsFor: 'contents' stamp: 'HAW 12/14/2020 18:30:58'!
positionOf: anObject

	contents keysAndValuesDo: [ :aPosition :aPlacedObject |
		aPlacedObject = anObject ifTrue: [ ^aPosition  ]].
	
	self error: self class objectNotInRoomErrorDescription ! !
!Room methodsFor: 'contents' stamp: 'HAW 12/14/2020 18:47:43'!
removeAt: aPosition

	^contents removeKey: aPosition ! !
!Room methodsFor: 'assertions' stamp: 'HAW 12/14/2020 18:09:38'!
assertIsEmpty: aPosition

	^(self isEmptyAt: aPosition) ifFalse: [ self error: self class positionIsNotEmptyErrorDescription ]! !
!Room methodsFor: 'assertions' stamp: 'HAW 12/14/2020 18:43:14'!
assertPositionComponentIsValid: aPositionComponent withLimit: limit 

	^ (aPositionComponent < 0 or: [aPositionComponent >= limit or: [ aPositionComponent isInteger not]]) 
		ifTrue: [self error: self class invalidPositionErrorDescription ]! !
!Room methodsFor: 'assertions' stamp: 'HAW 12/14/2020 17:44:04'!
assertPositionIsValid: aPosition

	self assertPositionComponentIsValid: aPosition x withLimit: width.
	self assertPositionComponentIsValid: aPosition y withLimit: height.
	! !
!Room methodsFor: 'testing' stamp: 'HAW 12/14/2020 17:47:56'!
isEmpty
	
	^contents isEmpty ! !
!Room methodsFor: 'testing' stamp: 'HAW 12/14/2020 18:08:47'!
isEmptyAt: aPosition

	^ (contents includesKey: aPosition) not! !

!classDefinition: 'Room class' category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:11:31'!
Room class
	instanceVariableNames: ''!

!classDefinition: 'Room class' category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:11:31'!
Room class
	instanceVariableNames: ''!
!Room class methodsFor: 'error descriptions' stamp: 'HAW 12/14/2020 18:43:14'!
invalidPositionErrorDescription
	
	^'Invalid position'! !
!Room class methodsFor: 'error descriptions' stamp: 'HAW 12/14/2020 17:16:22'!
invalidSizeErrorDescription
	
	^'Invalid size'! !
!Room class methodsFor: 'error descriptions' stamp: 'HAW 12/14/2020 18:30:38'!
objectNotInRoomErrorDescription
	
	^'Object not in room'! !
!Room class methodsFor: 'error descriptions' stamp: 'HAW 12/14/2020 18:09:38'!
positionIsNotEmptyErrorDescription
	
	^'Position not empty'! !
!Room class methodsFor: 'instance creation' stamp: 'HAW 12/14/2020 19:27:12'!
ofWidth: aWidth andHeight: aHeight 
	
	self assertIsValidWitdth: aWidth andHeight: aHeight .
	
	^self new initializeOfWidth: aWidth andHeight: aHeight ! !
!Room class methodsFor: 'assertions' stamp: 'HAW 12/14/2020 17:22:01'!
assertIsValidSizeComponent: aSizeComponent

	^ (aSizeComponent < 1 or: [aSizeComponent isInteger not ]) ifTrue: [self error: self invalidSizeErrorDescription ]! !
!Room class methodsFor: 'assertions' stamp: 'HAW 12/14/2020 19:27:12'!
assertIsValidWitdth: aWidth andHeight: aHeight

	self assertIsValidSizeComponent: aWidth.
	self assertIsValidSizeComponent: aHeight! !

!classDefinition: #StageObject category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:11:31'!
Object subclass: #StageObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classDefinition: #StageObject category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:11:31'!
Object subclass: #StageObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!
!StageObject methodsFor: 'taken' stamp: 'HAW 12/14/2020 19:30:06'!
putAllTo: aPlayableCharacter

	self subclassResponsibility 
	! !
!StageObject methodsFor: 'taken' stamp: 'HAW 12/14/2020 19:30:18'!
takenBy: aPlayableCharacter 

	self subclassResponsibility 
	! !

!classDefinition: #NonPortableObject category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:11:31'!
StageObject subclass: #NonPortableObject
	instanceVariableNames: 'name stageObjects'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classDefinition: #NonPortableObject category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:11:31'!
StageObject subclass: #NonPortableObject
	instanceVariableNames: 'name stageObjects'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!
!NonPortableObject methodsFor: 'initialization' stamp: 'HAW 12/14/2020 19:00:02'!
initializeNamed: aName withAll: aCollectionOfStageObjects 
	
	name := aName.
	stageObjects := aCollectionOfStageObjects asOrderedCollection .! !
!NonPortableObject methodsFor: 'taken' stamp: 'HAW 12/14/2020 19:24:52' overrides: 50907985!
putAllTo: aPlayableCharacter 
	
	| toRemove |
	
	toRemove := OrderedCollection new.
	[ stageObjects do: [ :aStageObject | (aStageObject putAllTo: aPlayableCharacter) ifTrue: [ toRemove add: aStageObject ]]]
		ensure: [ stageObjects removeAll: toRemove ].
	
	^false! !
!NonPortableObject methodsFor: 'taken' stamp: 'HAW 12/14/2020 18:53:21' overrides: 50907990!
takenBy: aPlayableCharacter 
	
	aPlayableCharacter takeNonPortableObject: self! !
!NonPortableObject methodsFor: 'testing' stamp: 'HAW 12/14/2020 19:08:45'!
includes: aStageObject

	^stageObjects includes: aStageObject ! !
!NonPortableObject methodsFor: 'testing' stamp: 'HAW 12/14/2020 18:57:19'!
isEmpty
	
	^stageObjects isEmpty ! !

!classDefinition: 'NonPortableObject class' category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:11:32'!
NonPortableObject class
	instanceVariableNames: ''!

!classDefinition: 'NonPortableObject class' category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:11:32'!
NonPortableObject class
	instanceVariableNames: ''!
!NonPortableObject class methodsFor: 'instance creation' stamp: 'HAW 12/14/2020 19:00:27'!
named: aName 
	
	^self named: aName withAll: #()! !
!NonPortableObject class methodsFor: 'instance creation' stamp: 'HAW 12/14/2020 18:56:40'!
named: aName withAll: aCollectionOfStageObjects 
	
	^self new initializeNamed: aName withAll: aCollectionOfStageObjects ! !

!classDefinition: #PortableObject category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:11:32'!
StageObject subclass: #PortableObject
	instanceVariableNames: 'name weight'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classDefinition: #PortableObject category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:11:32'!
StageObject subclass: #PortableObject
	instanceVariableNames: 'name weight'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!
!PortableObject methodsFor: 'testing' stamp: 'FRT 10/11/2020 17:54:20'!
doesItAddPoints

	self subclassResponsibility	! !
!PortableObject methodsFor: 'adding' stamp: 'HAW 10/18/2020 12:28:24'!
assertCanAddTo: aBackpack

	self subclassResponsibility	! !
!PortableObject methodsFor: 'accessing' stamp: 'FRT 10/11/2020 18:53:51'!
weight

	^ weight! !
!PortableObject methodsFor: 'taken' stamp: 'HAW 12/14/2020 19:15:12' overrides: 50907985!
putAllTo: aPlayableCharacter

	aPlayableCharacter take: self.
	^true! !
!PortableObject methodsFor: 'taken' stamp: 'HAW 12/14/2020 18:53:53' overrides: 50907990!
takenBy: aPlayableCharacter 
	
	aPlayableCharacter takePortableObject: self! !

!classDefinition: #NoPointsPortableObject category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:11:32'!
PortableObject subclass: #NoPointsPortableObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classDefinition: #NoPointsPortableObject category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:11:32'!
PortableObject subclass: #NoPointsPortableObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!
!NoPointsPortableObject methodsFor: 'initialization' stamp: 'HAW 10/14/2020 14:34:36'!
initializeNamed: aName weighing: aWeight
	
	name := aName.
	weight := aWeight.! !
!NoPointsPortableObject methodsFor: 'testing' stamp: 'FRT 10/11/2020 17:54:20' overrides: 50908085!
doesItAddPoints	

	^ false! !
!NoPointsPortableObject methodsFor: 'adding' stamp: 'HAW 10/18/2020 12:28:48' overrides: 50908089!
assertCanAddTo: aBackpack 
	
	^aBackpack assertCanAddNoPointsPortableObject: self! !

!classDefinition: 'NoPointsPortableObject class' category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:11:32'!
NoPointsPortableObject class
	instanceVariableNames: ''!

!classDefinition: 'NoPointsPortableObject class' category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:11:32'!
NoPointsPortableObject class
	instanceVariableNames: ''!
!NoPointsPortableObject class methodsFor: 'instance creation' stamp: 'HAW 10/14/2020 14:34:36'!
named: aName weighing: aWeight
	
	^ self new initializeNamed: aName weighing: aWeight. ! !

!classDefinition: #PointsPortableObject category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:11:32'!
PortableObject subclass: #PointsPortableObject
	instanceVariableNames: 'points'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classDefinition: #PointsPortableObject category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:11:33'!
PortableObject subclass: #PointsPortableObject
	instanceVariableNames: 'points'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!
!PointsPortableObject methodsFor: 'testing' stamp: 'FRT 10/11/2020 17:54:20' overrides: 50908085!
doesItAddPoints

	^ true! !
!PointsPortableObject methodsFor: 'initialization' stamp: 'HAW 10/14/2020 14:36:26'!
initializeNamed: aName weighing: aWeight worth: gamePoints
	
	name := aName.
	weight := aWeight.
	points := gamePoints.! !
!PointsPortableObject methodsFor: 'accessing' stamp: 'FRT 10/11/2020 19:06:57'!
points

	^ points! !
!PointsPortableObject methodsFor: 'adding' stamp: 'HAW 10/18/2020 12:29:07' overrides: 50908089!
assertCanAddTo: aBackpack 
	
	^aBackpack assertCanAddPointPortableObject: self! !

!classDefinition: 'PointsPortableObject class' category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:11:33'!
PointsPortableObject class
	instanceVariableNames: ''!

!classDefinition: 'PointsPortableObject class' category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:11:33'!
PointsPortableObject class
	instanceVariableNames: ''!
!PointsPortableObject class methodsFor: 'instance creation' stamp: 'HAW 10/14/2020 14:36:26'!
named: aName weighing: aWeight worth: gamePoints
	
	^ self new initializeNamed: aName weighing: aWeight worth: gamePoints.! !

!classRemoval: #PointsPortableObject stamp: 'FG 12/17/2020 21:11:33'!
PortableObject subclass: #PointsPortableObject
	instanceVariableNames: 'points'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classRemoval: #NoPointsPortableObject stamp: 'FG 12/17/2020 21:11:33'!
PortableObject subclass: #NoPointsPortableObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classRemoval: #PortableObject stamp: 'FG 12/17/2020 21:11:34'!
StageObject subclass: #PortableObject
	instanceVariableNames: 'name weight'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classRemoval: #NonPortableObject stamp: 'FG 12/17/2020 21:11:34'!
StageObject subclass: #NonPortableObject
	instanceVariableNames: 'name stageObjects'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classRemoval: #StageObject stamp: 'FG 12/17/2020 21:11:34'!
Object subclass: #StageObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classRemoval: #Room stamp: 'FG 12/17/2020 21:11:35'!
Object subclass: #Room
	instanceVariableNames: 'width height contents'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classRemoval: #PlayableCharacterHeading stamp: 'FG 12/17/2020 21:11:35'!
Object subclass: #PlayableCharacterHeading
	instanceVariableNames: 'cardinalPoint forwardPoint rightHeading leftHeading'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classRemoval: #PlayableCharacter stamp: 'FG 12/17/2020 21:11:35'!
Object subclass: #PlayableCharacter
	instanceVariableNames: 'heading backpack name room'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classRemoval: #Backpack stamp: 'FG 12/17/2020 21:11:36'!
Object subclass: #Backpack
	instanceVariableNames: 'weightCapacity gamePointsCapacity container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classRemoval: #RoomTest stamp: 'FG 12/17/2020 21:11:36'!
TestCase subclass: #RoomTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classRemoval: #PlayableCharacterTest stamp: 'FG 12/17/2020 21:11:36'!
TestCase subclass: #PlayableCharacterTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classRemoval: #BackpackTest stamp: 'FG 12/17/2020 21:11:37'!
TestCase subclass: #BackpackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classDefinition: #BackpackTest category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:11:37'!
TestCase subclass: #BackpackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!

!classDefinition: #BackpackTest category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:11:37'!
TestCase subclass: #BackpackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:29:03'!
assertShouldAddAll: portableObjects withPoints: expectedTotalPoints

	| aBackpack |
	
	aBackpack := Backpack containingUpTo: self backpackWeight limitingPointsTo: 100.

	portableObjects do: [ :aPortableObject | aBackpack add: aPortableObject ].
	
	self assert: aBackpack size equals: portableObjects size.
	self assert: aBackpack totalWeight equals: (portableObjects sum: [ :aPortableObject | aPortableObject weight ]).
	self assert: aBackpack totalPoints equals: expectedTotalPoints.
! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:28:32'!
assertShouldNotAddPortableObjectIfWeightExceeded: aPortableObject

	| aBackpack |
	aBackpack := Backpack containingUpTo: self backpackWeight limitingPointsTo: 100.

	self
		should: [ aBackpack add: aPortableObject ]
		raise: Error
		withMessageText: Backpack maxWeightExceededErrorDescription.
		
	self assert: aBackpack isEmpty. 
! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:28:32'!
backpackWeight

	^ 42! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:28:41'!
test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded

	self assertShouldNotAddPortableObjectIfWeightExceeded: 
		(NoPointsPortableObject named: 'help-wanted sign' weighing: self backpackWeight + 1)
! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:28:47'!
test08ShouldNotAddPointsPortableObjectIfWeightExceeded

	self assertShouldNotAddPortableObjectIfWeightExceeded: 
		(PointsPortableObject named: 'left-handed hammer' weighing: self backpackWeight + 6 worth: 5) ! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:26:42'!
test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity

	self 
		assertShouldAddAll: self twoPortableObjects
		withPoints: 5.
! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:27:27'!
test10ShouldAddPortableObjectsIfWeightEqualsMaxWeightCapacity

	self 
		assertShouldAddAll:  self twoPortableObjects, {(PointsPortableObject named: 'letter' weighing: 1 worth: 5)}
		withPoints: 10.
! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:27:39'!
twoPortableObjects

	^ {
		(PointsPortableObject named: 'left-handed hammer' weighing: 40 worth: 5).
		(NoPointsPortableObject named: 'help-wanted sign' weighing: 1) }! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04'!
test01CanNotCreateBackpackWithZeroMaxWeight

	self
		should: [ Backpack containingUpTo: 0 limitingPointsTo: 100 ]
		raise: Error
		withMessageText: Backpack invalidWeightCapacityErrorDescription.
! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04'!
test02CanNotCreateBackpackWithNegativeMaxWeight

	self
		should: [ Backpack containingUpTo: -1 limitingPointsTo: 100 ]
		raise: Error
		withMessageText: Backpack invalidWeightCapacityErrorDescription.! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04'!
test03CanNotCreateBackpackWithZeroMaxPoints

	self
		should: [ Backpack containingUpTo: 10 limitingPointsTo: 0 ]
		raise: Error
		withMessageText: Backpack invalidPointsCapacityErrorDescription.
! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04'!
test04CanNotCreateBackpackWithNegativeMaxPoints

	self
		should: [ Backpack containingUpTo: 10 limitingPointsTo: -1 ]
		raise: Error
		withMessageText: Backpack invalidPointsCapacityErrorDescription.! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04'!
test05CanNotCreateBackpackWithNoIntegerMaxWeight

	self
		should: [ Backpack containingUpTo: 1.0 limitingPointsTo: 100 ]
		raise: Error
		withMessageText: Backpack weightCapacityMustBeIntegerErrorDescription.
! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04'!
test06CanNotCreateBackpackWithNoIntegerMaxPoints

	self
		should: [ Backpack containingUpTo: 100 limitingPointsTo: 1.0 ]
		raise: Error
		withMessageText: Backpack pointsCapacityMustBeIntegerErrorDescription.
! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:49:20'!
test11ShouldAddZeroWeightWhenEmpty

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	self assert: aBackpack totalWeight equals: 0.
	self assert: aBackpack isEmpty
! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:35:57'!
test12ShouldAddWeightWhenAddingPortableObjects

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	aBackpack add: (PointsPortableObject named: 'left-handed hammer' weighing: 10 worth: 5).
	aBackpack add: (NoPointsPortableObject named: 'help-wanted sign' weighing: 10).
	
	self assert: aBackpack size equals: 2.
	self assert: aBackpack totalWeight equals: 20.

! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:49:31'!
test13ShouldAddZeroPointsWhenEmpty

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	self assert: aBackpack totalPoints equals: 0.
	self assert: aBackpack isEmpty.
! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:35:57'!
test14ShouldAddPointsWhenAddingPointsPortableObjects

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	aBackpack add: (PointsPortableObject named: 'left-handed hammer' weighing: 10 worth: 5).
	aBackpack add: (PointsPortableObject named: 'car key' weighing: 10 worth: 20).
	
	self assert: aBackpack size equals: 2.
	self assert: aBackpack totalPoints equals: 25.

! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:35:57'!
test15ShouldNotAddPointsWhenAddingNoPointsPortableObjects

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	aBackpack add: (PointsPortableObject named: 'left-handed hammer' weighing: 10 worth: 5).
	aBackpack add: (NoPointsPortableObject named: 'help-wanted sign' weighing: 10).
	aBackpack add: (NoPointsPortableObject named: 'help-wanted sign' weighing: 10).
	
	self assert: aBackpack size equals: 3.
	self assert: aBackpack totalPoints equals: 5.

! !

!classDefinition: #PlayableCharacterTest category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:11:38'!
TestCase subclass: #PlayableCharacterTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!

!classDefinition: #PlayableCharacterTest category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:11:38'!
TestCase subclass: #PlayableCharacterTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:05:24'!
paper

	^ NoPointsPortableObject named: 'Paper' weighing: 100! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:00:16'!
test01_forwardWhenHeadingNorthIncrementsYCoordinate

	| playableCharacter |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 1@2 heading: #North in: self defaultRoom .

	playableCharacter moveForward.

	self assert: (playableCharacter isAt: 1@3 heading: #North)! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:00:16'!
test02_backwardWhenHeadingNorthDecrementsYCoordinate

	| playableCharacter |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 1@2 heading: #North in: self defaultRoom .

	playableCharacter moveBackward.

	self assert: (playableCharacter isAt: 1@1 heading: #North)! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:00:16'!
test03_rotateRightWhenHeadingNorthHeadsEast

	| playableCharacter |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 1@2 heading: #North in: self defaultRoom .

	playableCharacter rotateRight.

	self assert: (playableCharacter isAt: 1@2 heading: #East)! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:00:16'!
test04_rotateLeftWhenHeadingNorthHeadsWest

	| playableCharacter |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 1@2 heading: #North in: self defaultRoom .

	playableCharacter rotateLeft.

	self assert: (playableCharacter isAt: 1@2 heading: #West)! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:00:16'!
test05_movingWhenHeadingEastWorksAsExpected

	| playableCharacter |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 1@2 heading: #East in: self defaultRoom .

	playableCharacter
		moveForward;
		moveForward;
		moveBackward;
		rotateRight;
		rotateLeft;
		rotateLeft.

	self assert: (playableCharacter isAt: 2@2 heading: #North)! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:00:16'!
test06_movingWhenHeadingSouthWorksAsExpected

	| playableCharacter |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 1@2 heading: #South in: self defaultRoom .

	playableCharacter
		moveForward;
		moveForward;
		moveBackward;
		rotateRight;
		rotateLeft;
		rotateLeft.

	self assert: (playableCharacter isAt: 1@1 heading: #East)! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:00:16'!
test07_movingWhenHeadingWestWorksAsExpected

	| playableCharacter |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 2@2 heading: #West in: self defaultRoom .

	playableCharacter
		moveForward;
		moveForward;
		moveBackward;
		rotateRight;
		rotateLeft;
		rotateLeft.

	self assert: (playableCharacter isAt: 1@2 heading: #South)! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:00:16'!
test08_canNotCreatePlayableCharacterWhenHeadingIsNotValid

	self
		should: [PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 1@2 heading: #X in: self defaultRoom ]
		raise: Error
		withExceptionDo: [:anError |
			self assert: PlayableCharacter invalidCardinalPointErrorDescription equals: anError messageText ]! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:00:16'!
test09_canTakePortableObjects

	| playableCharacter paper |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 2@2 heading: #West in: self defaultRoom .
	paper := NoPointsPortableObject named: 'Paper' weighing: 1.
	
	playableCharacter take: paper.
	
	self assert: (playableCharacter backpackIncludes: paper)! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:05:24'!
test10_canNotTakeMoreObjectsThanTheBackpackCanCarry

	| playableCharacter paper key |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 2@2 heading: #West in: self defaultRoom .
	paper := self paper.
	key := NoPointsPortableObject named: 'Key' weighing: 1.
	
	playableCharacter take: paper.
	self 
		should: [ playableCharacter take: key ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [:anError |
			self assert: Backpack maxWeightExceededErrorDescription equals: anError messageText.
			self assert: (playableCharacter backpackIncludes: paper).
			self deny: (playableCharacter backpackIncludes: key) ]
	
	! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:43:14'!
test11_CanNotCreateCharacterWithInvalidPosition

	| room |

	room := self defaultRoom.
	self 
		should: [ PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 1@-1 heading: #West in: room ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [:anError |
			self assert: Room invalidPositionErrorDescription equals: anError messageText.
			self assert: room isEmpty ]! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:09:38'!
test12_CanNotCreateCharacterOnNotEmptyPosition

	| room paperPosition paper |

	room := self defaultRoom.
	paperPosition := 1@1.
	paper := self paper.
	room at: paperPosition put: paper.
	
	self 
		should: [ PlayableCharacter named: 'Luigi' using: self defaultBackpack at: paperPosition heading: #West in: room ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [:anError |
			self assert: Room positionIsNotEmptyErrorDescription equals: anError messageText.
			self assert: paper equals: (room at: paperPosition)]! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:16:13'!
test13_moveForwardModifiesPositionInRoom

	| room  player |

	room := self defaultRoom.
	
	player := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 1@1 heading: #West in: room.
	player moveForward.
	
	self assert: (player isAt: 0@1 heading: #West).
	self assert: player equals: (room at: 0@1).
	self assert: (room isEmptyAt: 1@1).! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:17:08'!
test14_moveBackwardModifiesPositionInRoom

	| room  player |

	room := self defaultRoom.
	
	player := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 1@1 heading: #West in: room.
	player moveBackward.
	
	self assert: (player isAt: 2@1 heading: #West).
	self assert: player equals: (room at: 2@1).
	self assert: (room isEmptyAt: 1@1).! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:43:14'!
test15_canNotMoveToInvalidPosition

	| room  player |

	room := self defaultRoom.
	
	player := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 0@1 heading: #West in: room.
	
	self 
		should: [ player moveForward ]
		raise: Error 
		withExceptionDo: [:anError |
			self assert: Room invalidPositionErrorDescription equals: anError messageText.
			self assert: player equals: (room at: 0@1). ]
			
! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:44:47'!
test16_canNotTakeFromAnEmptyOrInvalidPosition

	| room  player |

	room := self defaultRoom.
	
	player := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 0@0 heading: #North in: room.
	
	self 
		should: [ player take ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [:anError |
			self assert: Room objectNotInRoomErrorDescription equals: anError messageText.
			self assert: player backpackIsEmpty ]
			
! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:46:11'!
test17_canTakeAPortableObject

	| room  player paper |

	room := self defaultRoom.
	paper := self paper.
	room at: 0@1 put: paper.
	player := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 0@0 heading: #North in: room.
	
	player take.
	
	self assert: (room isEmptyAt: 0@1).
	self assert: (player backpackIncludes: paper).! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:50:54'!
test18_emptyNonPortableObjectDoesNotAddObjectsToBackpack

	| room  player box |

	room := self defaultRoom.
	box := NonPortableObject named: 'Box'.
	room at: 0@1 put: box.
	player := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 0@0 heading: #North in: room.
	
	player take.
	
	self assert: box equals: (room at: 0@1).
	self assert: player backpackIsEmpty.! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:56:03'!
test19_portableInNonPortableObjectIsAddedToBackpack

	| room  player box paper |

	room := self defaultRoom.
	paper := self paper.
	box := NonPortableObject named: 'Box' withAll: { paper }.
	room at: 0@1 put: box.
	player := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 0@0 heading: #North in: room.
	
	player take.
	
	self assert: box equals: (room at: 0@1).
	self assert: box isEmpty.
	self assert: (player backpackIncludes: paper).! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 19:19:55'!
test20_takeFromNonPortableObjectsIsRecursive

	| room  player box paper anotherPaper |

	room := self defaultRoom.
	paper := self paper.
	anotherPaper := self paper.
	box := NonPortableObject named: 'Box' withAll: { paper. anotherPaper }.
	room at: 0@1 put: box.
	player := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 0@0 heading: #North in: room.
	
	self 
		should: [ player take ]
		raise: Error
		withMessageText: Backpack maxWeightExceededErrorDescription.
	
	self assert: box equals: (room at: 0@1).
	self deny: box isEmpty.
	self assert: (box includes: anotherPaper).
	self assert: (player backpackIncludes: paper).
	self assert: 1 equals: player backpackSize! !
!PlayableCharacterTest methodsFor: 'defaults' stamp: 'HAW 12/9/2020 13:53:29'!
defaultBackpack

	^ Backpack containingUpTo: 100 limitingPointsTo: 100 ! !
!PlayableCharacterTest methodsFor: 'defaults' stamp: 'HAW 12/14/2020 18:02:57'!
defaultRoom
	
	^Room ofWidth: 10 andHeight: 10! !

!classDefinition: #RoomTest category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:11:40'!
TestCase subclass: #RoomTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!

!classDefinition: #RoomTest category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:11:40'!
TestCase subclass: #RoomTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!
!RoomTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 17:20:02'!
test01_WidthMustBeStrictlyPositive

	self assertInvalidSizeWith: 0 and: 1
	! !
!RoomTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 17:20:13'!
test02_HeightMustBeStrictlyPositive

	self assertInvalidSizeWith: 1 and: 0
	! !
!RoomTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 17:20:25'!
test03_WidthMustBeInteger

	self assertInvalidSizeWith: 1.1 and: 1
	! !
!RoomTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 17:20:36'!
test04_HeightMustBeInteger

	self assertInvalidSizeWith: 1 and: 1.1
		! !
!RoomTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 17:39:43'!
test05_CanNotPutAStageObjectWithXLessThanCero

	self assertCanNotPutAt: -1@1
		! !
!RoomTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 17:39:49'!
test06_CanNotPutAStageObjectWithXGreaterOrEqualToWidth

	self assertCanNotPutAt: 10@1! !
!RoomTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 17:39:56'!
test07_CanNotPutAStageObjectWithANonIntegerX

	self assertCanNotPutAt: 1.1@1! !
!RoomTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 17:40:04'!
test08_CanNotPutAStageObjectWithYLessThanCero

	self assertCanNotPutAt: 1@-1
		! !
!RoomTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 17:40:25'!
test09_CanNotPutAStageObjectWithYGreaterOrEqualToHeight

	self assertCanNotPutAt: 1@10! !
!RoomTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 17:41:13'!
test10_CanNotPutAStageObjectWithANonIntegerY

	self assertCanNotPutAt: 1@1.1! !
!RoomTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 17:46:46'!
test11_StageObjectsAreKeept

	| room |
	
	room := Room ofWidth: 10 andHeight: 10.
	
	room at: 0@0 put: self paper.
	
	self deny: room isEmpty.! !
!RoomTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:30:22'!
test12_canNotGetPositionOfNonPutObject

	| room |
	
	room := Room ofWidth: 10 andHeight: 10.
	self
		should: [ room positionOf: self paper ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Room objectNotInRoomErrorDescription! !
!RoomTest methodsFor: 'test objects' stamp: 'HAW 12/14/2020 17:36:15'!
paper

	^ PointsPortableObject named: 'paper' weighing: 1 worth: 1! !
!RoomTest methodsFor: 'assertions' stamp: 'HAW 12/14/2020 18:43:14'!
assertCanNotPutAt: aPosition

	| room width |
	
	width := 10.
	room := Room ofWidth: width andHeight: 10.
	
	self 
		should: [ room at: aPosition put: self paper ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: Room invalidPositionErrorDescription equals: anError messageText.
			self assert: room isEmpty ].! !
!RoomTest methodsFor: 'assertions' stamp: 'HAW 12/14/2020 17:19:50'!
assertInvalidSizeWith: aWitdh and: aHeight

	self 
		should: [ Room ofWidth: aWitdh andHeight: aHeight ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Room invalidSizeErrorDescription! !

!classDefinition: #Backpack category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:11:41'!
Object subclass: #Backpack
	instanceVariableNames: 'weightCapacity gamePointsCapacity container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!

!classDefinition: #Backpack category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:11:41'!
Object subclass: #Backpack
	instanceVariableNames: 'weightCapacity gamePointsCapacity container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!
!Backpack methodsFor: 'exceptions' stamp: 'FRT 10/8/2020 18:02:29'!
signalMaxPointsExceeded

	self error: self class maxPointsExceededErrorDescription ! !
!Backpack methodsFor: 'exceptions' stamp: 'FRT 10/8/2020 18:02:47'!
signalMaxWeightExceeded

	self error: self class maxWeightExceededErrorDescription ! !
!Backpack methodsFor: 'initialization' stamp: 'HAW 10/14/2020 14:31:56'!
initializeContainingUpTo: aWeightCapacity limitingPointsTo: pointsCapacity

	weightCapacity := aWeightCapacity.
	gamePointsCapacity := pointsCapacity.
	
	container := OrderedCollection new.
	
	
	! !
!Backpack methodsFor: 'accessing' stamp: 'FRT 10/11/2020 19:14:47' overrides: 16880927!
size

	^ container size.! !
!Backpack methodsFor: 'accessing' stamp: 'HAW 10/18/2020 12:20:52'!
totalPoints
		
	^(container select: [ :portableObject | portableObject doesItAddPoints ])	
		sum: [ :portableObject | portableObject points ]
		ifEmpty: [ 0 ]! !
!Backpack methodsFor: 'accessing' stamp: 'HAW 10/18/2020 12:20:20'!
totalWeight
	
	^container 
		sum: [ :portableObject | portableObject weight ]
		ifEmpty: [ 0 ]
		! !
!Backpack methodsFor: 'assertions' stamp: 'FRT 10/12/2020 14:12:36'!
assertPointsAdding: aPointsPortableObject

	(self totalPoints + aPointsPortableObject points) > gamePointsCapacity ifTrue: [ self signalMaxPointsExceeded ]! !
!Backpack methodsFor: 'assertions' stamp: 'FRT 10/15/2020 12:22:34'!
assertWeightAdding: aPortableObject tolerating: aThreshold

	(self totalWeight + aPortableObject weight - weightCapacity) > aThreshold ifTrue: [ self signalMaxWeightExceeded ]! !
!Backpack methodsFor: 'adding' stamp: 'HAW 10/18/2020 12:28:24'!
add: aPortableObject
	
	aPortableObject assertCanAddTo: self.
	
	container add: aPortableObject.
	! !
!Backpack methodsFor: 'testing' stamp: 'HAW 12/9/2020 19:44:17'!
includes: aPortableObject 
	
	^container includes: aPortableObject ! !
!Backpack methodsFor: 'testing' stamp: 'FRT 10/11/2020 18:38:38'!
isEmpty

	^ container isEmpty.! !
!Backpack methodsFor: 'adding - private' stamp: 'HAW 10/18/2020 12:28:48'!
assertCanAddNoPointsPortableObject: aNoPointsPortableObject 
	
	self assertWeightAdding: aNoPointsPortableObject tolerating: 0.
	! !
!Backpack methodsFor: 'adding - private' stamp: 'HAW 10/18/2020 12:29:07'!
assertCanAddPointPortableObject: aPointsPortableObject 
	
	self assertWeightAdding: aPointsPortableObject tolerating: 5.
	self assertPointsAdding: aPointsPortableObject.
	! !

!classDefinition: 'Backpack class' category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:11:41'!
Backpack class
	instanceVariableNames: ''!

!classDefinition: 'Backpack class' category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:11:41'!
Backpack class
	instanceVariableNames: ''!
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 18:27:33'!
invalidPointsCapacityErrorDescription

	^ 'Points capacity must be positive'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 18:21:04'!
invalidWeightCapacityErrorDescription

	^ 'Weight capacity must be positive'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/8/2020 17:36:29'!
maxPointsExceededErrorDescription

	^ 'Maximum points has been exceeded'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/8/2020 17:36:17'!
maxWeightExceededErrorDescription

	^ 'Maximum weight has been exceeded'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/8/2020 17:43:00'!
pointsCapacityMustBeIntegerErrorDescription

	^ 'Points capacity must be integer'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/8/2020 17:42:48'!
weightCapacityMustBeIntegerErrorDescription

	^ 'Weight capacity must be integer'! !
!Backpack class methodsFor: 'exceptions' stamp: 'FRT 10/11/2020 18:27:16'!
signalInvalidPointsCapacity

	self error: self invalidPointsCapacityErrorDescription 
! !
!Backpack class methodsFor: 'exceptions' stamp: 'FRT 10/11/2020 18:21:51'!
signalInvalidWeightCapacity

	self error: self invalidWeightCapacityErrorDescription 
! !
!Backpack class methodsFor: 'exceptions' stamp: 'FRT 10/8/2020 17:41:06'!
signalPointsCapacityMustBeInteger

	self error: self pointsCapacityMustBeIntegerErrorDescription
! !
!Backpack class methodsFor: 'exceptions' stamp: 'FRT 10/8/2020 17:40:47'!
signalWeightCapacityMustBeInteger

	self error: self weightCapacityMustBeIntegerErrorDescription
! !
!Backpack class methodsFor: 'instance creation' stamp: 'HAW 10/14/2020 14:31:56'!
containingUpTo: aWeightCapacity limitingPointsTo: pointsCapacity

	aWeightCapacity strictlyPositive  ifFalse: [ self signalInvalidWeightCapacity ].
	pointsCapacity strictlyPositive ifFalse: [ self signalInvalidPointsCapacity ].
	
	aWeightCapacity isInteger ifFalse: [ self signalWeightCapacityMustBeInteger ].
	pointsCapacity isInteger ifFalse: [ self signalPointsCapacityMustBeInteger ].
	
	^ self new initializeContainingUpTo: aWeightCapacity limitingPointsTo: pointsCapacity.
! !

!classDefinition: #PlayableCharacter category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:11:42'!
Object subclass: #PlayableCharacter
	instanceVariableNames: 'heading backpack name room'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!

!classDefinition: #PlayableCharacter category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:11:42'!
Object subclass: #PlayableCharacter
	instanceVariableNames: 'heading backpack name room'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!
!PlayableCharacter methodsFor: 'initialization' stamp: 'HAW 12/14/2020 18:27:11'!
initializeNamed: aName using: aBackpack at: aPosition heading: aMarsRoverHeading in: aRoom  

	name := aName.
	backpack := aBackpack.
	heading := aMarsRoverHeading.
	room := aRoom.
	room at: aPosition put: self! !
!PlayableCharacter methodsFor: 'testing' stamp: 'HAW 12/14/2020 18:25:08'!
isAt: aPosition heading: aCardinalPoint

	^self position = aPosition and: [ heading cardinalPoint = aCardinalPoint ]! !
!PlayableCharacter methodsFor: 'moving' stamp: 'HAW 12/14/2020 19:09:28'!
forwardPosition

	^ self position + heading forwardPoint! !
!PlayableCharacter methodsFor: 'moving' stamp: 'HAW 12/14/2020 18:25:13'!
moveBackward
	
	self moveTo: self position - heading forwardPoint.
	! !
!PlayableCharacter methodsFor: 'moving' stamp: 'HAW 12/14/2020 19:09:36'!
moveForward
	
	self moveTo: self forwardPosition ! !
!PlayableCharacter methodsFor: 'moving' stamp: 'HAW 12/14/2020 18:27:14'!
moveTo: aNewPosition
	
	room moveFrom: self position to: aNewPosition.
		! !
!PlayableCharacter methodsFor: 'moving' stamp: 'HAW 12/14/2020 18:25:48'!
position

	^room positionOf: self! !
!PlayableCharacter methodsFor: 'rotating' stamp: 'HAW 10/11/2019 08:31:55'!
rotateLeft
	
	heading := heading leftHeading! !
!PlayableCharacter methodsFor: 'rotating' stamp: 'HAW 10/11/2019 08:32:04'!
rotateRight
	
	heading := heading rightHeading! !
!PlayableCharacter methodsFor: 'taking objects' stamp: 'HAW 12/14/2020 19:09:28'!
take
	
	| toTake |
	
	toTake := room at: self forwardPosition.
	toTake takenBy: self 
	! !
!PlayableCharacter methodsFor: 'taking objects' stamp: 'HAW 12/9/2020 19:28:57'!
take: aPortableObject

	backpack add: aPortableObject.! !
!PlayableCharacter methodsFor: 'taking - private' stamp: 'HAW 12/14/2020 18:58:05'!
takeNonPortableObject: aNonPortableObject 
	
	aNonPortableObject putAllTo: self! !
!PlayableCharacter methodsFor: 'taking - private' stamp: 'HAW 12/14/2020 19:09:51'!
takePortableObject: aPortableObject 
	
	self take: aPortableObject.
	room removeAt: self forwardPosition ! !
!PlayableCharacter methodsFor: 'backpack' stamp: 'HAW 12/9/2020 19:43:44'!
backpackIncludes: aPortableObject 
	
	^backpack includes: aPortableObject ! !
!PlayableCharacter methodsFor: 'backpack' stamp: 'HAW 12/14/2020 18:42:40'!
backpackIsEmpty
	
	^backpack isEmpty ! !
!PlayableCharacter methodsFor: 'backpack' stamp: 'HAW 12/14/2020 19:09:03'!
backpackSize
	
	^backpack size! !

!classDefinition: 'PlayableCharacter class' category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:11:43'!
PlayableCharacter class
	instanceVariableNames: 'headings'!

!classDefinition: 'PlayableCharacter class' category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:11:43'!
PlayableCharacter class
	instanceVariableNames: 'headings'!
!PlayableCharacter class methodsFor: 'heading' stamp: 'HAW 7/2/2018 16:28:16'!
headingFor: aCardinalPoint
	
	^headings at: aCardinalPoint ifAbsent: [ self error: self invalidCardinalPointErrorDescription ]! !
!PlayableCharacter class methodsFor: 'heading' stamp: 'HAW 7/2/2018 16:26:14'!
invalidCardinalPointErrorDescription
	
	^'Invalid cardinal point'! !
!PlayableCharacter class methodsFor: 'instance creation' stamp: 'HAW 12/14/2020 18:01:51'!
named: aName using: aBackpack at: aPosition heading: aCardinalPoint in: aRoom  
	
	| newHeading |

	newHeading := self headingFor: aCardinalPoint.
	
	^self new initializeNamed: aName using: aBackpack at: aPosition heading: newHeading in: aRoom ! !
!PlayableCharacter class methodsFor: 'initialization' stamp: 'HAW 10/11/2019 08:37:25'!
forHeadingAt: aCardinalPoint leftIs: aLeftCardinalPoint rightIs: aRightCardinalPoint
	
	(headings at: aCardinalPoint) leftHeading: (headings at: aLeftCardinalPoint) rightHeading: (headings at: aRightCardinalPoint).
	! !
!PlayableCharacter class methodsFor: 'initialization' stamp: 'HAW 7/2/2018 15:27:41' overrides: 16883149!
initialize

	self initializeHeadings! !
!PlayableCharacter class methodsFor: 'initialization' stamp: 'HAW 12/9/2020 19:31:43'!
initializeHeadings

	headings := Dictionary new.
	
	(OrderedCollection 
		with: (PlayableCharacterHeading for: #North forwardWith: 0@1 )	
		with: (PlayableCharacterHeading for: #East forwardWith: 1@0 )
		with: (PlayableCharacterHeading for: #South forwardWith: 0@-1 )
		with: (PlayableCharacterHeading for: #West forwardWith: -1@0 ))
			do: [ :heading | headings at: heading cardinalPoint put: heading ].
	
	self 
		forHeadingAt: #North leftIs: #West rightIs: #East;
		forHeadingAt: #South leftIs: #East rightIs: #West;
		forHeadingAt: #East leftIs: #North rightIs: #South;
		forHeadingAt: #West leftIs: #South rightIs: #North.
	! !

!classDefinition: #PlayableCharacterHeading category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:11:43'!
Object subclass: #PlayableCharacterHeading
	instanceVariableNames: 'cardinalPoint forwardPoint rightHeading leftHeading'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!

!classDefinition: #PlayableCharacterHeading category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:11:43'!
Object subclass: #PlayableCharacterHeading
	instanceVariableNames: 'cardinalPoint forwardPoint rightHeading leftHeading'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!
!PlayableCharacterHeading methodsFor: 'accessing' stamp: 'HAW 7/2/2018 15:29:44'!
cardinalPoint
	
	^cardinalPoint! !
!PlayableCharacterHeading methodsFor: 'accessing' stamp: 'HAW 7/2/2018 15:30:39'!
forwardPoint
	
	^forwardPoint! !
!PlayableCharacterHeading methodsFor: 'accessing' stamp: 'HAW 10/11/2019 08:31:33'!
leftHeading
	
	^leftHeading! !
!PlayableCharacterHeading methodsFor: 'accessing' stamp: 'HAW 10/11/2019 08:31:27'!
rightHeading
	
	^rightHeading! !
!PlayableCharacterHeading methodsFor: 'initialization' stamp: 'HAW 10/11/2019 08:27:25'!
initializeFor: aCardinalPoint forwardWith: aForwardPoint  
	
	cardinalPoint := aCardinalPoint.
	forwardPoint := aForwardPoint.
! !
!PlayableCharacterHeading methodsFor: 'initialization' stamp: 'HAW 10/11/2019 08:31:33'!
leftHeading: aLeftHeading rightHeading: aRightHeading
 
	leftHeading := aLeftHeading.
	rightHeading := aRightHeading ! !

!classDefinition: 'PlayableCharacterHeading class' category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:11:44'!
PlayableCharacterHeading class
	instanceVariableNames: ''!

!classDefinition: 'PlayableCharacterHeading class' category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:11:44'!
PlayableCharacterHeading class
	instanceVariableNames: ''!
!PlayableCharacterHeading class methodsFor: 'instance creation' stamp: 'HAW 10/11/2019 08:27:46'!
for: aCardinalPoint forwardWith: aForwardPoint  

	^self new initializeFor: aCardinalPoint forwardWith: aForwardPoint ! !

!classDefinition: #Room category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:11:44'!
Object subclass: #Room
	instanceVariableNames: 'width height contents'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!

!classDefinition: #Room category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:11:44'!
Object subclass: #Room
	instanceVariableNames: 'width height contents'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!
!Room methodsFor: 'initialization' stamp: 'HAW 12/14/2020 17:47:16'!
initializeOfWidth: aWidth andHeight: aHeight 
	
	width := aWidth.
	height := aHeight.
	contents := Dictionary new.! !
!Room methodsFor: 'contents' stamp: 'HAW 12/14/2020 18:42:28' overrides: 16880774!
at: aPosition

	^contents at: aPosition ifAbsent: [self error: self class objectNotInRoomErrorDescription ]! !
!Room methodsFor: 'contents' stamp: 'HAW 12/14/2020 18:07:24' overrides: 16880792!
at: aPosition put: aStageObject

	self assertPositionIsValid: aPosition.
	self assertIsEmpty: aPosition.
	
	contents at: aPosition put: aStageObject ! !
!Room methodsFor: 'contents' stamp: 'HAW 12/14/2020 18:23:18'!
moveFrom: aSourcePosition to: aTargetPosition

	| toMove |
	
	toMove := self at: aSourcePosition.
	self at: aTargetPosition put: toMove.
	contents removeKey: aSourcePosition.
	! !
!Room methodsFor: 'contents' stamp: 'HAW 12/14/2020 18:30:58'!
positionOf: anObject

	contents keysAndValuesDo: [ :aPosition :aPlacedObject |
		aPlacedObject = anObject ifTrue: [ ^aPosition  ]].
	
	self error: self class objectNotInRoomErrorDescription ! !
!Room methodsFor: 'contents' stamp: 'HAW 12/14/2020 18:47:43'!
removeAt: aPosition

	^contents removeKey: aPosition ! !
!Room methodsFor: 'assertions' stamp: 'HAW 12/14/2020 18:09:38'!
assertIsEmpty: aPosition

	^(self isEmptyAt: aPosition) ifFalse: [ self error: self class positionIsNotEmptyErrorDescription ]! !
!Room methodsFor: 'assertions' stamp: 'HAW 12/14/2020 18:43:14'!
assertPositionComponentIsValid: aPositionComponent withLimit: limit 

	^ (aPositionComponent < 0 or: [aPositionComponent >= limit or: [ aPositionComponent isInteger not]]) 
		ifTrue: [self error: self class invalidPositionErrorDescription ]! !
!Room methodsFor: 'assertions' stamp: 'HAW 12/14/2020 17:44:04'!
assertPositionIsValid: aPosition

	self assertPositionComponentIsValid: aPosition x withLimit: width.
	self assertPositionComponentIsValid: aPosition y withLimit: height.
	! !
!Room methodsFor: 'testing' stamp: 'HAW 12/14/2020 17:47:56'!
isEmpty
	
	^contents isEmpty ! !
!Room methodsFor: 'testing' stamp: 'HAW 12/14/2020 18:08:47'!
isEmptyAt: aPosition

	^ (contents includesKey: aPosition) not! !

!classDefinition: 'Room class' category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:11:44'!
Room class
	instanceVariableNames: ''!

!classDefinition: 'Room class' category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:11:44'!
Room class
	instanceVariableNames: ''!
!Room class methodsFor: 'error descriptions' stamp: 'HAW 12/14/2020 18:43:14'!
invalidPositionErrorDescription
	
	^'Invalid position'! !
!Room class methodsFor: 'error descriptions' stamp: 'HAW 12/14/2020 17:16:22'!
invalidSizeErrorDescription
	
	^'Invalid size'! !
!Room class methodsFor: 'error descriptions' stamp: 'HAW 12/14/2020 18:30:38'!
objectNotInRoomErrorDescription
	
	^'Object not in room'! !
!Room class methodsFor: 'error descriptions' stamp: 'HAW 12/14/2020 18:09:38'!
positionIsNotEmptyErrorDescription
	
	^'Position not empty'! !
!Room class methodsFor: 'instance creation' stamp: 'HAW 12/14/2020 19:27:12'!
ofWidth: aWidth andHeight: aHeight 
	
	self assertIsValidWitdth: aWidth andHeight: aHeight .
	
	^self new initializeOfWidth: aWidth andHeight: aHeight ! !
!Room class methodsFor: 'assertions' stamp: 'HAW 12/14/2020 17:22:01'!
assertIsValidSizeComponent: aSizeComponent

	^ (aSizeComponent < 1 or: [aSizeComponent isInteger not ]) ifTrue: [self error: self invalidSizeErrorDescription ]! !
!Room class methodsFor: 'assertions' stamp: 'HAW 12/14/2020 19:27:12'!
assertIsValidWitdth: aWidth andHeight: aHeight

	self assertIsValidSizeComponent: aWidth.
	self assertIsValidSizeComponent: aHeight! !

!classDefinition: #StageObject category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:11:45'!
Object subclass: #StageObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!

!classDefinition: #StageObject category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:11:45'!
Object subclass: #StageObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!
!StageObject methodsFor: 'taken' stamp: 'HAW 12/14/2020 19:30:06'!
putAllTo: aPlayableCharacter

	self subclassResponsibility 
	! !
!StageObject methodsFor: 'taken' stamp: 'HAW 12/14/2020 19:30:18'!
takenBy: aPlayableCharacter 

	self subclassResponsibility 
	! !

!classDefinition: #NonPortableObject category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:11:45'!
StageObject subclass: #NonPortableObject
	instanceVariableNames: 'name stageObjects'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!

!classDefinition: #NonPortableObject category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:11:45'!
StageObject subclass: #NonPortableObject
	instanceVariableNames: 'name stageObjects'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!
!NonPortableObject methodsFor: 'initialization' stamp: 'HAW 12/14/2020 19:00:02'!
initializeNamed: aName withAll: aCollectionOfStageObjects 
	
	name := aName.
	stageObjects := aCollectionOfStageObjects asOrderedCollection .! !
!NonPortableObject methodsFor: 'taken' stamp: 'HAW 12/14/2020 19:24:52' overrides: 50909563!
putAllTo: aPlayableCharacter 
	
	| toRemove |
	
	toRemove := OrderedCollection new.
	[ stageObjects do: [ :aStageObject | (aStageObject putAllTo: aPlayableCharacter) ifTrue: [ toRemove add: aStageObject ]]]
		ensure: [ stageObjects removeAll: toRemove ].
	
	^false! !
!NonPortableObject methodsFor: 'taken' stamp: 'HAW 12/14/2020 18:53:21' overrides: 50909568!
takenBy: aPlayableCharacter 
	
	aPlayableCharacter takeNonPortableObject: self! !
!NonPortableObject methodsFor: 'testing' stamp: 'HAW 12/14/2020 19:08:45'!
includes: aStageObject

	^stageObjects includes: aStageObject ! !
!NonPortableObject methodsFor: 'testing' stamp: 'HAW 12/14/2020 18:57:19'!
isEmpty
	
	^stageObjects isEmpty ! !

!classDefinition: 'NonPortableObject class' category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:11:45'!
NonPortableObject class
	instanceVariableNames: ''!

!classDefinition: 'NonPortableObject class' category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:11:45'!
NonPortableObject class
	instanceVariableNames: ''!
!NonPortableObject class methodsFor: 'instance creation' stamp: 'HAW 12/14/2020 19:00:27'!
named: aName 
	
	^self named: aName withAll: #()! !
!NonPortableObject class methodsFor: 'instance creation' stamp: 'HAW 12/14/2020 18:56:40'!
named: aName withAll: aCollectionOfStageObjects 
	
	^self new initializeNamed: aName withAll: aCollectionOfStageObjects ! !

!classDefinition: #PortableObject category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:11:45'!
StageObject subclass: #PortableObject
	instanceVariableNames: 'name weight'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!

!classDefinition: #PortableObject category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:11:45'!
StageObject subclass: #PortableObject
	instanceVariableNames: 'name weight'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!
!PortableObject methodsFor: 'testing' stamp: 'FRT 10/11/2020 17:54:20'!
doesItAddPoints

	self subclassResponsibility	! !
!PortableObject methodsFor: 'adding' stamp: 'HAW 10/18/2020 12:28:24'!
assertCanAddTo: aBackpack

	self subclassResponsibility	! !
!PortableObject methodsFor: 'accessing' stamp: 'FRT 10/11/2020 18:53:51'!
weight

	^ weight! !
!PortableObject methodsFor: 'taken' stamp: 'HAW 12/14/2020 19:15:12' overrides: 50909563!
putAllTo: aPlayableCharacter

	aPlayableCharacter take: self.
	^true! !
!PortableObject methodsFor: 'taken' stamp: 'HAW 12/14/2020 18:53:53' overrides: 50909568!
takenBy: aPlayableCharacter 
	
	aPlayableCharacter takePortableObject: self! !

!classDefinition: #NoPointsPortableObject category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:11:46'!
PortableObject subclass: #NoPointsPortableObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!

!classDefinition: #NoPointsPortableObject category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:11:46'!
PortableObject subclass: #NoPointsPortableObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!
!NoPointsPortableObject methodsFor: 'initialization' stamp: 'HAW 10/14/2020 14:34:36'!
initializeNamed: aName weighing: aWeight
	
	name := aName.
	weight := aWeight.! !
!NoPointsPortableObject methodsFor: 'testing' stamp: 'FRT 10/11/2020 17:54:20' overrides: 50909668!
doesItAddPoints	

	^ false! !
!NoPointsPortableObject methodsFor: 'adding' stamp: 'HAW 10/18/2020 12:28:48' overrides: 50909672!
assertCanAddTo: aBackpack 
	
	^aBackpack assertCanAddNoPointsPortableObject: self! !

!classDefinition: 'NoPointsPortableObject class' category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:11:46'!
NoPointsPortableObject class
	instanceVariableNames: ''!

!classDefinition: 'NoPointsPortableObject class' category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:11:46'!
NoPointsPortableObject class
	instanceVariableNames: ''!
!NoPointsPortableObject class methodsFor: 'instance creation' stamp: 'HAW 10/14/2020 14:34:36'!
named: aName weighing: aWeight
	
	^ self new initializeNamed: aName weighing: aWeight. ! !

!classDefinition: #PointsPortableObject category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:11:46'!
PortableObject subclass: #PointsPortableObject
	instanceVariableNames: 'points'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!

!classDefinition: #PointsPortableObject category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:11:46'!
PortableObject subclass: #PointsPortableObject
	instanceVariableNames: 'points'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!
!PointsPortableObject methodsFor: 'testing' stamp: 'FRT 10/11/2020 17:54:20' overrides: 50909668!
doesItAddPoints

	^ true! !
!PointsPortableObject methodsFor: 'initialization' stamp: 'HAW 10/14/2020 14:36:26'!
initializeNamed: aName weighing: aWeight worth: gamePoints
	
	name := aName.
	weight := aWeight.
	points := gamePoints.! !
!PointsPortableObject methodsFor: 'accessing' stamp: 'FRT 10/11/2020 19:06:57'!
points

	^ points! !
!PointsPortableObject methodsFor: 'adding' stamp: 'HAW 10/18/2020 12:29:07' overrides: 50909672!
assertCanAddTo: aBackpack 
	
	^aBackpack assertCanAddPointPortableObject: self! !

!classDefinition: 'PointsPortableObject class' category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:11:46'!
PointsPortableObject class
	instanceVariableNames: ''!

!classDefinition: 'PointsPortableObject class' category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:11:46'!
PointsPortableObject class
	instanceVariableNames: ''!
!PointsPortableObject class methodsFor: 'instance creation' stamp: 'HAW 10/14/2020 14:36:26'!
named: aName weighing: aWeight worth: gamePoints
	
	^ self new initializeNamed: aName weighing: aWeight worth: gamePoints.! !

!classDefinition: #DoorTest category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:11:47'!
TestCase subclass: #DoorTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!

!classDefinition: #DoorTest category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:11:47'!
TestCase subclass: #DoorTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!

!classDefinition: #Door category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:11:47'!
Object subclass: #Door
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!
!DoorTest methodsFor: 'no messages' stamp: 'FG 12/17/2020 17:37:56'!
test01DoorCanNotBeInTheSameRoomTwice

	| door room |
	
	room := Room ofWidth: 10 andHeight: 10. 
	
	door := Door in: room and: room.
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 17:38:20' prior: 50909829!
test01DoorCanNotBeInTheSameRoomTwice

	| door room |
	
	room := Room ofWidth: 10 andHeight: 10. 
	
	door := Door in: room and: room.
	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 17:39:50'!
test01DoorCannotBeInTheSameRoomTwice

	| door room |
	
	room := Room ofWidth: 10 andHeight: 10. 
	
	self 
		should: [ Door in: room and: room ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Door doorCannotBeInTheSameRoomTwice
	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 17:40:04' prior: 50909844!
test01DoorCannotBeInTheSameRoomTwice

	| room |
	
	room := Room ofWidth: 10 andHeight: 10. 
	
	self 
		should: [ Door in: room and: room ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Door doorCannotBeInTheSameRoomTwice
	
	! !

!methodRemoval: DoorTest #test01DoorCanNotBeInTheSameRoomTwice stamp: 'FG 12/17/2020 21:11:47'!
test01DoorCanNotBeInTheSameRoomTwice

	| door room |
	
	room := Room ofWidth: 10 andHeight: 10. 
	
	door := Door in: room and: room.
	
	!
!Door class methodsFor: 'exceptions' stamp: 'FG 12/17/2020 17:40:30'!
doorCannotBeInTheSameRoomTwice
	self shouldBeImplemented.! !
!Door class methodsFor: 'exceptions' stamp: 'FG 12/17/2020 17:41:28' prior: 50909873!
doorCannotBeInTheSameRoomTwice
	^ 'Error - Cannot create door that leads to the same room that its in'.! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 17:41:38' prior: 50909855!
test01DoorCannotBeInTheSameRoomTwice

	| room |
	
	room := Room ofWidth: 10 andHeight: 10. 
	
	self 
		should: [ Door in: room and: room ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Door doorCannotBeInTheSameRoomTwice.
	
	! !
!Door class methodsFor: 'nil' stamp: 'FG 12/17/2020 17:42:38'!
in: aRoom and: anotherRoom
	
	^ self basicNew initializeIn: aRoom and: anotherRoom.! !
!Door methodsFor: 'no messages' stamp: 'FG 12/17/2020 17:43:16'!
initializeIn: aRoom and: anotherRoom
! !
!Door methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 17:45:09' prior: 50909900!
initializeIn: aRoom and: anotherRoom
	
	(aRoom = anotherRoom) ifTrue: [ self error: Door doorCannotBeInTheSameRoomTwice ].! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 17:53:41'!
test02CannotPlaceDoorInInvalidPositionInAnyOfTheRooms

	| room1 room2 |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
	
	self 
		should: [ Door in: room1 at: -1@0 and: room2 at: 1@1 ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Room invalidPositionErrorDescription.
	
	! !
!Door class methodsFor: 'initialization' stamp: 'FG 12/17/2020 17:54:33'!
in: aRoom at: aPosition and: anotherRoom at: anotherPosition
	
	^ self basicNew initializeIn: aRoom at: aPosition and: anotherRoom at: anotherPosition.! !

!methodRemoval: Door class #in:and: stamp: 'FG 12/17/2020 21:11:47'!
in: aRoom and: anotherRoom
	
	^ self basicNew initializeIn: aRoom and: anotherRoom.!
!Door methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 17:55:33'!
initializeIn: aRoom at: aPosition and: anotherRoom at: anotherPosition
	
	(aRoom = anotherRoom) ifTrue: [ self error: Door doorCannotBeInTheSameRoomTwice ].
	
	aRoom put: self at: aPosition.! !

!methodRemoval: Door #initializeIn:and: stamp: 'FG 12/17/2020 21:11:47'!
initializeIn: aRoom and: anotherRoom
	
	(aRoom = anotherRoom) ifTrue: [ self error: Door doorCannotBeInTheSameRoomTwice ].!
!Door methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 17:56:50' prior: 50909937!
initializeIn: aRoom at: aPosition and: anotherRoom at: anotherPosition
	
	(aRoom = anotherRoom) ifTrue: [ self error: Door doorCannotBeInTheSameRoomTwice ].
	
	aRoom at: aPosition put: self.
	aRoom at: aPosition put: self.! !
!Door methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 17:58:12' prior: 50909953!
initializeIn: aRoom at: aPosition and: anotherRoom at: anotherPosition
	
	(aRoom = anotherRoom) ifTrue: [ self error: Door doorCannotBeInTheSameRoomTwice ].
	
	aRoom at: aPosition put: self.
	anotherRoom at: anotherPosition put: self.! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 18:02:32' prior: 50909912!
test02CannotPlaceDoorInInvalidPositionInAnyOfTheRooms

	| room1 room2 |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
	
	self 
		should: [ Door in: room1 at: -1@0 and: room2 at: 1@1 ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Room invalidPositionErrorDescription.
		
	self 
		should: [ Door in: room1 at: 1@0 and: room2 at: -1@1 ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Room invalidPositionErrorDescription.
	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 18:03:06'!
test03CannotPlaceDoorInOcupiedPositionInAnyOfTheRooms

	| room1 room2 |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
	
	self 
		should: [ Door in: room1 at: -1@0 and: room2 at: 1@1 ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Room invalidPositionErrorDescription.
		
	self 
		should: [ Door in: room1 at: 1@0 and: room2 at: -1@1 ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Room invalidPositionErrorDescription.
	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 18:03:21'!
paper

	^ PointsPortableObject named: 'paper' weighing: 1 worth: 1! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 18:04:34' prior: 50909992!
test03CannotPlaceDoorInOcupiedPositionInAnyOfTheRooms

	| room1 room2 |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
	
	room1 at: 1@1 put: self paper.
	room2 at: 1@1 put: self paper. 
	
	self 
		should: [ Door in: room1 at: 1@1 and: room2 at: 0@1 ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Room invalidPositionErrorDescription.
		
	self 
		should: [ Door in: room1 at: 1@0 and: room2 at: 1@1 ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Room invalidPositionErrorDescription.
	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 18:05:29' prior: 50910016!
test03CannotPlaceDoorInOcupiedPositionInAnyOfTheRooms

	| room1 room2 |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
	
	room1 at: 1@1 put: self paper.
	room2 at: 1@1 put: self paper. 
	
	self 
		should: [ Door in: room1 at: 1@1 and: room2 at: 0@1 ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Room positionIsNotEmptyErrorDescription.
		
	self 
		should: [ Door in: room1 at: 1@0 and: room2 at: 1@1 ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Room positionIsNotEmptyErrorDescription.
	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 18:06:59'!
test04DoorIsBothRooms

	| room1 room2 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1.	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 18:09:21' prior: 50910057!
test04DoorIsBothRooms

	| room1 room2 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1.	
	
	self deny: (room1 isEmptyAt: 1@1).
	self deny: (room2 isEmptyAt: 0@1).
	self assert: (room1 at: 1@1) equals: door.
	self assert: (room2 at: 0@1) equals: door.  
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 18:09:51'!
test04DoorIsInBothRooms

	| room1 room2 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1.	
	
	self deny: (room1 isEmptyAt: 1@1).
	self deny: (room2 isEmptyAt: 0@1).
	self assert: (room1 at: 1@1) equals: door.
	self assert: (room2 at: 0@1) equals: door.  
	! !

!methodRemoval: DoorTest #test04DoorIsBothRooms stamp: 'FG 12/17/2020 21:11:48'!
test04DoorIsBothRooms

	| room1 room2 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1.	
	
	self deny: (room1 isEmptyAt: 1@1).
	self deny: (room2 isEmptyAt: 0@1).
	self assert: (room1 at: 1@1) equals: door.
	self assert: (room2 at: 0@1) equals: door.  
	!
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 18:10:36'!
test01DoorShouldBeInDifferentRooms

	| room |
	
	room := Room ofWidth: 10 andHeight: 10. 
	
	self 
		should: [ Door in: room and: room ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Door doorCannotBeInTheSameRoomTwice.
	
	! !

!methodRemoval: DoorTest #test01DoorCannotBeInTheSameRoomTwice stamp: 'FG 12/17/2020 21:11:48'!
test01DoorCannotBeInTheSameRoomTwice

	| room |
	
	room := Room ofWidth: 10 andHeight: 10. 
	
	self 
		should: [ Door in: room and: room ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Door doorCannotBeInTheSameRoomTwice.
	
	!
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 18:10:57' prior: 50910108!
test01DoorShouldBeInDifferentRooms

	| room |
	
	room := Room ofWidth: 10 andHeight: 10. 
	
	self 
		should: [ Door in: room at: 1@1 and: room at:1@1]
		raise: Error - MessageNotUnderstood 
		withMessageText: Door doorCannotBeInTheSameRoomTwice.
	
	! !
!Door methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 18:18:56' prior: 50909963!
initializeIn: aRoom at: aPosition and: anotherRoom at: anotherPosition
	
	(aRoom = anotherRoom) ifTrue: [ self error: Door doorCannotBeInTheSameRoomTwice ].
	
	aRoom at: aPosition put: self.
	anotherRoom at: anotherPosition put: self.! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 18:30:36'!
test05DoorLeadFromOneRoomToTheOther

	| room1 room2 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1.	
	
	self assert: (door moveFrom: room1) equals: room2.
	self assert: (door moveFrom: room2) equals: room2. ! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 18:30:39' prior: 50910150!
test05DoorLeadFromOneRoomToTheOther

	| room1 room2 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1.	
	
	self assert: (door moveFrom: room1) equals: room2.
	self assert: (door moveFrom: room2) equals: room1. ! !
!Door methodsFor: 'accessing' stamp: 'FG 12/17/2020 18:30:56'!
moveFrom: aRoom 
	self shouldBeImplemented.! !

!classDefinition: #Door category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:11:48'!
Object subclass: #Door
	instanceVariableNames: 'firstRoom'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!

!classDefinition: #Door category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:11:48'!
Object subclass: #Door
	instanceVariableNames: 'firstRoom secondRoom'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!
!Door methodsFor: 'accessing' stamp: 'FG 12/17/2020 18:32:39' prior: 50910175!
moveFrom: aRoom 
	(aRoom = firstRoom) ifTrue: [^ secondRoom].
	(aRoom = secondRoom) ifTrue: [^ firstRoom].! !
!Door methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 18:33:28' prior: 50910140!
initializeIn: aRoom at: aPosition and: anotherRoom at: anotherPosition
	
	(aRoom = anotherRoom) ifTrue: [ self error: Door doorCannotBeInTheSameRoomTwice ].
	
	aRoom at: aPosition put: self.
	anotherRoom at: anotherPosition put: self.
	
	firstRoom := aRoom.
	secondRoom := anotherRoom.! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 18:39:08'!
test06CannotMoveFromARoomWhichDoesntHasTheDoor

	| room1 room2 room3 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
	room3 := Room 	ofWidth: 10 andHeight: 10.
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1.	
	
	self assert: (door moveFrom: room1) equals: room2.
	self assert: (door moveFrom: room2) equals: room1. ! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 18:40:45' prior: 50910215!
test06CannotMoveFromARoomWhichDoesntHasTheDoor

	| room1 room2 room3 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
	room3 := Room 	ofWidth: 10 andHeight: 10.
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1.	
	
	self 
		should: [ door moveFrom: room3]
		raise: Error - MessageNotUnderstood 
		withMessageText: (Door cannotMoveFrom: room3).! !
!Door class methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 18:41:01'!
cannotMoveFrom: aRoom 
	self shouldBeImplemented.! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 18:43:01' prior: 50910230!
test06CannotMoveFromARoomWhichDoesntHasTheDoor

	| room1 room2 room3 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
	room3 := Room 	ofWidth: 10 andHeight: 10.
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1.	
	
	self 
		should: [ door moveFrom: room3]
		raise: Error - MessageNotUnderstood 
		withMessageText: (Door cannotMoveFromARoomWithoutThisDoor).! !
!Door class methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 18:43:13'!
cannotMoveFromARoomWithoutThisDoor
	self shouldBeImplemented.! !
!Door class methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 18:43:36' prior: 50910266!
cannotMoveFromARoomWithoutThisDoor
	^ 'Error - Cannot move from a room without this door'.! !
!Door methodsFor: 'accessing' stamp: 'FG 12/17/2020 18:44:22' prior: 50910196!
moveFrom: aRoom 
	(aRoom = firstRoom) ifTrue: [^ secondRoom].
	(aRoom = secondRoom) ifTrue: [^ firstRoom].
	self error: Door cannotMoveFromARoomWithoutThisDoor.! !

!classDefinition: #Door category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:11:49'!
Object subclass: #Door
	instanceVariableNames: 'firstRoom secondRoom state'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!

!classDefinition: #Door category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:11:49'!
Object subclass: #Door
	instanceVariableNames: 'firstRoom secondRoom state'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!

!classDefinition: #ClosedDoor category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:11:49'!
Object subclass: #ClosedDoor
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 18:53:54'!
test07DoorStartsClosed

	| room1 room2 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1.	
	
	self assert: (door state isKindaOf: 
	ClosedDoor).! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 18:54:16' prior: 50910311!
test07DoorStartsClosed

	| room1 room2 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1.	
	
	self assert: (door state isKindOf: ClosedDoor).! !

!classDefinition: #DoorState category: 'Unknown' stamp: 'FG 12/17/2020 21:11:49'!
Object subclass: #DoorState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Unknown'!

!classDefinition: #ClosedDoor category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:11:49'!
DoorState subclass: #ClosedDoor
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!

!classDefinition: #ClosedDoor category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:11:49'!
DoorState subclass: #ClosedDoor
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!

!classDefinition: #DoorState category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:11:49'!
Object subclass: #DoorState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!

!classDefinition: #DoorState category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:11:49'!
Object subclass: #DoorState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!
!Door methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 18:55:59' prior: 50910203!
initializeIn: aRoom at: aPosition and: anotherRoom at: anotherPosition
	
	(aRoom = anotherRoom) ifTrue: [ self error: Door doorCannotBeInTheSameRoomTwice ].
	
	aRoom at: aPosition put: self.
	anotherRoom at: anotherPosition put: self.
	
	state := ClosedDoor new.
	firstRoom := aRoom.
	secondRoom := anotherRoom.! !
!Door methodsFor: 'accessing' stamp: 'FG 12/17/2020 18:57:04'!
isClosed
	state isClosed: self.! !
!ClosedDoor methodsFor: 'no messages' stamp: 'FG 12/17/2020 18:57:22'!
isClosed: door
	^ true.! !
!ClosedDoor methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 18:57:27'!
isClosed
	^ true.! !

!methodRemoval: ClosedDoor #isClosed: stamp: 'FG 12/17/2020 21:11:49'!
isClosed: door
	^ true.!
!Door methodsFor: 'accessing' stamp: 'FG 12/17/2020 18:57:39' prior: 50910385!
isClosed
	state isClosed.! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 18:58:00' prior: 50910322!
test07DoorStartsClosed

	| room1 room2 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1.	
	
	self assert: door isClosed.! !
!Door methodsFor: 'accessing' stamp: 'FG 12/17/2020 18:59:37'!
useFrom: aRoom 
	(aRoom = firstRoom) ifTrue: [^ secondRoom].
	(aRoom = secondRoom) ifTrue: [^ firstRoom].
	self error: Door cannotMoveFromARoomWithoutThisDoor.! !

!methodRemoval: Door #moveFrom: stamp: 'FG 12/17/2020 21:11:49'!
moveFrom: aRoom 
	(aRoom = firstRoom) ifTrue: [^ secondRoom].
	(aRoom = secondRoom) ifTrue: [^ firstRoom].
	self error: Door cannotMoveFromARoomWithoutThisDoor.!
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 18:59:54' prior: 50910163!
test05DoorLeadFromOneRoomToTheOther

	| room1 room2 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1.	
	
	self assert: (door useFrom: room1) equals: room2.
	self assert: (door useFrom: room2) equals: room1. ! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:00:00' prior: 50910250!
test06CannotMoveFromARoomWhichDoesntHasTheDoor

	| room1 room2 room3 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
	room3 := Room 	ofWidth: 10 andHeight: 10.
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1.	
	
	self 
		should: [ door useFrom: room3]
		raise: Error - MessageNotUnderstood 
		withMessageText: (Door cannotMoveFromARoomWithoutThisDoor).! !
!Door methodsFor: 'accessing' stamp: 'FG 12/17/2020 19:01:42' prior: 50910400!
isClosed
	^ state isClosed.! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:03:51'!
test08CannotUseAClosedDoor

	| room1 room2 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1.	
	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:04:33' prior: 50910462!
test08CannotUseAClosedDoor

	| room1 room2 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1.	
	
	self 
		should: [ door useFrom: room1]
		raise: Error - MessageNotUnderstood 
		withMessageText: (Door cannotUseClosedDoor).
	
	! !
!Door methodsFor: 'accessing' stamp: 'FG 12/17/2020 19:05:53' prior: 50910413!
useFrom: aRoom 

	state useDoor: self.! !
!Door methodsFor: 'accessing' stamp: 'FG 12/17/2020 19:06:14'!
useOpenDoorFrom: aRoom 

	(aRoom = firstRoom) ifTrue: [^ secondRoom].
	(aRoom = secondRoom) ifTrue: [^ firstRoom].
	self error: Door cannotMoveFromARoomWithoutThisDoor.! !
!ClosedDoor methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:06:51'!
useDoor: aDoor

	aDoor useClosedDoor.! !
!Door methodsFor: 'accessing' stamp: 'FG 12/17/2020 19:07:30'!
useClosedDoorFrom

	self error: Door.! !
!Door methodsFor: 'accessing' stamp: 'FG 12/17/2020 19:07:46' prior: 50910485!
useFrom: aRoom 

	state useDoor: self from: aRoom.! !
!ClosedDoor methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:07:58'!
useDoor: aDoor from: aRoom

	aDoor useClosedDoor.! !

!methodRemoval: ClosedDoor #useDoor: stamp: 'FG 12/17/2020 21:11:50'!
useDoor: aDoor

	aDoor useClosedDoor.!
!Door methodsFor: 'accessing' stamp: 'FG 12/17/2020 19:08:14'!
useClosedDoor

	self error: Door.! !

!methodRemoval: Door #useClosedDoorFrom stamp: 'FG 12/17/2020 21:11:50'!
useClosedDoorFrom

	self error: Door.!

!methodRemoval: Door class #cannotMoveFrom: stamp: 'FG 12/17/2020 21:11:50'!
cannotMoveFrom: aRoom 
	self shouldBeImplemented.!
!Door class methodsFor: 'exceptions' stamp: 'FG 12/17/2020 19:09:17'!
cannotUseClosedDoor
	^ 'Error - The door is closed. You cannot use it'.! !
!Door methodsFor: 'use' stamp: 'FG 12/17/2020 19:11:07' prior: 50910505!
useFrom: aRoom 

	^ state useDoor: self from: aRoom.! !
!Door methodsFor: 'use - private' stamp: 'FG 12/17/2020 19:11:56' prior: 50910518!
useClosedDoor

	self error: Door cannotUseClosedDoor .! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:13:05'!
test08CannotOpenDoorWithWrongKey

	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:13:09'!
test09CannotOpenDoorWithWrongKey

	
	! !

!methodRemoval: DoorTest #test08CannotOpenDoorWithWrongKey stamp: 'FG 12/17/2020 21:11:50'!
test08CannotOpenDoorWithWrongKey

	
	!

!classDefinition: #Door category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:11:50'!
Object subclass: #Door
	instanceVariableNames: 'firstRoom secondRoom state key'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!
!Door methodsFor: 'initialization' stamp: 'FG 12/17/2020 19:13:55'!
initializeIn: aRoom at: aPosition and: anotherRoom at: anotherPosition thatOpensWith: aKey
	
	(aRoom = anotherRoom) ifTrue: [ self error: Door doorCannotBeInTheSameRoomTwice ].
	
	aRoom at: aPosition put: self.
	anotherRoom at: anotherPosition put: self.
	
	key := aKey.
	state := ClosedDoor new.
	firstRoom := aRoom.
	secondRoom := anotherRoom.! !

!methodRemoval: Door #initializeIn:at:and:at:thatOpensWith: stamp: 'FG 12/17/2020 21:11:50'!
initializeIn: aRoom at: aPosition and: anotherRoom at: anotherPosition thatOpensWith: aKey
	
	(aRoom = anotherRoom) ifTrue: [ self error: Door doorCannotBeInTheSameRoomTwice ].
	
	aRoom at: aPosition put: self.
	anotherRoom at: anotherPosition put: self.
	
	key := aKey.
	state := ClosedDoor new.
	firstRoom := aRoom.
	secondRoom := anotherRoom.!
!Door methodsFor: 'initialization' stamp: 'FG 12/17/2020 19:15:27'!
initializeIn: aRoom at: aPosition and: anotherRoom at: anotherPosition thatOpensWith: aKey 
	
	(aRoom = anotherRoom) ifTrue: [ self error: Door doorCannotBeInTheSameRoomTwice ].
	
	aRoom at: aPosition put: self.
	anotherRoom at: anotherPosition put: self.
	
	state := ClosedDoor new.
	firstRoom := aRoom.
	secondRoom := anotherRoom.! !
!Door class methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:15:27' prior: 50909925!
in: aRoom at: aPosition and: anotherRoom at: anotherPosition
	
	^ self basicNew initializeIn: aRoom at: aPosition and: anotherRoom at: anotherPosition thatOpensWith: aKey.! !

!methodRemoval: Door #initializeIn:at:and:at: stamp: 'FG 12/17/2020 21:11:51'!
initializeIn: aRoom at: aPosition and: anotherRoom at: anotherPosition
	
	(aRoom = anotherRoom) ifTrue: [ self error: Door doorCannotBeInTheSameRoomTwice ].
	
	aRoom at: aPosition put: self.
	anotherRoom at: anotherPosition put: self.
	
	state := ClosedDoor new.
	firstRoom := aRoom.
	secondRoom := anotherRoom.!
!Door methodsFor: 'initialization' stamp: 'FG 12/17/2020 19:15:43' prior: 50910592!
initializeIn: aRoom at: aPosition and: anotherRoom at: anotherPosition thatOpensWith: aKey 
	
	(aRoom = anotherRoom) ifTrue: [ self error: Door doorCannotBeInTheSameRoomTwice ].
	
	aRoom at: aPosition put: self.
	anotherRoom at: anotherPosition put: self.
	
	key := aKey.
	state := ClosedDoor new.
	firstRoom := aRoom.
	secondRoom := anotherRoom.! !
!Door methodsFor: 'nil' stamp: 'FG 12/17/2020 19:17:59'!
openWith: aKey

	(key = aKey) ifFalse: [ self error: Door cannotOpenWithWrongKey].
	 ! !
!Door class methodsFor: 'exceptions' stamp: 'FG 12/17/2020 19:18:28'!
cannotOpenWithWrongKey
	^ 'Error - Cannot open door with a wrong key'.! !

!classDefinition: #Keys category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:11:51'!
PortableObject subclass: #Keys
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!

!classDefinition: #Keys category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:11:51'!
PortableObject subclass: #Keys
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!
!Keys methodsFor: 'no messages' stamp: 'FG 12/17/2020 19:20:45'!
initializeNamed: aName weighing: aWeight
	
	name := aName.
	weight := aWeight.! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:21:08'!
wrongKey

	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:21:35' prior: 50910671!
wrongKey

	^ Keys ! !
!Keys class methodsFor: 'no messages' stamp: 'FG 12/17/2020 19:21:51'!
named: aName weighing: aWeight
	
	^ self new initializeNamed: aName weighing: aWeight. ! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:22:20' prior: 50910675!
wrongKey

	^ Keys named: 'Wrong Key' weighing: 5 ! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:22:29' prior: 50910548!
test09CannotOpenDoorWithWrongKey

	

	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:22:59'!
correctKey

	^ Keys named: 'Correct Key' weighing: 5 ! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:23:07' prior: 50910689!
test09CannotOpenDoorWithWrongKey

	

	

	
	! !
!Door class methodsFor: 'initialization' stamp: 'FG 12/17/2020 19:24:00'!
in: aRoom at: aPosition and: anotherRoom at: anotherPosition thatOpensWith: aKey 
	
	^ self basicNew initializeIn: aRoom at: aPosition and: anotherRoom at: anotherPosition thatOpensWith: aKey.! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:24:00' prior: 50910037!
test03CannotPlaceDoorInOcupiedPositionInAnyOfTheRooms

	| room1 room2 |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
	
	room1 at: 1@1 put: self paper.
	room2 at: 1@1 put: self paper. 
	
	self 
		should: [ Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: self correctKey ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Room positionIsNotEmptyErrorDescription.
		
	self 
		should: [ Door in: room1 at: 1@0 and: room2 at: 1@1 thatOpensWith: self correctKey ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Room positionIsNotEmptyErrorDescription.
	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:24:00' prior: 50910429!
test05DoorLeadFromOneRoomToTheOther

	| room1 room2 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: self correctKey.	
	
	self assert: (door useFrom: room1) equals: room2.
	self assert: (door useFrom: room2) equals: room1. ! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:24:00' prior: 50910129!
test01DoorShouldBeInDifferentRooms

	| room |
	
	room := Room ofWidth: 10 andHeight: 10. 
	
	self 
		should: [ Door in: room at: 1@1 and: room at:1@1 thatOpensWith: self correctKey]
		raise: Error - MessageNotUnderstood 
		withMessageText: Door doorCannotBeInTheSameRoomTwice.
	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:24:00' prior: 50910404!
test07DoorStartsClosed

	| room1 room2 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: self correctKey.	
	
	self assert: door isClosed.! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:24:00' prior: 50910472!
test08CannotUseAClosedDoor

	| room1 room2 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: self correctKey.	
	
	self 
		should: [ door useFrom: room1]
		raise: Error - MessageNotUnderstood 
		withMessageText: (Door cannotUseClosedDoor).
	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:24:00' prior: 50909974!
test02CannotPlaceDoorInInvalidPositionInAnyOfTheRooms

	| room1 room2 |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
	
	self 
		should: [ Door in: room1 at: -1@0 and: room2 at: 1@1 thatOpensWith: self correctKey ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Room invalidPositionErrorDescription.
		
	self 
		should: [ Door in: room1 at: 1@0 and: room2 at: -1@1 thatOpensWith: self correctKey ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Room invalidPositionErrorDescription.
	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:24:00' prior: 50910080!
test04DoorIsInBothRooms

	| room1 room2 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: self correctKey.	
	
	self deny: (room1 isEmptyAt: 1@1).
	self deny: (room2 isEmptyAt: 0@1).
	self assert: (room1 at: 1@1) equals: door.
	self assert: (room2 at: 0@1) equals: door.  
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:24:00' prior: 50910442!
test06CannotMoveFromARoomWhichDoesntHasTheDoor

	| room1 room2 room3 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
	room3 := Room 	ofWidth: 10 andHeight: 10.
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: self correctKey.	
	
	self 
		should: [ door useFrom: room3]
		raise: Error - MessageNotUnderstood 
		withMessageText: (Door cannotMoveFromARoomWithoutThisDoor).! !

!methodRemoval: Door class #in:at:and:at: stamp: 'FG 12/17/2020 21:11:51'!
in: aRoom at: aPosition and: anotherRoom at: anotherPosition
	
	^ self basicNew initializeIn: aRoom at: aPosition and: anotherRoom at: anotherPosition thatOpensWith: aKey.!
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:25:22' prior: 50910698!
test09CannotOpenDoorWithWrongKey

	| room1 room2 door |

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: self correctKey.	

	

	

	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:25:58' prior: 50910849!
test09CannotOpenDoorWithWrongKey

	| room1 room2 door |

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: self correctKey.	
	
	self 
		should: [ door openWith: self wrongKey ]
		raise: Error - MessageNotUnderstood 
		withMessageText: (Door cannotOpenWithWrongKey).
	

	

	

	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:27:26'!
test09DoorOpensWithTheCorrectKey

	| room1 room2 door key |

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 

	key := self correctKey.	
			
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: key.	
	
	door openWith: key.
	
	self deny: door isClosed.	

	

	

	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:27:32'!
test10DoorOpensWithTheCorrectKey

	| room1 room2 door key |

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 

	key := self correctKey.	
			
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: key.	
	
	door openWith: key.
	
	self deny: door isClosed.	

	

	

	
	! !

!methodRemoval: DoorTest #test09DoorOpensWithTheCorrectKey stamp: 'FG 12/17/2020 21:11:52'!
test09DoorOpensWithTheCorrectKey

	| room1 room2 door key |

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 

	key := self correctKey.	
			
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: key.	
	
	door openWith: key.
	
	self deny: door isClosed.	

	

	

	
	!

!classDefinition: #OpenDoor category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:11:52'!
DoorState subclass: #OpenDoor
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!
!Door methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:29:27' prior: 50910640!
openWith: aKey

	(key = aKey) ifFalse: [ self error: Door cannotOpenWithWrongKey].
	
	state := OpenDoor new.
	 ! !
!OpenDoor methodsFor: 'no messages' stamp: 'FG 12/17/2020 19:30:01'!
isClosed
	^ false.! !
!OpenDoor methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:30:56'!
useDoor: aDoor from: aRoom
	^ aDoor useOpenDoorFrom: aRoom. ! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:32:05' prior: 50910735!
test05DoorLeadFromOneRoomToTheOther

	| room1 room2 door key |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	key := self correctKey.
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: key.
	door openWith: key.	
	
	self assert: (door useFrom: room1) equals: room2.
	self assert: (door useFrom: room2) equals: room1. ! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:33:02' prior: 50910824!
test06CannotMoveFromARoomWhichDoesntHasTheDoor

	| room1 room2 room3 door key |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
	room3 := Room 	ofWidth: 10 andHeight: 10.
	
	key := self correctKey.	
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: self key.
	door openWith: key.	
	
	self 
		should: [ door useFrom: room3]
		raise: Error - MessageNotUnderstood 
		withMessageText: (Door cannotMoveFromARoomWithoutThisDoor).! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:33:23' prior: 50910952!
test06CannotMoveFromARoomWhichDoesntHasTheDoor

	| room1 room2 room3 door key |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
	room3 := Room 	ofWidth: 10 andHeight: 10.
	
	key := self correctKey.	
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: key.
	door openWith: key.	
	
	self 
		should: [ door useFrom: room3]
		raise: Error - MessageNotUnderstood 
		withMessageText: (Door cannotMoveFromARoomWithoutThisDoor).! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:33:52'!
test11CannotOpenAnAlreadyOpenDoor

	| room1 room2 door key |

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 

	key := self correctKey.	
			
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: key.	
	
	door openWith: key.
	
	self deny: door isClosed.	

	

	

	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:34:37' prior: 50910988!
test11CannotOpenAnAlreadyOpenDoor

	| room1 room2 door key |

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 

	key := self correctKey.	
			
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: key.	
	
	door openWith: key.
	
	self 
		should: [ door openWith: key ]
		raise: Error - MessageNotUnderstood 
		withMessageText: (Door doorAlreadyOpen).

	

	

	
	! !
!Door methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:35:52' prior: 50910922!
openWith: aKey

	(key = aKey) ifFalse: [ self error: Door cannotOpenWithWrongKey].
	
	state openDoor: self.
	 ! !
!ClosedDoor methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:36:18'!
openDoor: aDoor

	aDoor openClosedDoor.
	! !
!OpenDoor methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:36:37'!
openDoor: aDoor
	
	aDoor openOpenedDoor.! !
!Door methodsFor: 'open - private' stamp: 'FG 12/17/2020 19:37:42'!
openClosedDoor

	! !
!Door methodsFor: 'open - private' stamp: 'FG 12/17/2020 19:38:37'!
openOpenedDoor

	self error: Door doorAlreadyOpen.! !
!Door methodsFor: 'open - private' stamp: 'FG 12/17/2020 19:39:00' prior: 50911032!
openClosedDoor

	state := OpenDoor new.

	! !
!Door class methodsFor: 'exceptions' stamp: 'FG 12/17/2020 19:39:38'!
doorAlreadyOpen

	^ 'Error - Door is already open' ! !
!Keys methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:42:15'!
isAKey
	^ true.! !
!NoPointsPortableObject methodsFor: 'nil' stamp: 'FG 12/17/2020 19:42:29'!
isAKey
	^ false.! !
!PointsPortableObject methodsFor: 'nil' stamp: 'FG 12/17/2020 19:42:42'!
isAKey
	^ false.! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:45:53'!
test12ADoorCannotBeLockedWithAnyObjectThatIsNotAKey

	| room1 room2 door paper |

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 

	
	

	

	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:47:47' prior: 50911058!
test12ADoorCannotBeLockedWithAnyObjectThatIsNotAKey

	| room1 room2 |

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 	
		
	self 
		should: [ Door in: room1 at: 1@1  and: room2  at: 1@1  thatOpensWith: self paper ]
		raise: Error - MessageNotUnderstood 
		withMessageText: (Door cannotBeLockedWithANonKeyObject).

	
	

	

	
	! !
!Door class methodsFor: 'exceptions' stamp: 'FG 12/17/2020 19:48:24'!
cannotBeLockedWithANonKeyObject
	^ 'Error - Door Cannot Be Locked With Non Key Object'.! !
!Door methodsFor: 'initialization' stamp: 'FG 12/17/2020 19:48:56' prior: 50910627!
initializeIn: aRoom at: aPosition and: anotherRoom at: anotherPosition thatOpensWith: aKey 
	
	(aRoom = anotherRoom) ifTrue: [ self error: Door doorCannotBeInTheSameRoomTwice ].
	(aKey isAKey) ifFalse: [ self error: Door cannotBeLockedWithANonKeyObject ].
	
	aRoom at: aPosition put: self.
	anotherRoom at: anotherPosition put: self.
	
	key := aKey.
	state := ClosedDoor new.
	firstRoom := aRoom.
	secondRoom := anotherRoom.! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:53:03'!
test13CannotCloseDoorWithANonKeyObject

	| room1 room2 door key|

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 	
		
	key := self correctKey.	
	door := Door in: room1 at: 1@1  and: room2  at: 1@1  thatOpensWith: key.
	door openWith:	 key.
		
	self 
		should: [ door closeWith: self paper ]
		raise: Error - MessageNotUnderstood 
		withMessageText: (Door cannotBeLockedWithANonKeyObject).

	
	

	

	
	! !
!Door methodsFor: 'nil' stamp: 'FG 12/17/2020 19:54:00'!
closeWith: aKey

	(key isAKey) ifFalse: [self error: Door cannotBeLockedWithANonKeyObject ].
	 ! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:54:37' prior: 50911103!
test13CannotCloseDoorWithANonKeyObject

	| room1 room2 door key|

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 	
		
	key := self correctKey.	
	door := Door in: room1 at: 1@1  and: room2  at: 1@1  thatOpensWith: key.
	door openWith:	 key.
		
	self 
		should: [ door closeWith: self paper ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Door cannotBeLockedWithANonKeyObject.

	
	

	

	
	! !
!Door methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:55:06' prior: 50911119!
closeWith: aKey

	(aKey isAKey) ifFalse: [self error: Door cannotBeLockedWithANonKeyObject ].
	 ! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:56:25'!
test13CannotCloseAClosedDoor

	| room1 room2 door key|

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 	
		
	key := self correctKey.	
	door := Door in: room1 at: 1@1  and: room2  at: 1@1  thatOpensWith: key.
		
	self 
		should: [ door closeWith: self correctKey ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Door cannotCloseAnAlreadyClosedDoor.

	
	

	

	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:56:31'!
test14CannotCloseAClosedDoor

	| room1 room2 door key|

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 	
		
	key := self correctKey.	
	door := Door in: room1 at: 1@1  and: room2  at: 1@1  thatOpensWith: key.
		
	self 
		should: [ door closeWith: self correctKey ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Door cannotCloseAnAlreadyClosedDoor.

	
	

	

	
	! !

!methodRemoval: DoorTest #test13CannotCloseAClosedDoor stamp: 'FG 12/17/2020 21:11:53'!
test13CannotCloseAClosedDoor

	| room1 room2 door key|

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 	
		
	key := self correctKey.	
	door := Door in: room1 at: 1@1  and: room2  at: 1@1  thatOpensWith: key.
		
	self 
		should: [ door closeWith: self correctKey ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Door cannotCloseAnAlreadyClosedDoor.

	
	

	

	
	!
!Door methodsFor: 'close' stamp: 'FG 12/17/2020 19:57:25' prior: 50911142!
closeWith: aKey

	(aKey isAKey) ifFalse: [self error: Door cannotBeLockedWithANonKeyObject ].
	
	state closeDoor: self with: aKey.
	 ! !
!ClosedDoor methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:57:56'!
closeDoor: aDoor with: aKey

	aDoor closeClosedDoor.! !
!Door methodsFor: 'nil' stamp: 'FG 12/17/2020 19:58:31'!
closeClosedDoor

	self error: Door doorAlreadyClosed.! !
!Door class methodsFor: 'exceptions' stamp: 'FG 12/17/2020 19:58:43'!
doorAlreadyClosed

	^ 'Error - Door is already closed' ! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:59:08' prior: 50911164!
test14CannotCloseAClosedDoor

	| room1 room2 door key|

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 	
		
	key := self correctKey.	
	door := Door in: room1 at: 1@1  and: room2  at: 1@1  thatOpensWith: key.
		
	self 
		should: [ door closeWith: self correctKey ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Door doorAlreadyClosed.

	
	

	

	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:02:24'!
test15DoorCanBeClosedWithAKey

	| room1 room2 door key newKey|

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 	
		
	key := self correctKey.	
	door := Door in: room1 at: 1@1  and: room2  at: 1@1  thatOpensWith: key.
	door openWith: key.

	newKey := self wrongKey.
	door closeWith: newKey.
	
	self assert: door isClosed.
	
	door openWith: newKey.
	
	self deny: door isClosed	.
	
		
	

	

	
	! !
!OpenDoor methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:03:13'!
closeDoor: aDoor with: aKey

	aDoor closeOpenedDoorWith: aKey.! !
!Door methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:03:38'!
closeOpenedDoorWith: aKey

	state := ClosedDoor new.
	key := aKey.! !
!Door methodsFor: 'initialization' stamp: 'FG 12/17/2020 20:05:43'!
assertThat: aRoom isDifferentFrom: anotherRoom

	^ (aRoom = anotherRoom) ifTrue: [ self error: Door doorCannotBeInTheSameRoomTwice ]! !
!Door methodsFor: 'initialization' stamp: 'FG 12/17/2020 20:05:43' prior: 50911087!
initializeIn: aRoom at: aPosition and: anotherRoom at: anotherPosition thatOpensWith: aKey 
	
	self assertThat: aRoom isDifferentFrom: anotherRoom.
	(aKey isAKey) ifFalse: [ self error: Door cannotBeLockedWithANonKeyObject ].
	
	aRoom at: aPosition put: self.
	anotherRoom at: anotherPosition put: self.
	
	key := aKey.
	state := ClosedDoor new.
	firstRoom := aRoom.
	secondRoom := anotherRoom.! !
!Door methodsFor: 'initialization' stamp: 'FG 12/17/2020 20:06:42'!
assertIsValidKey: aKey

	^ (aKey isAKey) ifFalse: [ self error: Door cannotBeLockedWithANonKeyObject ]! !
!Door methodsFor: 'initialization' stamp: 'FG 12/17/2020 20:06:42' prior: 50911263!
initializeIn: aRoom at: aPosition and: anotherRoom at: anotherPosition thatOpensWith: aKey 
	
	self assertThat: aRoom isDifferentFrom: anotherRoom.
	self assertIsValidKey: aKey.
	
	aRoom at: aPosition put: self.
	anotherRoom at: anotherPosition put: self.
	
	key := aKey.
	state := ClosedDoor new.
	firstRoom := aRoom.
	secondRoom := anotherRoom.! !
!Door methodsFor: 'open' stamp: 'FG 12/17/2020 20:10:12'!
assertThatIsTheCorrectKey: aKey

	^ (key = aKey) ifFalse: [ self error: Door cannotOpenWithWrongKey]! !
!Door methodsFor: 'open' stamp: 'FG 12/17/2020 20:10:12' prior: 50911017!
openWith: aKey

	self assertThatIsTheCorrectKey: aKey.
	
	state openDoor: self.
	 ! !
!Door methodsFor: 'close' stamp: 'FG 12/17/2020 20:10:31' prior: 50911195!
closeWith: aKey

	self assertIsValidKey: aKey.
	
	state closeDoor: self with: aKey.
	 ! !
!DoorState methodsFor: 'nil' stamp: 'FG 12/17/2020 20:11:15'!
closeDoor: aDoor with: aKey
	self subclassResponsibility.! !
!DoorState methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:11:33'!
isClosed
	self subclassResponsibility.! !
!DoorState methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:11:47'!
openDoor: aDoor with: aKey
	self subclassResponsibility.! !
!DoorState methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:12:30'!
openDoor: aDoor
	self subclassResponsibility.! !

!methodRemoval: DoorState #openDoor:with: stamp: 'FG 12/17/2020 21:11:54'!
openDoor: aDoor with: aKey
	self subclassResponsibility.!
!DoorState methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:12:47'!
useDoor: aDoor from: aRoom
	self subclassResponsibility ! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:14:15' overrides: 16927572!
setUp
	
	||! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:14:48' prior: 50911342 overrides: 16927572!
setUp
	
	| room anotherRoom|
	
	room := Room ofWidth: 10 andHeight: 10.
	anotherRoom := Room ofWidth: 10 andHeight: 10. ! !

!classDefinition: #DoorTest category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:11:54'!
TestCase subclass: #DoorTest
	instanceVariableNames: 'asd asda'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!

!classDefinition: #DoorTest category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:11:54'!
TestCase subclass: #DoorTest
	instanceVariableNames: 'asd asda'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:18:38' prior: 50911346 overrides: 16927572!
setUp
	
	asd := Room ofWidth: 10 andHeight: 10.
	asda := Room ofWidth: 10 andHeight: 10. ! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:18:44' prior: 50910749!
test01DoorShouldBeInDifferentRooms

	| room |
	
	asd := Room ofWidth: 10 andHeight: 10. 
	
	self 
		should: [ Door in: room at: 1@1 and: room at:1@1 thatOpensWith: self correctKey]
		raise: Error - MessageNotUnderstood 
		withMessageText: Door doorCannotBeInTheSameRoomTwice.
	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:18:59' prior: 50911377!
test01DoorShouldBeInDifferentRooms

	| room |
	
	self 
		should: [ Door in: room at: 1@1 and: asd at:1@1 thatOpensWith: self correctKey]
		raise: Error - MessageNotUnderstood 
		withMessageText: Door doorCannotBeInTheSameRoomTwice.
	
	! !

!methodRemoval: DoorTest #setUp stamp: 'FG 12/17/2020 21:11:54'!
setUp
	
	asd := Room ofWidth: 10 andHeight: 10.
	asda := Room ofWidth: 10 andHeight: 10. !

!classDefinition: #DoorTest category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:11:54'!
TestCase subclass: #DoorTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!

!classDefinition: #DoorTest category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:11:54'!
TestCase subclass: #DoorTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:19:52' prior: 50911389!
test01DoorShouldBeInDifferentRooms

	| room |
	
	room := Room ofWidth: 10 andHeight: 10. 
	
	self 
		should: [ Door in: room at: 1@1 and: room at:1@1 thatOpensWith: self correctKey]
		raise: Error - MessageNotUnderstood 
		withMessageText: Door doorCannotBeInTheSameRoomTwice.
	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:20:11'!
room

	^ Room ofWidth: 10 andHeight: 10 ! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:20:19' prior: 50911421!
test01DoorShouldBeInDifferentRooms

	| room |
	
	room := self room. 
	
	self 
		should: [ Door in: room at: 1@1 and: room at:1@1 thatOpensWith: self correctKey]
		raise: Error - MessageNotUnderstood 
		withMessageText: Door doorCannotBeInTheSameRoomTwice.
	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:21:04' prior: 50911438!
test01DoorShouldBeInDifferentRooms

       |sameRoom|

	sameRoom := self room.

	self 
		should: [ Door in: sameRoom  at: 1@1 and: sameRoom at:1@1 thatOpensWith: self correctKey]
		raise: Error - MessageNotUnderstood 
		withMessageText: Door doorCannotBeInTheSameRoomTwice.
	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:22:18'!
shouldDo: aBlock failingAndRaising: anErrorMessage

	self 
		should: aBlock
		raise: Error - MessageNotUnderstood 
		withMessageText: anErrorMessage.
	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:22:55' prior: 50911450!
test01DoorShouldBeInDifferentRooms

       |sameRoom|

	sameRoom := self room.

	self 
		shouldDo: [ Door in: sameRoom  at: 1@1 and: sameRoom at:1@1 thatOpensWith: self correctKey]
		failingAndRaising: Door doorCannotBeInTheSameRoomTwice.
	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:23:09' prior: 50910787!
test02CannotPlaceDoorInInvalidPositionInAnyOfTheRooms

	| room1 room2 |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
	
	self 
		should: [ Door in: room1 at: -1@0 and: room2 at: 1@1 thatOpensWith: self correctKey ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Room invalidPositionErrorDescription.
		
	self 
		should: [ Door in: room1 at: 1@0 and: room2 at: -1@1 thatOpensWith: self correctKey ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Room invalidPositionErrorDescription.
	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:23:18' prior: 50911481!
test02CannotPlaceDoorInInvalidPositionInAnyOfTheRooms

	| room room2 |
	
	room := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
	
	self 
		should: [ Door in: room at: -1@0 and: room2 at: 1@1 thatOpensWith: self correctKey ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Room invalidPositionErrorDescription.
		
	self 
		should: [ Door in: room at: 1@0 and: room2 at: -1@1 thatOpensWith: self correctKey ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Room invalidPositionErrorDescription.
	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:23:28' prior: 50911502!
test02CannotPlaceDoorInInvalidPositionInAnyOfTheRooms

	| room anotherRoom |
	
	room := Room ofWidth: 10 andHeight: 10.
	anotherRoom := Room ofWidth: 10 andHeight: 10. 
	
	self 
		should: [ Door in: room at: -1@0 and: anotherRoom at: 1@1 thatOpensWith: self correctKey ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Room invalidPositionErrorDescription.
		
	self 
		should: [ Door in: room at: 1@0 and: anotherRoom at: -1@1 thatOpensWith: self correctKey ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Room invalidPositionErrorDescription.
	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:24:33' prior: 50911523!
test02CannotPlaceDoorInInvalidPositionInAnyOfTheRooms

	| room anotherRoom |
	
	room := Room ofWidth: 10 andHeight: 10.
	anotherRoom := Room ofWidth: 10 andHeight: 10. 
	
	self 
		shouldDo:  [ Door in: room at: -1@0 and: anotherRoom at: 1@1 thatOpensWith: self correctKey ]
		failingAndRaising: Room invalidPositionErrorDescription.
		
		
	self 
		shouldDo:  [ Door in: room at: 1@0 and: anotherRoom at: -1@1 thatOpensWith: self correctKey ]
		failingAndRaising: Room invalidPositionErrorDescription.
	
	! !

!methodRemoval: DoorTest #test02CannotPlaceDoorInInvalidPositionInAnyOfTheRooms stamp: 'FG 12/17/2020 21:11:55'!
test02CannotPlaceDoorInInvalidPositionInAnyOfTheRooms

	| room anotherRoom |
	
	room := Room ofWidth: 10 andHeight: 10.
	anotherRoom := Room ofWidth: 10 andHeight: 10. 
	
	self 
		shouldDo:  [ Door in: room at: -1@0 and: anotherRoom at: 1@1 thatOpensWith: self correctKey ]
		failingAndRaising: Room invalidPositionErrorDescription.
		
		
	self 
		shouldDo:  [ Door in: room at: 1@0 and: anotherRoom at: -1@1 thatOpensWith: self correctKey ]
		failingAndRaising: Room invalidPositionErrorDescription.
	
	!

!methodRemoval: DoorTest #test03CannotPlaceDoorInOcupiedPositionInAnyOfTheRooms stamp: 'FG 12/17/2020 21:11:55'!
test03CannotPlaceDoorInOcupiedPositionInAnyOfTheRooms

	| room1 room2 |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
	
	room1 at: 1@1 put: self paper.
	room2 at: 1@1 put: self paper. 
	
	self 
		should: [ Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: self correctKey ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Room positionIsNotEmptyErrorDescription.
		
	self 
		should: [ Door in: room1 at: 1@0 and: room2 at: 1@1 thatOpensWith: self correctKey ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Room positionIsNotEmptyErrorDescription.
	
	!
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:24:55'!
test03DoorIsInBothRooms

	| room1 room2 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: self correctKey.	
	
	self deny: (room1 isEmptyAt: 1@1).
	self deny: (room2 isEmptyAt: 0@1).
	self assert: (room1 at: 1@1) equals: door.
	self assert: (room2 at: 0@1) equals: door.  
	! !

!methodRemoval: DoorTest #test04DoorIsInBothRooms stamp: 'FG 12/17/2020 21:11:55'!
test04DoorIsInBothRooms

	| room1 room2 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: self correctKey.	
	
	self deny: (room1 isEmptyAt: 1@1).
	self deny: (room2 isEmptyAt: 0@1).
	self assert: (room1 at: 1@1) equals: door.
	self assert: (room2 at: 0@1) equals: door.  
	!
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:25:04'!
test04DoorLeadFromOneRoomToTheOther

	| room1 room2 door key |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	key := self correctKey.
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: key.
	door openWith: key.	
	
	self assert: (door useFrom: room1) equals: room2.
	self assert: (door useFrom: room2) equals: room1. ! !

!methodRemoval: DoorTest #test05DoorLeadFromOneRoomToTheOther stamp: 'FG 12/17/2020 21:11:55'!
test05DoorLeadFromOneRoomToTheOther

	| room1 room2 door key |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	key := self correctKey.
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: key.
	door openWith: key.	
	
	self assert: (door useFrom: room1) equals: room2.
	self assert: (door useFrom: room2) equals: room1. !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:25:16'!
test02DoorIsInBothRooms

	| room1 room2 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: self correctKey.	
	
	self deny: (room1 isEmptyAt: 1@1).
	self deny: (room2 isEmptyAt: 0@1).
	self assert: (room1 at: 1@1) equals: door.
	self assert: (room2 at: 0@1) equals: door.  
	! !

!methodRemoval: DoorTest #test03DoorIsInBothRooms stamp: 'FG 12/17/2020 21:11:55'!
test03DoorIsInBothRooms

	| room1 room2 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: self correctKey.	
	
	self deny: (room1 isEmptyAt: 1@1).
	self deny: (room2 isEmptyAt: 0@1).
	self assert: (room1 at: 1@1) equals: door.
	self assert: (room2 at: 0@1) equals: door.  
	!
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:25:22'!
test03DoorLeadFromOneRoomToTheOther

	| room1 room2 door key |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	key := self correctKey.
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: key.
	door openWith: key.	
	
	self assert: (door useFrom: room1) equals: room2.
	self assert: (door useFrom: room2) equals: room1. ! !

!methodRemoval: DoorTest #test04DoorLeadFromOneRoomToTheOther stamp: 'FG 12/17/2020 21:11:55'!
test04DoorLeadFromOneRoomToTheOther

	| room1 room2 door key |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	key := self correctKey.
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: key.
	door openWith: key.	
	
	self assert: (door useFrom: room1) equals: room2.
	self assert: (door useFrom: room2) equals: room1. !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:25:28'!
test04CannotMoveFromARoomWhichDoesntHasTheDoor

	| room1 room2 room3 door key |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
	room3 := Room 	ofWidth: 10 andHeight: 10.
	
	key := self correctKey.	
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: key.
	door openWith: key.	
	
	self 
		should: [ door useFrom: room3]
		raise: Error - MessageNotUnderstood 
		withMessageText: (Door cannotMoveFromARoomWithoutThisDoor).! !

!methodRemoval: DoorTest #test06CannotMoveFromARoomWhichDoesntHasTheDoor stamp: 'FG 12/17/2020 21:11:55'!
test06CannotMoveFromARoomWhichDoesntHasTheDoor

	| room1 room2 room3 door key |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
	room3 := Room 	ofWidth: 10 andHeight: 10.
	
	key := self correctKey.	
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: key.
	door openWith: key.	
	
	self 
		should: [ door useFrom: room3]
		raise: Error - MessageNotUnderstood 
		withMessageText: (Door cannotMoveFromARoomWithoutThisDoor).!
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:25:34'!
test05DoorStartsClosed

	| room1 room2 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: self correctKey.	
	
	self assert: door isClosed.! !

!methodRemoval: DoorTest #test07DoorStartsClosed stamp: 'FG 12/17/2020 21:11:55'!
test07DoorStartsClosed

	| room1 room2 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: self correctKey.	
	
	self assert: door isClosed.!
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:25:38'!
test06CannotUseAClosedDoor

	| room1 room2 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: self correctKey.	
	
	self 
		should: [ door useFrom: room1]
		raise: Error - MessageNotUnderstood 
		withMessageText: (Door cannotUseClosedDoor).
	
	! !

!methodRemoval: DoorTest #test08CannotUseAClosedDoor stamp: 'FG 12/17/2020 21:11:56'!
test08CannotUseAClosedDoor

	| room1 room2 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: self correctKey.	
	
	self 
		should: [ door useFrom: room1]
		raise: Error - MessageNotUnderstood 
		withMessageText: (Door cannotUseClosedDoor).
	
	!
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:25:47'!
test07CannotOpenDoorWithWrongKey

	| room1 room2 door |

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: self correctKey.	
	
	self 
		should: [ door openWith: self wrongKey ]
		raise: Error - MessageNotUnderstood 
		withMessageText: (Door cannotOpenWithWrongKey).
	

	

	

	
	! !

!methodRemoval: DoorTest #test09CannotOpenDoorWithWrongKey stamp: 'FG 12/17/2020 21:11:56'!
test09CannotOpenDoorWithWrongKey

	| room1 room2 door |

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: self correctKey.	
	
	self 
		should: [ door openWith: self wrongKey ]
		raise: Error - MessageNotUnderstood 
		withMessageText: (Door cannotOpenWithWrongKey).
	

	

	

	
	!
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:25:53'!
test08DoorOpensWithTheCorrectKey

	| room1 room2 door key |

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 

	key := self correctKey.	
			
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: key.	
	
	door openWith: key.
	
	self deny: door isClosed.	

	

	

	
	! !

!methodRemoval: DoorTest #test10DoorOpensWithTheCorrectKey stamp: 'FG 12/17/2020 21:11:56'!
test10DoorOpensWithTheCorrectKey

	| room1 room2 door key |

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 

	key := self correctKey.	
			
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: key.	
	
	door openWith: key.
	
	self deny: door isClosed.	

	

	

	
	!
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:25:58'!
test09CannotOpenAnAlreadyOpenDoor

	| room1 room2 door key |

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 

	key := self correctKey.	
			
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: key.	
	
	door openWith: key.
	
	self 
		should: [ door openWith: key ]
		raise: Error - MessageNotUnderstood 
		withMessageText: (Door doorAlreadyOpen).

	

	

	
	! !

!methodRemoval: DoorTest #test11CannotOpenAnAlreadyOpenDoor stamp: 'FG 12/17/2020 21:11:56'!
test11CannotOpenAnAlreadyOpenDoor

	| room1 room2 door key |

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 

	key := self correctKey.	
			
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: key.	
	
	door openWith: key.
	
	self 
		should: [ door openWith: key ]
		raise: Error - MessageNotUnderstood 
		withMessageText: (Door doorAlreadyOpen).

	

	

	
	!
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:26:03'!
test10ADoorCannotBeLockedWithAnyObjectThatIsNotAKey

	| room1 room2 |

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 	
		
	self 
		should: [ Door in: room1 at: 1@1  and: room2  at: 1@1  thatOpensWith: self paper ]
		raise: Error - MessageNotUnderstood 
		withMessageText: (Door cannotBeLockedWithANonKeyObject).

	
	

	

	
	! !

!methodRemoval: DoorTest #test12ADoorCannotBeLockedWithAnyObjectThatIsNotAKey stamp: 'FG 12/17/2020 21:11:56'!
test12ADoorCannotBeLockedWithAnyObjectThatIsNotAKey

	| room1 room2 |

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 	
		
	self 
		should: [ Door in: room1 at: 1@1  and: room2  at: 1@1  thatOpensWith: self paper ]
		raise: Error - MessageNotUnderstood 
		withMessageText: (Door cannotBeLockedWithANonKeyObject).

	
	

	

	
	!
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:26:08'!
test11CannotCloseDoorWithANonKeyObject

	| room1 room2 door key|

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 	
		
	key := self correctKey.	
	door := Door in: room1 at: 1@1  and: room2  at: 1@1  thatOpensWith: key.
	door openWith:	 key.
		
	self 
		should: [ door closeWith: self paper ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Door cannotBeLockedWithANonKeyObject.

	
	

	

	
	! !

!methodRemoval: DoorTest #test13CannotCloseDoorWithANonKeyObject stamp: 'FG 12/17/2020 21:11:56'!
test13CannotCloseDoorWithANonKeyObject

	| room1 room2 door key|

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 	
		
	key := self correctKey.	
	door := Door in: room1 at: 1@1  and: room2  at: 1@1  thatOpensWith: key.
	door openWith:	 key.
		
	self 
		should: [ door closeWith: self paper ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Door cannotBeLockedWithANonKeyObject.

	
	

	

	
	!
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:26:14'!
test12CannotCloseAClosedDoor

	| room1 room2 door key|

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 	
		
	key := self correctKey.	
	door := Door in: room1 at: 1@1  and: room2  at: 1@1  thatOpensWith: key.
		
	self 
		should: [ door closeWith: self correctKey ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Door doorAlreadyClosed.

	
	

	

	
	! !

!methodRemoval: DoorTest #test14CannotCloseAClosedDoor stamp: 'FG 12/17/2020 21:11:56'!
test14CannotCloseAClosedDoor

	| room1 room2 door key|

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 	
		
	key := self correctKey.	
	door := Door in: room1 at: 1@1  and: room2  at: 1@1  thatOpensWith: key.
		
	self 
		should: [ door closeWith: self correctKey ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Door doorAlreadyClosed.

	
	

	

	
	!
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:26:20'!
test13DoorCanBeClosedWithAKey

	| room1 room2 door key newKey|

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 	
		
	key := self correctKey.	
	door := Door in: room1 at: 1@1  and: room2  at: 1@1  thatOpensWith: key.
	door openWith: key.

	newKey := self wrongKey.
	door closeWith: newKey.
	
	self assert: door isClosed.
	
	door openWith: newKey.
	
	self deny: door isClosed	.
	
		
	

	

	
	! !

!methodRemoval: DoorTest #test15DoorCanBeClosedWithAKey stamp: 'FG 12/17/2020 21:11:56'!
test15DoorCanBeClosedWithAKey

	| room1 room2 door key newKey|

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 	
		
	key := self correctKey.	
	door := Door in: room1 at: 1@1  and: room2  at: 1@1  thatOpensWith: key.
	door openWith: key.

	newKey := self wrongKey.
	door closeWith: newKey.
	
	self assert: door isClosed.
	
	door openWith: newKey.
	
	self deny: door isClosed	.
	
		
	

	

	
	!
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:26:37' prior: 50911665!
test02DoorIsInBothRooms

	| room room2 door |
	
	room := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room at: 1@1 and: room2 at: 0@1 thatOpensWith: self correctKey.	
	
	self deny: (room isEmptyAt: 1@1).
	self deny: (room2 isEmptyAt: 0@1).
	self assert: (room at: 1@1) equals: door.
	self assert: (room2 at: 0@1) equals: door.  
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:26:57' prior: 50912022!
test02DoorIsInBothRooms

	| room anotherRoom door |
	
	room := Room ofWidth: 10 andHeight: 10.
	anotherRoom := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room at: 1@1 and: anotherRoom at: 0@1 thatOpensWith: self correctKey.	
	
	self deny: (room isEmptyAt: 1@1).
	self deny: (anotherRoom isEmptyAt: 0@1).
	self assert: (room at: 1@1) equals: door.
	self assert: (anotherRoom at: 0@1) equals: door.  
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:27:47' prior: 50911695!
test03DoorLeadFromOneRoomToTheOther

	| room anotherRoom door key |
	
	room := Room ofWidth: 10 andHeight: 10.
	anotherRoom := Room ofWidth: 10 andHeight: 10. 
		
	key := self correctKey.
	door := Door in: room at: 1@1 and: anotherRoom at: 0@1 thatOpensWith: key.
	door openWith: key.	
	
	self assert: (door useFrom: room) equals: anotherRoom.
	self assert: (door useFrom: anotherRoom) equals: room. ! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:28:20'!
openedDoor

	| room anotherRoom door key |
	
	room := Room ofWidth: 10 andHeight: 10.
	anotherRoom := Room ofWidth: 10 andHeight: 10. 
		
	key := self correctKey.
	door := Door in: room at: 1@1 and: anotherRoom at: 0@1 thatOpensWith: key.
	door openWith: key.	
	
	^ door! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:29:54' prior: 50911725!
test04CannotMoveFromARoomWhichDoesntHasTheDoor

	| room door |
	
	room := Room ofWidth: 10 andHeight: 10.
	
	door := self openedDoor.
	self 
		should: [ door useFrom: room]
		raise: Error - MessageNotUnderstood 
		withMessageText: (Door cannotMoveFromARoomWithoutThisDoor).! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:30:41' prior: 50912081!
test04CannotMoveFromARoomWhichDoesntHasTheDoor

	| room door |
	
	room := Room ofWidth: 10 andHeight: 10.
	
	door := self openedDoor.
	
	self 
		shouldDo: [ door useFrom: room] 
		failingAndRaising: Door cannotMoveFromARoomWithoutThisDoor
! !
!Room methodsFor: 'contents' stamp: 'FG 12/17/2020 20:36:04' prior: 50909439!
moveFrom: aSourcePosition to: aTargetPosition

	| toMove |
	
	((self at: aTargetPosition) isKindOf: Door) 
	ifTrue:[
	
	]
	ifFalse: [
		toMove := self at: aSourcePosition.
		self at: aTargetPosition put: toMove.
		contents removeKey: aSourcePosition.
	].
	! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'FG 12/17/2020 20:40:19'!
test21_playerShouldMoveFromRoomsWhenPassThroughADoor

	| room anotherRoom player box paper anotherPaper |

	room := self defaultRoom.
	anotherRoom := self defaultRoom.
	Door in: room at:  0@1 and: anotherRoom at: 0@1  thatOpensWith: self correctKey .
	player := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 0@0 heading: #North in: room.
	
	player moveForward.
	
	! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'FG 12/17/2020 20:42:03' prior: 50912115!
test21_playerShouldMoveFromRoomsWhenPassThroughADoor

	| room anotherRoom player box paper anotherPaper |

	room := self defaultRoom.
	anotherRoom := self defaultRoom.
	Door in: room at:  0@1 and: anotherRoom at: 0@1  thatOpensWith: self correctKey .
	player := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 0@0 heading: #North in: room.
	
	player moveForward.
	
	self assert: (anotherRoom at: 0@2) equals: player. 
	! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'FG 12/17/2020 20:42:13' prior: 50912130!
test21_playerShouldMoveFromRoomsWhenPassThroughADoor

	| room anotherRoom player |

	room := self defaultRoom.
	anotherRoom := self defaultRoom.
	Door in: room at:  0@1 and: anotherRoom at: 0@1  thatOpensWith: self correctKey .
	player := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 0@0 heading: #North in: room.
	
	player moveForward.
	
	self assert: (anotherRoom at: 0@2) equals: player. 
	! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'FG 12/17/2020 20:42:37'!
correctKey

	^ Keys named: 'Correct Key' weighing: 5 ! !
!Room methodsFor: 'contents' stamp: 'FG 12/17/2020 20:47:06' prior: 50912104!
moveFrom: aSourcePosition to: aTargetPosition

	| toMove |
	
		toMove := self at: aSourcePosition.
		self at: aTargetPosition put: toMove.
		contents removeKey: aSourcePosition.
	! !
!Room methodsFor: 'contents' stamp: 'FG 12/17/2020 20:50:22'!
moveAt: aPosition to: anotherRoom at: anotherPosition

	anotherRoom at: anotherPosition put: (self at: aPosition).
	contents removeKey: aPosition.! !
!PlayableCharacter methodsFor: 'moving' stamp: 'FG 12/17/2020 20:52:08' prior: 50909199!
moveForward
	
	self moveTo: self forwardPosition ! !
!PlayableCharacter methodsFor: 'moving' stamp: 'FG 12/17/2020 20:54:01' prior: 50909203!
moveTo: aNewPosition
	
	((room at: aNewPosition) isKindOf: Door)
	ifTrue:[
		room 
	]
	ifFalse:[
		room moveFrom: self position to: aNewPosition.
	] ! !
!PlayableCharacter methodsFor: 'moving' stamp: 'FG 12/17/2020 20:56:21' prior: 50912189!
moveTo: aNewPosition
	
	((room at: aNewPosition) isKindOf: Door)
	ifTrue:[
		room moveAt: (room positionOf: self) to: ((room at: aNewPosition) useFrom: room) at:  room
	]
	ifFalse:[
		room moveFrom: self position to: aNewPosition.
	] ! !
!PlayableCharacter methodsFor: 'moving' stamp: 'FG 12/17/2020 21:00:54' prior: 50912197!
moveTo: aNewPosition
	
	|newRoom|
	
	((room at: aNewPosition) isKindOf: Door)
	ifTrue:[
		newRoom := 	(room at: aNewPosition) useFrom: room.
		room moveAt: self position to: newRoom at: (newRoom positionOf: (room at: aNewPosition)).
	]
	ifFalse:[
		room moveFrom: self position to: aNewPosition.
	] ! !
!PlayableCharacter methodsFor: 'moving' stamp: 'FG 12/17/2020 21:01:19' prior: 50912208!
moveTo: aNewPosition
	
	|newRoom|
	
	((room at: aNewPosition) isKindOf: Door)
	ifTrue:[
		newRoom := 	(room at: aNewPosition) useFrom: room.
		room moveAt: self position to: newRoom at: (newRoom positionOf: (room at: aNewPosition) + heading forwardPoint).
	]
	ifFalse:[
		room moveFrom: self position to: aNewPosition.
	] ! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'FG 12/17/2020 21:02:53'!
openedDoor

	| room anotherRoom door key |
	
	room := Room ofWidth: 10 andHeight: 10.
	anotherRoom := Room ofWidth: 10 andHeight: 10. 
		
	key := self correctKey.
	door := Door in: room at: 1@1 and: anotherRoom at: 0@1 thatOpensWith: key.
	door openWith: key.	
	
	^ door! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'FG 12/17/2020 21:03:06' prior: 50912234!
openedDoor

	| room anotherRoom door key |
	
	room := Room ofWidth: 10 andHeight: 10.
	anotherRoom := Room ofWidth: 10 andHeight: 10. 
		
	key := self correctKey.
	door := self openedDoor.
	door openWith: key.	
	
	^ door! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'FG 12/17/2020 21:03:44' prior: 50912147!
test21_playerShouldMoveFromRoomsWhenPassThroughADoor

	| room anotherRoom player |

	room := self defaultRoom.
	anotherRoom := self defaultRoom.
	self openedDoor.
	player := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 0@0 heading: #North in: room.
	
	player moveForward.
	
	self assert: (anotherRoom at: 0@2) equals: player. 
	! !

!classDefinition: #BackpackTest category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:11:57'!
TestCase subclass: #BackpackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classDefinition: #BackpackTest category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:11:57'!
TestCase subclass: #BackpackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:29:03' prior: 50908320!
assertShouldAddAll: portableObjects withPoints: expectedTotalPoints

	| aBackpack |
	
	aBackpack := Backpack containingUpTo: self backpackWeight limitingPointsTo: 100.

	portableObjects do: [ :aPortableObject | aBackpack add: aPortableObject ].
	
	self assert: aBackpack size equals: portableObjects size.
	self assert: aBackpack totalWeight equals: (portableObjects sum: [ :aPortableObject | aPortableObject weight ]).
	self assert: aBackpack totalPoints equals: expectedTotalPoints.
! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:28:32' prior: 50908338!
assertShouldNotAddPortableObjectIfWeightExceeded: aPortableObject

	| aBackpack |
	aBackpack := Backpack containingUpTo: self backpackWeight limitingPointsTo: 100.

	self
		should: [ aBackpack add: aPortableObject ]
		raise: Error
		withMessageText: Backpack maxWeightExceededErrorDescription.
		
	self assert: aBackpack isEmpty. 
! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:28:32' prior: 50908351!
backpackWeight

	^ 42! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:28:41' prior: 50908354!
test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded

	self assertShouldNotAddPortableObjectIfWeightExceeded: 
		(NoPointsPortableObject named: 'help-wanted sign' weighing: self backpackWeight + 1)
! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:28:47' prior: 50908363!
test08ShouldNotAddPointsPortableObjectIfWeightExceeded

	self assertShouldNotAddPortableObjectIfWeightExceeded: 
		(PointsPortableObject named: 'left-handed hammer' weighing: self backpackWeight + 6 worth: 5) ! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:26:42' prior: 50908372!
test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity

	self 
		assertShouldAddAll: self twoPortableObjects
		withPoints: 5.
! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:27:27' prior: 50908379!
test10ShouldAddPortableObjectsIfWeightEqualsMaxWeightCapacity

	self 
		assertShouldAddAll:  self twoPortableObjects, {(PointsPortableObject named: 'letter' weighing: 1 worth: 5)}
		withPoints: 10.
! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:27:39' prior: 50908388!
twoPortableObjects

	^ {
		(PointsPortableObject named: 'left-handed hammer' weighing: 40 worth: 5).
		(NoPointsPortableObject named: 'help-wanted sign' weighing: 1) }! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04' prior: 50908396!
test01CanNotCreateBackpackWithZeroMaxWeight

	self
		should: [ Backpack containingUpTo: 0 limitingPointsTo: 100 ]
		raise: Error
		withMessageText: Backpack invalidWeightCapacityErrorDescription.
! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04' prior: 50908405!
test02CanNotCreateBackpackWithNegativeMaxWeight

	self
		should: [ Backpack containingUpTo: -1 limitingPointsTo: 100 ]
		raise: Error
		withMessageText: Backpack invalidWeightCapacityErrorDescription.! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04' prior: 50908414!
test03CanNotCreateBackpackWithZeroMaxPoints

	self
		should: [ Backpack containingUpTo: 10 limitingPointsTo: 0 ]
		raise: Error
		withMessageText: Backpack invalidPointsCapacityErrorDescription.
! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04' prior: 50908423!
test04CanNotCreateBackpackWithNegativeMaxPoints

	self
		should: [ Backpack containingUpTo: 10 limitingPointsTo: -1 ]
		raise: Error
		withMessageText: Backpack invalidPointsCapacityErrorDescription.! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04' prior: 50908432!
test05CanNotCreateBackpackWithNoIntegerMaxWeight

	self
		should: [ Backpack containingUpTo: 1.0 limitingPointsTo: 100 ]
		raise: Error
		withMessageText: Backpack weightCapacityMustBeIntegerErrorDescription.
! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04' prior: 50908441!
test06CanNotCreateBackpackWithNoIntegerMaxPoints

	self
		should: [ Backpack containingUpTo: 100 limitingPointsTo: 1.0 ]
		raise: Error
		withMessageText: Backpack pointsCapacityMustBeIntegerErrorDescription.
! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:49:20' prior: 50908450!
test11ShouldAddZeroWeightWhenEmpty

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	self assert: aBackpack totalWeight equals: 0.
	self assert: aBackpack isEmpty
! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:35:57' prior: 50908459!
test12ShouldAddWeightWhenAddingPortableObjects

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	aBackpack add: (PointsPortableObject named: 'left-handed hammer' weighing: 10 worth: 5).
	aBackpack add: (NoPointsPortableObject named: 'help-wanted sign' weighing: 10).
	
	self assert: aBackpack size equals: 2.
	self assert: aBackpack totalWeight equals: 20.

! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:49:31' prior: 50908474!
test13ShouldAddZeroPointsWhenEmpty

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	self assert: aBackpack totalPoints equals: 0.
	self assert: aBackpack isEmpty.
! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:35:57' prior: 50908483!
test14ShouldAddPointsWhenAddingPointsPortableObjects

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	aBackpack add: (PointsPortableObject named: 'left-handed hammer' weighing: 10 worth: 5).
	aBackpack add: (PointsPortableObject named: 'car key' weighing: 10 worth: 20).
	
	self assert: aBackpack size equals: 2.
	self assert: aBackpack totalPoints equals: 25.

! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:35:57' prior: 50908498!
test15ShouldNotAddPointsWhenAddingNoPointsPortableObjects

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	aBackpack add: (PointsPortableObject named: 'left-handed hammer' weighing: 10 worth: 5).
	aBackpack add: (NoPointsPortableObject named: 'help-wanted sign' weighing: 10).
	aBackpack add: (NoPointsPortableObject named: 'help-wanted sign' weighing: 10).
	
	self assert: aBackpack size equals: 3.
	self assert: aBackpack totalPoints equals: 5.

! !

!classDefinition: #PlayableCharacterTest category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:11:58'!
TestCase subclass: #PlayableCharacterTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classDefinition: #PlayableCharacterTest category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:11:58'!
TestCase subclass: #PlayableCharacterTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/9/2020 19:36:13' prior: 50908539!
test01_forwardWhenHeadingNorthIncrementsYCoordinate

	| playableCharacter |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 1@2 heading: #North .

	playableCharacter moveForward.

	self assert: (playableCharacter isAt: 1@3 heading: #North)! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/9/2020 19:36:13' prior: 50908551!
test02_backwardWhenHeadingNorthDecrementsYCoordinate

	| playableCharacter |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 1@2 heading: #North .

	playableCharacter moveBackward.

	self assert: (playableCharacter isAt: 1@1 heading: #North)! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/9/2020 19:36:13' prior: 50908563!
test03_rotateRightWhenHeadingNorthHeadsEast

	| playableCharacter |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 1@2 heading: #North .

	playableCharacter rotateRight.

	self assert: (playableCharacter isAt: 1@2 heading: #East)! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/9/2020 19:36:13' prior: 50908575!
test04_rotateLeftWhenHeadingNorthHeadsWest

	| playableCharacter |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 1@2 heading: #North .

	playableCharacter rotateLeft.

	self assert: (playableCharacter isAt: 1@2 heading: #West)! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/9/2020 19:36:13' prior: 50908587!
test05_movingWhenHeadingEastWorksAsExpected

	| playableCharacter |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 1@2 heading: #East .

	playableCharacter
		moveForward;
		moveForward;
		moveBackward;
		rotateRight;
		rotateLeft;
		rotateLeft.

	self assert: (playableCharacter isAt: 2@2 heading: #North)! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/9/2020 19:36:13' prior: 50908601!
test06_movingWhenHeadingSouthWorksAsExpected

	| playableCharacter |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 1@2 heading: #South .

	playableCharacter
		moveForward;
		moveForward;
		moveBackward;
		rotateRight;
		rotateLeft;
		rotateLeft.

	self assert: (playableCharacter isAt: 1@1 heading: #East)! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/9/2020 19:36:13' prior: 50908616!
test07_movingWhenHeadingWestWorksAsExpected

	| playableCharacter |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 2@2 heading: #West .

	playableCharacter
		moveForward;
		moveForward;
		moveBackward;
		rotateRight;
		rotateLeft;
		rotateLeft.

	self assert: (playableCharacter isAt: 1@2 heading: #South)! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/9/2020 19:36:13' prior: 50908630!
test08_canNotCreatePlayableCharacterWhenHeadingIsNotValid

	self
		should: [PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 1@2 heading: #X ]
		raise: Error
		withExceptionDo: [:anError |
			self assert: PlayableCharacter invalidCardinalPointErrorDescription equals: anError messageText ]! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/9/2020 19:43:14' prior: 50908643!
test09_canTakePortableObjects

	| playableCharacter paper |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 2@2 heading: #West .
	paper := NoPointsPortableObject named: 'Paper' weighing: 1.
	
	playableCharacter take: paper.
	
	self assert: (playableCharacter backpackIncludes: paper)! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/9/2020 19:47:21' prior: 50908657!
test10_canNotTakeMoreObjectsThanTheBackpackCanCarry

	| playableCharacter paper key |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 2@2 heading: #West .
	paper := NoPointsPortableObject named: 'Paper' weighing: 100.
	key := NoPointsPortableObject named: 'Key' weighing: 1.
	
	playableCharacter take: paper.
	self 
		should: [ playableCharacter take: key ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [:anError |
			self assert: Backpack maxWeightExceededErrorDescription equals: anError messageText.
			self assert: (playableCharacter backpackIncludes: paper).
			self deny: (playableCharacter backpackIncludes: key) ]
	
	! !
!PlayableCharacterTest methodsFor: 'as yet unclassified' stamp: 'HAW 12/9/2020 13:53:29' prior: 50908847!
defaultBackpack

	^ Backpack containingUpTo: 100 limitingPointsTo: 100 ! !

!classDefinition: #Backpack category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:11:58'!
Object subclass: #Backpack
	instanceVariableNames: 'weightCapacity gamePointsCapacity container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classDefinition: #Backpack category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:11:58'!
Object subclass: #Backpack
	instanceVariableNames: 'weightCapacity gamePointsCapacity container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!
!Backpack methodsFor: 'exceptions' stamp: 'FRT 10/8/2020 18:02:29' prior: 50908987!
signalMaxPointsExceeded

	self error: self class maxPointsExceededErrorDescription ! !
!Backpack methodsFor: 'exceptions' stamp: 'FRT 10/8/2020 18:02:47' prior: 50908992!
signalMaxWeightExceeded

	self error: self class maxWeightExceededErrorDescription ! !
!Backpack methodsFor: 'initialization' stamp: 'HAW 10/14/2020 14:31:56' prior: 50908997!
initializeContainingUpTo: aWeightCapacity limitingPointsTo: pointsCapacity

	weightCapacity := aWeightCapacity.
	gamePointsCapacity := pointsCapacity.
	
	container := OrderedCollection new.
	
	
	! !
!Backpack methodsFor: 'accessing' stamp: 'FRT 10/11/2020 19:14:47' prior: 50909006 overrides: 16880927!
size

	^ container size.! !
!Backpack methodsFor: 'accessing' stamp: 'HAW 10/18/2020 12:20:52' prior: 50909009!
totalPoints
		
	^(container select: [ :portableObject | portableObject doesItAddPoints ])	
		sum: [ :portableObject | portableObject points ]
		ifEmpty: [ 0 ]! !
!Backpack methodsFor: 'accessing' stamp: 'HAW 10/18/2020 12:20:20' prior: 50909017!
totalWeight
	
	^container 
		sum: [ :portableObject | portableObject weight ]
		ifEmpty: [ 0 ]
		! !
!Backpack methodsFor: 'assertions' stamp: 'FRT 10/12/2020 14:12:36' prior: 50909023!
assertPointsAdding: aPointsPortableObject

	(self totalPoints + aPointsPortableObject points) > gamePointsCapacity ifTrue: [ self signalMaxPointsExceeded ]! !
!Backpack methodsFor: 'assertions' stamp: 'FRT 10/15/2020 12:22:34' prior: 50909031!
assertWeightAdding: aPortableObject tolerating: aThreshold

	(self totalWeight + aPortableObject weight - weightCapacity) > aThreshold ifTrue: [ self signalMaxWeightExceeded ]! !
!Backpack methodsFor: 'adding' stamp: 'HAW 10/18/2020 12:28:24' prior: 50909039!
add: aPortableObject
	
	aPortableObject assertCanAddTo: self.
	
	container add: aPortableObject.
	! !
!Backpack methodsFor: 'testing' stamp: 'HAW 12/9/2020 19:44:17' prior: 50909045!
includes: aPortableObject 
	
	^container includes: aPortableObject ! !
!Backpack methodsFor: 'testing' stamp: 'FRT 10/11/2020 18:38:38' prior: 50909050!
isEmpty

	^ container isEmpty.! !
!Backpack methodsFor: 'adding - private' stamp: 'HAW 10/18/2020 12:28:48' prior: 50909054!
assertCanAddNoPointsPortableObject: aNoPointsPortableObject 
	
	self assertWeightAdding: aNoPointsPortableObject tolerating: 0.
	! !
!Backpack methodsFor: 'adding - private' stamp: 'HAW 10/18/2020 12:29:07' prior: 50909061!
assertCanAddPointPortableObject: aPointsPortableObject 
	
	self assertWeightAdding: aPointsPortableObject tolerating: 5.
	self assertPointsAdding: aPointsPortableObject.
	! !

!classDefinition: 'Backpack class' category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:11:59'!
Backpack class
	instanceVariableNames: ''!

!classDefinition: 'Backpack class' category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:11:59'!
Backpack class
	instanceVariableNames: ''!
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 18:27:33' prior: 50909080!
invalidPointsCapacityErrorDescription

	^ 'Points capacity must be positive'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 18:21:04' prior: 50909085!
invalidWeightCapacityErrorDescription

	^ 'Weight capacity must be positive'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/8/2020 17:36:29' prior: 50909090!
maxPointsExceededErrorDescription

	^ 'Maximum points has been exceeded'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/8/2020 17:36:17' prior: 50909095!
maxWeightExceededErrorDescription

	^ 'Maximum weight has been exceeded'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/8/2020 17:43:00' prior: 50909100!
pointsCapacityMustBeIntegerErrorDescription

	^ 'Points capacity must be integer'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/8/2020 17:42:48' prior: 50909106!
weightCapacityMustBeIntegerErrorDescription

	^ 'Weight capacity must be integer'! !
!Backpack class methodsFor: 'exceptions' stamp: 'FRT 10/11/2020 18:27:16' prior: 50909111!
signalInvalidPointsCapacity

	self error: self invalidPointsCapacityErrorDescription 
! !
!Backpack class methodsFor: 'exceptions' stamp: 'FRT 10/11/2020 18:21:51' prior: 50909117!
signalInvalidWeightCapacity

	self error: self invalidWeightCapacityErrorDescription 
! !
!Backpack class methodsFor: 'exceptions' stamp: 'FRT 10/8/2020 17:41:06' prior: 50909123!
signalPointsCapacityMustBeInteger

	self error: self pointsCapacityMustBeIntegerErrorDescription
! !
!Backpack class methodsFor: 'exceptions' stamp: 'FRT 10/8/2020 17:40:47' prior: 50909129!
signalWeightCapacityMustBeInteger

	self error: self weightCapacityMustBeIntegerErrorDescription
! !
!Backpack class methodsFor: 'instance creation' stamp: 'HAW 10/14/2020 14:31:56' prior: 50909135!
containingUpTo: aWeightCapacity limitingPointsTo: pointsCapacity

	aWeightCapacity strictlyPositive  ifFalse: [ self signalInvalidWeightCapacity ].
	pointsCapacity strictlyPositive ifFalse: [ self signalInvalidPointsCapacity ].
	
	aWeightCapacity isInteger ifFalse: [ self signalWeightCapacityMustBeInteger ].
	pointsCapacity isInteger ifFalse: [ self signalPointsCapacityMustBeInteger ].
	
	^ self new initializeContainingUpTo: aWeightCapacity limitingPointsTo: pointsCapacity.
! !

!classDefinition: #PlayableCharacter category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:11:59'!
Object subclass: #PlayableCharacter
	instanceVariableNames: 'position heading backpack name'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classDefinition: #PlayableCharacter category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:11:59'!
Object subclass: #PlayableCharacter
	instanceVariableNames: 'position heading backpack name'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!
!PlayableCharacter methodsFor: 'initialization' stamp: 'HAW 12/9/2020 19:35:22'!
initializeNamed: aName using: aBackpack at: aPosition heading: aMarsRoverHeading 

	name := aName.
	backpack := aBackpack.
	position := aPosition.
	heading := aMarsRoverHeading! !
!PlayableCharacter methodsFor: 'testing' stamp: 'HAW 12/9/2020 19:43:44' prior: 50909244!
backpackIncludes: aPortableObject 
	
	^backpack includes: aPortableObject ! !
!PlayableCharacter methodsFor: 'testing' stamp: 'HAW 7/1/2018 14:25:05' prior: 50909182!
isAt: aPosition heading: aCardinalPoint

	^position = aPosition and: [ heading cardinalPoint = aCardinalPoint ]! !
!PlayableCharacter methodsFor: 'moving' stamp: 'HAW 10/11/2019 08:22:42' prior: 50909194!
moveBackward
	
	position := position - heading forwardPoint ! !
!PlayableCharacter methodsFor: 'moving' stamp: 'HAW 10/11/2019 08:21:58' prior: 50912184!
moveForward
	
	position := position + heading forwardPoint! !
!PlayableCharacter methodsFor: 'rotating' stamp: 'HAW 10/11/2019 08:31:55' prior: 50909212!
rotateLeft
	
	heading := heading leftHeading! !
!PlayableCharacter methodsFor: 'rotating' stamp: 'HAW 10/11/2019 08:32:04' prior: 50909216!
rotateRight
	
	heading := heading rightHeading! !
!PlayableCharacter methodsFor: 'taking objects' stamp: 'HAW 12/9/2020 19:28:57' prior: 50909227!
take: aPortableObject

	backpack add: aPortableObject.! !

!classDefinition: 'PlayableCharacter class' category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:12:00'!
PlayableCharacter class
	instanceVariableNames: 'headings'!

!classDefinition: 'PlayableCharacter class' category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:12:00'!
PlayableCharacter class
	instanceVariableNames: 'headings'!
!PlayableCharacter class methodsFor: 'heading' stamp: 'HAW 7/2/2018 16:28:16' prior: 50909269!
headingFor: aCardinalPoint
	
	^headings at: aCardinalPoint ifAbsent: [ self error: self invalidCardinalPointErrorDescription ]! !
!PlayableCharacter class methodsFor: 'heading' stamp: 'HAW 7/2/2018 16:26:14' prior: 50909276!
invalidCardinalPointErrorDescription
	
	^'Invalid cardinal point'! !
!PlayableCharacter class methodsFor: 'instance creation' stamp: 'HAW 12/9/2020 19:36:13'!
named: aName using: aBackpack at: aPosition heading: aCardinalPoint 
	
	| newHeading |

	newHeading := self headingFor: aCardinalPoint.
	
	^self new initializeNamed: aName using: aBackpack at: aPosition heading: newHeading ! !
!PlayableCharacter class methodsFor: 'initialization' stamp: 'HAW 10/11/2019 08:37:25' prior: 50909292!
forHeadingAt: aCardinalPoint leftIs: aLeftCardinalPoint rightIs: aRightCardinalPoint
	
	(headings at: aCardinalPoint) leftHeading: (headings at: aLeftCardinalPoint) rightHeading: (headings at: aRightCardinalPoint).
	! !
!PlayableCharacter class methodsFor: 'initialization' stamp: 'HAW 7/2/2018 15:27:41' prior: 50909303 overrides: 16883149!
initialize

	self initializeHeadings! !
!PlayableCharacter class methodsFor: 'initialization' stamp: 'HAW 12/9/2020 19:31:43' prior: 50909307!
initializeHeadings

	headings := Dictionary new.
	
	(OrderedCollection 
		with: (PlayableCharacterHeading for: #North forwardWith: 0@1 )	
		with: (PlayableCharacterHeading for: #East forwardWith: 1@0 )
		with: (PlayableCharacterHeading for: #South forwardWith: 0@-1 )
		with: (PlayableCharacterHeading for: #West forwardWith: -1@0 ))
			do: [ :heading | headings at: heading cardinalPoint put: heading ].
	
	self 
		forHeadingAt: #North leftIs: #West rightIs: #East;
		forHeadingAt: #South leftIs: #East rightIs: #West;
		forHeadingAt: #East leftIs: #North rightIs: #South;
		forHeadingAt: #West leftIs: #South rightIs: #North.
	! !

!classDefinition: #PlayableCharacterHeading category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:12:00'!
Object subclass: #PlayableCharacterHeading
	instanceVariableNames: 'cardinalPoint forwardPoint rightHeading leftHeading'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classDefinition: #PlayableCharacterHeading category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:12:00'!
Object subclass: #PlayableCharacterHeading
	instanceVariableNames: 'cardinalPoint forwardPoint rightHeading leftHeading'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!
!PlayableCharacterHeading methodsFor: 'accessing' stamp: 'HAW 7/2/2018 15:29:44' prior: 50909352!
cardinalPoint
	
	^cardinalPoint! !
!PlayableCharacterHeading methodsFor: 'accessing' stamp: 'HAW 7/2/2018 15:30:39' prior: 50909356!
forwardPoint
	
	^forwardPoint! !
!PlayableCharacterHeading methodsFor: 'accessing' stamp: 'HAW 10/11/2019 08:31:33' prior: 50909360!
leftHeading
	
	^leftHeading! !
!PlayableCharacterHeading methodsFor: 'accessing' stamp: 'HAW 10/11/2019 08:31:27' prior: 50909364!
rightHeading
	
	^rightHeading! !
!PlayableCharacterHeading methodsFor: 'initialization' stamp: 'HAW 10/11/2019 08:27:25' prior: 50909368!
initializeFor: aCardinalPoint forwardWith: aForwardPoint  
	
	cardinalPoint := aCardinalPoint.
	forwardPoint := aForwardPoint.
! !
!PlayableCharacterHeading methodsFor: 'initialization' stamp: 'HAW 10/11/2019 08:31:33' prior: 50909375!
leftHeading: aLeftHeading rightHeading: aRightHeading
 
	leftHeading := aLeftHeading.
	rightHeading := aRightHeading ! !

!classDefinition: 'PlayableCharacterHeading class' category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:12:00'!
PlayableCharacterHeading class
	instanceVariableNames: ''!

!classDefinition: 'PlayableCharacterHeading class' category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:12:00'!
PlayableCharacterHeading class
	instanceVariableNames: ''!
!PlayableCharacterHeading class methodsFor: 'instance creation' stamp: 'HAW 10/11/2019 08:27:46' prior: 50909394!
for: aCardinalPoint forwardWith: aForwardPoint  

	^self new initializeFor: aCardinalPoint forwardWith: aForwardPoint ! !

!classDefinition: #StageObject category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:12:00'!
Object subclass: #StageObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classDefinition: #StageObject category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:12:00'!
Object subclass: #StageObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classDefinition: #PortableObject category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:12:00'!
StageObject subclass: #PortableObject
	instanceVariableNames: 'name weight'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classDefinition: #PortableObject category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:12:00'!
StageObject subclass: #PortableObject
	instanceVariableNames: 'name weight'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!
!PortableObject methodsFor: 'testing' stamp: 'FRT 10/11/2020 17:54:20' prior: 50909668!
doesItAddPoints

	self subclassResponsibility	! !
!PortableObject methodsFor: 'adding' stamp: 'HAW 10/18/2020 12:28:24' prior: 50909672!
assertCanAddTo: aBackpack

	self subclassResponsibility	! !
!PortableObject methodsFor: 'accessing' stamp: 'FRT 10/11/2020 18:53:51' prior: 50909677!
weight

	^ weight! !

!classDefinition: #NoPointsPortableObject category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:12:01'!
PortableObject subclass: #NoPointsPortableObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classDefinition: #NoPointsPortableObject category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:12:01'!
PortableObject subclass: #NoPointsPortableObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!
!NoPointsPortableObject methodsFor: 'initialization' stamp: 'HAW 10/14/2020 14:34:36' prior: 50909711!
initializeNamed: aName weighing: aWeight
	
	name := aName.
	weight := aWeight.! !
!NoPointsPortableObject methodsFor: 'testing' stamp: 'FRT 10/11/2020 17:54:20' prior: 50909717 overrides: 50913097!
doesItAddPoints	

	^ false! !
!NoPointsPortableObject methodsFor: 'adding' stamp: 'HAW 10/18/2020 12:28:48' prior: 50909722 overrides: 50913102!
assertCanAddTo: aBackpack 
	
	^aBackpack assertCanAddNoPointsPortableObject: self! !

!classDefinition: 'NoPointsPortableObject class' category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:12:01'!
NoPointsPortableObject class
	instanceVariableNames: ''!

!classDefinition: 'NoPointsPortableObject class' category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:12:01'!
NoPointsPortableObject class
	instanceVariableNames: ''!
!NoPointsPortableObject class methodsFor: 'instance creation' stamp: 'HAW 10/14/2020 14:34:36' prior: 50909740!
named: aName weighing: aWeight
	
	^ self new initializeNamed: aName weighing: aWeight. ! !

!classDefinition: #PointsPortableObject category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:12:01'!
PortableObject subclass: #PointsPortableObject
	instanceVariableNames: 'points'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classDefinition: #PointsPortableObject category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:12:01'!
PortableObject subclass: #PointsPortableObject
	instanceVariableNames: 'points'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!
!PointsPortableObject methodsFor: 'testing' stamp: 'FRT 10/11/2020 17:54:20' prior: 50909765 overrides: 50913097!
doesItAddPoints

	^ true! !
!PointsPortableObject methodsFor: 'initialization' stamp: 'HAW 10/14/2020 14:36:26' prior: 50909769!
initializeNamed: aName weighing: aWeight worth: gamePoints
	
	name := aName.
	weight := aWeight.
	points := gamePoints.! !
!PointsPortableObject methodsFor: 'accessing' stamp: 'FRT 10/11/2020 19:06:57' prior: 50909776!
points

	^ points! !
!PointsPortableObject methodsFor: 'adding' stamp: 'HAW 10/18/2020 12:29:07' prior: 50909780 overrides: 50913102!
assertCanAddTo: aBackpack 
	
	^aBackpack assertCanAddPointPortableObject: self! !

!classDefinition: 'PointsPortableObject class' category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:12:01'!
PointsPortableObject class
	instanceVariableNames: ''!

!classDefinition: 'PointsPortableObject class' category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:12:01'!
PointsPortableObject class
	instanceVariableNames: ''!
!PointsPortableObject class methodsFor: 'instance creation' stamp: 'HAW 10/14/2020 14:36:26' prior: 50909798!
named: aName weighing: aWeight worth: gamePoints
	
	^ self new initializeNamed: aName weighing: aWeight worth: gamePoints.! !

!classDefinition: #BackpackTest category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:12:01'!
TestCase subclass: #BackpackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classDefinition: #BackpackTest category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:12:01'!
TestCase subclass: #BackpackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:29:03' prior: 50912286!
assertShouldAddAll: portableObjects withPoints: expectedTotalPoints

	| aBackpack |
	
	aBackpack := Backpack containingUpTo: self backpackWeight limitingPointsTo: 100.

	portableObjects do: [ :aPortableObject | aBackpack add: aPortableObject ].
	
	self assert: aBackpack size equals: portableObjects size.
	self assert: aBackpack totalWeight equals: (portableObjects sum: [ :aPortableObject | aPortableObject weight ]).
	self assert: aBackpack totalPoints equals: expectedTotalPoints.
! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:28:32' prior: 50912304!
assertShouldNotAddPortableObjectIfWeightExceeded: aPortableObject

	| aBackpack |
	aBackpack := Backpack containingUpTo: self backpackWeight limitingPointsTo: 100.

	self
		should: [ aBackpack add: aPortableObject ]
		raise: Error
		withMessageText: Backpack maxWeightExceededErrorDescription.
		
	self assert: aBackpack isEmpty. 
! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:28:32' prior: 50912318!
backpackWeight

	^ 42! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:28:41' prior: 50912322!
test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded

	self assertShouldNotAddPortableObjectIfWeightExceeded: 
		(NoPointsPortableObject named: 'help-wanted sign' weighing: self backpackWeight + 1)
! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:28:47' prior: 50912332!
test08ShouldNotAddPointsPortableObjectIfWeightExceeded

	self assertShouldNotAddPortableObjectIfWeightExceeded: 
		(PointsPortableObject named: 'left-handed hammer' weighing: self backpackWeight + 6 worth: 5) ! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:26:42' prior: 50912342!
test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity

	self 
		assertShouldAddAll: self twoPortableObjects
		withPoints: 5.
! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:27:27' prior: 50912349!
test10ShouldAddPortableObjectsIfWeightEqualsMaxWeightCapacity

	self 
		assertShouldAddAll:  self twoPortableObjects, {(PointsPortableObject named: 'letter' weighing: 1 worth: 5)}
		withPoints: 10.
! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:27:39' prior: 50912358!
twoPortableObjects

	^ {
		(PointsPortableObject named: 'left-handed hammer' weighing: 40 worth: 5).
		(NoPointsPortableObject named: 'help-wanted sign' weighing: 1) }! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04' prior: 50912367!
test01CanNotCreateBackpackWithZeroMaxWeight

	self
		should: [ Backpack containingUpTo: 0 limitingPointsTo: 100 ]
		raise: Error
		withMessageText: Backpack invalidWeightCapacityErrorDescription.
! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04' prior: 50912376!
test02CanNotCreateBackpackWithNegativeMaxWeight

	self
		should: [ Backpack containingUpTo: -1 limitingPointsTo: 100 ]
		raise: Error
		withMessageText: Backpack invalidWeightCapacityErrorDescription.! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04' prior: 50912386!
test03CanNotCreateBackpackWithZeroMaxPoints

	self
		should: [ Backpack containingUpTo: 10 limitingPointsTo: 0 ]
		raise: Error
		withMessageText: Backpack invalidPointsCapacityErrorDescription.
! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04' prior: 50912395!
test04CanNotCreateBackpackWithNegativeMaxPoints

	self
		should: [ Backpack containingUpTo: 10 limitingPointsTo: -1 ]
		raise: Error
		withMessageText: Backpack invalidPointsCapacityErrorDescription.! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04' prior: 50912405!
test05CanNotCreateBackpackWithNoIntegerMaxWeight

	self
		should: [ Backpack containingUpTo: 1.0 limitingPointsTo: 100 ]
		raise: Error
		withMessageText: Backpack weightCapacityMustBeIntegerErrorDescription.
! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04' prior: 50912415!
test06CanNotCreateBackpackWithNoIntegerMaxPoints

	self
		should: [ Backpack containingUpTo: 100 limitingPointsTo: 1.0 ]
		raise: Error
		withMessageText: Backpack pointsCapacityMustBeIntegerErrorDescription.
! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:49:20' prior: 50912425!
test11ShouldAddZeroWeightWhenEmpty

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	self assert: aBackpack totalWeight equals: 0.
	self assert: aBackpack isEmpty
! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:35:57' prior: 50912434!
test12ShouldAddWeightWhenAddingPortableObjects

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	aBackpack add: (PointsPortableObject named: 'left-handed hammer' weighing: 10 worth: 5).
	aBackpack add: (NoPointsPortableObject named: 'help-wanted sign' weighing: 10).
	
	self assert: aBackpack size equals: 2.
	self assert: aBackpack totalWeight equals: 20.

! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:49:31' prior: 50912450!
test13ShouldAddZeroPointsWhenEmpty

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	self assert: aBackpack totalPoints equals: 0.
	self assert: aBackpack isEmpty.
! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:35:57' prior: 50912460!
test14ShouldAddPointsWhenAddingPointsPortableObjects

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	aBackpack add: (PointsPortableObject named: 'left-handed hammer' weighing: 10 worth: 5).
	aBackpack add: (PointsPortableObject named: 'car key' weighing: 10 worth: 20).
	
	self assert: aBackpack size equals: 2.
	self assert: aBackpack totalPoints equals: 25.

! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:35:57' prior: 50912476!
test15ShouldNotAddPointsWhenAddingNoPointsPortableObjects

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	aBackpack add: (PointsPortableObject named: 'left-handed hammer' weighing: 10 worth: 5).
	aBackpack add: (NoPointsPortableObject named: 'help-wanted sign' weighing: 10).
	aBackpack add: (NoPointsPortableObject named: 'help-wanted sign' weighing: 10).
	
	self assert: aBackpack size equals: 3.
	self assert: aBackpack totalPoints equals: 5.

! !

!classDefinition: #PlayableCharacterTest category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:12:02'!
TestCase subclass: #PlayableCharacterTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classDefinition: #PlayableCharacterTest category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:12:02'!
TestCase subclass: #PlayableCharacterTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/9/2020 19:36:13' prior: 50912511!
test01_forwardWhenHeadingNorthIncrementsYCoordinate

	| playableCharacter |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 1@2 heading: #North .

	playableCharacter moveForward.

	self assert: (playableCharacter isAt: 1@3 heading: #North)! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/9/2020 19:36:13' prior: 50912523!
test02_backwardWhenHeadingNorthDecrementsYCoordinate

	| playableCharacter |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 1@2 heading: #North .

	playableCharacter moveBackward.

	self assert: (playableCharacter isAt: 1@1 heading: #North)! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/9/2020 19:36:13' prior: 50912535!
test03_rotateRightWhenHeadingNorthHeadsEast

	| playableCharacter |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 1@2 heading: #North .

	playableCharacter rotateRight.

	self assert: (playableCharacter isAt: 1@2 heading: #East)! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/9/2020 19:36:13' prior: 50912547!
test04_rotateLeftWhenHeadingNorthHeadsWest

	| playableCharacter |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 1@2 heading: #North .

	playableCharacter rotateLeft.

	self assert: (playableCharacter isAt: 1@2 heading: #West)! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/9/2020 19:36:13' prior: 50912559!
test05_movingWhenHeadingEastWorksAsExpected

	| playableCharacter |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 1@2 heading: #East .

	playableCharacter
		moveForward;
		moveForward;
		moveBackward;
		rotateRight;
		rotateLeft;
		rotateLeft.

	self assert: (playableCharacter isAt: 2@2 heading: #North)! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/9/2020 19:36:13' prior: 50912573!
test06_movingWhenHeadingSouthWorksAsExpected

	| playableCharacter |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 1@2 heading: #South .

	playableCharacter
		moveForward;
		moveForward;
		moveBackward;
		rotateRight;
		rotateLeft;
		rotateLeft.

	self assert: (playableCharacter isAt: 1@1 heading: #East)! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/9/2020 19:36:13' prior: 50912587!
test07_movingWhenHeadingWestWorksAsExpected

	| playableCharacter |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 2@2 heading: #West .

	playableCharacter
		moveForward;
		moveForward;
		moveBackward;
		rotateRight;
		rotateLeft;
		rotateLeft.

	self assert: (playableCharacter isAt: 1@2 heading: #South)! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/9/2020 19:36:13' prior: 50912601!
test08_canNotCreatePlayableCharacterWhenHeadingIsNotValid

	self
		should: [PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 1@2 heading: #X ]
		raise: Error
		withExceptionDo: [:anError |
			self assert: PlayableCharacter invalidCardinalPointErrorDescription equals: anError messageText ]! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/9/2020 19:43:14' prior: 50912614!
test09_canTakePortableObjects

	| playableCharacter paper |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 2@2 heading: #West .
	paper := NoPointsPortableObject named: 'Paper' weighing: 1.
	
	playableCharacter take: paper.
	
	self assert: (playableCharacter backpackIncludes: paper)! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/9/2020 19:47:21' prior: 50912628!
test10_canNotTakeMoreObjectsThanTheBackpackCanCarry

	| playableCharacter paper key |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 2@2 heading: #West .
	paper := NoPointsPortableObject named: 'Paper' weighing: 100.
	key := NoPointsPortableObject named: 'Key' weighing: 1.
	
	playableCharacter take: paper.
	self 
		should: [ playableCharacter take: key ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [:anError |
			self assert: Backpack maxWeightExceededErrorDescription equals: anError messageText.
			self assert: (playableCharacter backpackIncludes: paper).
			self deny: (playableCharacter backpackIncludes: key) ]
	
	! !
!PlayableCharacterTest methodsFor: 'as yet unclassified' stamp: 'HAW 12/9/2020 13:53:29' prior: 50912653!
defaultBackpack

	^ Backpack containingUpTo: 100 limitingPointsTo: 100 ! !

!classDefinition: #Backpack category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:12:02'!
Object subclass: #Backpack
	instanceVariableNames: 'weightCapacity gamePointsCapacity container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classDefinition: #Backpack category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:12:02'!
Object subclass: #Backpack
	instanceVariableNames: 'weightCapacity gamePointsCapacity container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!
!Backpack methodsFor: 'exceptions' stamp: 'FRT 10/8/2020 18:02:29' prior: 50912676!
signalMaxPointsExceeded

	self error: self class maxPointsExceededErrorDescription ! !
!Backpack methodsFor: 'exceptions' stamp: 'FRT 10/8/2020 18:02:47' prior: 50912682!
signalMaxWeightExceeded

	self error: self class maxWeightExceededErrorDescription ! !
!Backpack methodsFor: 'initialization' stamp: 'HAW 10/14/2020 14:31:56' prior: 50912688!
initializeContainingUpTo: aWeightCapacity limitingPointsTo: pointsCapacity

	weightCapacity := aWeightCapacity.
	gamePointsCapacity := pointsCapacity.
	
	container := OrderedCollection new.
	
	
	! !
!Backpack methodsFor: 'accessing' stamp: 'FRT 10/11/2020 19:14:47' prior: 50912698 overrides: 16880927!
size

	^ container size.! !
!Backpack methodsFor: 'accessing' stamp: 'HAW 10/18/2020 12:20:52' prior: 50912702!
totalPoints
		
	^(container select: [ :portableObject | portableObject doesItAddPoints ])	
		sum: [ :portableObject | portableObject points ]
		ifEmpty: [ 0 ]! !
!Backpack methodsFor: 'accessing' stamp: 'HAW 10/18/2020 12:20:20' prior: 50912710!
totalWeight
	
	^container 
		sum: [ :portableObject | portableObject weight ]
		ifEmpty: [ 0 ]
		! !
!Backpack methodsFor: 'assertions' stamp: 'FRT 10/12/2020 14:12:36' prior: 50912716!
assertPointsAdding: aPointsPortableObject

	(self totalPoints + aPointsPortableObject points) > gamePointsCapacity ifTrue: [ self signalMaxPointsExceeded ]! !
!Backpack methodsFor: 'assertions' stamp: 'FRT 10/15/2020 12:22:34' prior: 50912724!
assertWeightAdding: aPortableObject tolerating: aThreshold

	(self totalWeight + aPortableObject weight - weightCapacity) > aThreshold ifTrue: [ self signalMaxWeightExceeded ]! !
!Backpack methodsFor: 'adding' stamp: 'HAW 10/18/2020 12:28:24' prior: 50912733!
add: aPortableObject
	
	aPortableObject assertCanAddTo: self.
	
	container add: aPortableObject.
	! !
!Backpack methodsFor: 'testing' stamp: 'HAW 12/9/2020 19:44:17' prior: 50912739!
includes: aPortableObject 
	
	^container includes: aPortableObject ! !
!Backpack methodsFor: 'testing' stamp: 'FRT 10/11/2020 18:38:38' prior: 50912744!
isEmpty

	^ container isEmpty.! !
!Backpack methodsFor: 'adding - private' stamp: 'HAW 10/18/2020 12:28:48' prior: 50912748!
assertCanAddNoPointsPortableObject: aNoPointsPortableObject 
	
	self assertWeightAdding: aNoPointsPortableObject tolerating: 0.
	! !
!Backpack methodsFor: 'adding - private' stamp: 'HAW 10/18/2020 12:29:07' prior: 50912755!
assertCanAddPointPortableObject: aPointsPortableObject 
	
	self assertWeightAdding: aPointsPortableObject tolerating: 5.
	self assertPointsAdding: aPointsPortableObject.
	! !

!classDefinition: 'Backpack class' category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:12:03'!
Backpack class
	instanceVariableNames: ''!

!classDefinition: 'Backpack class' category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:12:03'!
Backpack class
	instanceVariableNames: ''!
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 18:27:33' prior: 50912773!
invalidPointsCapacityErrorDescription

	^ 'Points capacity must be positive'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 18:21:04' prior: 50912779!
invalidWeightCapacityErrorDescription

	^ 'Weight capacity must be positive'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/8/2020 17:36:29' prior: 50912785!
maxPointsExceededErrorDescription

	^ 'Maximum points has been exceeded'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/8/2020 17:36:17' prior: 50912791!
maxWeightExceededErrorDescription

	^ 'Maximum weight has been exceeded'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/8/2020 17:43:00' prior: 50912797!
pointsCapacityMustBeIntegerErrorDescription

	^ 'Points capacity must be integer'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/8/2020 17:42:48' prior: 50912803!
weightCapacityMustBeIntegerErrorDescription

	^ 'Weight capacity must be integer'! !
!Backpack class methodsFor: 'exceptions' stamp: 'FRT 10/11/2020 18:27:16' prior: 50912809!
signalInvalidPointsCapacity

	self error: self invalidPointsCapacityErrorDescription 
! !
!Backpack class methodsFor: 'exceptions' stamp: 'FRT 10/11/2020 18:21:51' prior: 50912815!
signalInvalidWeightCapacity

	self error: self invalidWeightCapacityErrorDescription 
! !
!Backpack class methodsFor: 'exceptions' stamp: 'FRT 10/8/2020 17:41:06' prior: 50912821!
signalPointsCapacityMustBeInteger

	self error: self pointsCapacityMustBeIntegerErrorDescription
! !
!Backpack class methodsFor: 'exceptions' stamp: 'FRT 10/8/2020 17:40:47' prior: 50912827!
signalWeightCapacityMustBeInteger

	self error: self weightCapacityMustBeIntegerErrorDescription
! !
!Backpack class methodsFor: 'instance creation' stamp: 'HAW 10/14/2020 14:31:56' prior: 50912834!
containingUpTo: aWeightCapacity limitingPointsTo: pointsCapacity

	aWeightCapacity strictlyPositive  ifFalse: [ self signalInvalidWeightCapacity ].
	pointsCapacity strictlyPositive ifFalse: [ self signalInvalidPointsCapacity ].
	
	aWeightCapacity isInteger ifFalse: [ self signalWeightCapacityMustBeInteger ].
	pointsCapacity isInteger ifFalse: [ self signalPointsCapacityMustBeInteger ].
	
	^ self new initializeContainingUpTo: aWeightCapacity limitingPointsTo: pointsCapacity.
! !

!classDefinition: #PlayableCharacter category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:12:03'!
Object subclass: #PlayableCharacter
	instanceVariableNames: 'position heading backpack name'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classDefinition: #PlayableCharacter category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:12:03'!
Object subclass: #PlayableCharacter
	instanceVariableNames: 'position heading backpack name'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!
!PlayableCharacter methodsFor: 'initialization' stamp: 'HAW 12/9/2020 19:35:22' prior: 50912870!
initializeNamed: aName using: aBackpack at: aPosition heading: aMarsRoverHeading 

	name := aName.
	backpack := aBackpack.
	position := aPosition.
	heading := aMarsRoverHeading! !
!PlayableCharacter methodsFor: 'testing' stamp: 'HAW 12/9/2020 19:43:44' prior: 50912879!
backpackIncludes: aPortableObject 
	
	^backpack includes: aPortableObject ! !
!PlayableCharacter methodsFor: 'testing' stamp: 'HAW 7/1/2018 14:25:05' prior: 50912885!
isAt: aPosition heading: aCardinalPoint

	^position = aPosition and: [ heading cardinalPoint = aCardinalPoint ]! !
!PlayableCharacter methodsFor: 'moving' stamp: 'HAW 10/11/2019 08:22:42' prior: 50912892!
moveBackward
	
	position := position - heading forwardPoint ! !
!PlayableCharacter methodsFor: 'moving' stamp: 'HAW 10/11/2019 08:21:58' prior: 50912897!
moveForward
	
	position := position + heading forwardPoint! !
!PlayableCharacter methodsFor: 'rotating' stamp: 'HAW 10/11/2019 08:31:55' prior: 50912902!
rotateLeft
	
	heading := heading leftHeading! !
!PlayableCharacter methodsFor: 'rotating' stamp: 'HAW 10/11/2019 08:32:04' prior: 50912907!
rotateRight
	
	heading := heading rightHeading! !
!PlayableCharacter methodsFor: 'taking objects' stamp: 'HAW 12/9/2020 19:28:57' prior: 50912912!
take: aPortableObject

	backpack add: aPortableObject.! !

!classDefinition: 'PlayableCharacter class' category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:12:04'!
PlayableCharacter class
	instanceVariableNames: 'headings'!

!classDefinition: 'PlayableCharacter class' category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:12:04'!
PlayableCharacter class
	instanceVariableNames: 'headings'!
!PlayableCharacter class methodsFor: 'heading' stamp: 'HAW 7/2/2018 16:28:16' prior: 50912928!
headingFor: aCardinalPoint
	
	^headings at: aCardinalPoint ifAbsent: [ self error: self invalidCardinalPointErrorDescription ]! !
!PlayableCharacter class methodsFor: 'heading' stamp: 'HAW 7/2/2018 16:26:14' prior: 50912936!
invalidCardinalPointErrorDescription
	
	^'Invalid cardinal point'! !
!PlayableCharacter class methodsFor: 'instance creation' stamp: 'HAW 12/9/2020 19:36:13' prior: 50912941!
named: aName using: aBackpack at: aPosition heading: aCardinalPoint 
	
	| newHeading |

	newHeading := self headingFor: aCardinalPoint.
	
	^self new initializeNamed: aName using: aBackpack at: aPosition heading: newHeading ! !
!PlayableCharacter class methodsFor: 'initialization' stamp: 'HAW 10/11/2019 08:37:25' prior: 50912952!
forHeadingAt: aCardinalPoint leftIs: aLeftCardinalPoint rightIs: aRightCardinalPoint
	
	(headings at: aCardinalPoint) leftHeading: (headings at: aLeftCardinalPoint) rightHeading: (headings at: aRightCardinalPoint).
	! !
!PlayableCharacter class methodsFor: 'initialization' stamp: 'HAW 7/2/2018 15:27:41' prior: 50912963 overrides: 16883149!
initialize

	self initializeHeadings! !
!PlayableCharacter class methodsFor: 'initialization' stamp: 'HAW 12/9/2020 19:31:43' prior: 50912968!
initializeHeadings

	headings := Dictionary new.
	
	(OrderedCollection 
		with: (PlayableCharacterHeading for: #North forwardWith: 0@1 )	
		with: (PlayableCharacterHeading for: #East forwardWith: 1@0 )
		with: (PlayableCharacterHeading for: #South forwardWith: 0@-1 )
		with: (PlayableCharacterHeading for: #West forwardWith: -1@0 ))
			do: [ :heading | headings at: heading cardinalPoint put: heading ].
	
	self 
		forHeadingAt: #North leftIs: #West rightIs: #East;
		forHeadingAt: #South leftIs: #East rightIs: #West;
		forHeadingAt: #East leftIs: #North rightIs: #South;
		forHeadingAt: #West leftIs: #South rightIs: #North.
	! !

!classDefinition: #PlayableCharacterHeading category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:12:04'!
Object subclass: #PlayableCharacterHeading
	instanceVariableNames: 'cardinalPoint forwardPoint rightHeading leftHeading'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classDefinition: #PlayableCharacterHeading category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:12:04'!
Object subclass: #PlayableCharacterHeading
	instanceVariableNames: 'cardinalPoint forwardPoint rightHeading leftHeading'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!
!PlayableCharacterHeading methodsFor: 'accessing' stamp: 'HAW 7/2/2018 15:29:44' prior: 50913011!
cardinalPoint
	
	^cardinalPoint! !
!PlayableCharacterHeading methodsFor: 'accessing' stamp: 'HAW 7/2/2018 15:30:39' prior: 50913016!
forwardPoint
	
	^forwardPoint! !
!PlayableCharacterHeading methodsFor: 'accessing' stamp: 'HAW 10/11/2019 08:31:33' prior: 50913021!
leftHeading
	
	^leftHeading! !
!PlayableCharacterHeading methodsFor: 'accessing' stamp: 'HAW 10/11/2019 08:31:27' prior: 50913026!
rightHeading
	
	^rightHeading! !
!PlayableCharacterHeading methodsFor: 'initialization' stamp: 'HAW 10/11/2019 08:27:25' prior: 50913031!
initializeFor: aCardinalPoint forwardWith: aForwardPoint  
	
	cardinalPoint := aCardinalPoint.
	forwardPoint := aForwardPoint.
! !
!PlayableCharacterHeading methodsFor: 'initialization' stamp: 'HAW 10/11/2019 08:31:33' prior: 50913039!
leftHeading: aLeftHeading rightHeading: aRightHeading
 
	leftHeading := aLeftHeading.
	rightHeading := aRightHeading ! !

!classDefinition: 'PlayableCharacterHeading class' category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:12:04'!
PlayableCharacterHeading class
	instanceVariableNames: ''!

!classDefinition: 'PlayableCharacterHeading class' category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:12:04'!
PlayableCharacterHeading class
	instanceVariableNames: ''!
!PlayableCharacterHeading class methodsFor: 'instance creation' stamp: 'HAW 10/11/2019 08:27:46' prior: 50913058!
for: aCardinalPoint forwardWith: aForwardPoint  

	^self new initializeFor: aCardinalPoint forwardWith: aForwardPoint ! !

!classDefinition: #StageObject category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:12:04'!
Object subclass: #StageObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classDefinition: #StageObject category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:12:04'!
Object subclass: #StageObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classDefinition: #PortableObject category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:12:04'!
StageObject subclass: #PortableObject
	instanceVariableNames: 'name weight'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classDefinition: #PortableObject category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:12:05'!
StageObject subclass: #PortableObject
	instanceVariableNames: 'name weight'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!
!PortableObject methodsFor: 'testing' stamp: 'FRT 10/11/2020 17:54:20' prior: 50913097!
doesItAddPoints

	self subclassResponsibility	! !
!PortableObject methodsFor: 'adding' stamp: 'HAW 10/18/2020 12:28:24' prior: 50913102!
assertCanAddTo: aBackpack

	self subclassResponsibility	! !
!PortableObject methodsFor: 'accessing' stamp: 'FRT 10/11/2020 18:53:51' prior: 50913107!
weight

	^ weight! !

!classDefinition: #NoPointsPortableObject category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:12:05'!
PortableObject subclass: #NoPointsPortableObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classDefinition: #NoPointsPortableObject category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:12:05'!
PortableObject subclass: #NoPointsPortableObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!
!NoPointsPortableObject methodsFor: 'initialization' stamp: 'HAW 10/14/2020 14:34:36' prior: 50913128!
initializeNamed: aName weighing: aWeight
	
	name := aName.
	weight := aWeight.! !
!NoPointsPortableObject methodsFor: 'testing' stamp: 'FRT 10/11/2020 17:54:20' prior: 50913135 overrides: 50914050!
doesItAddPoints	

	^ false! !
!NoPointsPortableObject methodsFor: 'adding' stamp: 'HAW 10/18/2020 12:28:48' prior: 50913140 overrides: 50914055!
assertCanAddTo: aBackpack 
	
	^aBackpack assertCanAddNoPointsPortableObject: self! !

!classDefinition: 'NoPointsPortableObject class' category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:12:05'!
NoPointsPortableObject class
	instanceVariableNames: ''!

!classDefinition: 'NoPointsPortableObject class' category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:12:05'!
NoPointsPortableObject class
	instanceVariableNames: ''!
!NoPointsPortableObject class methodsFor: 'instance creation' stamp: 'HAW 10/14/2020 14:34:36' prior: 50913158!
named: aName weighing: aWeight
	
	^ self new initializeNamed: aName weighing: aWeight. ! !

!classDefinition: #PointsPortableObject category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:12:05'!
PortableObject subclass: #PointsPortableObject
	instanceVariableNames: 'points'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classDefinition: #PointsPortableObject category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:12:05'!
PortableObject subclass: #PointsPortableObject
	instanceVariableNames: 'points'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!
!PointsPortableObject methodsFor: 'testing' stamp: 'FRT 10/11/2020 17:54:20' prior: 50913182 overrides: 50914050!
doesItAddPoints

	^ true! !
!PointsPortableObject methodsFor: 'initialization' stamp: 'HAW 10/14/2020 14:36:26' prior: 50913187!
initializeNamed: aName weighing: aWeight worth: gamePoints
	
	name := aName.
	weight := aWeight.
	points := gamePoints.! !
!PointsPortableObject methodsFor: 'accessing' stamp: 'FRT 10/11/2020 19:06:57' prior: 50913194!
points

	^ points! !
!PointsPortableObject methodsFor: 'adding' stamp: 'HAW 10/18/2020 12:29:07' prior: 50913199 overrides: 50914055!
assertCanAddTo: aBackpack 
	
	^aBackpack assertCanAddPointPortableObject: self! !

!classDefinition: 'PointsPortableObject class' category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:12:05'!
PointsPortableObject class
	instanceVariableNames: ''!

!classDefinition: 'PointsPortableObject class' category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:12:05'!
PointsPortableObject class
	instanceVariableNames: ''!
!PointsPortableObject class methodsFor: 'instance creation' stamp: 'HAW 10/14/2020 14:36:26' prior: 50913216!
named: aName weighing: aWeight worth: gamePoints
	
	^ self new initializeNamed: aName weighing: aWeight worth: gamePoints.! !

!classRemoval: #PointsPortableObject stamp: 'FG 12/17/2020 21:12:05'!
PortableObject subclass: #PointsPortableObject
	instanceVariableNames: 'points'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classRemoval: #NoPointsPortableObject stamp: 'FG 12/17/2020 21:12:06'!
PortableObject subclass: #NoPointsPortableObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classRemoval: #PortableObject stamp: 'FG 12/17/2020 21:12:06'!
StageObject subclass: #PortableObject
	instanceVariableNames: 'name weight'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classRemoval: #StageObject stamp: 'FG 12/17/2020 21:12:06'!
Object subclass: #StageObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classRemoval: #PlayableCharacterHeading stamp: 'FG 12/17/2020 21:12:07'!
Object subclass: #PlayableCharacterHeading
	instanceVariableNames: 'cardinalPoint forwardPoint rightHeading leftHeading'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classRemoval: #PlayableCharacter stamp: 'FG 12/17/2020 21:12:07'!
Object subclass: #PlayableCharacter
	instanceVariableNames: 'position heading backpack name'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classRemoval: #Backpack stamp: 'FG 12/17/2020 21:12:07'!
Object subclass: #Backpack
	instanceVariableNames: 'weightCapacity gamePointsCapacity container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classRemoval: #PlayableCharacterTest stamp: 'FG 12/17/2020 21:12:08'!
TestCase subclass: #PlayableCharacterTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classRemoval: #BackpackTest stamp: 'FG 12/17/2020 21:12:08'!
TestCase subclass: #BackpackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classDefinition: #BackpackTest category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:12:08'!
TestCase subclass: #BackpackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classDefinition: #BackpackTest category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:12:08'!
TestCase subclass: #BackpackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:29:03'!
assertShouldAddAll: portableObjects withPoints: expectedTotalPoints

	| aBackpack |
	
	aBackpack := Backpack containingUpTo: self backpackWeight limitingPointsTo: 100.

	portableObjects do: [ :aPortableObject | aBackpack add: aPortableObject ].
	
	self assert: aBackpack size equals: portableObjects size.
	self assert: aBackpack totalWeight equals: (portableObjects sum: [ :aPortableObject | aPortableObject weight ]).
	self assert: aBackpack totalPoints equals: expectedTotalPoints.
! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:28:32'!
assertShouldNotAddPortableObjectIfWeightExceeded: aPortableObject

	| aBackpack |
	aBackpack := Backpack containingUpTo: self backpackWeight limitingPointsTo: 100.

	self
		should: [ aBackpack add: aPortableObject ]
		raise: Error
		withMessageText: Backpack maxWeightExceededErrorDescription.
		
	self assert: aBackpack isEmpty. 
! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:28:32'!
backpackWeight

	^ 42! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:28:41'!
test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded

	self assertShouldNotAddPortableObjectIfWeightExceeded: 
		(NoPointsPortableObject named: 'help-wanted sign' weighing: self backpackWeight + 1)
! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:28:47'!
test08ShouldNotAddPointsPortableObjectIfWeightExceeded

	self assertShouldNotAddPortableObjectIfWeightExceeded: 
		(PointsPortableObject named: 'left-handed hammer' weighing: self backpackWeight + 6 worth: 5) ! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:26:42'!
test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity

	self 
		assertShouldAddAll: self twoPortableObjects
		withPoints: 5.
! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:27:27'!
test10ShouldAddPortableObjectsIfWeightEqualsMaxWeightCapacity

	self 
		assertShouldAddAll:  self twoPortableObjects, {(PointsPortableObject named: 'letter' weighing: 1 worth: 5)}
		withPoints: 10.
! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:27:39'!
twoPortableObjects

	^ {
		(PointsPortableObject named: 'left-handed hammer' weighing: 40 worth: 5).
		(NoPointsPortableObject named: 'help-wanted sign' weighing: 1) }! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04'!
test01CanNotCreateBackpackWithZeroMaxWeight

	self
		should: [ Backpack containingUpTo: 0 limitingPointsTo: 100 ]
		raise: Error
		withMessageText: Backpack invalidWeightCapacityErrorDescription.
! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04'!
test02CanNotCreateBackpackWithNegativeMaxWeight

	self
		should: [ Backpack containingUpTo: -1 limitingPointsTo: 100 ]
		raise: Error
		withMessageText: Backpack invalidWeightCapacityErrorDescription.! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04'!
test03CanNotCreateBackpackWithZeroMaxPoints

	self
		should: [ Backpack containingUpTo: 10 limitingPointsTo: 0 ]
		raise: Error
		withMessageText: Backpack invalidPointsCapacityErrorDescription.
! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04'!
test04CanNotCreateBackpackWithNegativeMaxPoints

	self
		should: [ Backpack containingUpTo: 10 limitingPointsTo: -1 ]
		raise: Error
		withMessageText: Backpack invalidPointsCapacityErrorDescription.! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04'!
test05CanNotCreateBackpackWithNoIntegerMaxWeight

	self
		should: [ Backpack containingUpTo: 1.0 limitingPointsTo: 100 ]
		raise: Error
		withMessageText: Backpack weightCapacityMustBeIntegerErrorDescription.
! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04'!
test06CanNotCreateBackpackWithNoIntegerMaxPoints

	self
		should: [ Backpack containingUpTo: 100 limitingPointsTo: 1.0 ]
		raise: Error
		withMessageText: Backpack pointsCapacityMustBeIntegerErrorDescription.
! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:49:20'!
test11ShouldAddZeroWeightWhenEmpty

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	self assert: aBackpack totalWeight equals: 0.
	self assert: aBackpack isEmpty
! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:35:57'!
test12ShouldAddWeightWhenAddingPortableObjects

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	aBackpack add: (PointsPortableObject named: 'left-handed hammer' weighing: 10 worth: 5).
	aBackpack add: (NoPointsPortableObject named: 'help-wanted sign' weighing: 10).
	
	self assert: aBackpack size equals: 2.
	self assert: aBackpack totalWeight equals: 20.

! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:49:31'!
test13ShouldAddZeroPointsWhenEmpty

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	self assert: aBackpack totalPoints equals: 0.
	self assert: aBackpack isEmpty.
! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:35:57'!
test14ShouldAddPointsWhenAddingPointsPortableObjects

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	aBackpack add: (PointsPortableObject named: 'left-handed hammer' weighing: 10 worth: 5).
	aBackpack add: (PointsPortableObject named: 'car key' weighing: 10 worth: 20).
	
	self assert: aBackpack size equals: 2.
	self assert: aBackpack totalPoints equals: 25.

! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:35:57'!
test15ShouldNotAddPointsWhenAddingNoPointsPortableObjects

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	aBackpack add: (PointsPortableObject named: 'left-handed hammer' weighing: 10 worth: 5).
	aBackpack add: (NoPointsPortableObject named: 'help-wanted sign' weighing: 10).
	aBackpack add: (NoPointsPortableObject named: 'help-wanted sign' weighing: 10).
	
	self assert: aBackpack size equals: 3.
	self assert: aBackpack totalPoints equals: 5.

! !

!classDefinition: #PlayableCharacterTest category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:12:09'!
TestCase subclass: #PlayableCharacterTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classDefinition: #PlayableCharacterTest category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:12:09'!
TestCase subclass: #PlayableCharacterTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:05:24'!
paper

	^ NoPointsPortableObject named: 'Paper' weighing: 100! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:00:16'!
test01_forwardWhenHeadingNorthIncrementsYCoordinate

	| playableCharacter |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 1@2 heading: #North in: self defaultRoom .

	playableCharacter moveForward.

	self assert: (playableCharacter isAt: 1@3 heading: #North)! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:00:16'!
test02_backwardWhenHeadingNorthDecrementsYCoordinate

	| playableCharacter |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 1@2 heading: #North in: self defaultRoom .

	playableCharacter moveBackward.

	self assert: (playableCharacter isAt: 1@1 heading: #North)! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:00:16'!
test03_rotateRightWhenHeadingNorthHeadsEast

	| playableCharacter |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 1@2 heading: #North in: self defaultRoom .

	playableCharacter rotateRight.

	self assert: (playableCharacter isAt: 1@2 heading: #East)! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:00:16'!
test04_rotateLeftWhenHeadingNorthHeadsWest

	| playableCharacter |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 1@2 heading: #North in: self defaultRoom .

	playableCharacter rotateLeft.

	self assert: (playableCharacter isAt: 1@2 heading: #West)! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:00:16'!
test05_movingWhenHeadingEastWorksAsExpected

	| playableCharacter |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 1@2 heading: #East in: self defaultRoom .

	playableCharacter
		moveForward;
		moveForward;
		moveBackward;
		rotateRight;
		rotateLeft;
		rotateLeft.

	self assert: (playableCharacter isAt: 2@2 heading: #North)! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:00:16'!
test06_movingWhenHeadingSouthWorksAsExpected

	| playableCharacter |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 1@2 heading: #South in: self defaultRoom .

	playableCharacter
		moveForward;
		moveForward;
		moveBackward;
		rotateRight;
		rotateLeft;
		rotateLeft.

	self assert: (playableCharacter isAt: 1@1 heading: #East)! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:00:16'!
test07_movingWhenHeadingWestWorksAsExpected

	| playableCharacter |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 2@2 heading: #West in: self defaultRoom .

	playableCharacter
		moveForward;
		moveForward;
		moveBackward;
		rotateRight;
		rotateLeft;
		rotateLeft.

	self assert: (playableCharacter isAt: 1@2 heading: #South)! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:00:16'!
test08_canNotCreatePlayableCharacterWhenHeadingIsNotValid

	self
		should: [PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 1@2 heading: #X in: self defaultRoom ]
		raise: Error
		withExceptionDo: [:anError |
			self assert: PlayableCharacter invalidCardinalPointErrorDescription equals: anError messageText ]! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:00:16'!
test09_canTakePortableObjects

	| playableCharacter paper |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 2@2 heading: #West in: self defaultRoom .
	paper := NoPointsPortableObject named: 'Paper' weighing: 1.
	
	playableCharacter take: paper.
	
	self assert: (playableCharacter backpackIncludes: paper)! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:05:24'!
test10_canNotTakeMoreObjectsThanTheBackpackCanCarry

	| playableCharacter paper key |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 2@2 heading: #West in: self defaultRoom .
	paper := self paper.
	key := NoPointsPortableObject named: 'Key' weighing: 1.
	
	playableCharacter take: paper.
	self 
		should: [ playableCharacter take: key ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [:anError |
			self assert: Backpack maxWeightExceededErrorDescription equals: anError messageText.
			self assert: (playableCharacter backpackIncludes: paper).
			self deny: (playableCharacter backpackIncludes: key) ]
	
	! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:43:14'!
test11_CanNotCreateCharacterWithInvalidPosition

	| room |

	room := self defaultRoom.
	self 
		should: [ PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 1@-1 heading: #West in: room ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [:anError |
			self assert: Room invalidPositionErrorDescription equals: anError messageText.
			self assert: room isEmpty ]! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:09:38'!
test12_CanNotCreateCharacterOnNotEmptyPosition

	| room paperPosition paper |

	room := self defaultRoom.
	paperPosition := 1@1.
	paper := self paper.
	room at: paperPosition put: paper.
	
	self 
		should: [ PlayableCharacter named: 'Luigi' using: self defaultBackpack at: paperPosition heading: #West in: room ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [:anError |
			self assert: Room positionIsNotEmptyErrorDescription equals: anError messageText.
			self assert: paper equals: (room at: paperPosition)]! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:16:13'!
test13_moveForwardModifiesPositionInRoom

	| room  player |

	room := self defaultRoom.
	
	player := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 1@1 heading: #West in: room.
	player moveForward.
	
	self assert: (player isAt: 0@1 heading: #West).
	self assert: player equals: (room at: 0@1).
	self assert: (room isEmptyAt: 1@1).! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:17:08'!
test14_moveBackwardModifiesPositionInRoom

	| room  player |

	room := self defaultRoom.
	
	player := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 1@1 heading: #West in: room.
	player moveBackward.
	
	self assert: (player isAt: 2@1 heading: #West).
	self assert: player equals: (room at: 2@1).
	self assert: (room isEmptyAt: 1@1).! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:43:14'!
test15_canNotMoveToInvalidPosition

	| room  player |

	room := self defaultRoom.
	
	player := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 0@1 heading: #West in: room.
	
	self 
		should: [ player moveForward ]
		raise: Error 
		withExceptionDo: [:anError |
			self assert: Room invalidPositionErrorDescription equals: anError messageText.
			self assert: player equals: (room at: 0@1). ]
			
! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:44:47'!
test16_canNotTakeFromAnEmptyOrInvalidPosition

	| room  player |

	room := self defaultRoom.
	
	player := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 0@0 heading: #North in: room.
	
	self 
		should: [ player take ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [:anError |
			self assert: Room objectNotInRoomErrorDescription equals: anError messageText.
			self assert: player backpackIsEmpty ]
			
! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:46:11'!
test17_canTakeAPortableObject

	| room  player paper |

	room := self defaultRoom.
	paper := self paper.
	room at: 0@1 put: paper.
	player := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 0@0 heading: #North in: room.
	
	player take.
	
	self assert: (room isEmptyAt: 0@1).
	self assert: (player backpackIncludes: paper).! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:50:54'!
test18_emptyNonPortableObjectDoesNotAddObjectsToBackpack

	| room  player box |

	room := self defaultRoom.
	box := NonPortableObject named: 'Box'.
	room at: 0@1 put: box.
	player := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 0@0 heading: #North in: room.
	
	player take.
	
	self assert: box equals: (room at: 0@1).
	self assert: player backpackIsEmpty.! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:56:03'!
test19_portableInNonPortableObjectIsAddedToBackpack

	| room  player box paper |

	room := self defaultRoom.
	paper := self paper.
	box := NonPortableObject named: 'Box' withAll: { paper }.
	room at: 0@1 put: box.
	player := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 0@0 heading: #North in: room.
	
	player take.
	
	self assert: box equals: (room at: 0@1).
	self assert: box isEmpty.
	self assert: (player backpackIncludes: paper).! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 19:19:55'!
test20_takeFromNonPortableObjectsIsRecursive

	| room  player box paper anotherPaper |

	room := self defaultRoom.
	paper := self paper.
	anotherPaper := self paper.
	box := NonPortableObject named: 'Box' withAll: { paper. anotherPaper }.
	room at: 0@1 put: box.
	player := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 0@0 heading: #North in: room.
	
	self 
		should: [ player take ]
		raise: Error
		withMessageText: Backpack maxWeightExceededErrorDescription.
	
	self assert: box equals: (room at: 0@1).
	self deny: box isEmpty.
	self assert: (box includes: anotherPaper).
	self assert: (player backpackIncludes: paper).
	self assert: 1 equals: player backpackSize! !
!PlayableCharacterTest methodsFor: 'defaults' stamp: 'HAW 12/9/2020 13:53:29'!
defaultBackpack

	^ Backpack containingUpTo: 100 limitingPointsTo: 100 ! !
!PlayableCharacterTest methodsFor: 'defaults' stamp: 'HAW 12/14/2020 18:02:57'!
defaultRoom
	
	^Room ofWidth: 10 andHeight: 10! !

!classDefinition: #RoomTest category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:12:11'!
TestCase subclass: #RoomTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classDefinition: #RoomTest category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:12:11'!
TestCase subclass: #RoomTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!
!RoomTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 17:20:02' prior: 50908873!
test01_WidthMustBeStrictlyPositive

	self assertInvalidSizeWith: 0 and: 1
	! !
!RoomTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 17:20:13' prior: 50908878!
test02_HeightMustBeStrictlyPositive

	self assertInvalidSizeWith: 1 and: 0
	! !
!RoomTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 17:20:25' prior: 50908883!
test03_WidthMustBeInteger

	self assertInvalidSizeWith: 1.1 and: 1
	! !
!RoomTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 17:20:36' prior: 50908888!
test04_HeightMustBeInteger

	self assertInvalidSizeWith: 1 and: 1.1
		! !
!RoomTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 17:39:43' prior: 50908893!
test05_CanNotPutAStageObjectWithXLessThanCero

	self assertCanNotPutAt: -1@1
		! !
!RoomTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 17:39:49' prior: 50908898!
test06_CanNotPutAStageObjectWithXGreaterOrEqualToWidth

	self assertCanNotPutAt: 10@1! !
!RoomTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 17:39:56' prior: 50908903!
test07_CanNotPutAStageObjectWithANonIntegerX

	self assertCanNotPutAt: 1.1@1! !
!RoomTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 17:40:04' prior: 50908908!
test08_CanNotPutAStageObjectWithYLessThanCero

	self assertCanNotPutAt: 1@-1
		! !
!RoomTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 17:40:25' prior: 50908913!
test09_CanNotPutAStageObjectWithYGreaterOrEqualToHeight

	self assertCanNotPutAt: 1@10! !
!RoomTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 17:41:13' prior: 50908918!
test10_CanNotPutAStageObjectWithANonIntegerY

	self assertCanNotPutAt: 1@1.1! !
!RoomTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 17:46:46' prior: 50908923!
test11_StageObjectsAreKeept

	| room |
	
	room := Room ofWidth: 10 andHeight: 10.
	
	room at: 0@0 put: self paper.
	
	self deny: room isEmpty.! !
!RoomTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:30:22' prior: 50908930!
test12_canNotGetPositionOfNonPutObject

	| room |
	
	room := Room ofWidth: 10 andHeight: 10.
	self
		should: [ room positionOf: self paper ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Room objectNotInRoomErrorDescription! !
!RoomTest methodsFor: 'test objects' stamp: 'HAW 12/14/2020 17:36:15' prior: 50908940!
paper

	^ PointsPortableObject named: 'paper' weighing: 1 worth: 1! !
!RoomTest methodsFor: 'assertions' stamp: 'HAW 12/14/2020 18:43:14' prior: 50908945!
assertCanNotPutAt: aPosition

	| room width |
	
	width := 10.
	room := Room ofWidth: width andHeight: 10.
	
	self 
		should: [ room at: aPosition put: self paper ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: Room invalidPositionErrorDescription equals: anError messageText.
			self assert: room isEmpty ].! !
!RoomTest methodsFor: 'assertions' stamp: 'HAW 12/14/2020 17:19:50' prior: 50908959!
assertInvalidSizeWith: aWitdh and: aHeight

	self 
		should: [ Room ofWidth: aWitdh andHeight: aHeight ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Room invalidSizeErrorDescription! !

!classDefinition: #Backpack category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:12:11'!
Object subclass: #Backpack
	instanceVariableNames: 'weightCapacity gamePointsCapacity container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classDefinition: #Backpack category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:12:12'!
Object subclass: #Backpack
	instanceVariableNames: 'weightCapacity gamePointsCapacity container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!
!Backpack methodsFor: 'exceptions' stamp: 'FRT 10/8/2020 18:02:29'!
signalMaxPointsExceeded

	self error: self class maxPointsExceededErrorDescription ! !
!Backpack methodsFor: 'exceptions' stamp: 'FRT 10/8/2020 18:02:47'!
signalMaxWeightExceeded

	self error: self class maxWeightExceededErrorDescription ! !
!Backpack methodsFor: 'initialization' stamp: 'HAW 10/14/2020 14:31:56'!
initializeContainingUpTo: aWeightCapacity limitingPointsTo: pointsCapacity

	weightCapacity := aWeightCapacity.
	gamePointsCapacity := pointsCapacity.
	
	container := OrderedCollection new.
	
	
	! !
!Backpack methodsFor: 'accessing' stamp: 'FRT 10/11/2020 19:14:47' overrides: 16880927!
size

	^ container size.! !
!Backpack methodsFor: 'accessing' stamp: 'HAW 10/18/2020 12:20:52'!
totalPoints
		
	^(container select: [ :portableObject | portableObject doesItAddPoints ])	
		sum: [ :portableObject | portableObject points ]
		ifEmpty: [ 0 ]! !
!Backpack methodsFor: 'accessing' stamp: 'HAW 10/18/2020 12:20:20'!
totalWeight
	
	^container 
		sum: [ :portableObject | portableObject weight ]
		ifEmpty: [ 0 ]
		! !
!Backpack methodsFor: 'assertions' stamp: 'FRT 10/12/2020 14:12:36'!
assertPointsAdding: aPointsPortableObject

	(self totalPoints + aPointsPortableObject points) > gamePointsCapacity ifTrue: [ self signalMaxPointsExceeded ]! !
!Backpack methodsFor: 'assertions' stamp: 'FRT 10/15/2020 12:22:34'!
assertWeightAdding: aPortableObject tolerating: aThreshold

	(self totalWeight + aPortableObject weight - weightCapacity) > aThreshold ifTrue: [ self signalMaxWeightExceeded ]! !
!Backpack methodsFor: 'adding' stamp: 'HAW 10/18/2020 12:28:24'!
add: aPortableObject
	
	aPortableObject assertCanAddTo: self.
	
	container add: aPortableObject.
	! !
!Backpack methodsFor: 'testing' stamp: 'HAW 12/9/2020 19:44:17'!
includes: aPortableObject 
	
	^container includes: aPortableObject ! !
!Backpack methodsFor: 'testing' stamp: 'FRT 10/11/2020 18:38:38'!
isEmpty

	^ container isEmpty.! !
!Backpack methodsFor: 'adding - private' stamp: 'HAW 10/18/2020 12:28:48'!
assertCanAddNoPointsPortableObject: aNoPointsPortableObject 
	
	self assertWeightAdding: aNoPointsPortableObject tolerating: 0.
	! !
!Backpack methodsFor: 'adding - private' stamp: 'HAW 10/18/2020 12:29:07'!
assertCanAddPointPortableObject: aPointsPortableObject 
	
	self assertWeightAdding: aPointsPortableObject tolerating: 5.
	self assertPointsAdding: aPointsPortableObject.
	! !

!classDefinition: 'Backpack class' category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:12:12'!
Backpack class
	instanceVariableNames: ''!

!classDefinition: 'Backpack class' category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:12:12'!
Backpack class
	instanceVariableNames: ''!
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 18:27:33'!
invalidPointsCapacityErrorDescription

	^ 'Points capacity must be positive'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 18:21:04'!
invalidWeightCapacityErrorDescription

	^ 'Weight capacity must be positive'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/8/2020 17:36:29'!
maxPointsExceededErrorDescription

	^ 'Maximum points has been exceeded'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/8/2020 17:36:17'!
maxWeightExceededErrorDescription

	^ 'Maximum weight has been exceeded'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/8/2020 17:43:00'!
pointsCapacityMustBeIntegerErrorDescription

	^ 'Points capacity must be integer'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/8/2020 17:42:48'!
weightCapacityMustBeIntegerErrorDescription

	^ 'Weight capacity must be integer'! !
!Backpack class methodsFor: 'exceptions' stamp: 'FRT 10/11/2020 18:27:16'!
signalInvalidPointsCapacity

	self error: self invalidPointsCapacityErrorDescription 
! !
!Backpack class methodsFor: 'exceptions' stamp: 'FRT 10/11/2020 18:21:51'!
signalInvalidWeightCapacity

	self error: self invalidWeightCapacityErrorDescription 
! !
!Backpack class methodsFor: 'exceptions' stamp: 'FRT 10/8/2020 17:41:06'!
signalPointsCapacityMustBeInteger

	self error: self pointsCapacityMustBeIntegerErrorDescription
! !
!Backpack class methodsFor: 'exceptions' stamp: 'FRT 10/8/2020 17:40:47'!
signalWeightCapacityMustBeInteger

	self error: self weightCapacityMustBeIntegerErrorDescription
! !
!Backpack class methodsFor: 'instance creation' stamp: 'HAW 10/14/2020 14:31:56'!
containingUpTo: aWeightCapacity limitingPointsTo: pointsCapacity

	aWeightCapacity strictlyPositive  ifFalse: [ self signalInvalidWeightCapacity ].
	pointsCapacity strictlyPositive ifFalse: [ self signalInvalidPointsCapacity ].
	
	aWeightCapacity isInteger ifFalse: [ self signalWeightCapacityMustBeInteger ].
	pointsCapacity isInteger ifFalse: [ self signalPointsCapacityMustBeInteger ].
	
	^ self new initializeContainingUpTo: aWeightCapacity limitingPointsTo: pointsCapacity.
! !

!classDefinition: #PlayableCharacter category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:12:13'!
Object subclass: #PlayableCharacter
	instanceVariableNames: 'heading backpack name room'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classDefinition: #PlayableCharacter category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:12:13'!
Object subclass: #PlayableCharacter
	instanceVariableNames: 'heading backpack name room'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!
!PlayableCharacter methodsFor: 'initialization' stamp: 'HAW 12/14/2020 18:27:11'!
initializeNamed: aName using: aBackpack at: aPosition heading: aMarsRoverHeading in: aRoom  

	name := aName.
	backpack := aBackpack.
	heading := aMarsRoverHeading.
	room := aRoom.
	room at: aPosition put: self! !
!PlayableCharacter methodsFor: 'testing' stamp: 'HAW 12/14/2020 18:25:08'!
isAt: aPosition heading: aCardinalPoint

	^self position = aPosition and: [ heading cardinalPoint = aCardinalPoint ]! !
!PlayableCharacter methodsFor: 'moving' stamp: 'HAW 12/14/2020 19:09:28'!
forwardPosition

	^ self position + heading forwardPoint! !
!PlayableCharacter methodsFor: 'moving' stamp: 'HAW 12/14/2020 18:25:13'!
moveBackward
	
	self moveTo: self position - heading forwardPoint.
	! !
!PlayableCharacter methodsFor: 'moving' stamp: 'HAW 12/14/2020 19:09:36'!
moveForward
	
	self moveTo: self forwardPosition ! !
!PlayableCharacter methodsFor: 'moving' stamp: 'HAW 12/14/2020 18:27:14'!
moveTo: aNewPosition
	
	room moveFrom: self position to: aNewPosition.
		! !
!PlayableCharacter methodsFor: 'moving' stamp: 'HAW 12/14/2020 18:25:48'!
position

	^room positionOf: self! !
!PlayableCharacter methodsFor: 'rotating' stamp: 'HAW 10/11/2019 08:31:55'!
rotateLeft
	
	heading := heading leftHeading! !
!PlayableCharacter methodsFor: 'rotating' stamp: 'HAW 10/11/2019 08:32:04'!
rotateRight
	
	heading := heading rightHeading! !
!PlayableCharacter methodsFor: 'taking objects' stamp: 'HAW 12/14/2020 19:09:28'!
take
	
	| toTake |
	
	toTake := room at: self forwardPosition.
	toTake takenBy: self 
	! !
!PlayableCharacter methodsFor: 'taking objects' stamp: 'HAW 12/9/2020 19:28:57'!
take: aPortableObject

	backpack add: aPortableObject.! !
!PlayableCharacter methodsFor: 'taking - private' stamp: 'HAW 12/14/2020 18:58:05'!
takeNonPortableObject: aNonPortableObject 
	
	aNonPortableObject putAllTo: self! !
!PlayableCharacter methodsFor: 'taking - private' stamp: 'HAW 12/14/2020 19:09:51'!
takePortableObject: aPortableObject 
	
	self take: aPortableObject.
	room removeAt: self forwardPosition ! !
!PlayableCharacter methodsFor: 'backpack' stamp: 'HAW 12/9/2020 19:43:44'!
backpackIncludes: aPortableObject 
	
	^backpack includes: aPortableObject ! !
!PlayableCharacter methodsFor: 'backpack' stamp: 'HAW 12/14/2020 18:42:40'!
backpackIsEmpty
	
	^backpack isEmpty ! !
!PlayableCharacter methodsFor: 'backpack' stamp: 'HAW 12/14/2020 19:09:03'!
backpackSize
	
	^backpack size! !

!classDefinition: 'PlayableCharacter class' category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:12:14'!
PlayableCharacter class
	instanceVariableNames: 'headings'!

!classDefinition: 'PlayableCharacter class' category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:12:14'!
PlayableCharacter class
	instanceVariableNames: 'headings'!
!PlayableCharacter class methodsFor: 'heading' stamp: 'HAW 7/2/2018 16:28:16'!
headingFor: aCardinalPoint
	
	^headings at: aCardinalPoint ifAbsent: [ self error: self invalidCardinalPointErrorDescription ]! !
!PlayableCharacter class methodsFor: 'heading' stamp: 'HAW 7/2/2018 16:26:14'!
invalidCardinalPointErrorDescription
	
	^'Invalid cardinal point'! !
!PlayableCharacter class methodsFor: 'instance creation' stamp: 'HAW 12/14/2020 18:01:51'!
named: aName using: aBackpack at: aPosition heading: aCardinalPoint in: aRoom  
	
	| newHeading |

	newHeading := self headingFor: aCardinalPoint.
	
	^self new initializeNamed: aName using: aBackpack at: aPosition heading: newHeading in: aRoom ! !
!PlayableCharacter class methodsFor: 'initialization' stamp: 'HAW 10/11/2019 08:37:25'!
forHeadingAt: aCardinalPoint leftIs: aLeftCardinalPoint rightIs: aRightCardinalPoint
	
	(headings at: aCardinalPoint) leftHeading: (headings at: aLeftCardinalPoint) rightHeading: (headings at: aRightCardinalPoint).
	! !
!PlayableCharacter class methodsFor: 'initialization' stamp: 'HAW 7/2/2018 15:27:41' overrides: 16883149!
initialize

	self initializeHeadings! !
!PlayableCharacter class methodsFor: 'initialization' stamp: 'HAW 12/9/2020 19:31:43'!
initializeHeadings

	headings := Dictionary new.
	
	(OrderedCollection 
		with: (PlayableCharacterHeading for: #North forwardWith: 0@1 )	
		with: (PlayableCharacterHeading for: #East forwardWith: 1@0 )
		with: (PlayableCharacterHeading for: #South forwardWith: 0@-1 )
		with: (PlayableCharacterHeading for: #West forwardWith: -1@0 ))
			do: [ :heading | headings at: heading cardinalPoint put: heading ].
	
	self 
		forHeadingAt: #North leftIs: #West rightIs: #East;
		forHeadingAt: #South leftIs: #East rightIs: #West;
		forHeadingAt: #East leftIs: #North rightIs: #South;
		forHeadingAt: #West leftIs: #South rightIs: #North.
	! !

!classDefinition: #PlayableCharacterHeading category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:12:14'!
Object subclass: #PlayableCharacterHeading
	instanceVariableNames: 'cardinalPoint forwardPoint rightHeading leftHeading'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classDefinition: #PlayableCharacterHeading category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:12:14'!
Object subclass: #PlayableCharacterHeading
	instanceVariableNames: 'cardinalPoint forwardPoint rightHeading leftHeading'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!
!PlayableCharacterHeading methodsFor: 'accessing' stamp: 'HAW 7/2/2018 15:29:44'!
cardinalPoint
	
	^cardinalPoint! !
!PlayableCharacterHeading methodsFor: 'accessing' stamp: 'HAW 7/2/2018 15:30:39'!
forwardPoint
	
	^forwardPoint! !
!PlayableCharacterHeading methodsFor: 'accessing' stamp: 'HAW 10/11/2019 08:31:33'!
leftHeading
	
	^leftHeading! !
!PlayableCharacterHeading methodsFor: 'accessing' stamp: 'HAW 10/11/2019 08:31:27'!
rightHeading
	
	^rightHeading! !
!PlayableCharacterHeading methodsFor: 'initialization' stamp: 'HAW 10/11/2019 08:27:25'!
initializeFor: aCardinalPoint forwardWith: aForwardPoint  
	
	cardinalPoint := aCardinalPoint.
	forwardPoint := aForwardPoint.
! !
!PlayableCharacterHeading methodsFor: 'initialization' stamp: 'HAW 10/11/2019 08:31:33'!
leftHeading: aLeftHeading rightHeading: aRightHeading
 
	leftHeading := aLeftHeading.
	rightHeading := aRightHeading ! !

!classDefinition: 'PlayableCharacterHeading class' category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:12:15'!
PlayableCharacterHeading class
	instanceVariableNames: ''!

!classDefinition: 'PlayableCharacterHeading class' category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:12:15'!
PlayableCharacterHeading class
	instanceVariableNames: ''!
!PlayableCharacterHeading class methodsFor: 'instance creation' stamp: 'HAW 10/11/2019 08:27:46'!
for: aCardinalPoint forwardWith: aForwardPoint  

	^self new initializeFor: aCardinalPoint forwardWith: aForwardPoint ! !

!classDefinition: #Room category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:12:15'!
Object subclass: #Room
	instanceVariableNames: 'width height contents'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classDefinition: #Room category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:12:15'!
Object subclass: #Room
	instanceVariableNames: 'width height contents'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!
!Room methodsFor: 'initialization' stamp: 'HAW 12/14/2020 17:47:16' prior: 50909418!
initializeOfWidth: aWidth andHeight: aHeight 
	
	width := aWidth.
	height := aHeight.
	contents := Dictionary new.! !
!Room methodsFor: 'contents' stamp: 'HAW 12/14/2020 18:42:28' prior: 50909425 overrides: 16880774!
at: aPosition

	^contents at: aPosition ifAbsent: [self error: self class objectNotInRoomErrorDescription ]! !
!Room methodsFor: 'contents' stamp: 'HAW 12/14/2020 18:07:24' prior: 50909432 overrides: 16880792!
at: aPosition put: aStageObject

	self assertPositionIsValid: aPosition.
	self assertIsEmpty: aPosition.
	
	contents at: aPosition put: aStageObject ! !
!Room methodsFor: 'contents' stamp: 'HAW 12/14/2020 18:23:18' prior: 50912168!
moveFrom: aSourcePosition to: aTargetPosition

	| toMove |
	
	toMove := self at: aSourcePosition.
	self at: aTargetPosition put: toMove.
	contents removeKey: aSourcePosition.
	! !
!Room methodsFor: 'contents' stamp: 'HAW 12/14/2020 18:30:58' prior: 50909447!
positionOf: anObject

	contents keysAndValuesDo: [ :aPosition :aPlacedObject |
		aPlacedObject = anObject ifTrue: [ ^aPosition  ]].
	
	self error: self class objectNotInRoomErrorDescription ! !
!Room methodsFor: 'contents' stamp: 'HAW 12/14/2020 18:47:43' prior: 50909456!
removeAt: aPosition

	^contents removeKey: aPosition ! !
!Room methodsFor: 'assertions' stamp: 'HAW 12/14/2020 18:09:38' prior: 50909460!
assertIsEmpty: aPosition

	^(self isEmptyAt: aPosition) ifFalse: [ self error: self class positionIsNotEmptyErrorDescription ]! !
!Room methodsFor: 'assertions' stamp: 'HAW 12/14/2020 18:43:14' prior: 50909467!
assertPositionComponentIsValid: aPositionComponent withLimit: limit 

	^ (aPositionComponent < 0 or: [aPositionComponent >= limit or: [ aPositionComponent isInteger not]]) 
		ifTrue: [self error: self class invalidPositionErrorDescription ]! !
!Room methodsFor: 'assertions' stamp: 'HAW 12/14/2020 17:44:04' prior: 50909477!
assertPositionIsValid: aPosition

	self assertPositionComponentIsValid: aPosition x withLimit: width.
	self assertPositionComponentIsValid: aPosition y withLimit: height.
	! !
!Room methodsFor: 'testing' stamp: 'HAW 12/14/2020 17:47:56' prior: 50909485!
isEmpty
	
	^contents isEmpty ! !
!Room methodsFor: 'testing' stamp: 'HAW 12/14/2020 18:08:47' prior: 50909488!
isEmptyAt: aPosition

	^ (contents includesKey: aPosition) not! !

!classDefinition: 'Room class' category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:12:15'!
Room class
	instanceVariableNames: ''!

!classDefinition: 'Room class' category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:12:15'!
Room class
	instanceVariableNames: ''!
!Room class methodsFor: 'error descriptions' stamp: 'HAW 12/14/2020 18:43:14' prior: 50909503!
invalidPositionErrorDescription
	
	^'Invalid position'! !
!Room class methodsFor: 'error descriptions' stamp: 'HAW 12/14/2020 17:16:22' prior: 50909508!
invalidSizeErrorDescription
	
	^'Invalid size'! !
!Room class methodsFor: 'error descriptions' stamp: 'HAW 12/14/2020 18:30:38' prior: 50909513!
objectNotInRoomErrorDescription
	
	^'Object not in room'! !
!Room class methodsFor: 'error descriptions' stamp: 'HAW 12/14/2020 18:09:38' prior: 50909518!
positionIsNotEmptyErrorDescription
	
	^'Position not empty'! !
!Room class methodsFor: 'instance creation' stamp: 'HAW 12/14/2020 19:27:12' prior: 50909523!
ofWidth: aWidth andHeight: aHeight 
	
	self assertIsValidWitdth: aWidth andHeight: aHeight .
	
	^self new initializeOfWidth: aWidth andHeight: aHeight ! !
!Room class methodsFor: 'assertions' stamp: 'HAW 12/14/2020 17:22:01' prior: 50909531!
assertIsValidSizeComponent: aSizeComponent

	^ (aSizeComponent < 1 or: [aSizeComponent isInteger not ]) ifTrue: [self error: self invalidSizeErrorDescription ]! !
!Room class methodsFor: 'assertions' stamp: 'HAW 12/14/2020 19:27:12' prior: 50909539!
assertIsValidWitdth: aWidth andHeight: aHeight

	self assertIsValidSizeComponent: aWidth.
	self assertIsValidSizeComponent: aHeight! !

!classDefinition: #StageObject category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:12:16'!
Object subclass: #StageObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classDefinition: #StageObject category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:12:16'!
Object subclass: #StageObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!
!StageObject methodsFor: 'taken' stamp: 'HAW 12/14/2020 19:30:06'!
putAllTo: aPlayableCharacter

	self subclassResponsibility 
	! !
!StageObject methodsFor: 'taken' stamp: 'HAW 12/14/2020 19:30:18'!
takenBy: aPlayableCharacter 

	self subclassResponsibility 
	! !

!classDefinition: #NonPortableObject category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:12:16'!
StageObject subclass: #NonPortableObject
	instanceVariableNames: 'name stageObjects'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classDefinition: #NonPortableObject category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:12:16'!
StageObject subclass: #NonPortableObject
	instanceVariableNames: 'name stageObjects'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!
!NonPortableObject methodsFor: 'initialization' stamp: 'HAW 12/14/2020 19:00:02' prior: 50909592!
initializeNamed: aName withAll: aCollectionOfStageObjects 
	
	name := aName.
	stageObjects := aCollectionOfStageObjects asOrderedCollection .! !
!NonPortableObject methodsFor: 'taken' stamp: 'HAW 12/14/2020 19:24:52' prior: 50909600 overrides: 50915496!
putAllTo: aPlayableCharacter 
	
	| toRemove |
	
	toRemove := OrderedCollection new.
	[ stageObjects do: [ :aStageObject | (aStageObject putAllTo: aPlayableCharacter) ifTrue: [ toRemove add: aStageObject ]]]
		ensure: [ stageObjects removeAll: toRemove ].
	
	^false! !
!NonPortableObject methodsFor: 'taken' stamp: 'HAW 12/14/2020 18:53:21' prior: 50909612 overrides: 50915501!
takenBy: aPlayableCharacter 
	
	aPlayableCharacter takeNonPortableObject: self! !
!NonPortableObject methodsFor: 'testing' stamp: 'HAW 12/14/2020 19:08:45' prior: 50909617!
includes: aStageObject

	^stageObjects includes: aStageObject ! !
!NonPortableObject methodsFor: 'testing' stamp: 'HAW 12/14/2020 18:57:19' prior: 50909622!
isEmpty
	
	^stageObjects isEmpty ! !

!classDefinition: 'NonPortableObject class' category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:12:16'!
NonPortableObject class
	instanceVariableNames: ''!

!classDefinition: 'NonPortableObject class' category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:12:16'!
NonPortableObject class
	instanceVariableNames: ''!
!NonPortableObject class methodsFor: 'instance creation' stamp: 'HAW 12/14/2020 19:00:27' prior: 50909638!
named: aName 
	
	^self named: aName withAll: #()! !
!NonPortableObject class methodsFor: 'instance creation' stamp: 'HAW 12/14/2020 18:56:40' prior: 50909643!
named: aName withAll: aCollectionOfStageObjects 
	
	^self new initializeNamed: aName withAll: aCollectionOfStageObjects ! !

!classDefinition: #PortableObject category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:12:16'!
StageObject subclass: #PortableObject
	instanceVariableNames: 'name weight'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classDefinition: #PortableObject category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:12:16'!
StageObject subclass: #PortableObject
	instanceVariableNames: 'name weight'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!
!PortableObject methodsFor: 'testing' stamp: 'FRT 10/11/2020 17:54:20'!
doesItAddPoints

	self subclassResponsibility	! !
!PortableObject methodsFor: 'adding' stamp: 'HAW 10/18/2020 12:28:24'!
assertCanAddTo: aBackpack

	self subclassResponsibility	! !
!PortableObject methodsFor: 'accessing' stamp: 'FRT 10/11/2020 18:53:51'!
weight

	^ weight! !
!PortableObject methodsFor: 'taken' stamp: 'HAW 12/14/2020 19:15:12' overrides: 50915496!
putAllTo: aPlayableCharacter

	aPlayableCharacter take: self.
	^true! !
!PortableObject methodsFor: 'taken' stamp: 'HAW 12/14/2020 18:53:53' overrides: 50915501!
takenBy: aPlayableCharacter 
	
	aPlayableCharacter takePortableObject: self! !

!classDefinition: #NoPointsPortableObject category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:12:17'!
PortableObject subclass: #NoPointsPortableObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classDefinition: #NoPointsPortableObject category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:12:17'!
PortableObject subclass: #NoPointsPortableObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!
!NoPointsPortableObject methodsFor: 'initialization' stamp: 'HAW 10/14/2020 14:34:36'!
initializeNamed: aName weighing: aWeight
	
	name := aName.
	weight := aWeight.! !
!NoPointsPortableObject methodsFor: 'testing' stamp: 'FRT 10/11/2020 17:54:20' overrides: 50915598!
doesItAddPoints	

	^ false! !
!NoPointsPortableObject methodsFor: 'adding' stamp: 'HAW 10/18/2020 12:28:48' overrides: 50915602!
assertCanAddTo: aBackpack 
	
	^aBackpack assertCanAddNoPointsPortableObject: self! !

!classDefinition: 'NoPointsPortableObject class' category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:12:17'!
NoPointsPortableObject class
	instanceVariableNames: ''!

!classDefinition: 'NoPointsPortableObject class' category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:12:17'!
NoPointsPortableObject class
	instanceVariableNames: ''!
!NoPointsPortableObject class methodsFor: 'instance creation' stamp: 'HAW 10/14/2020 14:34:36'!
named: aName weighing: aWeight
	
	^ self new initializeNamed: aName weighing: aWeight. ! !

!classDefinition: #PointsPortableObject category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:12:17'!
PortableObject subclass: #PointsPortableObject
	instanceVariableNames: 'points'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classDefinition: #PointsPortableObject category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:12:17'!
PortableObject subclass: #PointsPortableObject
	instanceVariableNames: 'points'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!
!PointsPortableObject methodsFor: 'testing' stamp: 'FRT 10/11/2020 17:54:20' overrides: 50915598!
doesItAddPoints

	^ true! !
!PointsPortableObject methodsFor: 'initialization' stamp: 'HAW 10/14/2020 14:36:26'!
initializeNamed: aName weighing: aWeight worth: gamePoints
	
	name := aName.
	weight := aWeight.
	points := gamePoints.! !
!PointsPortableObject methodsFor: 'accessing' stamp: 'FRT 10/11/2020 19:06:57'!
points

	^ points! !
!PointsPortableObject methodsFor: 'adding' stamp: 'HAW 10/18/2020 12:29:07' overrides: 50915602!
assertCanAddTo: aBackpack 
	
	^aBackpack assertCanAddPointPortableObject: self! !

!classDefinition: 'PointsPortableObject class' category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:12:17'!
PointsPortableObject class
	instanceVariableNames: ''!

!classDefinition: 'PointsPortableObject class' category: 'ISW1-2020-2C-2doParcial' stamp: 'FG 12/17/2020 21:12:17'!
PointsPortableObject class
	instanceVariableNames: ''!
!PointsPortableObject class methodsFor: 'instance creation' stamp: 'HAW 10/14/2020 14:36:26'!
named: aName weighing: aWeight worth: gamePoints
	
	^ self new initializeNamed: aName weighing: aWeight worth: gamePoints.! !

!classRemoval: #PointsPortableObject stamp: 'FG 12/17/2020 21:12:17'!
PortableObject subclass: #PointsPortableObject
	instanceVariableNames: 'points'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classRemoval: #NoPointsPortableObject stamp: 'FG 12/17/2020 21:12:18'!
PortableObject subclass: #NoPointsPortableObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classRemoval: #PortableObject stamp: 'FG 12/17/2020 21:12:18'!
StageObject subclass: #PortableObject
	instanceVariableNames: 'name weight'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classRemoval: #NonPortableObject stamp: 'FG 12/17/2020 21:12:18'!
StageObject subclass: #NonPortableObject
	instanceVariableNames: 'name stageObjects'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classRemoval: #StageObject stamp: 'FG 12/17/2020 21:12:19'!
Object subclass: #StageObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classRemoval: #Room stamp: 'FG 12/17/2020 21:12:19'!
Object subclass: #Room
	instanceVariableNames: 'width height contents'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classRemoval: #PlayableCharacterHeading stamp: 'FG 12/17/2020 21:12:19'!
Object subclass: #PlayableCharacterHeading
	instanceVariableNames: 'cardinalPoint forwardPoint rightHeading leftHeading'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classRemoval: #PlayableCharacter stamp: 'FG 12/17/2020 21:12:20'!
Object subclass: #PlayableCharacter
	instanceVariableNames: 'heading backpack name room'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classRemoval: #Backpack stamp: 'FG 12/17/2020 21:12:20'!
Object subclass: #Backpack
	instanceVariableNames: 'weightCapacity gamePointsCapacity container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classRemoval: #RoomTest stamp: 'FG 12/17/2020 21:12:20'!
TestCase subclass: #RoomTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classRemoval: #PlayableCharacterTest stamp: 'FG 12/17/2020 21:12:21'!
TestCase subclass: #PlayableCharacterTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classRemoval: #BackpackTest stamp: 'FG 12/17/2020 21:12:21'!
TestCase subclass: #BackpackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-2doParcial'!

!classDefinition: #BackpackTest category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:12:21'!
TestCase subclass: #BackpackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!

!classDefinition: #BackpackTest category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:12:21'!
TestCase subclass: #BackpackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:29:03'!
assertShouldAddAll: portableObjects withPoints: expectedTotalPoints

	| aBackpack |
	
	aBackpack := Backpack containingUpTo: self backpackWeight limitingPointsTo: 100.

	portableObjects do: [ :aPortableObject | aBackpack add: aPortableObject ].
	
	self assert: aBackpack size equals: portableObjects size.
	self assert: aBackpack totalWeight equals: (portableObjects sum: [ :aPortableObject | aPortableObject weight ]).
	self assert: aBackpack totalPoints equals: expectedTotalPoints.
! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:28:32'!
assertShouldNotAddPortableObjectIfWeightExceeded: aPortableObject

	| aBackpack |
	aBackpack := Backpack containingUpTo: self backpackWeight limitingPointsTo: 100.

	self
		should: [ aBackpack add: aPortableObject ]
		raise: Error
		withMessageText: Backpack maxWeightExceededErrorDescription.
		
	self assert: aBackpack isEmpty. 
! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:28:32'!
backpackWeight

	^ 42! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:28:41'!
test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded

	self assertShouldNotAddPortableObjectIfWeightExceeded: 
		(NoPointsPortableObject named: 'help-wanted sign' weighing: self backpackWeight + 1)
! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:28:47'!
test08ShouldNotAddPointsPortableObjectIfWeightExceeded

	self assertShouldNotAddPortableObjectIfWeightExceeded: 
		(PointsPortableObject named: 'left-handed hammer' weighing: self backpackWeight + 6 worth: 5) ! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:26:42'!
test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity

	self 
		assertShouldAddAll: self twoPortableObjects
		withPoints: 5.
! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:27:27'!
test10ShouldAddPortableObjectsIfWeightEqualsMaxWeightCapacity

	self 
		assertShouldAddAll:  self twoPortableObjects, {(PointsPortableObject named: 'letter' weighing: 1 worth: 5)}
		withPoints: 10.
! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:27:39'!
twoPortableObjects

	^ {
		(PointsPortableObject named: 'left-handed hammer' weighing: 40 worth: 5).
		(NoPointsPortableObject named: 'help-wanted sign' weighing: 1) }! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04'!
test01CanNotCreateBackpackWithZeroMaxWeight

	self
		should: [ Backpack containingUpTo: 0 limitingPointsTo: 100 ]
		raise: Error
		withMessageText: Backpack invalidWeightCapacityErrorDescription.
! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04'!
test02CanNotCreateBackpackWithNegativeMaxWeight

	self
		should: [ Backpack containingUpTo: -1 limitingPointsTo: 100 ]
		raise: Error
		withMessageText: Backpack invalidWeightCapacityErrorDescription.! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04'!
test03CanNotCreateBackpackWithZeroMaxPoints

	self
		should: [ Backpack containingUpTo: 10 limitingPointsTo: 0 ]
		raise: Error
		withMessageText: Backpack invalidPointsCapacityErrorDescription.
! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04'!
test04CanNotCreateBackpackWithNegativeMaxPoints

	self
		should: [ Backpack containingUpTo: 10 limitingPointsTo: -1 ]
		raise: Error
		withMessageText: Backpack invalidPointsCapacityErrorDescription.! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04'!
test05CanNotCreateBackpackWithNoIntegerMaxWeight

	self
		should: [ Backpack containingUpTo: 1.0 limitingPointsTo: 100 ]
		raise: Error
		withMessageText: Backpack weightCapacityMustBeIntegerErrorDescription.
! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04'!
test06CanNotCreateBackpackWithNoIntegerMaxPoints

	self
		should: [ Backpack containingUpTo: 100 limitingPointsTo: 1.0 ]
		raise: Error
		withMessageText: Backpack pointsCapacityMustBeIntegerErrorDescription.
! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:49:20'!
test11ShouldAddZeroWeightWhenEmpty

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	self assert: aBackpack totalWeight equals: 0.
	self assert: aBackpack isEmpty
! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:35:57'!
test12ShouldAddWeightWhenAddingPortableObjects

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	aBackpack add: (PointsPortableObject named: 'left-handed hammer' weighing: 10 worth: 5).
	aBackpack add: (NoPointsPortableObject named: 'help-wanted sign' weighing: 10).
	
	self assert: aBackpack size equals: 2.
	self assert: aBackpack totalWeight equals: 20.

! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:49:31'!
test13ShouldAddZeroPointsWhenEmpty

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	self assert: aBackpack totalPoints equals: 0.
	self assert: aBackpack isEmpty.
! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:35:57'!
test14ShouldAddPointsWhenAddingPointsPortableObjects

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	aBackpack add: (PointsPortableObject named: 'left-handed hammer' weighing: 10 worth: 5).
	aBackpack add: (PointsPortableObject named: 'car key' weighing: 10 worth: 20).
	
	self assert: aBackpack size equals: 2.
	self assert: aBackpack totalPoints equals: 25.

! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:35:57'!
test15ShouldNotAddPointsWhenAddingNoPointsPortableObjects

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	aBackpack add: (PointsPortableObject named: 'left-handed hammer' weighing: 10 worth: 5).
	aBackpack add: (NoPointsPortableObject named: 'help-wanted sign' weighing: 10).
	aBackpack add: (NoPointsPortableObject named: 'help-wanted sign' weighing: 10).
	
	self assert: aBackpack size equals: 3.
	self assert: aBackpack totalPoints equals: 5.

! !

!classDefinition: #PlayableCharacterTest category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:12:22'!
TestCase subclass: #PlayableCharacterTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!

!classDefinition: #PlayableCharacterTest category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:12:22'!
TestCase subclass: #PlayableCharacterTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:05:24'!
paper

	^ NoPointsPortableObject named: 'Paper' weighing: 100! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:00:16'!
test01_forwardWhenHeadingNorthIncrementsYCoordinate

	| playableCharacter |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 1@2 heading: #North in: self defaultRoom .

	playableCharacter moveForward.

	self assert: (playableCharacter isAt: 1@3 heading: #North)! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:00:16'!
test02_backwardWhenHeadingNorthDecrementsYCoordinate

	| playableCharacter |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 1@2 heading: #North in: self defaultRoom .

	playableCharacter moveBackward.

	self assert: (playableCharacter isAt: 1@1 heading: #North)! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:00:16'!
test03_rotateRightWhenHeadingNorthHeadsEast

	| playableCharacter |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 1@2 heading: #North in: self defaultRoom .

	playableCharacter rotateRight.

	self assert: (playableCharacter isAt: 1@2 heading: #East)! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:00:16'!
test04_rotateLeftWhenHeadingNorthHeadsWest

	| playableCharacter |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 1@2 heading: #North in: self defaultRoom .

	playableCharacter rotateLeft.

	self assert: (playableCharacter isAt: 1@2 heading: #West)! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:00:16'!
test05_movingWhenHeadingEastWorksAsExpected

	| playableCharacter |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 1@2 heading: #East in: self defaultRoom .

	playableCharacter
		moveForward;
		moveForward;
		moveBackward;
		rotateRight;
		rotateLeft;
		rotateLeft.

	self assert: (playableCharacter isAt: 2@2 heading: #North)! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:00:16'!
test06_movingWhenHeadingSouthWorksAsExpected

	| playableCharacter |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 1@2 heading: #South in: self defaultRoom .

	playableCharacter
		moveForward;
		moveForward;
		moveBackward;
		rotateRight;
		rotateLeft;
		rotateLeft.

	self assert: (playableCharacter isAt: 1@1 heading: #East)! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:00:16'!
test07_movingWhenHeadingWestWorksAsExpected

	| playableCharacter |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 2@2 heading: #West in: self defaultRoom .

	playableCharacter
		moveForward;
		moveForward;
		moveBackward;
		rotateRight;
		rotateLeft;
		rotateLeft.

	self assert: (playableCharacter isAt: 1@2 heading: #South)! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:00:16'!
test08_canNotCreatePlayableCharacterWhenHeadingIsNotValid

	self
		should: [PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 1@2 heading: #X in: self defaultRoom ]
		raise: Error
		withExceptionDo: [:anError |
			self assert: PlayableCharacter invalidCardinalPointErrorDescription equals: anError messageText ]! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:00:16'!
test09_canTakePortableObjects

	| playableCharacter paper |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 2@2 heading: #West in: self defaultRoom .
	paper := NoPointsPortableObject named: 'Paper' weighing: 1.
	
	playableCharacter take: paper.
	
	self assert: (playableCharacter backpackIncludes: paper)! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:05:24'!
test10_canNotTakeMoreObjectsThanTheBackpackCanCarry

	| playableCharacter paper key |

	playableCharacter := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 2@2 heading: #West in: self defaultRoom .
	paper := self paper.
	key := NoPointsPortableObject named: 'Key' weighing: 1.
	
	playableCharacter take: paper.
	self 
		should: [ playableCharacter take: key ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [:anError |
			self assert: Backpack maxWeightExceededErrorDescription equals: anError messageText.
			self assert: (playableCharacter backpackIncludes: paper).
			self deny: (playableCharacter backpackIncludes: key) ]
	
	! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:43:14'!
test11_CanNotCreateCharacterWithInvalidPosition

	| room |

	room := self defaultRoom.
	self 
		should: [ PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 1@-1 heading: #West in: room ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [:anError |
			self assert: Room invalidPositionErrorDescription equals: anError messageText.
			self assert: room isEmpty ]! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:09:38'!
test12_CanNotCreateCharacterOnNotEmptyPosition

	| room paperPosition paper |

	room := self defaultRoom.
	paperPosition := 1@1.
	paper := self paper.
	room at: paperPosition put: paper.
	
	self 
		should: [ PlayableCharacter named: 'Luigi' using: self defaultBackpack at: paperPosition heading: #West in: room ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [:anError |
			self assert: Room positionIsNotEmptyErrorDescription equals: anError messageText.
			self assert: paper equals: (room at: paperPosition)]! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:16:13'!
test13_moveForwardModifiesPositionInRoom

	| room  player |

	room := self defaultRoom.
	
	player := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 1@1 heading: #West in: room.
	player moveForward.
	
	self assert: (player isAt: 0@1 heading: #West).
	self assert: player equals: (room at: 0@1).
	self assert: (room isEmptyAt: 1@1).! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:17:08'!
test14_moveBackwardModifiesPositionInRoom

	| room  player |

	room := self defaultRoom.
	
	player := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 1@1 heading: #West in: room.
	player moveBackward.
	
	self assert: (player isAt: 2@1 heading: #West).
	self assert: player equals: (room at: 2@1).
	self assert: (room isEmptyAt: 1@1).! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:43:14'!
test15_canNotMoveToInvalidPosition

	| room  player |

	room := self defaultRoom.
	
	player := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 0@1 heading: #West in: room.
	
	self 
		should: [ player moveForward ]
		raise: Error 
		withExceptionDo: [:anError |
			self assert: Room invalidPositionErrorDescription equals: anError messageText.
			self assert: player equals: (room at: 0@1). ]
			
! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:44:47'!
test16_canNotTakeFromAnEmptyOrInvalidPosition

	| room  player |

	room := self defaultRoom.
	
	player := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 0@0 heading: #North in: room.
	
	self 
		should: [ player take ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [:anError |
			self assert: Room objectNotInRoomErrorDescription equals: anError messageText.
			self assert: player backpackIsEmpty ]
			
! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:46:11'!
test17_canTakeAPortableObject

	| room  player paper |

	room := self defaultRoom.
	paper := self paper.
	room at: 0@1 put: paper.
	player := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 0@0 heading: #North in: room.
	
	player take.
	
	self assert: (room isEmptyAt: 0@1).
	self assert: (player backpackIncludes: paper).! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:50:54'!
test18_emptyNonPortableObjectDoesNotAddObjectsToBackpack

	| room  player box |

	room := self defaultRoom.
	box := NonPortableObject named: 'Box'.
	room at: 0@1 put: box.
	player := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 0@0 heading: #North in: room.
	
	player take.
	
	self assert: box equals: (room at: 0@1).
	self assert: player backpackIsEmpty.! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:56:03'!
test19_portableInNonPortableObjectIsAddedToBackpack

	| room  player box paper |

	room := self defaultRoom.
	paper := self paper.
	box := NonPortableObject named: 'Box' withAll: { paper }.
	room at: 0@1 put: box.
	player := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 0@0 heading: #North in: room.
	
	player take.
	
	self assert: box equals: (room at: 0@1).
	self assert: box isEmpty.
	self assert: (player backpackIncludes: paper).! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 19:19:55'!
test20_takeFromNonPortableObjectsIsRecursive

	| room  player box paper anotherPaper |

	room := self defaultRoom.
	paper := self paper.
	anotherPaper := self paper.
	box := NonPortableObject named: 'Box' withAll: { paper. anotherPaper }.
	room at: 0@1 put: box.
	player := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 0@0 heading: #North in: room.
	
	self 
		should: [ player take ]
		raise: Error
		withMessageText: Backpack maxWeightExceededErrorDescription.
	
	self assert: box equals: (room at: 0@1).
	self deny: box isEmpty.
	self assert: (box includes: anotherPaper).
	self assert: (player backpackIncludes: paper).
	self assert: 1 equals: player backpackSize! !
!PlayableCharacterTest methodsFor: 'defaults' stamp: 'HAW 12/9/2020 13:53:29'!
defaultBackpack

	^ Backpack containingUpTo: 100 limitingPointsTo: 100 ! !
!PlayableCharacterTest methodsFor: 'defaults' stamp: 'HAW 12/14/2020 18:02:57'!
defaultRoom
	
	^Room ofWidth: 10 andHeight: 10! !

!classDefinition: #RoomTest category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:12:24'!
TestCase subclass: #RoomTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!

!classDefinition: #RoomTest category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:12:24'!
TestCase subclass: #RoomTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!
!RoomTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 17:20:02'!
test01_WidthMustBeStrictlyPositive

	self assertInvalidSizeWith: 0 and: 1
	! !
!RoomTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 17:20:13'!
test02_HeightMustBeStrictlyPositive

	self assertInvalidSizeWith: 1 and: 0
	! !
!RoomTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 17:20:25'!
test03_WidthMustBeInteger

	self assertInvalidSizeWith: 1.1 and: 1
	! !
!RoomTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 17:20:36'!
test04_HeightMustBeInteger

	self assertInvalidSizeWith: 1 and: 1.1
		! !
!RoomTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 17:39:43'!
test05_CanNotPutAStageObjectWithXLessThanCero

	self assertCanNotPutAt: -1@1
		! !
!RoomTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 17:39:49'!
test06_CanNotPutAStageObjectWithXGreaterOrEqualToWidth

	self assertCanNotPutAt: 10@1! !
!RoomTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 17:39:56'!
test07_CanNotPutAStageObjectWithANonIntegerX

	self assertCanNotPutAt: 1.1@1! !
!RoomTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 17:40:04'!
test08_CanNotPutAStageObjectWithYLessThanCero

	self assertCanNotPutAt: 1@-1
		! !
!RoomTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 17:40:25'!
test09_CanNotPutAStageObjectWithYGreaterOrEqualToHeight

	self assertCanNotPutAt: 1@10! !
!RoomTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 17:41:13'!
test10_CanNotPutAStageObjectWithANonIntegerY

	self assertCanNotPutAt: 1@1.1! !
!RoomTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 17:46:46'!
test11_StageObjectsAreKeept

	| room |
	
	room := Room ofWidth: 10 andHeight: 10.
	
	room at: 0@0 put: self paper.
	
	self deny: room isEmpty.! !
!RoomTest methodsFor: 'tests' stamp: 'HAW 12/14/2020 18:30:22'!
test12_canNotGetPositionOfNonPutObject

	| room |
	
	room := Room ofWidth: 10 andHeight: 10.
	self
		should: [ room positionOf: self paper ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Room objectNotInRoomErrorDescription! !
!RoomTest methodsFor: 'test objects' stamp: 'HAW 12/14/2020 17:36:15'!
paper

	^ PointsPortableObject named: 'paper' weighing: 1 worth: 1! !
!RoomTest methodsFor: 'assertions' stamp: 'HAW 12/14/2020 18:43:14'!
assertCanNotPutAt: aPosition

	| room width |
	
	width := 10.
	room := Room ofWidth: width andHeight: 10.
	
	self 
		should: [ room at: aPosition put: self paper ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: Room invalidPositionErrorDescription equals: anError messageText.
			self assert: room isEmpty ].! !
!RoomTest methodsFor: 'assertions' stamp: 'HAW 12/14/2020 17:19:50'!
assertInvalidSizeWith: aWitdh and: aHeight

	self 
		should: [ Room ofWidth: aWitdh andHeight: aHeight ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Room invalidSizeErrorDescription! !

!classDefinition: #Backpack category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:12:25'!
Object subclass: #Backpack
	instanceVariableNames: 'weightCapacity gamePointsCapacity container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!

!classDefinition: #Backpack category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:12:25'!
Object subclass: #Backpack
	instanceVariableNames: 'weightCapacity gamePointsCapacity container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!
!Backpack methodsFor: 'exceptions' stamp: 'FRT 10/8/2020 18:02:29'!
signalMaxPointsExceeded

	self error: self class maxPointsExceededErrorDescription ! !
!Backpack methodsFor: 'exceptions' stamp: 'FRT 10/8/2020 18:02:47'!
signalMaxWeightExceeded

	self error: self class maxWeightExceededErrorDescription ! !
!Backpack methodsFor: 'initialization' stamp: 'HAW 10/14/2020 14:31:56'!
initializeContainingUpTo: aWeightCapacity limitingPointsTo: pointsCapacity

	weightCapacity := aWeightCapacity.
	gamePointsCapacity := pointsCapacity.
	
	container := OrderedCollection new.
	
	
	! !
!Backpack methodsFor: 'accessing' stamp: 'FRT 10/11/2020 19:14:47' overrides: 16880927!
size

	^ container size.! !
!Backpack methodsFor: 'accessing' stamp: 'HAW 10/18/2020 12:20:52'!
totalPoints
		
	^(container select: [ :portableObject | portableObject doesItAddPoints ])	
		sum: [ :portableObject | portableObject points ]
		ifEmpty: [ 0 ]! !
!Backpack methodsFor: 'accessing' stamp: 'HAW 10/18/2020 12:20:20'!
totalWeight
	
	^container 
		sum: [ :portableObject | portableObject weight ]
		ifEmpty: [ 0 ]
		! !
!Backpack methodsFor: 'assertions' stamp: 'FRT 10/12/2020 14:12:36'!
assertPointsAdding: aPointsPortableObject

	(self totalPoints + aPointsPortableObject points) > gamePointsCapacity ifTrue: [ self signalMaxPointsExceeded ]! !
!Backpack methodsFor: 'assertions' stamp: 'FRT 10/15/2020 12:22:34'!
assertWeightAdding: aPortableObject tolerating: aThreshold

	(self totalWeight + aPortableObject weight - weightCapacity) > aThreshold ifTrue: [ self signalMaxWeightExceeded ]! !
!Backpack methodsFor: 'adding' stamp: 'HAW 10/18/2020 12:28:24'!
add: aPortableObject
	
	aPortableObject assertCanAddTo: self.
	
	container add: aPortableObject.
	! !
!Backpack methodsFor: 'testing' stamp: 'HAW 12/9/2020 19:44:17'!
includes: aPortableObject 
	
	^container includes: aPortableObject ! !
!Backpack methodsFor: 'testing' stamp: 'FRT 10/11/2020 18:38:38'!
isEmpty

	^ container isEmpty.! !
!Backpack methodsFor: 'adding - private' stamp: 'HAW 10/18/2020 12:28:48'!
assertCanAddNoPointsPortableObject: aNoPointsPortableObject 
	
	self assertWeightAdding: aNoPointsPortableObject tolerating: 0.
	! !
!Backpack methodsFor: 'adding - private' stamp: 'HAW 10/18/2020 12:29:07'!
assertCanAddPointPortableObject: aPointsPortableObject 
	
	self assertWeightAdding: aPointsPortableObject tolerating: 5.
	self assertPointsAdding: aPointsPortableObject.
	! !

!classDefinition: 'Backpack class' category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:12:26'!
Backpack class
	instanceVariableNames: ''!

!classDefinition: 'Backpack class' category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:12:26'!
Backpack class
	instanceVariableNames: ''!
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 18:27:33'!
invalidPointsCapacityErrorDescription

	^ 'Points capacity must be positive'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 18:21:04'!
invalidWeightCapacityErrorDescription

	^ 'Weight capacity must be positive'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/8/2020 17:36:29'!
maxPointsExceededErrorDescription

	^ 'Maximum points has been exceeded'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/8/2020 17:36:17'!
maxWeightExceededErrorDescription

	^ 'Maximum weight has been exceeded'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/8/2020 17:43:00'!
pointsCapacityMustBeIntegerErrorDescription

	^ 'Points capacity must be integer'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/8/2020 17:42:48'!
weightCapacityMustBeIntegerErrorDescription

	^ 'Weight capacity must be integer'! !
!Backpack class methodsFor: 'exceptions' stamp: 'FRT 10/11/2020 18:27:16'!
signalInvalidPointsCapacity

	self error: self invalidPointsCapacityErrorDescription 
! !
!Backpack class methodsFor: 'exceptions' stamp: 'FRT 10/11/2020 18:21:51'!
signalInvalidWeightCapacity

	self error: self invalidWeightCapacityErrorDescription 
! !
!Backpack class methodsFor: 'exceptions' stamp: 'FRT 10/8/2020 17:41:06'!
signalPointsCapacityMustBeInteger

	self error: self pointsCapacityMustBeIntegerErrorDescription
! !
!Backpack class methodsFor: 'exceptions' stamp: 'FRT 10/8/2020 17:40:47'!
signalWeightCapacityMustBeInteger

	self error: self weightCapacityMustBeIntegerErrorDescription
! !
!Backpack class methodsFor: 'instance creation' stamp: 'HAW 10/14/2020 14:31:56'!
containingUpTo: aWeightCapacity limitingPointsTo: pointsCapacity

	aWeightCapacity strictlyPositive  ifFalse: [ self signalInvalidWeightCapacity ].
	pointsCapacity strictlyPositive ifFalse: [ self signalInvalidPointsCapacity ].
	
	aWeightCapacity isInteger ifFalse: [ self signalWeightCapacityMustBeInteger ].
	pointsCapacity isInteger ifFalse: [ self signalPointsCapacityMustBeInteger ].
	
	^ self new initializeContainingUpTo: aWeightCapacity limitingPointsTo: pointsCapacity.
! !

!classDefinition: #PlayableCharacter category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:12:26'!
Object subclass: #PlayableCharacter
	instanceVariableNames: 'heading backpack name room'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!

!classDefinition: #PlayableCharacter category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:12:26'!
Object subclass: #PlayableCharacter
	instanceVariableNames: 'heading backpack name room'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!
!PlayableCharacter methodsFor: 'initialization' stamp: 'HAW 12/14/2020 18:27:11'!
initializeNamed: aName using: aBackpack at: aPosition heading: aMarsRoverHeading in: aRoom  

	name := aName.
	backpack := aBackpack.
	heading := aMarsRoverHeading.
	room := aRoom.
	room at: aPosition put: self! !
!PlayableCharacter methodsFor: 'testing' stamp: 'HAW 12/14/2020 18:25:08'!
isAt: aPosition heading: aCardinalPoint

	^self position = aPosition and: [ heading cardinalPoint = aCardinalPoint ]! !
!PlayableCharacter methodsFor: 'moving' stamp: 'HAW 12/14/2020 19:09:28'!
forwardPosition

	^ self position + heading forwardPoint! !
!PlayableCharacter methodsFor: 'moving' stamp: 'HAW 12/14/2020 18:25:13'!
moveBackward
	
	self moveTo: self position - heading forwardPoint.
	! !
!PlayableCharacter methodsFor: 'moving' stamp: 'HAW 12/14/2020 19:09:36'!
moveForward
	
	self moveTo: self forwardPosition ! !
!PlayableCharacter methodsFor: 'moving' stamp: 'HAW 12/14/2020 18:27:14'!
moveTo: aNewPosition
	
	room moveFrom: self position to: aNewPosition.
		! !
!PlayableCharacter methodsFor: 'moving' stamp: 'HAW 12/14/2020 18:25:48'!
position

	^room positionOf: self! !
!PlayableCharacter methodsFor: 'rotating' stamp: 'HAW 10/11/2019 08:31:55'!
rotateLeft
	
	heading := heading leftHeading! !
!PlayableCharacter methodsFor: 'rotating' stamp: 'HAW 10/11/2019 08:32:04'!
rotateRight
	
	heading := heading rightHeading! !
!PlayableCharacter methodsFor: 'taking objects' stamp: 'HAW 12/14/2020 19:09:28'!
take
	
	| toTake |
	
	toTake := room at: self forwardPosition.
	toTake takenBy: self 
	! !
!PlayableCharacter methodsFor: 'taking objects' stamp: 'HAW 12/9/2020 19:28:57'!
take: aPortableObject

	backpack add: aPortableObject.! !
!PlayableCharacter methodsFor: 'taking - private' stamp: 'HAW 12/14/2020 18:58:05'!
takeNonPortableObject: aNonPortableObject 
	
	aNonPortableObject putAllTo: self! !
!PlayableCharacter methodsFor: 'taking - private' stamp: 'HAW 12/14/2020 19:09:51'!
takePortableObject: aPortableObject 
	
	self take: aPortableObject.
	room removeAt: self forwardPosition ! !
!PlayableCharacter methodsFor: 'backpack' stamp: 'HAW 12/9/2020 19:43:44'!
backpackIncludes: aPortableObject 
	
	^backpack includes: aPortableObject ! !
!PlayableCharacter methodsFor: 'backpack' stamp: 'HAW 12/14/2020 18:42:40'!
backpackIsEmpty
	
	^backpack isEmpty ! !
!PlayableCharacter methodsFor: 'backpack' stamp: 'HAW 12/14/2020 19:09:03'!
backpackSize
	
	^backpack size! !

!classDefinition: 'PlayableCharacter class' category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:12:27'!
PlayableCharacter class
	instanceVariableNames: 'headings'!

!classDefinition: 'PlayableCharacter class' category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:12:27'!
PlayableCharacter class
	instanceVariableNames: 'headings'!
!PlayableCharacter class methodsFor: 'heading' stamp: 'HAW 7/2/2018 16:28:16'!
headingFor: aCardinalPoint
	
	^headings at: aCardinalPoint ifAbsent: [ self error: self invalidCardinalPointErrorDescription ]! !
!PlayableCharacter class methodsFor: 'heading' stamp: 'HAW 7/2/2018 16:26:14'!
invalidCardinalPointErrorDescription
	
	^'Invalid cardinal point'! !
!PlayableCharacter class methodsFor: 'instance creation' stamp: 'HAW 12/14/2020 18:01:51'!
named: aName using: aBackpack at: aPosition heading: aCardinalPoint in: aRoom  
	
	| newHeading |

	newHeading := self headingFor: aCardinalPoint.
	
	^self new initializeNamed: aName using: aBackpack at: aPosition heading: newHeading in: aRoom ! !
!PlayableCharacter class methodsFor: 'initialization' stamp: 'HAW 10/11/2019 08:37:25'!
forHeadingAt: aCardinalPoint leftIs: aLeftCardinalPoint rightIs: aRightCardinalPoint
	
	(headings at: aCardinalPoint) leftHeading: (headings at: aLeftCardinalPoint) rightHeading: (headings at: aRightCardinalPoint).
	! !
!PlayableCharacter class methodsFor: 'initialization' stamp: 'HAW 7/2/2018 15:27:41' overrides: 16883149!
initialize

	self initializeHeadings! !
!PlayableCharacter class methodsFor: 'initialization' stamp: 'HAW 12/9/2020 19:31:43'!
initializeHeadings

	headings := Dictionary new.
	
	(OrderedCollection 
		with: (PlayableCharacterHeading for: #North forwardWith: 0@1 )	
		with: (PlayableCharacterHeading for: #East forwardWith: 1@0 )
		with: (PlayableCharacterHeading for: #South forwardWith: 0@-1 )
		with: (PlayableCharacterHeading for: #West forwardWith: -1@0 ))
			do: [ :heading | headings at: heading cardinalPoint put: heading ].
	
	self 
		forHeadingAt: #North leftIs: #West rightIs: #East;
		forHeadingAt: #South leftIs: #East rightIs: #West;
		forHeadingAt: #East leftIs: #North rightIs: #South;
		forHeadingAt: #West leftIs: #South rightIs: #North.
	! !

!classDefinition: #PlayableCharacterHeading category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:12:28'!
Object subclass: #PlayableCharacterHeading
	instanceVariableNames: 'cardinalPoint forwardPoint rightHeading leftHeading'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!

!classDefinition: #PlayableCharacterHeading category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:12:28'!
Object subclass: #PlayableCharacterHeading
	instanceVariableNames: 'cardinalPoint forwardPoint rightHeading leftHeading'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!
!PlayableCharacterHeading methodsFor: 'accessing' stamp: 'HAW 7/2/2018 15:29:44'!
cardinalPoint
	
	^cardinalPoint! !
!PlayableCharacterHeading methodsFor: 'accessing' stamp: 'HAW 7/2/2018 15:30:39'!
forwardPoint
	
	^forwardPoint! !
!PlayableCharacterHeading methodsFor: 'accessing' stamp: 'HAW 10/11/2019 08:31:33'!
leftHeading
	
	^leftHeading! !
!PlayableCharacterHeading methodsFor: 'accessing' stamp: 'HAW 10/11/2019 08:31:27'!
rightHeading
	
	^rightHeading! !
!PlayableCharacterHeading methodsFor: 'initialization' stamp: 'HAW 10/11/2019 08:27:25'!
initializeFor: aCardinalPoint forwardWith: aForwardPoint  
	
	cardinalPoint := aCardinalPoint.
	forwardPoint := aForwardPoint.
! !
!PlayableCharacterHeading methodsFor: 'initialization' stamp: 'HAW 10/11/2019 08:31:33'!
leftHeading: aLeftHeading rightHeading: aRightHeading
 
	leftHeading := aLeftHeading.
	rightHeading := aRightHeading ! !

!classDefinition: 'PlayableCharacterHeading class' category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:12:28'!
PlayableCharacterHeading class
	instanceVariableNames: ''!

!classDefinition: 'PlayableCharacterHeading class' category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:12:28'!
PlayableCharacterHeading class
	instanceVariableNames: ''!
!PlayableCharacterHeading class methodsFor: 'instance creation' stamp: 'HAW 10/11/2019 08:27:46'!
for: aCardinalPoint forwardWith: aForwardPoint  

	^self new initializeFor: aCardinalPoint forwardWith: aForwardPoint ! !

!classDefinition: #Room category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:12:28'!
Object subclass: #Room
	instanceVariableNames: 'width height contents'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!

!classDefinition: #Room category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:12:28'!
Object subclass: #Room
	instanceVariableNames: 'width height contents'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!
!Room methodsFor: 'initialization' stamp: 'HAW 12/14/2020 17:47:16'!
initializeOfWidth: aWidth andHeight: aHeight 
	
	width := aWidth.
	height := aHeight.
	contents := Dictionary new.! !
!Room methodsFor: 'contents' stamp: 'HAW 12/14/2020 18:42:28' overrides: 16880774!
at: aPosition

	^contents at: aPosition ifAbsent: [self error: self class objectNotInRoomErrorDescription ]! !
!Room methodsFor: 'contents' stamp: 'HAW 12/14/2020 18:07:24' overrides: 16880792!
at: aPosition put: aStageObject

	self assertPositionIsValid: aPosition.
	self assertIsEmpty: aPosition.
	
	contents at: aPosition put: aStageObject ! !
!Room methodsFor: 'contents' stamp: 'HAW 12/14/2020 18:23:18'!
moveFrom: aSourcePosition to: aTargetPosition

	| toMove |
	
	toMove := self at: aSourcePosition.
	self at: aTargetPosition put: toMove.
	contents removeKey: aSourcePosition.
	! !
!Room methodsFor: 'contents' stamp: 'HAW 12/14/2020 18:30:58'!
positionOf: anObject

	contents keysAndValuesDo: [ :aPosition :aPlacedObject |
		aPlacedObject = anObject ifTrue: [ ^aPosition  ]].
	
	self error: self class objectNotInRoomErrorDescription ! !
!Room methodsFor: 'contents' stamp: 'HAW 12/14/2020 18:47:43'!
removeAt: aPosition

	^contents removeKey: aPosition ! !
!Room methodsFor: 'assertions' stamp: 'HAW 12/14/2020 18:09:38'!
assertIsEmpty: aPosition

	^(self isEmptyAt: aPosition) ifFalse: [ self error: self class positionIsNotEmptyErrorDescription ]! !
!Room methodsFor: 'assertions' stamp: 'HAW 12/14/2020 18:43:14'!
assertPositionComponentIsValid: aPositionComponent withLimit: limit 

	^ (aPositionComponent < 0 or: [aPositionComponent >= limit or: [ aPositionComponent isInteger not]]) 
		ifTrue: [self error: self class invalidPositionErrorDescription ]! !
!Room methodsFor: 'assertions' stamp: 'HAW 12/14/2020 17:44:04'!
assertPositionIsValid: aPosition

	self assertPositionComponentIsValid: aPosition x withLimit: width.
	self assertPositionComponentIsValid: aPosition y withLimit: height.
	! !
!Room methodsFor: 'testing' stamp: 'HAW 12/14/2020 17:47:56'!
isEmpty
	
	^contents isEmpty ! !
!Room methodsFor: 'testing' stamp: 'HAW 12/14/2020 18:08:47'!
isEmptyAt: aPosition

	^ (contents includesKey: aPosition) not! !

!classDefinition: 'Room class' category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:12:29'!
Room class
	instanceVariableNames: ''!

!classDefinition: 'Room class' category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:12:29'!
Room class
	instanceVariableNames: ''!
!Room class methodsFor: 'error descriptions' stamp: 'HAW 12/14/2020 18:43:14'!
invalidPositionErrorDescription
	
	^'Invalid position'! !
!Room class methodsFor: 'error descriptions' stamp: 'HAW 12/14/2020 17:16:22'!
invalidSizeErrorDescription
	
	^'Invalid size'! !
!Room class methodsFor: 'error descriptions' stamp: 'HAW 12/14/2020 18:30:38'!
objectNotInRoomErrorDescription
	
	^'Object not in room'! !
!Room class methodsFor: 'error descriptions' stamp: 'HAW 12/14/2020 18:09:38'!
positionIsNotEmptyErrorDescription
	
	^'Position not empty'! !
!Room class methodsFor: 'instance creation' stamp: 'HAW 12/14/2020 19:27:12'!
ofWidth: aWidth andHeight: aHeight 
	
	self assertIsValidWitdth: aWidth andHeight: aHeight .
	
	^self new initializeOfWidth: aWidth andHeight: aHeight ! !
!Room class methodsFor: 'assertions' stamp: 'HAW 12/14/2020 17:22:01'!
assertIsValidSizeComponent: aSizeComponent

	^ (aSizeComponent < 1 or: [aSizeComponent isInteger not ]) ifTrue: [self error: self invalidSizeErrorDescription ]! !
!Room class methodsFor: 'assertions' stamp: 'HAW 12/14/2020 19:27:12'!
assertIsValidWitdth: aWidth andHeight: aHeight

	self assertIsValidSizeComponent: aWidth.
	self assertIsValidSizeComponent: aHeight! !

!classDefinition: #StageObject category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:12:29'!
Object subclass: #StageObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!

!classDefinition: #StageObject category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:12:29'!
Object subclass: #StageObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!
!StageObject methodsFor: 'taken' stamp: 'HAW 12/14/2020 19:30:06'!
putAllTo: aPlayableCharacter

	self subclassResponsibility 
	! !
!StageObject methodsFor: 'taken' stamp: 'HAW 12/14/2020 19:30:18'!
takenBy: aPlayableCharacter 

	self subclassResponsibility 
	! !

!classDefinition: #NonPortableObject category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:12:29'!
StageObject subclass: #NonPortableObject
	instanceVariableNames: 'name stageObjects'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!

!classDefinition: #NonPortableObject category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:12:29'!
StageObject subclass: #NonPortableObject
	instanceVariableNames: 'name stageObjects'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!
!NonPortableObject methodsFor: 'initialization' stamp: 'HAW 12/14/2020 19:00:02'!
initializeNamed: aName withAll: aCollectionOfStageObjects 
	
	name := aName.
	stageObjects := aCollectionOfStageObjects asOrderedCollection .! !
!NonPortableObject methodsFor: 'taken' stamp: 'HAW 12/14/2020 19:24:52' overrides: 50917076!
putAllTo: aPlayableCharacter 
	
	| toRemove |
	
	toRemove := OrderedCollection new.
	[ stageObjects do: [ :aStageObject | (aStageObject putAllTo: aPlayableCharacter) ifTrue: [ toRemove add: aStageObject ]]]
		ensure: [ stageObjects removeAll: toRemove ].
	
	^false! !
!NonPortableObject methodsFor: 'taken' stamp: 'HAW 12/14/2020 18:53:21' overrides: 50917081!
takenBy: aPlayableCharacter 
	
	aPlayableCharacter takeNonPortableObject: self! !
!NonPortableObject methodsFor: 'testing' stamp: 'HAW 12/14/2020 19:08:45'!
includes: aStageObject

	^stageObjects includes: aStageObject ! !
!NonPortableObject methodsFor: 'testing' stamp: 'HAW 12/14/2020 18:57:19'!
isEmpty
	
	^stageObjects isEmpty ! !

!classDefinition: 'NonPortableObject class' category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:12:30'!
NonPortableObject class
	instanceVariableNames: ''!

!classDefinition: 'NonPortableObject class' category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:12:30'!
NonPortableObject class
	instanceVariableNames: ''!
!NonPortableObject class methodsFor: 'instance creation' stamp: 'HAW 12/14/2020 19:00:27'!
named: aName 
	
	^self named: aName withAll: #()! !
!NonPortableObject class methodsFor: 'instance creation' stamp: 'HAW 12/14/2020 18:56:40'!
named: aName withAll: aCollectionOfStageObjects 
	
	^self new initializeNamed: aName withAll: aCollectionOfStageObjects ! !

!classDefinition: #PortableObject category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:12:30'!
StageObject subclass: #PortableObject
	instanceVariableNames: 'name weight'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!

!classDefinition: #PortableObject category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:12:30'!
StageObject subclass: #PortableObject
	instanceVariableNames: 'name weight'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!
!PortableObject methodsFor: 'testing' stamp: 'FRT 10/11/2020 17:54:20'!
doesItAddPoints

	self subclassResponsibility	! !
!PortableObject methodsFor: 'adding' stamp: 'HAW 10/18/2020 12:28:24'!
assertCanAddTo: aBackpack

	self subclassResponsibility	! !
!PortableObject methodsFor: 'accessing' stamp: 'FRT 10/11/2020 18:53:51'!
weight

	^ weight! !
!PortableObject methodsFor: 'taken' stamp: 'HAW 12/14/2020 19:15:12' overrides: 50917076!
putAllTo: aPlayableCharacter

	aPlayableCharacter take: self.
	^true! !
!PortableObject methodsFor: 'taken' stamp: 'HAW 12/14/2020 18:53:53' overrides: 50917081!
takenBy: aPlayableCharacter 
	
	aPlayableCharacter takePortableObject: self! !

!classDefinition: #NoPointsPortableObject category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:12:30'!
PortableObject subclass: #NoPointsPortableObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!

!classDefinition: #NoPointsPortableObject category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:12:30'!
PortableObject subclass: #NoPointsPortableObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!
!NoPointsPortableObject methodsFor: 'initialization' stamp: 'HAW 10/14/2020 14:34:36'!
initializeNamed: aName weighing: aWeight
	
	name := aName.
	weight := aWeight.! !
!NoPointsPortableObject methodsFor: 'testing' stamp: 'FRT 10/11/2020 17:54:20' overrides: 50917181!
doesItAddPoints	

	^ false! !
!NoPointsPortableObject methodsFor: 'adding' stamp: 'HAW 10/18/2020 12:28:48' overrides: 50917185!
assertCanAddTo: aBackpack 
	
	^aBackpack assertCanAddNoPointsPortableObject: self! !

!classDefinition: 'NoPointsPortableObject class' category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:12:30'!
NoPointsPortableObject class
	instanceVariableNames: ''!

!classDefinition: 'NoPointsPortableObject class' category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:12:30'!
NoPointsPortableObject class
	instanceVariableNames: ''!
!NoPointsPortableObject class methodsFor: 'instance creation' stamp: 'HAW 10/14/2020 14:34:36'!
named: aName weighing: aWeight
	
	^ self new initializeNamed: aName weighing: aWeight. ! !

!classDefinition: #PointsPortableObject category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:12:30'!
PortableObject subclass: #PointsPortableObject
	instanceVariableNames: 'points'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!

!classDefinition: #PointsPortableObject category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:12:30'!
PortableObject subclass: #PointsPortableObject
	instanceVariableNames: 'points'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!
!PointsPortableObject methodsFor: 'testing' stamp: 'FRT 10/11/2020 17:54:20' overrides: 50917181!
doesItAddPoints

	^ true! !
!PointsPortableObject methodsFor: 'initialization' stamp: 'HAW 10/14/2020 14:36:26'!
initializeNamed: aName weighing: aWeight worth: gamePoints
	
	name := aName.
	weight := aWeight.
	points := gamePoints.! !
!PointsPortableObject methodsFor: 'accessing' stamp: 'FRT 10/11/2020 19:06:57'!
points

	^ points! !
!PointsPortableObject methodsFor: 'adding' stamp: 'HAW 10/18/2020 12:29:07' overrides: 50917185!
assertCanAddTo: aBackpack 
	
	^aBackpack assertCanAddPointPortableObject: self! !

!classDefinition: 'PointsPortableObject class' category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:12:31'!
PointsPortableObject class
	instanceVariableNames: ''!

!classDefinition: 'PointsPortableObject class' category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:12:31'!
PointsPortableObject class
	instanceVariableNames: ''!
!PointsPortableObject class methodsFor: 'instance creation' stamp: 'HAW 10/14/2020 14:36:26'!
named: aName weighing: aWeight worth: gamePoints
	
	^ self new initializeNamed: aName weighing: aWeight worth: gamePoints.! !

!classDefinition: #DoorTest category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:12:31'!
TestCase subclass: #DoorTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!

!classDefinition: #DoorTest category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:12:31'!
TestCase subclass: #DoorTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!

!classDefinition: #Door category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:12:31'!
Object subclass: #Door
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!
!DoorTest methodsFor: 'no messages' stamp: 'FG 12/17/2020 17:37:56'!
test01DoorCanNotBeInTheSameRoomTwice

	| door room |
	
	room := Room ofWidth: 10 andHeight: 10. 
	
	door := Door in: room and: room.
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 17:38:20' prior: 50917342!
test01DoorCanNotBeInTheSameRoomTwice

	| door room |
	
	room := Room ofWidth: 10 andHeight: 10. 
	
	door := Door in: room and: room.
	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 17:39:50'!
test01DoorCannotBeInTheSameRoomTwice

	| door room |
	
	room := Room ofWidth: 10 andHeight: 10. 
	
	self 
		should: [ Door in: room and: room ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Door doorCannotBeInTheSameRoomTwice
	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 17:40:04' prior: 50917357!
test01DoorCannotBeInTheSameRoomTwice

	| room |
	
	room := Room ofWidth: 10 andHeight: 10. 
	
	self 
		should: [ Door in: room and: room ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Door doorCannotBeInTheSameRoomTwice
	
	! !

!methodRemoval: DoorTest #test01DoorCanNotBeInTheSameRoomTwice stamp: 'FG 12/17/2020 21:12:31'!
test01DoorCanNotBeInTheSameRoomTwice

	| door room |
	
	room := Room ofWidth: 10 andHeight: 10. 
	
	door := Door in: room and: room.
	
	!
!Door class methodsFor: 'exceptions' stamp: 'FG 12/17/2020 17:40:30' prior: 50909878!
doorCannotBeInTheSameRoomTwice
	self shouldBeImplemented.! !
!Door class methodsFor: 'exceptions' stamp: 'FG 12/17/2020 17:41:28' prior: 50917386!
doorCannotBeInTheSameRoomTwice
	^ 'Error - Cannot create door that leads to the same room that its in'.! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 17:41:38' prior: 50917368!
test01DoorCannotBeInTheSameRoomTwice

	| room |
	
	room := Room ofWidth: 10 andHeight: 10. 
	
	self 
		should: [ Door in: room and: room ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Door doorCannotBeInTheSameRoomTwice.
	
	! !
!Door class methodsFor: 'nil' stamp: 'FG 12/17/2020 17:42:38'!
in: aRoom and: anotherRoom
	
	^ self basicNew initializeIn: aRoom and: anotherRoom.! !
!Door methodsFor: 'no messages' stamp: 'FG 12/17/2020 17:43:16'!
initializeIn: aRoom and: anotherRoom
! !
!Door methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 17:45:09' prior: 50917413!
initializeIn: aRoom and: anotherRoom
	
	(aRoom = anotherRoom) ifTrue: [ self error: Door doorCannotBeInTheSameRoomTwice ].! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 17:53:41'!
test02CannotPlaceDoorInInvalidPositionInAnyOfTheRooms

	| room1 room2 |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
	
	self 
		should: [ Door in: room1 at: -1@0 and: room2 at: 1@1 ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Room invalidPositionErrorDescription.
	
	! !
!Door class methodsFor: 'initialization' stamp: 'FG 12/17/2020 17:54:33'!
in: aRoom at: aPosition and: anotherRoom at: anotherPosition
	
	^ self basicNew initializeIn: aRoom at: aPosition and: anotherRoom at: anotherPosition.! !

!methodRemoval: Door class #in:and: stamp: 'FG 12/17/2020 21:12:32'!
in: aRoom and: anotherRoom
	
	^ self basicNew initializeIn: aRoom and: anotherRoom.!
!Door methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 17:55:33'!
initializeIn: aRoom at: aPosition and: anotherRoom at: anotherPosition
	
	(aRoom = anotherRoom) ifTrue: [ self error: Door doorCannotBeInTheSameRoomTwice ].
	
	aRoom put: self at: aPosition.! !

!methodRemoval: Door #initializeIn:and: stamp: 'FG 12/17/2020 21:12:32'!
initializeIn: aRoom and: anotherRoom
	
	(aRoom = anotherRoom) ifTrue: [ self error: Door doorCannotBeInTheSameRoomTwice ].!
!Door methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 17:56:50' prior: 50917450!
initializeIn: aRoom at: aPosition and: anotherRoom at: anotherPosition
	
	(aRoom = anotherRoom) ifTrue: [ self error: Door doorCannotBeInTheSameRoomTwice ].
	
	aRoom at: aPosition put: self.
	aRoom at: aPosition put: self.! !
!Door methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 17:58:12' prior: 50917466!
initializeIn: aRoom at: aPosition and: anotherRoom at: anotherPosition
	
	(aRoom = anotherRoom) ifTrue: [ self error: Door doorCannotBeInTheSameRoomTwice ].
	
	aRoom at: aPosition put: self.
	anotherRoom at: anotherPosition put: self.! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 18:02:32' prior: 50917425!
test02CannotPlaceDoorInInvalidPositionInAnyOfTheRooms

	| room1 room2 |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
	
	self 
		should: [ Door in: room1 at: -1@0 and: room2 at: 1@1 ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Room invalidPositionErrorDescription.
		
	self 
		should: [ Door in: room1 at: 1@0 and: room2 at: -1@1 ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Room invalidPositionErrorDescription.
	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 18:03:06'!
test03CannotPlaceDoorInOcupiedPositionInAnyOfTheRooms

	| room1 room2 |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
	
	self 
		should: [ Door in: room1 at: -1@0 and: room2 at: 1@1 ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Room invalidPositionErrorDescription.
		
	self 
		should: [ Door in: room1 at: 1@0 and: room2 at: -1@1 ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Room invalidPositionErrorDescription.
	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 18:03:21' prior: 50910010!
paper

	^ PointsPortableObject named: 'paper' weighing: 1 worth: 1! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 18:04:34' prior: 50917505!
test03CannotPlaceDoorInOcupiedPositionInAnyOfTheRooms

	| room1 room2 |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
	
	room1 at: 1@1 put: self paper.
	room2 at: 1@1 put: self paper. 
	
	self 
		should: [ Door in: room1 at: 1@1 and: room2 at: 0@1 ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Room invalidPositionErrorDescription.
		
	self 
		should: [ Door in: room1 at: 1@0 and: room2 at: 1@1 ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Room invalidPositionErrorDescription.
	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 18:05:29' prior: 50917530!
test03CannotPlaceDoorInOcupiedPositionInAnyOfTheRooms

	| room1 room2 |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
	
	room1 at: 1@1 put: self paper.
	room2 at: 1@1 put: self paper. 
	
	self 
		should: [ Door in: room1 at: 1@1 and: room2 at: 0@1 ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Room positionIsNotEmptyErrorDescription.
		
	self 
		should: [ Door in: room1 at: 1@0 and: room2 at: 1@1 ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Room positionIsNotEmptyErrorDescription.
	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 18:06:59'!
test04DoorIsBothRooms

	| room1 room2 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1.	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 18:09:21' prior: 50917571!
test04DoorIsBothRooms

	| room1 room2 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1.	
	
	self deny: (room1 isEmptyAt: 1@1).
	self deny: (room2 isEmptyAt: 0@1).
	self assert: (room1 at: 1@1) equals: door.
	self assert: (room2 at: 0@1) equals: door.  
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 18:09:51'!
test04DoorIsInBothRooms

	| room1 room2 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1.	
	
	self deny: (room1 isEmptyAt: 1@1).
	self deny: (room2 isEmptyAt: 0@1).
	self assert: (room1 at: 1@1) equals: door.
	self assert: (room2 at: 0@1) equals: door.  
	! !

!methodRemoval: DoorTest #test04DoorIsBothRooms stamp: 'FG 12/17/2020 21:12:32'!
test04DoorIsBothRooms

	| room1 room2 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1.	
	
	self deny: (room1 isEmptyAt: 1@1).
	self deny: (room2 isEmptyAt: 0@1).
	self assert: (room1 at: 1@1) equals: door.
	self assert: (room2 at: 0@1) equals: door.  
	!
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 18:10:36' prior: 50911470!
test01DoorShouldBeInDifferentRooms

	| room |
	
	room := Room ofWidth: 10 andHeight: 10. 
	
	self 
		should: [ Door in: room and: room ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Door doorCannotBeInTheSameRoomTwice.
	
	! !

!methodRemoval: DoorTest #test01DoorCannotBeInTheSameRoomTwice stamp: 'FG 12/17/2020 21:12:32'!
test01DoorCannotBeInTheSameRoomTwice

	| room |
	
	room := Room ofWidth: 10 andHeight: 10. 
	
	self 
		should: [ Door in: room and: room ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Door doorCannotBeInTheSameRoomTwice.
	
	!
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 18:10:57' prior: 50917622!
test01DoorShouldBeInDifferentRooms

	| room |
	
	room := Room ofWidth: 10 andHeight: 10. 
	
	self 
		should: [ Door in: room at: 1@1 and: room at:1@1]
		raise: Error - MessageNotUnderstood 
		withMessageText: Door doorCannotBeInTheSameRoomTwice.
	
	! !
!Door methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 18:18:56' prior: 50917476!
initializeIn: aRoom at: aPosition and: anotherRoom at: anotherPosition
	
	(aRoom = anotherRoom) ifTrue: [ self error: Door doorCannotBeInTheSameRoomTwice ].
	
	aRoom at: aPosition put: self.
	anotherRoom at: anotherPosition put: self.! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 18:30:36'!
test05DoorLeadFromOneRoomToTheOther

	| room1 room2 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1.	
	
	self assert: (door moveFrom: room1) equals: room2.
	self assert: (door moveFrom: room2) equals: room2. ! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 18:30:39' prior: 50917664!
test05DoorLeadFromOneRoomToTheOther

	| room1 room2 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1.	
	
	self assert: (door moveFrom: room1) equals: room2.
	self assert: (door moveFrom: room2) equals: room1. ! !
!Door methodsFor: 'accessing' stamp: 'FG 12/17/2020 18:30:56'!
moveFrom: aRoom 
	self shouldBeImplemented.! !

!classDefinition: #Door category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:12:32'!
Object subclass: #Door
	instanceVariableNames: 'firstRoom'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!

!classDefinition: #Door category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:12:32'!
Object subclass: #Door
	instanceVariableNames: 'firstRoom secondRoom'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!
!Door methodsFor: 'accessing' stamp: 'FG 12/17/2020 18:32:39' prior: 50917689!
moveFrom: aRoom 
	(aRoom = firstRoom) ifTrue: [^ secondRoom].
	(aRoom = secondRoom) ifTrue: [^ firstRoom].! !
!Door methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 18:33:28' prior: 50917654!
initializeIn: aRoom at: aPosition and: anotherRoom at: anotherPosition
	
	(aRoom = anotherRoom) ifTrue: [ self error: Door doorCannotBeInTheSameRoomTwice ].
	
	aRoom at: aPosition put: self.
	anotherRoom at: anotherPosition put: self.
	
	firstRoom := aRoom.
	secondRoom := anotherRoom.! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 18:39:08'!
test06CannotMoveFromARoomWhichDoesntHasTheDoor

	| room1 room2 room3 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
	room3 := Room 	ofWidth: 10 andHeight: 10.
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1.	
	
	self assert: (door moveFrom: room1) equals: room2.
	self assert: (door moveFrom: room2) equals: room1. ! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 18:40:45' prior: 50917729!
test06CannotMoveFromARoomWhichDoesntHasTheDoor

	| room1 room2 room3 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
	room3 := Room 	ofWidth: 10 andHeight: 10.
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1.	
	
	self 
		should: [ door moveFrom: room3]
		raise: Error - MessageNotUnderstood 
		withMessageText: (Door cannotMoveFrom: room3).! !
!Door class methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 18:41:01'!
cannotMoveFrom: aRoom 
	self shouldBeImplemented.! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 18:43:01' prior: 50917744!
test06CannotMoveFromARoomWhichDoesntHasTheDoor

	| room1 room2 room3 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
	room3 := Room 	ofWidth: 10 andHeight: 10.
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1.	
	
	self 
		should: [ door moveFrom: room3]
		raise: Error - MessageNotUnderstood 
		withMessageText: (Door cannotMoveFromARoomWithoutThisDoor).! !
!Door class methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 18:43:13' prior: 50910271!
cannotMoveFromARoomWithoutThisDoor
	self shouldBeImplemented.! !
!Door class methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 18:43:36' prior: 50917780!
cannotMoveFromARoomWithoutThisDoor
	^ 'Error - Cannot move from a room without this door'.! !
!Door methodsFor: 'accessing' stamp: 'FG 12/17/2020 18:44:22' prior: 50917710!
moveFrom: aRoom 
	(aRoom = firstRoom) ifTrue: [^ secondRoom].
	(aRoom = secondRoom) ifTrue: [^ firstRoom].
	self error: Door cannotMoveFromARoomWithoutThisDoor.! !

!classDefinition: #Door category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:12:33'!
Object subclass: #Door
	instanceVariableNames: 'firstRoom secondRoom state'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!

!classDefinition: #Door category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:12:33'!
Object subclass: #Door
	instanceVariableNames: 'firstRoom secondRoom state'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!

!classDefinition: #ClosedDoor category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:12:33'!
Object subclass: #ClosedDoor
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 18:53:54'!
test07DoorStartsClosed

	| room1 room2 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1.	
	
	self assert: (door state isKindaOf: 
	ClosedDoor).! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 18:54:16' prior: 50917825!
test07DoorStartsClosed

	| room1 room2 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1.	
	
	self assert: (door state isKindOf: ClosedDoor).! !

!classDefinition: #DoorState category: 'Unknown' stamp: 'FG 12/17/2020 21:12:33'!
Object subclass: #DoorState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Unknown'!

!classDefinition: #ClosedDoor category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:12:33'!
DoorState subclass: #ClosedDoor
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!

!classDefinition: #ClosedDoor category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:12:33'!
DoorState subclass: #ClosedDoor
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!

!classDefinition: #DoorState category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:12:33'!
Object subclass: #DoorState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!

!classDefinition: #DoorState category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:12:33'!
Object subclass: #DoorState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!
!Door methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 18:55:59' prior: 50917717!
initializeIn: aRoom at: aPosition and: anotherRoom at: anotherPosition
	
	(aRoom = anotherRoom) ifTrue: [ self error: Door doorCannotBeInTheSameRoomTwice ].
	
	aRoom at: aPosition put: self.
	anotherRoom at: anotherPosition put: self.
	
	state := ClosedDoor new.
	firstRoom := aRoom.
	secondRoom := anotherRoom.! !
!Door methodsFor: 'accessing' stamp: 'FG 12/17/2020 18:57:04' prior: 50910458!
isClosed
	state isClosed: self.! !
!ClosedDoor methodsFor: 'no messages' stamp: 'FG 12/17/2020 18:57:22'!
isClosed: door
	^ true.! !
!ClosedDoor methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 18:57:27' prior: 50910393 overrides: 50911319!
isClosed
	^ true.! !

!methodRemoval: ClosedDoor #isClosed: stamp: 'FG 12/17/2020 21:12:33'!
isClosed: door
	^ true.!
!Door methodsFor: 'accessing' stamp: 'FG 12/17/2020 18:57:39' prior: 50917900!
isClosed
	state isClosed.! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 18:58:00' prior: 50917836!
test07DoorStartsClosed

	| room1 room2 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1.	
	
	self assert: door isClosed.! !
!Door methodsFor: 'accessing' stamp: 'FG 12/17/2020 18:59:37' prior: 50910534!
useFrom: aRoom 
	(aRoom = firstRoom) ifTrue: [^ secondRoom].
	(aRoom = secondRoom) ifTrue: [^ firstRoom].
	self error: Door cannotMoveFromARoomWithoutThisDoor.! !

!methodRemoval: Door #moveFrom: stamp: 'FG 12/17/2020 21:12:34'!
moveFrom: aRoom 
	(aRoom = firstRoom) ifTrue: [^ secondRoom].
	(aRoom = secondRoom) ifTrue: [^ firstRoom].
	self error: Door cannotMoveFromARoomWithoutThisDoor.!
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 18:59:54' prior: 50917677!
test05DoorLeadFromOneRoomToTheOther

	| room1 room2 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1.	
	
	self assert: (door useFrom: room1) equals: room2.
	self assert: (door useFrom: room2) equals: room1. ! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:00:00' prior: 50917764!
test06CannotMoveFromARoomWhichDoesntHasTheDoor

	| room1 room2 room3 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
	room3 := Room 	ofWidth: 10 andHeight: 10.
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1.	
	
	self 
		should: [ door useFrom: room3]
		raise: Error - MessageNotUnderstood 
		withMessageText: (Door cannotMoveFromARoomWithoutThisDoor).! !
!Door methodsFor: 'accessing' stamp: 'FG 12/17/2020 19:01:42' prior: 50917916!
isClosed
	^ state isClosed.! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:03:51'!
test08CannotUseAClosedDoor

	| room1 room2 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1.	
	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:04:33' prior: 50917979!
test08CannotUseAClosedDoor

	| room1 room2 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1.	
	
	self 
		should: [ door useFrom: room1]
		raise: Error - MessageNotUnderstood 
		withMessageText: (Door cannotUseClosedDoor).
	
	! !
!Door methodsFor: 'accessing' stamp: 'FG 12/17/2020 19:05:53' prior: 50917930!
useFrom: aRoom 

	state useDoor: self.! !
!Door methodsFor: 'accessing' stamp: 'FG 12/17/2020 19:06:14' prior: 50910489!
useOpenDoorFrom: aRoom 

	(aRoom = firstRoom) ifTrue: [^ secondRoom].
	(aRoom = secondRoom) ifTrue: [^ firstRoom].
	self error: Door cannotMoveFromARoomWithoutThisDoor.! !
!ClosedDoor methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:06:51'!
useDoor: aDoor

	aDoor useClosedDoor.! !
!Door methodsFor: 'accessing' stamp: 'FG 12/17/2020 19:07:30'!
useClosedDoorFrom

	self error: Door.! !
!Door methodsFor: 'accessing' stamp: 'FG 12/17/2020 19:07:46' prior: 50918002!
useFrom: aRoom 

	state useDoor: self from: aRoom.! !
!ClosedDoor methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:07:58' prior: 50910510 overrides: 50911337!
useDoor: aDoor from: aRoom

	aDoor useClosedDoor.! !

!methodRemoval: ClosedDoor #useDoor: stamp: 'FG 12/17/2020 21:12:34'!
useDoor: aDoor

	aDoor useClosedDoor.!
!Door methodsFor: 'accessing' stamp: 'FG 12/17/2020 19:08:14' prior: 50910539!
useClosedDoor

	self error: Door.! !

!methodRemoval: Door #useClosedDoorFrom stamp: 'FG 12/17/2020 21:12:34'!
useClosedDoorFrom

	self error: Door.!

!methodRemoval: Door class #cannotMoveFrom: stamp: 'FG 12/17/2020 21:12:34'!
cannotMoveFrom: aRoom 
	self shouldBeImplemented.!
!Door class methodsFor: 'exceptions' stamp: 'FG 12/17/2020 19:09:17' prior: 50910529!
cannotUseClosedDoor
	^ 'Error - The door is closed. You cannot use it'.! !
!Door methodsFor: 'use' stamp: 'FG 12/17/2020 19:11:07' prior: 50918022!
useFrom: aRoom 

	^ state useDoor: self from: aRoom.! !
!Door methodsFor: 'use - private' stamp: 'FG 12/17/2020 19:11:56' prior: 50918036!
useClosedDoor

	self error: Door cannotUseClosedDoor .! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:13:05'!
test08CannotOpenDoorWithWrongKey

	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:13:09'!
test09CannotOpenDoorWithWrongKey

	
	! !

!methodRemoval: DoorTest #test08CannotOpenDoorWithWrongKey stamp: 'FG 12/17/2020 21:12:34'!
test08CannotOpenDoorWithWrongKey

	
	!

!classDefinition: #Door category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:12:34'!
Object subclass: #Door
	instanceVariableNames: 'firstRoom secondRoom state key'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!
!Door methodsFor: 'initialization' stamp: 'FG 12/17/2020 19:13:55' prior: 50911284!
initializeIn: aRoom at: aPosition and: anotherRoom at: anotherPosition thatOpensWith: aKey
	
	(aRoom = anotherRoom) ifTrue: [ self error: Door doorCannotBeInTheSameRoomTwice ].
	
	aRoom at: aPosition put: self.
	anotherRoom at: anotherPosition put: self.
	
	key := aKey.
	state := ClosedDoor new.
	firstRoom := aRoom.
	secondRoom := anotherRoom.! !

!methodRemoval: Door #initializeIn:at:and:at:thatOpensWith: stamp: 'FG 12/17/2020 21:12:34'!
initializeIn: aRoom at: aPosition and: anotherRoom at: anotherPosition thatOpensWith: aKey
	
	(aRoom = anotherRoom) ifTrue: [ self error: Door doorCannotBeInTheSameRoomTwice ].
	
	aRoom at: aPosition put: self.
	anotherRoom at: anotherPosition put: self.
	
	key := aKey.
	state := ClosedDoor new.
	firstRoom := aRoom.
	secondRoom := anotherRoom.!
!Door methodsFor: 'initialization' stamp: 'FG 12/17/2020 19:15:27'!
initializeIn: aRoom at: aPosition and: anotherRoom at: anotherPosition thatOpensWith: aKey 
	
	(aRoom = anotherRoom) ifTrue: [ self error: Door doorCannotBeInTheSameRoomTwice ].
	
	aRoom at: aPosition put: self.
	anotherRoom at: anotherPosition put: self.
	
	state := ClosedDoor new.
	firstRoom := aRoom.
	secondRoom := anotherRoom.! !
!Door class methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:15:27' prior: 50917438!
in: aRoom at: aPosition and: anotherRoom at: anotherPosition
	
	^ self basicNew initializeIn: aRoom at: aPosition and: anotherRoom at: anotherPosition thatOpensWith: aKey.! !

!methodRemoval: Door #initializeIn:at:and:at: stamp: 'FG 12/17/2020 21:12:35'!
initializeIn: aRoom at: aPosition and: anotherRoom at: anotherPosition
	
	(aRoom = anotherRoom) ifTrue: [ self error: Door doorCannotBeInTheSameRoomTwice ].
	
	aRoom at: aPosition put: self.
	anotherRoom at: anotherPosition put: self.
	
	state := ClosedDoor new.
	firstRoom := aRoom.
	secondRoom := anotherRoom.!
!Door methodsFor: 'initialization' stamp: 'FG 12/17/2020 19:15:43' prior: 50918111!
initializeIn: aRoom at: aPosition and: anotherRoom at: anotherPosition thatOpensWith: aKey 
	
	(aRoom = anotherRoom) ifTrue: [ self error: Door doorCannotBeInTheSameRoomTwice ].
	
	aRoom at: aPosition put: self.
	anotherRoom at: anotherPosition put: self.
	
	key := aKey.
	state := ClosedDoor new.
	firstRoom := aRoom.
	secondRoom := anotherRoom.! !
!Door methodsFor: 'nil' stamp: 'FG 12/17/2020 19:17:59' prior: 50911303!
openWith: aKey

	(key = aKey) ifFalse: [ self error: Door cannotOpenWithWrongKey].
	 ! !
!Door class methodsFor: 'exceptions' stamp: 'FG 12/17/2020 19:18:28' prior: 50910645!
cannotOpenWithWrongKey
	^ 'Error - Cannot open door with a wrong key'.! !

!classDefinition: #Keys category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:12:35'!
PortableObject subclass: #Keys
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!

!classDefinition: #Keys category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:12:35'!
PortableObject subclass: #Keys
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!
!Keys methodsFor: 'no messages' stamp: 'FG 12/17/2020 19:20:45' prior: 50910666!
initializeNamed: aName weighing: aWeight
	
	name := aName.
	weight := aWeight.! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:21:08' prior: 50910684!
wrongKey

	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:21:35' prior: 50918194!
wrongKey

	^ Keys ! !
!Keys class methodsFor: 'no messages' stamp: 'FG 12/17/2020 19:21:51' prior: 50910678!
named: aName weighing: aWeight
	
	^ self new initializeNamed: aName weighing: aWeight. ! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:22:20' prior: 50918198!
wrongKey

	^ Keys named: 'Wrong Key' weighing: 5 ! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:22:29' prior: 50918067!
test09CannotOpenDoorWithWrongKey

	

	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:22:59' prior: 50910693!
correctKey

	^ Keys named: 'Correct Key' weighing: 5 ! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:23:07' prior: 50918213!
test09CannotOpenDoorWithWrongKey

	

	

	
	! !
!Door class methodsFor: 'initialization' stamp: 'FG 12/17/2020 19:24:00' prior: 50910702!
in: aRoom at: aPosition and: anotherRoom at: anotherPosition thatOpensWith: aKey 
	
	^ self basicNew initializeIn: aRoom at: aPosition and: anotherRoom at: anotherPosition thatOpensWith: aKey.! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:24:00' prior: 50917551!
test03CannotPlaceDoorInOcupiedPositionInAnyOfTheRooms

	| room1 room2 |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
	
	room1 at: 1@1 put: self paper.
	room2 at: 1@1 put: self paper. 
	
	self 
		should: [ Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: self correctKey ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Room positionIsNotEmptyErrorDescription.
		
	self 
		should: [ Door in: room1 at: 1@0 and: room2 at: 1@1 thatOpensWith: self correctKey ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Room positionIsNotEmptyErrorDescription.
	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:24:00' prior: 50917946!
test05DoorLeadFromOneRoomToTheOther

	| room1 room2 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: self correctKey.	
	
	self assert: (door useFrom: room1) equals: room2.
	self assert: (door useFrom: room2) equals: room1. ! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:24:00' prior: 50917643!
test01DoorShouldBeInDifferentRooms

	| room |
	
	room := Room ofWidth: 10 andHeight: 10. 
	
	self 
		should: [ Door in: room at: 1@1 and: room at:1@1 thatOpensWith: self correctKey]
		raise: Error - MessageNotUnderstood 
		withMessageText: Door doorCannotBeInTheSameRoomTwice.
	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:24:00' prior: 50917920!
test07DoorStartsClosed

	| room1 room2 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: self correctKey.	
	
	self assert: door isClosed.! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:24:00' prior: 50917989!
test08CannotUseAClosedDoor

	| room1 room2 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: self correctKey.	
	
	self 
		should: [ door useFrom: room1]
		raise: Error - MessageNotUnderstood 
		withMessageText: (Door cannotUseClosedDoor).
	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:24:00' prior: 50917487!
test02CannotPlaceDoorInInvalidPositionInAnyOfTheRooms

	| room1 room2 |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
	
	self 
		should: [ Door in: room1 at: -1@0 and: room2 at: 1@1 thatOpensWith: self correctKey ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Room invalidPositionErrorDescription.
		
	self 
		should: [ Door in: room1 at: 1@0 and: room2 at: -1@1 thatOpensWith: self correctKey ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Room invalidPositionErrorDescription.
	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:24:00' prior: 50917594!
test04DoorIsInBothRooms

	| room1 room2 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: self correctKey.	
	
	self deny: (room1 isEmptyAt: 1@1).
	self deny: (room2 isEmptyAt: 0@1).
	self assert: (room1 at: 1@1) equals: door.
	self assert: (room2 at: 0@1) equals: door.  
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:24:00' prior: 50917959!
test06CannotMoveFromARoomWhichDoesntHasTheDoor

	| room1 room2 room3 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
	room3 := Room 	ofWidth: 10 andHeight: 10.
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: self correctKey.	
	
	self 
		should: [ door useFrom: room3]
		raise: Error - MessageNotUnderstood 
		withMessageText: (Door cannotMoveFromARoomWithoutThisDoor).! !

!methodRemoval: Door class #in:at:and:at: stamp: 'FG 12/17/2020 21:12:35'!
in: aRoom at: aPosition and: anotherRoom at: anotherPosition
	
	^ self basicNew initializeIn: aRoom at: aPosition and: anotherRoom at: anotherPosition thatOpensWith: aKey.!
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:25:22' prior: 50918223!
test09CannotOpenDoorWithWrongKey

	| room1 room2 door |

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: self correctKey.	

	

	

	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:25:58' prior: 50918375!
test09CannotOpenDoorWithWrongKey

	| room1 room2 door |

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: self correctKey.	
	
	self 
		should: [ door openWith: self wrongKey ]
		raise: Error - MessageNotUnderstood 
		withMessageText: (Door cannotOpenWithWrongKey).
	

	

	

	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:27:26'!
test09DoorOpensWithTheCorrectKey

	| room1 room2 door key |

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 

	key := self correctKey.	
			
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: key.	
	
	door openWith: key.
	
	self deny: door isClosed.	

	

	

	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:27:32'!
test10DoorOpensWithTheCorrectKey

	| room1 room2 door key |

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 

	key := self correctKey.	
			
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: key.	
	
	door openWith: key.
	
	self deny: door isClosed.	

	

	

	
	! !

!methodRemoval: DoorTest #test09DoorOpensWithTheCorrectKey stamp: 'FG 12/17/2020 21:12:36'!
test09DoorOpensWithTheCorrectKey

	| room1 room2 door key |

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 

	key := self correctKey.	
			
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: key.	
	
	door openWith: key.
	
	self deny: door isClosed.	

	

	

	
	!

!classDefinition: #OpenDoor category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:12:36'!
DoorState subclass: #OpenDoor
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!
!Door methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:29:27' prior: 50918160!
openWith: aKey

	(key = aKey) ifFalse: [ self error: Door cannotOpenWithWrongKey].
	
	state := OpenDoor new.
	 ! !
!OpenDoor methodsFor: 'no messages' stamp: 'FG 12/17/2020 19:30:01' prior: 50910928 overrides: 50911319!
isClosed
	^ false.! !
!OpenDoor methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:30:56' prior: 50910932 overrides: 50911337!
useDoor: aDoor from: aRoom
	^ aDoor useOpenDoorFrom: aRoom. ! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:32:05' prior: 50918261!
test05DoorLeadFromOneRoomToTheOther

	| room1 room2 door key |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	key := self correctKey.
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: key.
	door openWith: key.	
	
	self assert: (door useFrom: room1) equals: room2.
	self assert: (door useFrom: room2) equals: room1. ! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:33:02' prior: 50918350!
test06CannotMoveFromARoomWhichDoesntHasTheDoor

	| room1 room2 room3 door key |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
	room3 := Room 	ofWidth: 10 andHeight: 10.
	
	key := self correctKey.	
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: self key.
	door openWith: key.	
	
	self 
		should: [ door useFrom: room3]
		raise: Error - MessageNotUnderstood 
		withMessageText: (Door cannotMoveFromARoomWithoutThisDoor).! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:33:23' prior: 50918480!
test06CannotMoveFromARoomWhichDoesntHasTheDoor

	| room1 room2 room3 door key |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
	room3 := Room 	ofWidth: 10 andHeight: 10.
	
	key := self correctKey.	
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: key.
	door openWith: key.	
	
	self 
		should: [ door useFrom: room3]
		raise: Error - MessageNotUnderstood 
		withMessageText: (Door cannotMoveFromARoomWithoutThisDoor).! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:33:52'!
test11CannotOpenAnAlreadyOpenDoor

	| room1 room2 door key |

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 

	key := self correctKey.	
			
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: key.	
	
	door openWith: key.
	
	self deny: door isClosed.	

	

	

	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:34:37' prior: 50918516!
test11CannotOpenAnAlreadyOpenDoor

	| room1 room2 door key |

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 

	key := self correctKey.	
			
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: key.	
	
	door openWith: key.
	
	self 
		should: [ door openWith: key ]
		raise: Error - MessageNotUnderstood 
		withMessageText: (Door doorAlreadyOpen).

	

	

	
	! !
!Door methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:35:52' prior: 50918448!
openWith: aKey

	(key = aKey) ifFalse: [ self error: Door cannotOpenWithWrongKey].
	
	state openDoor: self.
	 ! !
!ClosedDoor methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:36:18' prior: 50911024 overrides: 50911328!
openDoor: aDoor

	aDoor openClosedDoor.
	! !
!OpenDoor methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:36:37' prior: 50911028 overrides: 50911328!
openDoor: aDoor
	
	aDoor openOpenedDoor.! !
!Door methodsFor: 'open - private' stamp: 'FG 12/17/2020 19:37:42' prior: 50911040!
openClosedDoor

	! !
!Door methodsFor: 'open - private' stamp: 'FG 12/17/2020 19:38:37' prior: 50911035!
openOpenedDoor

	self error: Door doorAlreadyOpen.! !
!Door methodsFor: 'open - private' stamp: 'FG 12/17/2020 19:39:00' prior: 50918562!
openClosedDoor

	state := OpenDoor new.

	! !
!Door class methodsFor: 'exceptions' stamp: 'FG 12/17/2020 19:39:38' prior: 50911044!
doorAlreadyOpen

	^ 'Error - Door is already open' ! !
!Keys methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:42:15' prior: 50911048!
isAKey
	^ true.! !
!NoPointsPortableObject methodsFor: 'nil' stamp: 'FG 12/17/2020 19:42:29'!
isAKey
	^ false.! !
!PointsPortableObject methodsFor: 'nil' stamp: 'FG 12/17/2020 19:42:42'!
isAKey
	^ false.! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:45:53'!
test12ADoorCannotBeLockedWithAnyObjectThatIsNotAKey

	| room1 room2 door paper |

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 

	
	

	

	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:47:47' prior: 50918591!
test12ADoorCannotBeLockedWithAnyObjectThatIsNotAKey

	| room1 room2 |

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 	
		
	self 
		should: [ Door in: room1 at: 1@1  and: room2  at: 1@1  thatOpensWith: self paper ]
		raise: Error - MessageNotUnderstood 
		withMessageText: (Door cannotBeLockedWithANonKeyObject).

	
	

	

	
	! !
!Door class methodsFor: 'exceptions' stamp: 'FG 12/17/2020 19:48:24' prior: 50911081!
cannotBeLockedWithANonKeyObject
	^ 'Error - Door Cannot Be Locked With Non Key Object'.! !
!Door methodsFor: 'initialization' stamp: 'FG 12/17/2020 19:48:56' prior: 50918146!
initializeIn: aRoom at: aPosition and: anotherRoom at: anotherPosition thatOpensWith: aKey 
	
	(aRoom = anotherRoom) ifTrue: [ self error: Door doorCannotBeInTheSameRoomTwice ].
	(aKey isAKey) ifFalse: [ self error: Door cannotBeLockedWithANonKeyObject ].
	
	aRoom at: aPosition put: self.
	anotherRoom at: anotherPosition put: self.
	
	key := aKey.
	state := ClosedDoor new.
	firstRoom := aRoom.
	secondRoom := anotherRoom.! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:53:03'!
test13CannotCloseDoorWithANonKeyObject

	| room1 room2 door key|

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 	
		
	key := self correctKey.	
	door := Door in: room1 at: 1@1  and: room2  at: 1@1  thatOpensWith: key.
	door openWith:	 key.
		
	self 
		should: [ door closeWith: self paper ]
		raise: Error - MessageNotUnderstood 
		withMessageText: (Door cannotBeLockedWithANonKeyObject).

	
	

	

	
	! !
!Door methodsFor: 'nil' stamp: 'FG 12/17/2020 19:54:00' prior: 50911309!
closeWith: aKey

	(key isAKey) ifFalse: [self error: Door cannotBeLockedWithANonKeyObject ].
	 ! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:54:37' prior: 50918637!
test13CannotCloseDoorWithANonKeyObject

	| room1 room2 door key|

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 	
		
	key := self correctKey.	
	door := Door in: room1 at: 1@1  and: room2  at: 1@1  thatOpensWith: key.
	door openWith:	 key.
		
	self 
		should: [ door closeWith: self paper ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Door cannotBeLockedWithANonKeyObject.

	
	

	

	
	! !
!Door methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:55:06' prior: 50918654!
closeWith: aKey

	(aKey isAKey) ifFalse: [self error: Door cannotBeLockedWithANonKeyObject ].
	 ! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:56:25'!
test13CannotCloseAClosedDoor

	| room1 room2 door key|

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 	
		
	key := self correctKey.	
	door := Door in: room1 at: 1@1  and: room2  at: 1@1  thatOpensWith: key.
		
	self 
		should: [ door closeWith: self correctKey ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Door cannotCloseAnAlreadyClosedDoor.

	
	

	

	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:56:31'!
test14CannotCloseAClosedDoor

	| room1 room2 door key|

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 	
		
	key := self correctKey.	
	door := Door in: room1 at: 1@1  and: room2  at: 1@1  thatOpensWith: key.
		
	self 
		should: [ door closeWith: self correctKey ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Door cannotCloseAnAlreadyClosedDoor.

	
	

	

	
	! !

!methodRemoval: DoorTest #test13CannotCloseAClosedDoor stamp: 'FG 12/17/2020 21:12:37'!
test13CannotCloseAClosedDoor

	| room1 room2 door key|

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 	
		
	key := self correctKey.	
	door := Door in: room1 at: 1@1  and: room2  at: 1@1  thatOpensWith: key.
		
	self 
		should: [ door closeWith: self correctKey ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Door cannotCloseAnAlreadyClosedDoor.

	
	

	

	
	!
!Door methodsFor: 'close' stamp: 'FG 12/17/2020 19:57:25' prior: 50918677!
closeWith: aKey

	(aKey isAKey) ifFalse: [self error: Door cannotBeLockedWithANonKeyObject ].
	
	state closeDoor: self with: aKey.
	 ! !
!ClosedDoor methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:57:56' prior: 50911202 overrides: 50911314!
closeDoor: aDoor with: aKey

	aDoor closeClosedDoor.! !
!Door methodsFor: 'nil' stamp: 'FG 12/17/2020 19:58:31' prior: 50911206!
closeClosedDoor

	self error: Door doorAlreadyClosed.! !
!Door class methodsFor: 'exceptions' stamp: 'FG 12/17/2020 19:58:43' prior: 50911210!
doorAlreadyClosed

	^ 'Error - Door is already closed' ! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 19:59:08' prior: 50918699!
test14CannotCloseAClosedDoor

	| room1 room2 door key|

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 	
		
	key := self correctKey.	
	door := Door in: room1 at: 1@1  and: room2  at: 1@1  thatOpensWith: key.
		
	self 
		should: [ door closeWith: self correctKey ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Door doorAlreadyClosed.

	
	

	

	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:02:24'!
test15DoorCanBeClosedWithAKey

	| room1 room2 door key newKey|

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 	
		
	key := self correctKey.	
	door := Door in: room1 at: 1@1  and: room2  at: 1@1  thatOpensWith: key.
	door openWith: key.

	newKey := self wrongKey.
	door closeWith: newKey.
	
	self assert: door isClosed.
	
	door openWith: newKey.
	
	self deny: door isClosed	.
	
		
	

	

	
	! !
!OpenDoor methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:03:13' prior: 50911246 overrides: 50911314!
closeDoor: aDoor with: aKey

	aDoor closeOpenedDoorWith: aKey.! !
!Door methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:03:38' prior: 50911251!
closeOpenedDoorWith: aKey

	state := ClosedDoor new.
	key := aKey.! !
!Door methodsFor: 'initialization' stamp: 'FG 12/17/2020 20:05:43' prior: 50911256!
assertThat: aRoom isDifferentFrom: anotherRoom

	^ (aRoom = anotherRoom) ifTrue: [ self error: Door doorCannotBeInTheSameRoomTwice ]! !
!Door methodsFor: 'initialization' stamp: 'FG 12/17/2020 20:05:43' prior: 50918621!
initializeIn: aRoom at: aPosition and: anotherRoom at: anotherPosition thatOpensWith: aKey 
	
	self assertThat: aRoom isDifferentFrom: anotherRoom.
	(aKey isAKey) ifFalse: [ self error: Door cannotBeLockedWithANonKeyObject ].
	
	aRoom at: aPosition put: self.
	anotherRoom at: anotherPosition put: self.
	
	key := aKey.
	state := ClosedDoor new.
	firstRoom := aRoom.
	secondRoom := anotherRoom.! !
!Door methodsFor: 'initialization' stamp: 'FG 12/17/2020 20:06:42' prior: 50911278!
assertIsValidKey: aKey

	^ (aKey isAKey) ifFalse: [ self error: Door cannotBeLockedWithANonKeyObject ]! !
!Door methodsFor: 'initialization' stamp: 'FG 12/17/2020 20:06:42' prior: 50918802!
initializeIn: aRoom at: aPosition and: anotherRoom at: anotherPosition thatOpensWith: aKey 
	
	self assertThat: aRoom isDifferentFrom: anotherRoom.
	self assertIsValidKey: aKey.
	
	aRoom at: aPosition put: self.
	anotherRoom at: anotherPosition put: self.
	
	key := aKey.
	state := ClosedDoor new.
	firstRoom := aRoom.
	secondRoom := anotherRoom.! !
!Door methodsFor: 'open' stamp: 'FG 12/17/2020 20:10:12' prior: 50911297!
assertThatIsTheCorrectKey: aKey

	^ (key = aKey) ifFalse: [ self error: Door cannotOpenWithWrongKey]! !
!Door methodsFor: 'open' stamp: 'FG 12/17/2020 20:10:12' prior: 50918545!
openWith: aKey

	self assertThatIsTheCorrectKey: aKey.
	
	state openDoor: self.
	 ! !
!Door methodsFor: 'close' stamp: 'FG 12/17/2020 20:10:31' prior: 50918730!
closeWith: aKey

	self assertIsValidKey: aKey.
	
	state closeDoor: self with: aKey.
	 ! !
!DoorState methodsFor: 'nil' stamp: 'FG 12/17/2020 20:11:15' prior: 50911314!
closeDoor: aDoor with: aKey
	self subclassResponsibility.! !
!DoorState methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:11:33' prior: 50911319!
isClosed
	self subclassResponsibility.! !
!DoorState methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:11:47'!
openDoor: aDoor with: aKey
	self subclassResponsibility.! !
!DoorState methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:12:30' prior: 50911328!
openDoor: aDoor
	self subclassResponsibility.! !

!methodRemoval: DoorState #openDoor:with: stamp: 'FG 12/17/2020 21:12:37'!
openDoor: aDoor with: aKey
	self subclassResponsibility.!
!DoorState methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:12:47' prior: 50911337!
useDoor: aDoor from: aRoom
	self subclassResponsibility ! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:14:15' overrides: 16927572!
setUp
	
	||! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:14:48' prior: 50918884 overrides: 16927572!
setUp
	
	| room anotherRoom|
	
	room := Room ofWidth: 10 andHeight: 10.
	anotherRoom := Room ofWidth: 10 andHeight: 10. ! !

!classDefinition: #DoorTest category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:12:38'!
TestCase subclass: #DoorTest
	instanceVariableNames: 'asd asda'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!

!classDefinition: #DoorTest category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:12:38'!
TestCase subclass: #DoorTest
	instanceVariableNames: 'asd asda'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:18:38' prior: 50918888 overrides: 16927572!
setUp
	
	asd := Room ofWidth: 10 andHeight: 10.
	asda := Room ofWidth: 10 andHeight: 10. ! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:18:44' prior: 50918275!
test01DoorShouldBeInDifferentRooms

	| room |
	
	asd := Room ofWidth: 10 andHeight: 10. 
	
	self 
		should: [ Door in: room at: 1@1 and: room at:1@1 thatOpensWith: self correctKey]
		raise: Error - MessageNotUnderstood 
		withMessageText: Door doorCannotBeInTheSameRoomTwice.
	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:18:59' prior: 50918919!
test01DoorShouldBeInDifferentRooms

	| room |
	
	self 
		should: [ Door in: room at: 1@1 and: asd at:1@1 thatOpensWith: self correctKey]
		raise: Error - MessageNotUnderstood 
		withMessageText: Door doorCannotBeInTheSameRoomTwice.
	
	! !

!methodRemoval: DoorTest #setUp stamp: 'FG 12/17/2020 21:12:38'!
setUp
	
	asd := Room ofWidth: 10 andHeight: 10.
	asda := Room ofWidth: 10 andHeight: 10. !

!classDefinition: #DoorTest category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:12:38'!
TestCase subclass: #DoorTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!

!classDefinition: #DoorTest category: 'ISW1-2020-2C-Recuperatorio-2doParcial' stamp: 'FG 12/17/2020 21:12:38'!
TestCase subclass: #DoorTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:19:52' prior: 50918931!
test01DoorShouldBeInDifferentRooms

	| room |
	
	room := Room ofWidth: 10 andHeight: 10. 
	
	self 
		should: [ Door in: room at: 1@1 and: room at:1@1 thatOpensWith: self correctKey]
		raise: Error - MessageNotUnderstood 
		withMessageText: Door doorCannotBeInTheSameRoomTwice.
	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:20:11' prior: 50911433!
room

	^ Room ofWidth: 10 andHeight: 10 ! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:20:19' prior: 50918963!
test01DoorShouldBeInDifferentRooms

	| room |
	
	room := self room. 
	
	self 
		should: [ Door in: room at: 1@1 and: room at:1@1 thatOpensWith: self correctKey]
		raise: Error - MessageNotUnderstood 
		withMessageText: Door doorCannotBeInTheSameRoomTwice.
	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:21:04' prior: 50918980!
test01DoorShouldBeInDifferentRooms

       |sameRoom|

	sameRoom := self room.

	self 
		should: [ Door in: sameRoom  at: 1@1 and: sameRoom at:1@1 thatOpensWith: self correctKey]
		raise: Error - MessageNotUnderstood 
		withMessageText: Door doorCannotBeInTheSameRoomTwice.
	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:22:18' prior: 50911462!
shouldDo: aBlock failingAndRaising: anErrorMessage

	self 
		should: aBlock
		raise: Error - MessageNotUnderstood 
		withMessageText: anErrorMessage.
	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:22:55' prior: 50918992!
test01DoorShouldBeInDifferentRooms

       |sameRoom|

	sameRoom := self room.

	self 
		shouldDo: [ Door in: sameRoom  at: 1@1 and: sameRoom at:1@1 thatOpensWith: self correctKey]
		failingAndRaising: Door doorCannotBeInTheSameRoomTwice.
	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:23:09' prior: 50918313!
test02CannotPlaceDoorInInvalidPositionInAnyOfTheRooms

	| room1 room2 |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
	
	self 
		should: [ Door in: room1 at: -1@0 and: room2 at: 1@1 thatOpensWith: self correctKey ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Room invalidPositionErrorDescription.
		
	self 
		should: [ Door in: room1 at: 1@0 and: room2 at: -1@1 thatOpensWith: self correctKey ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Room invalidPositionErrorDescription.
	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:23:18' prior: 50919023!
test02CannotPlaceDoorInInvalidPositionInAnyOfTheRooms

	| room room2 |
	
	room := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
	
	self 
		should: [ Door in: room at: -1@0 and: room2 at: 1@1 thatOpensWith: self correctKey ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Room invalidPositionErrorDescription.
		
	self 
		should: [ Door in: room at: 1@0 and: room2 at: -1@1 thatOpensWith: self correctKey ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Room invalidPositionErrorDescription.
	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:23:28' prior: 50919044!
test02CannotPlaceDoorInInvalidPositionInAnyOfTheRooms

	| room anotherRoom |
	
	room := Room ofWidth: 10 andHeight: 10.
	anotherRoom := Room ofWidth: 10 andHeight: 10. 
	
	self 
		should: [ Door in: room at: -1@0 and: anotherRoom at: 1@1 thatOpensWith: self correctKey ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Room invalidPositionErrorDescription.
		
	self 
		should: [ Door in: room at: 1@0 and: anotherRoom at: -1@1 thatOpensWith: self correctKey ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Room invalidPositionErrorDescription.
	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:24:33' prior: 50919065!
test02CannotPlaceDoorInInvalidPositionInAnyOfTheRooms

	| room anotherRoom |
	
	room := Room ofWidth: 10 andHeight: 10.
	anotherRoom := Room ofWidth: 10 andHeight: 10. 
	
	self 
		shouldDo:  [ Door in: room at: -1@0 and: anotherRoom at: 1@1 thatOpensWith: self correctKey ]
		failingAndRaising: Room invalidPositionErrorDescription.
		
		
	self 
		shouldDo:  [ Door in: room at: 1@0 and: anotherRoom at: -1@1 thatOpensWith: self correctKey ]
		failingAndRaising: Room invalidPositionErrorDescription.
	
	! !

!methodRemoval: DoorTest #test02CannotPlaceDoorInInvalidPositionInAnyOfTheRooms stamp: 'FG 12/17/2020 21:12:38'!
test02CannotPlaceDoorInInvalidPositionInAnyOfTheRooms

	| room anotherRoom |
	
	room := Room ofWidth: 10 andHeight: 10.
	anotherRoom := Room ofWidth: 10 andHeight: 10. 
	
	self 
		shouldDo:  [ Door in: room at: -1@0 and: anotherRoom at: 1@1 thatOpensWith: self correctKey ]
		failingAndRaising: Room invalidPositionErrorDescription.
		
		
	self 
		shouldDo:  [ Door in: room at: 1@0 and: anotherRoom at: -1@1 thatOpensWith: self correctKey ]
		failingAndRaising: Room invalidPositionErrorDescription.
	
	!

!methodRemoval: DoorTest #test03CannotPlaceDoorInOcupiedPositionInAnyOfTheRooms stamp: 'FG 12/17/2020 21:12:38'!
test03CannotPlaceDoorInOcupiedPositionInAnyOfTheRooms

	| room1 room2 |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
	
	room1 at: 1@1 put: self paper.
	room2 at: 1@1 put: self paper. 
	
	self 
		should: [ Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: self correctKey ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Room positionIsNotEmptyErrorDescription.
		
	self 
		should: [ Door in: room1 at: 1@0 and: room2 at: 1@1 thatOpensWith: self correctKey ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Room positionIsNotEmptyErrorDescription.
	
	!
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:24:55'!
test03DoorIsInBothRooms

	| room1 room2 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: self correctKey.	
	
	self deny: (room1 isEmptyAt: 1@1).
	self deny: (room2 isEmptyAt: 0@1).
	self assert: (room1 at: 1@1) equals: door.
	self assert: (room2 at: 0@1) equals: door.  
	! !

!methodRemoval: DoorTest #test04DoorIsInBothRooms stamp: 'FG 12/17/2020 21:12:39'!
test04DoorIsInBothRooms

	| room1 room2 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: self correctKey.	
	
	self deny: (room1 isEmptyAt: 1@1).
	self deny: (room2 isEmptyAt: 0@1).
	self assert: (room1 at: 1@1) equals: door.
	self assert: (room2 at: 0@1) equals: door.  
	!
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:25:04'!
test04DoorLeadFromOneRoomToTheOther

	| room1 room2 door key |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	key := self correctKey.
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: key.
	door openWith: key.	
	
	self assert: (door useFrom: room1) equals: room2.
	self assert: (door useFrom: room2) equals: room1. ! !

!methodRemoval: DoorTest #test05DoorLeadFromOneRoomToTheOther stamp: 'FG 12/17/2020 21:12:39'!
test05DoorLeadFromOneRoomToTheOther

	| room1 room2 door key |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	key := self correctKey.
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: key.
	door openWith: key.	
	
	self assert: (door useFrom: room1) equals: room2.
	self assert: (door useFrom: room2) equals: room1. !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:25:16' prior: 50912037!
test02DoorIsInBothRooms

	| room1 room2 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: self correctKey.	
	
	self deny: (room1 isEmptyAt: 1@1).
	self deny: (room2 isEmptyAt: 0@1).
	self assert: (room1 at: 1@1) equals: door.
	self assert: (room2 at: 0@1) equals: door.  
	! !

!methodRemoval: DoorTest #test03DoorIsInBothRooms stamp: 'FG 12/17/2020 21:12:39'!
test03DoorIsInBothRooms

	| room1 room2 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: self correctKey.	
	
	self deny: (room1 isEmptyAt: 1@1).
	self deny: (room2 isEmptyAt: 0@1).
	self assert: (room1 at: 1@1) equals: door.
	self assert: (room2 at: 0@1) equals: door.  
	!
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:25:22' prior: 50912053!
test03DoorLeadFromOneRoomToTheOther

	| room1 room2 door key |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	key := self correctKey.
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: key.
	door openWith: key.	
	
	self assert: (door useFrom: room1) equals: room2.
	self assert: (door useFrom: room2) equals: room1. ! !

!methodRemoval: DoorTest #test04DoorLeadFromOneRoomToTheOther stamp: 'FG 12/17/2020 21:12:39'!
test04DoorLeadFromOneRoomToTheOther

	| room1 room2 door key |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	key := self correctKey.
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: key.
	door openWith: key.	
	
	self assert: (door useFrom: room1) equals: room2.
	self assert: (door useFrom: room2) equals: room1. !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:25:28' prior: 50912093!
test04CannotMoveFromARoomWhichDoesntHasTheDoor

	| room1 room2 room3 door key |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
	room3 := Room 	ofWidth: 10 andHeight: 10.
	
	key := self correctKey.	
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: key.
	door openWith: key.	
	
	self 
		should: [ door useFrom: room3]
		raise: Error - MessageNotUnderstood 
		withMessageText: (Door cannotMoveFromARoomWithoutThisDoor).! !

!methodRemoval: DoorTest #test06CannotMoveFromARoomWhichDoesntHasTheDoor stamp: 'FG 12/17/2020 21:12:39'!
test06CannotMoveFromARoomWhichDoesntHasTheDoor

	| room1 room2 room3 door key |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
	room3 := Room 	ofWidth: 10 andHeight: 10.
	
	key := self correctKey.	
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: key.
	door openWith: key.	
	
	self 
		should: [ door useFrom: room3]
		raise: Error - MessageNotUnderstood 
		withMessageText: (Door cannotMoveFromARoomWithoutThisDoor).!
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:25:34' prior: 50911761!
test05DoorStartsClosed

	| room1 room2 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: self correctKey.	
	
	self assert: door isClosed.! !

!methodRemoval: DoorTest #test07DoorStartsClosed stamp: 'FG 12/17/2020 21:12:39'!
test07DoorStartsClosed

	| room1 room2 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: self correctKey.	
	
	self assert: door isClosed.!
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:25:38' prior: 50911782!
test06CannotUseAClosedDoor

	| room1 room2 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: self correctKey.	
	
	self 
		should: [ door useFrom: room1]
		raise: Error - MessageNotUnderstood 
		withMessageText: (Door cannotUseClosedDoor).
	
	! !

!methodRemoval: DoorTest #test08CannotUseAClosedDoor stamp: 'FG 12/17/2020 21:12:39'!
test08CannotUseAClosedDoor

	| room1 room2 door |
	
	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: self correctKey.	
	
	self 
		should: [ door useFrom: room1]
		raise: Error - MessageNotUnderstood 
		withMessageText: (Door cannotUseClosedDoor).
	
	!
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:25:47' prior: 50911810!
test07CannotOpenDoorWithWrongKey

	| room1 room2 door |

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: self correctKey.	
	
	self 
		should: [ door openWith: self wrongKey ]
		raise: Error - MessageNotUnderstood 
		withMessageText: (Door cannotOpenWithWrongKey).
	

	

	

	
	! !

!methodRemoval: DoorTest #test09CannotOpenDoorWithWrongKey stamp: 'FG 12/17/2020 21:12:39'!
test09CannotOpenDoorWithWrongKey

	| room1 room2 door |

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: self correctKey.	
	
	self 
		should: [ door openWith: self wrongKey ]
		raise: Error - MessageNotUnderstood 
		withMessageText: (Door cannotOpenWithWrongKey).
	

	

	

	
	!
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:25:53' prior: 50911840!
test08DoorOpensWithTheCorrectKey

	| room1 room2 door key |

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 

	key := self correctKey.	
			
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: key.	
	
	door openWith: key.
	
	self deny: door isClosed.	

	

	

	
	! !

!methodRemoval: DoorTest #test10DoorOpensWithTheCorrectKey stamp: 'FG 12/17/2020 21:12:39'!
test10DoorOpensWithTheCorrectKey

	| room1 room2 door key |

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 

	key := self correctKey.	
			
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: key.	
	
	door openWith: key.
	
	self deny: door isClosed.	

	

	

	
	!
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:25:58' prior: 50911865!
test09CannotOpenAnAlreadyOpenDoor

	| room1 room2 door key |

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 

	key := self correctKey.	
			
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: key.	
	
	door openWith: key.
	
	self 
		should: [ door openWith: key ]
		raise: Error - MessageNotUnderstood 
		withMessageText: (Door doorAlreadyOpen).

	

	

	
	! !

!methodRemoval: DoorTest #test11CannotOpenAnAlreadyOpenDoor stamp: 'FG 12/17/2020 21:12:39'!
test11CannotOpenAnAlreadyOpenDoor

	| room1 room2 door key |

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 

	key := self correctKey.	
			
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: key.	
	
	door openWith: key.
	
	self 
		should: [ door openWith: key ]
		raise: Error - MessageNotUnderstood 
		withMessageText: (Door doorAlreadyOpen).

	

	

	
	!
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:26:03' prior: 50911896!
test10ADoorCannotBeLockedWithAnyObjectThatIsNotAKey

	| room1 room2 |

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 	
		
	self 
		should: [ Door in: room1 at: 1@1  and: room2  at: 1@1  thatOpensWith: self paper ]
		raise: Error - MessageNotUnderstood 
		withMessageText: (Door cannotBeLockedWithANonKeyObject).

	
	

	

	
	! !

!methodRemoval: DoorTest #test12ADoorCannotBeLockedWithAnyObjectThatIsNotAKey stamp: 'FG 12/17/2020 21:12:39'!
test12ADoorCannotBeLockedWithAnyObjectThatIsNotAKey

	| room1 room2 |

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 	
		
	self 
		should: [ Door in: room1 at: 1@1  and: room2  at: 1@1  thatOpensWith: self paper ]
		raise: Error - MessageNotUnderstood 
		withMessageText: (Door cannotBeLockedWithANonKeyObject).

	
	

	

	
	!
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:26:08' prior: 50911925!
test11CannotCloseDoorWithANonKeyObject

	| room1 room2 door key|

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 	
		
	key := self correctKey.	
	door := Door in: room1 at: 1@1  and: room2  at: 1@1  thatOpensWith: key.
	door openWith:	 key.
		
	self 
		should: [ door closeWith: self paper ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Door cannotBeLockedWithANonKeyObject.

	
	

	

	
	! !

!methodRemoval: DoorTest #test13CannotCloseDoorWithANonKeyObject stamp: 'FG 12/17/2020 21:12:39'!
test13CannotCloseDoorWithANonKeyObject

	| room1 room2 door key|

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 	
		
	key := self correctKey.	
	door := Door in: room1 at: 1@1  and: room2  at: 1@1  thatOpensWith: key.
	door openWith:	 key.
		
	self 
		should: [ door closeWith: self paper ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Door cannotBeLockedWithANonKeyObject.

	
	

	

	
	!
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:26:14' prior: 50911958!
test12CannotCloseAClosedDoor

	| room1 room2 door key|

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 	
		
	key := self correctKey.	
	door := Door in: room1 at: 1@1  and: room2  at: 1@1  thatOpensWith: key.
		
	self 
		should: [ door closeWith: self correctKey ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Door doorAlreadyClosed.

	
	

	

	
	! !

!methodRemoval: DoorTest #test14CannotCloseAClosedDoor stamp: 'FG 12/17/2020 21:12:39'!
test14CannotCloseAClosedDoor

	| room1 room2 door key|

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 	
		
	key := self correctKey.	
	door := Door in: room1 at: 1@1  and: room2  at: 1@1  thatOpensWith: key.
		
	self 
		should: [ door closeWith: self correctKey ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Door doorAlreadyClosed.

	
	

	

	
	!
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:26:20' prior: 50911989!
test13DoorCanBeClosedWithAKey

	| room1 room2 door key newKey|

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 	
		
	key := self correctKey.	
	door := Door in: room1 at: 1@1  and: room2  at: 1@1  thatOpensWith: key.
	door openWith: key.

	newKey := self wrongKey.
	door closeWith: newKey.
	
	self assert: door isClosed.
	
	door openWith: newKey.
	
	self deny: door isClosed	.
	
		
	

	

	
	! !

!methodRemoval: DoorTest #test15DoorCanBeClosedWithAKey stamp: 'FG 12/17/2020 21:12:39'!
test15DoorCanBeClosedWithAKey

	| room1 room2 door key newKey|

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 	
		
	key := self correctKey.	
	door := Door in: room1 at: 1@1  and: room2  at: 1@1  thatOpensWith: key.
	door openWith: key.

	newKey := self wrongKey.
	door closeWith: newKey.
	
	self assert: door isClosed.
	
	door openWith: newKey.
	
	self deny: door isClosed	.
	
		
	

	

	
	!
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:26:37' prior: 50919207!
test02DoorIsInBothRooms

	| room room2 door |
	
	room := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room at: 1@1 and: room2 at: 0@1 thatOpensWith: self correctKey.	
	
	self deny: (room isEmptyAt: 1@1).
	self deny: (room2 isEmptyAt: 0@1).
	self assert: (room at: 1@1) equals: door.
	self assert: (room2 at: 0@1) equals: door.  
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:26:57' prior: 50919569!
test02DoorIsInBothRooms

	| room anotherRoom door |
	
	room := Room ofWidth: 10 andHeight: 10.
	anotherRoom := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room at: 1@1 and: anotherRoom at: 0@1 thatOpensWith: self correctKey.	
	
	self deny: (room isEmptyAt: 1@1).
	self deny: (anotherRoom isEmptyAt: 0@1).
	self assert: (room at: 1@1) equals: door.
	self assert: (anotherRoom at: 0@1) equals: door.  
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:27:47' prior: 50919237!
test03DoorLeadFromOneRoomToTheOther

	| room anotherRoom door key |
	
	room := Room ofWidth: 10 andHeight: 10.
	anotherRoom := Room ofWidth: 10 andHeight: 10. 
		
	key := self correctKey.
	door := Door in: room at: 1@1 and: anotherRoom at: 0@1 thatOpensWith: key.
	door openWith: key.	
	
	self assert: (door useFrom: room) equals: anotherRoom.
	self assert: (door useFrom: anotherRoom) equals: room. ! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:28:20' prior: 50912069!
openedDoor

	| room anotherRoom door key |
	
	room := Room ofWidth: 10 andHeight: 10.
	anotherRoom := Room ofWidth: 10 andHeight: 10. 
		
	key := self correctKey.
	door := Door in: room at: 1@1 and: anotherRoom at: 0@1 thatOpensWith: key.
	door openWith: key.	
	
	^ door! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:29:54' prior: 50919267!
test04CannotMoveFromARoomWhichDoesntHasTheDoor

	| room door |
	
	room := Room ofWidth: 10 andHeight: 10.
	
	door := self openedDoor.
	self 
		should: [ door useFrom: room]
		raise: Error - MessageNotUnderstood 
		withMessageText: (Door cannotMoveFromARoomWithoutThisDoor).! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 20:30:41' prior: 50919628!
test04CannotMoveFromARoomWhichDoesntHasTheDoor

	| room door |
	
	room := Room ofWidth: 10 andHeight: 10.
	
	door := self openedDoor.
	
	self 
		shouldDo: [ door useFrom: room] 
		failingAndRaising: Door cannotMoveFromARoomWithoutThisDoor
! !
!Room methodsFor: 'contents' stamp: 'FG 12/17/2020 20:36:04' prior: 50916952!
moveFrom: aSourcePosition to: aTargetPosition

	| toMove |
	
	((self at: aTargetPosition) isKindOf: Door) 
	ifTrue:[
	
	]
	ifFalse: [
		toMove := self at: aSourcePosition.
		self at: aTargetPosition put: toMove.
		contents removeKey: aSourcePosition.
	].
	! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'FG 12/17/2020 20:40:19'!
test21_playerShouldMoveFromRoomsWhenPassThroughADoor

	| room anotherRoom player box paper anotherPaper |

	room := self defaultRoom.
	anotherRoom := self defaultRoom.
	Door in: room at:  0@1 and: anotherRoom at: 0@1  thatOpensWith: self correctKey .
	player := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 0@0 heading: #North in: room.
	
	player moveForward.
	
	! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'FG 12/17/2020 20:42:03' prior: 50919662!
test21_playerShouldMoveFromRoomsWhenPassThroughADoor

	| room anotherRoom player box paper anotherPaper |

	room := self defaultRoom.
	anotherRoom := self defaultRoom.
	Door in: room at:  0@1 and: anotherRoom at: 0@1  thatOpensWith: self correctKey .
	player := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 0@0 heading: #North in: room.
	
	player moveForward.
	
	self assert: (anotherRoom at: 0@2) equals: player. 
	! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'FG 12/17/2020 20:42:13' prior: 50919677!
test21_playerShouldMoveFromRoomsWhenPassThroughADoor

	| room anotherRoom player |

	room := self defaultRoom.
	anotherRoom := self defaultRoom.
	Door in: room at:  0@1 and: anotherRoom at: 0@1  thatOpensWith: self correctKey .
	player := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 0@0 heading: #North in: room.
	
	player moveForward.
	
	self assert: (anotherRoom at: 0@2) equals: player. 
	! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'FG 12/17/2020 20:42:37'!
correctKey

	^ Keys named: 'Correct Key' weighing: 5 ! !
!Room methodsFor: 'contents' stamp: 'FG 12/17/2020 20:47:06' prior: 50919651!
moveFrom: aSourcePosition to: aTargetPosition

	| toMove |
	
		toMove := self at: aSourcePosition.
		self at: aTargetPosition put: toMove.
		contents removeKey: aSourcePosition.
	! !
!Room methodsFor: 'contents' stamp: 'FG 12/17/2020 20:50:22'!
moveAt: aPosition to: anotherRoom at: anotherPosition

	anotherRoom at: anotherPosition put: (self at: aPosition).
	contents removeKey: aPosition.! !
!PlayableCharacter methodsFor: 'moving' stamp: 'FG 12/17/2020 20:52:08' prior: 50916712!
moveForward
	
	self moveTo: self forwardPosition ! !
!PlayableCharacter methodsFor: 'moving' stamp: 'FG 12/17/2020 20:54:01' prior: 50916716!
moveTo: aNewPosition
	
	((room at: aNewPosition) isKindOf: Door)
	ifTrue:[
		room 
	]
	ifFalse:[
		room moveFrom: self position to: aNewPosition.
	] ! !
!PlayableCharacter methodsFor: 'moving' stamp: 'FG 12/17/2020 20:56:21' prior: 50919736!
moveTo: aNewPosition
	
	((room at: aNewPosition) isKindOf: Door)
	ifTrue:[
		room moveAt: (room positionOf: self) to: ((room at: aNewPosition) useFrom: room) at:  room
	]
	ifFalse:[
		room moveFrom: self position to: aNewPosition.
	] ! !
!PlayableCharacter methodsFor: 'moving' stamp: 'FG 12/17/2020 21:00:54' prior: 50919744!
moveTo: aNewPosition
	
	|newRoom|
	
	((room at: aNewPosition) isKindOf: Door)
	ifTrue:[
		newRoom := 	(room at: aNewPosition) useFrom: room.
		room moveAt: self position to: newRoom at: (newRoom positionOf: (room at: aNewPosition)).
	]
	ifFalse:[
		room moveFrom: self position to: aNewPosition.
	] ! !
!PlayableCharacter methodsFor: 'moving' stamp: 'FG 12/17/2020 21:01:19' prior: 50919755!
moveTo: aNewPosition
	
	|newRoom|
	
	((room at: aNewPosition) isKindOf: Door)
	ifTrue:[
		newRoom := 	(room at: aNewPosition) useFrom: room.
		room moveAt: self position to: newRoom at: (newRoom positionOf: (room at: aNewPosition) + heading forwardPoint).
	]
	ifFalse:[
		room moveFrom: self position to: aNewPosition.
	] ! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'FG 12/17/2020 21:02:53'!
openedDoor

	| room anotherRoom door key |
	
	room := Room ofWidth: 10 andHeight: 10.
	anotherRoom := Room ofWidth: 10 andHeight: 10. 
		
	key := self correctKey.
	door := Door in: room at: 1@1 and: anotherRoom at: 0@1 thatOpensWith: key.
	door openWith: key.	
	
	^ door! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'FG 12/17/2020 21:03:06' prior: 50919781!
openedDoor

	| room anotherRoom door key |
	
	room := Room ofWidth: 10 andHeight: 10.
	anotherRoom := Room ofWidth: 10 andHeight: 10. 
		
	key := self correctKey.
	door := self openedDoor.
	door openWith: key.	
	
	^ door! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'FG 12/17/2020 21:03:44' prior: 50919694!
test21_playerShouldMoveFromRoomsWhenPassThroughADoor

	| room anotherRoom player |

	room := self defaultRoom.
	anotherRoom := self defaultRoom.
	self openedDoor.
	player := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 0@0 heading: #North in: room.
	
	player moveForward.
	
	self assert: (anotherRoom at: 0@2) equals: player. 
	! !
!PlayableCharacterTest methodsFor: 'tests' stamp: 'FG 12/17/2020 21:13:53' prior: 50919793!
openedDoor

	| room anotherRoom door key |
	
	room := Room ofWidth: 10 andHeight: 10.
	anotherRoom := Room ofWidth: 10 andHeight: 10. 
		
	key := self correctKey.
	door := Door in: room at: 1@1 and: anotherRoom at: 0@1 thatOpensWith: key..
	door openWith: key.	
	
	^ door! !

!testRun: #PlayableCharacterTest #test21_playerShouldMoveFromRoomsWhenPassThroughADoor stamp: 'FG 12/17/2020 21:13:57'!
ERROR!

!testRun: #PlayableCharacterTest #test21_playerShouldMoveFromRoomsWhenPassThroughADoor stamp: 'FG 12/17/2020 21:13:57'!
ERROR!

!testRun: #PlayableCharacterTest #test01_forwardWhenHeadingNorthIncrementsYCoordinate stamp: 'FG 12/17/2020 21:14:43'!
ERROR!

!testRun: #PlayableCharacterTest #test02_backwardWhenHeadingNorthDecrementsYCoordinate stamp: 'FG 12/17/2020 21:14:43'!
ERROR!

!testRun: #PlayableCharacterTest #test03_rotateRightWhenHeadingNorthHeadsEast stamp: 'FG 12/17/2020 21:14:43'!
ERROR!

!testRun: #PlayableCharacterTest #test04_rotateLeftWhenHeadingNorthHeadsWest stamp: 'FG 12/17/2020 21:14:43'!
ERROR!

!testRun: #PlayableCharacterTest #test05_movingWhenHeadingEastWorksAsExpected stamp: 'FG 12/17/2020 21:14:43'!
ERROR!

!testRun: #PlayableCharacterTest #test06_movingWhenHeadingSouthWorksAsExpected stamp: 'FG 12/17/2020 21:14:43'!
ERROR!

!testRun: #PlayableCharacterTest #test07_movingWhenHeadingWestWorksAsExpected stamp: 'FG 12/17/2020 21:14:43'!
ERROR!

!testRun: #PlayableCharacterTest #test08_canNotCreatePlayableCharacterWhenHeadingIsNotValid stamp: 'FG 12/17/2020 21:14:43'!
FAILURE!

!testRun: #PlayableCharacterTest #test09_canTakePortableObjects stamp: 'FG 12/17/2020 21:14:43'!
ERROR!

!testRun: #PlayableCharacterTest #test10_canNotTakeMoreObjectsThanTheBackpackCanCarry stamp: 'FG 12/17/2020 21:14:43'!
ERROR!

!testRun: #PlayableCharacterTest #test11_CanNotCreateCharacterWithInvalidPosition stamp: 'FG 12/17/2020 21:14:43'!
ERROR!

!testRun: #PlayableCharacterTest #test12_CanNotCreateCharacterOnNotEmptyPosition stamp: 'FG 12/17/2020 21:14:43'!
ERROR!

!testRun: #PlayableCharacterTest #test13_moveForwardModifiesPositionInRoom stamp: 'FG 12/17/2020 21:14:43'!
ERROR!

!testRun: #PlayableCharacterTest #test14_moveBackwardModifiesPositionInRoom stamp: 'FG 12/17/2020 21:14:43'!
ERROR!

!testRun: #PlayableCharacterTest #test15_canNotMoveToInvalidPosition stamp: 'FG 12/17/2020 21:14:43'!
ERROR!

!testRun: #PlayableCharacterTest #test16_canNotTakeFromAnEmptyOrInvalidPosition stamp: 'FG 12/17/2020 21:14:43'!
ERROR!

!testRun: #PlayableCharacterTest #test17_canTakeAPortableObject stamp: 'FG 12/17/2020 21:14:43'!
ERROR!

!testRun: #PlayableCharacterTest #test18_emptyNonPortableObjectDoesNotAddObjectsToBackpack stamp: 'FG 12/17/2020 21:14:43'!
ERROR!

!testRun: #PlayableCharacterTest #test19_portableInNonPortableObjectIsAddedToBackpack stamp: 'FG 12/17/2020 21:14:43'!
ERROR!

!testRun: #PlayableCharacterTest #test20_takeFromNonPortableObjectsIsRecursive stamp: 'FG 12/17/2020 21:14:43'!
ERROR!

!testRun: #PlayableCharacterTest #test21_playerShouldMoveFromRoomsWhenPassThroughADoor stamp: 'FG 12/17/2020 21:14:43'!
ERROR!

!testRun: #PlayableCharacterTest #test01_forwardWhenHeadingNorthIncrementsYCoordinate stamp: 'FG 12/17/2020 21:15:04'!
ERROR!

!testRun: #PlayableCharacterTest #test01_forwardWhenHeadingNorthIncrementsYCoordinate stamp: 'FG 12/17/2020 21:15:04'!
ERROR!

!testRun: #PlayableCharacterTest #test01_forwardWhenHeadingNorthIncrementsYCoordinate stamp: 'FG 12/17/2020 21:15:09'!
ERROR!

!testRun: #PlayableCharacterTest #test01_forwardWhenHeadingNorthIncrementsYCoordinate stamp: 'FG 12/17/2020 21:15:09'!
ERROR!

!testRun: #PlayableCharacterTest #test01_forwardWhenHeadingNorthIncrementsYCoordinate stamp: 'FG 12/17/2020 21:15:48'!
ERROR!

!testRun: #PlayableCharacterTest #test01_forwardWhenHeadingNorthIncrementsYCoordinate stamp: 'FG 12/17/2020 21:15:49'!
ERROR!

!testRun: #PlayableCharacterTest #test01_forwardWhenHeadingNorthIncrementsYCoordinate stamp: 'FG 12/17/2020 21:19:26'!
ERROR!

!testRun: #PlayableCharacterTest #test01_forwardWhenHeadingNorthIncrementsYCoordinate stamp: 'FG 12/17/2020 21:19:26'!
ERROR!

!testRun: #PlayableCharacterTest #test01_forwardWhenHeadingNorthIncrementsYCoordinate stamp: 'FG 12/17/2020 21:23:41'!
ERROR!

!testRun: #PlayableCharacterTest #test01_forwardWhenHeadingNorthIncrementsYCoordinate stamp: 'FG 12/17/2020 21:25:29'!
ERROR!

!testRun: #PlayableCharacterTest #test01_forwardWhenHeadingNorthIncrementsYCoordinate stamp: 'FG 12/17/2020 21:25:29'!
ERROR!

!testRun: #RoomTest #test01_WidthMustBeStrictlyPositive stamp: 'FG 12/17/2020 21:25:44'!
PASSED!

!testRun: #RoomTest #test02_HeightMustBeStrictlyPositive stamp: 'FG 12/17/2020 21:25:44'!
PASSED!

!testRun: #RoomTest #test03_WidthMustBeInteger stamp: 'FG 12/17/2020 21:25:44'!
PASSED!

!testRun: #RoomTest #test04_HeightMustBeInteger stamp: 'FG 12/17/2020 21:25:44'!
PASSED!

!testRun: #RoomTest #test05_CanNotPutAStageObjectWithXLessThanCero stamp: 'FG 12/17/2020 21:25:44'!
PASSED!

!testRun: #RoomTest #test06_CanNotPutAStageObjectWithXGreaterOrEqualToWidth stamp: 'FG 12/17/2020 21:25:44'!
PASSED!

!testRun: #RoomTest #test07_CanNotPutAStageObjectWithANonIntegerX stamp: 'FG 12/17/2020 21:25:44'!
PASSED!

!testRun: #RoomTest #test08_CanNotPutAStageObjectWithYLessThanCero stamp: 'FG 12/17/2020 21:25:44'!
PASSED!

!testRun: #RoomTest #test09_CanNotPutAStageObjectWithYGreaterOrEqualToHeight stamp: 'FG 12/17/2020 21:25:44'!
PASSED!

!testRun: #RoomTest #test10_CanNotPutAStageObjectWithANonIntegerY stamp: 'FG 12/17/2020 21:25:44'!
PASSED!

!testRun: #RoomTest #test11_StageObjectsAreKeept stamp: 'FG 12/17/2020 21:25:44'!
PASSED!

!testRun: #RoomTest #test12_canNotGetPositionOfNonPutObject stamp: 'FG 12/17/2020 21:25:44'!
PASSED!

----SNAPSHOT----(17 December 2020 21:31:32) CuisUniversity-4384.image priorSource: 17857260!

!classRemoval: #PointsPortableObject stamp: 'FG 12/17/2020 21:31:39'!
PortableObject subclass: #PointsPortableObject
	instanceVariableNames: 'points'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!

!classRemoval: #NoPointsPortableObject stamp: 'FG 12/17/2020 21:31:39'!
PortableObject subclass: #NoPointsPortableObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!

!classRemoval: #Keys stamp: 'FG 12/17/2020 21:31:39'!
PortableObject subclass: #Keys
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!

!classRemoval: #PortableObject stamp: 'FG 12/17/2020 21:31:39'!
StageObject subclass: #PortableObject
	instanceVariableNames: 'name weight'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!

!classRemoval: #NonPortableObject stamp: 'FG 12/17/2020 21:31:40'!
StageObject subclass: #NonPortableObject
	instanceVariableNames: 'name stageObjects'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!

!classRemoval: #StageObject stamp: 'FG 12/17/2020 21:31:40'!
Object subclass: #StageObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!

!classRemoval: #Room stamp: 'FG 12/17/2020 21:31:40'!
Object subclass: #Room
	instanceVariableNames: 'width height contents'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!

!classRemoval: #PlayableCharacterHeading stamp: 'FG 12/17/2020 21:31:41'!
Object subclass: #PlayableCharacterHeading
	instanceVariableNames: 'cardinalPoint forwardPoint rightHeading leftHeading'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!

!classRemoval: #PlayableCharacter stamp: 'FG 12/17/2020 21:31:41'!
Object subclass: #PlayableCharacter
	instanceVariableNames: 'heading backpack name room'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!

!classRemoval: #OpenDoor stamp: 'FG 12/17/2020 21:31:41'!
DoorState subclass: #OpenDoor
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!

!classRemoval: #ClosedDoor stamp: 'FG 12/17/2020 21:31:42'!
DoorState subclass: #ClosedDoor
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!

!classRemoval: #DoorState stamp: 'FG 12/17/2020 21:31:42'!
Object subclass: #DoorState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!

!classRemoval: #Door stamp: 'FG 12/17/2020 21:31:42'!
Object subclass: #Door
	instanceVariableNames: 'firstRoom secondRoom state key'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!

!classRemoval: #Backpack stamp: 'FG 12/17/2020 21:31:43'!
Object subclass: #Backpack
	instanceVariableNames: 'weightCapacity gamePointsCapacity container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!

!classRemoval: #RoomTest stamp: 'FG 12/17/2020 21:31:43'!
TestCase subclass: #RoomTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!

!classRemoval: #PlayableCharacterTest stamp: 'FG 12/17/2020 21:31:43'!
TestCase subclass: #PlayableCharacterTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!

!classRemoval: #DoorTest stamp: 'FG 12/17/2020 21:31:44'!
TestCase subclass: #DoorTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!

!classRemoval: #BackpackTest stamp: 'FG 12/17/2020 21:31:44'!
TestCase subclass: #BackpackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Recuperatorio-2doParcial'!

----End fileIn of C:\Users\FACU PC\Documents\Clases Virtuales\Cosas IS 1\Cuis University\ISW1-2020-2C-Recuperatorio-2doParcial.st----!

!testRun: #PlayableCharacterTest #test01_forwardWhenHeadingNorthIncrementsYCoordinate stamp: 'FG 12/17/2020 21:32:04'!
ERROR!

!testRun: #PlayableCharacterTest #test01_forwardWhenHeadingNorthIncrementsYCoordinate stamp: 'FG 12/17/2020 21:32:04'!
ERROR!

!testRun: #PlayableCharacterTest #test01_forwardWhenHeadingNorthIncrementsYCoordinate stamp: 'FG 12/17/2020 21:32:25'!
ERROR!

!testRun: #PlayableCharacterTest #test01_forwardWhenHeadingNorthIncrementsYCoordinate stamp: 'FG 12/17/2020 21:32:25'!
ERROR!

!testRun: #PlayableCharacterTest #test01_forwardWhenHeadingNorthIncrementsYCoordinate stamp: 'FG 12/17/2020 21:34:45'!
ERROR!
!PlayableCharacter methodsFor: 'moving' stamp: 'FG 12/17/2020 21:36:53' prior: 50921521!
moveTo: aNewPosition
	
	|newRoom|
	
	(((room isEmptyAt: aNewPosition) not) and:[(room at: aNewPosition) isKindOf: Door])
	ifTrue:[
		newRoom := 	(room at: aNewPosition) useFrom: room.
		room moveAt: self position to: newRoom at: (newRoom positionOf: (room at: aNewPosition) + heading forwardPoint).
	]
	ifFalse:[
		room moveFrom: self position to: aNewPosition.
	] ! !

!testRun: #PlayableCharacterTest #test01_forwardWhenHeadingNorthIncrementsYCoordinate stamp: 'FG 12/17/2020 21:36:57'!
PASSED!

!testRun: #PlayableCharacterTest #test21_playerShouldMoveFromRoomsWhenPassThroughADoor stamp: 'FG 12/17/2020 21:37:01'!
ERROR!

!testRun: #PlayableCharacterTest #test21_playerShouldMoveFromRoomsWhenPassThroughADoor stamp: 'FG 12/17/2020 21:37:01'!
ERROR!

(room isEmptyAt: aNewPosition)!
!PlayableCharacterTest methodsFor: 'defaults' stamp: 'FG 12/17/2020 21:39:24' prior: 50920927!
openedDoor

	| room anotherRoom door key |
	
	room := Room ofWidth: 10 andHeight: 10.
	anotherRoom := Room ofWidth: 10 andHeight: 10. 
		
	key := self correctKey.
	door := Door in: room at: 0@1 and: anotherRoom at: 0@1 thatOpensWith: key..
	door openWith: key.	
	
	^ door! !

!testRun: #PlayableCharacterTest #test21_playerShouldMoveFromRoomsWhenPassThroughADoor stamp: 'FG 12/17/2020 21:39:29'!
ERROR!

!testRun: #PlayableCharacterTest #test21_playerShouldMoveFromRoomsWhenPassThroughADoor stamp: 'FG 12/17/2020 21:39:29'!
ERROR!
!PlayableCharacterTest methodsFor: 'tests' stamp: 'FG 12/17/2020 21:41:26' prior: 50920898!
test21_playerShouldMoveFromRoomsWhenPassThroughADoor

	| room anotherRoom player key door|

	room := self defaultRoom.
	anotherRoom := self defaultRoom.
	
	key := self correctKey.
	door := Door in: room at: 0@1 and: anotherRoom at: 0@1 thatOpensWith: key..
	door openWith: key.	
	
	player := PlayableCharacter named: 'Luigi' using: self defaultBackpack at: 0@0 heading: #North in: room.
	
	player moveForward.
	
	self assert: (anotherRoom at: 0@2) equals: player. 
	! !

!testRun: #PlayableCharacterTest #test21_playerShouldMoveFromRoomsWhenPassThroughADoor stamp: 'FG 12/17/2020 21:41:28'!
ERROR!

!testRun: #PlayableCharacterTest #test21_playerShouldMoveFromRoomsWhenPassThroughADoor stamp: 'FG 12/17/2020 21:41:28'!
ERROR!

newRoom positionOf: (room at: aNewPosition) !
!PlayableCharacter methodsFor: 'moving' stamp: 'FG 12/17/2020 21:42:48' prior: 50922163!
moveTo: aNewPosition
	
	|newRoom|
	
	(((room isEmptyAt: aNewPosition) not) and:[(room at: aNewPosition) isKindOf: Door])
	ifTrue:[
		newRoom := 	(room at: aNewPosition) useFrom: room.
		room moveAt: self position to: newRoom at: ((newRoom positionOf: (room at: aNewPosition)) + heading forwardPoint).
	]
	ifFalse:[
		room moveFrom: self position to: aNewPosition.
	] ! !

!testRun: #PlayableCharacterTest #test21_playerShouldMoveFromRoomsWhenPassThroughADoor stamp: 'FG 12/17/2020 21:42:56'!
PASSED!
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 21:43:34' prior: 50920441!
test05DoorStartsClosed

	| room room2 door |
	
	room := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room at: 1@1 and: room2 at: 0@1 thatOpensWith: self correctKey.	
	
	self assert: door isClosed.! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 21:43:41' prior: 50922257!
test05DoorStartsClosed

	| room anotherRoom door |
	
	room := Room ofWidth: 10 andHeight: 10.
	anotherRoom := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room at: 1@1 and: anotherRoom at: 0@1 thatOpensWith: self correctKey.	
	
	self assert: door isClosed.! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 21:44:09' prior: 50920452!
test06CannotUseAClosedDoor

	| room room2 door |
	
	room := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room at: 1@1 and: room2 at: 0@1 thatOpensWith: self correctKey.	
	
	self 
		should: [ door useFrom: room]
		raise: Error - MessageNotUnderstood 
		withMessageText: (Door cannotUseClosedDoor).
	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 21:44:16' prior: 50922280!
test06CannotUseAClosedDoor

	| room anotherRoom door |
	
	room := Room ofWidth: 10 andHeight: 10.
	anotherRoom := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room at: 1@1 and: anotherRoom at: 0@1 thatOpensWith: self correctKey.	
	
	self 
		should: [ door useFrom: room]
		raise: Error - MessageNotUnderstood 
		withMessageText: (Door cannotUseClosedDoor).
	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 21:44:44' prior: 50922294!
test06CannotUseAClosedDoor

	| room anotherRoom door |
	
	room := Room ofWidth: 10 andHeight: 10.
	anotherRoom := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room at: 1@1 and: anotherRoom at: 0@1 thatOpensWith: self correctKey.	
	
	self 
		shouldDo: [ door useFrom: room] 
		failingAndRaising: (Door cannotUseClosedDoor).
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 21:45:47' prior: 50920466!
test07CannotOpenDoorWithWrongKey

	| room anotherRoom door |

	room := Room ofWidth: 10 andHeight: 10.
	anotherRoom := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room at: 1@1 and: anotherRoom at: 0@1 thatOpensWith: self correctKey.	
	
	self 
		shouldDo:  [ door openWith: self wrongKey ]
		failingAndRaising: (Door cannotOpenWithWrongKey).
	
	

	

	

	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 21:46:36' prior: 50920481!
test08DoorOpensWithTheCorrectKey

	| room room2 door key |

	room := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 

	key := self correctKey.	
			
	door := Door in: room at: 1@1 and: room2 at: 0@1 thatOpensWith: key.	
	
	door openWith: key.
	
	self deny: door isClosed.	

	

	

	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 21:47:09' prior: 50922338!
test08DoorOpensWithTheCorrectKey

	| door |

	door := self openedDoor.
	self deny: door isClosed.	

	

	

	
	! !

!testRun: #DoorTest #test08DoorOpensWithTheCorrectKey stamp: 'FG 12/17/2020 21:47:14'!
PASSED!
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 21:47:45' prior: 50920494!
test09CannotOpenAnAlreadyOpenDoor

	| room1 room2 door key |

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 

	key := self correctKey.	
			
	door := Door in: room1 at: 1@1 and: room2 at: 0@1 thatOpensWith: key.	
	
	door openWith: key.
	
	self 
		should: [ door openWith: key ]
		raise: Error - MessageNotUnderstood 
		withMessageText: (Door doorAlreadyOpen).

	

	

	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 21:48:00' prior: 50922361!
test09CannotOpenAnAlreadyOpenDoor

	| room room2 door key |

	room := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 

	key := self correctKey.	
			
	door := Door in: room at: 1@1 and: room2 at: 0@1 thatOpensWith: key.	
	
	door openWith: key.
	
	self 
		should: [ door openWith: key ]
		raise: Error - MessageNotUnderstood 
		withMessageText: (Door doorAlreadyOpen).

	

	

	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 21:48:06' prior: 50922377!
test09CannotOpenAnAlreadyOpenDoor

	| room anotherRooom door key |

	room := Room ofWidth: 10 andHeight: 10.
	anotherRooom := Room ofWidth: 10 andHeight: 10. 

	key := self correctKey.	
			
	door := Door in: room at: 1@1 and: anotherRooom at: 0@1 thatOpensWith: key.	
	
	door openWith: key.
	
	self 
		should: [ door openWith: key ]
		raise: Error - MessageNotUnderstood 
		withMessageText: (Door doorAlreadyOpen).

	

	

	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 21:48:29' prior: 50922393!
test09CannotOpenAnAlreadyOpenDoor

	| room anotherRooom door key |

	room := Room ofWidth: 10 andHeight: 10.
	anotherRooom := Room ofWidth: 10 andHeight: 10. 

	key := self correctKey.	
			
	door := Door in: room at: 1@1 and: anotherRooom at: 0@1 thatOpensWith: key.	
	
	door openWith: key.
	
	self 
		shouldDo:  [ door openWith: key ] 
		failingAndRaising: (Door doorAlreadyOpen).

	

	

	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 21:48:39' prior: 50920510!
test10ADoorCannotBeLockedWithAnyObjectThatIsNotAKey

	| room room2 |

	room := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 	
		
	self 
		should: [ Door in: room at: 1@1  and: room2  at: 1@1  thatOpensWith: self paper ]
		raise: Error - MessageNotUnderstood 
		withMessageText: (Door cannotBeLockedWithANonKeyObject).

	
	

	

	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 21:48:45' prior: 50922426!
test10ADoorCannotBeLockedWithAnyObjectThatIsNotAKey

	| room anotherRoom |

	room := Room ofWidth: 10 andHeight: 10.
	anotherRoom := Room ofWidth: 10 andHeight: 10. 	
		
	self 
		should: [ Door in: room at: 1@1  and: anotherRoom  at: 1@1  thatOpensWith: self paper ]
		raise: Error - MessageNotUnderstood 
		withMessageText: (Door cannotBeLockedWithANonKeyObject).

	
	

	

	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 21:49:10' prior: 50922441!
test10ADoorCannotBeLockedWithAnyObjectThatIsNotAKey

	| room anotherRoom |

	room := Room ofWidth: 10 andHeight: 10.
	anotherRoom := Room ofWidth: 10 andHeight: 10. 	
	
	self 
		shouldDo:  [ Door in: room at: 1@1  and: anotherRoom  at: 1@1  thatOpensWith: self paper ]
		failingAndRaising: (Door cannotBeLockedWithANonKeyObject).


	
	

	

	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 21:49:32' prior: 50920524!
test11CannotCloseDoorWithANonKeyObject

	| room room2 door key|

	room := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 	
		
	key := self correctKey.	
	door := Door in: room at: 1@1  and: room2  at: 1@1  thatOpensWith: key.
	door openWith:	 key.
		
	self 
		should: [ door closeWith: self paper ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Door cannotBeLockedWithANonKeyObject.

	
	

	

	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 21:49:38' prior: 50922470!
test11CannotCloseDoorWithANonKeyObject

	| room anotherRoom door key|

	room := Room ofWidth: 10 andHeight: 10.
	anotherRoom := Room ofWidth: 10 andHeight: 10. 	
		
	key := self correctKey.	
	door := Door in: room at: 1@1  and: anotherRoom  at: 1@1  thatOpensWith: key.
	door openWith:	 key.
		
	self 
		should: [ door closeWith: self paper ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Door cannotBeLockedWithANonKeyObject.

	
	

	

	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 21:50:03' prior: 50922487!
test11CannotCloseDoorWithANonKeyObject

	| room anotherRoom door key|

	room := Room ofWidth: 10 andHeight: 10.
	anotherRoom := Room ofWidth: 10 andHeight: 10. 	
		
	key := self correctKey.	
	door := Door in: room at: 1@1  and: anotherRoom  at: 1@1  thatOpensWith: key.
	door openWith:	 key.
		
	self 
		shouldDo: [ door closeWith: self paper ] 
		failingAndRaising: 	 Door cannotBeLockedWithANonKeyObject.


	
	

	

	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 21:50:35' prior: 50920541!
test12CannotCloseAClosedDoor

	| room1 room2 door key|

	room1 := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 	
		
	key := self correctKey.	
	door := Door in: room1 at: 1@1  and: room2  at: 1@1  thatOpensWith: key.
		
	self 
		shouldDo:  [ door closeWith: self correctKey ]
		failingAndRaising: 	Door doorAlreadyClosed.
	
	

	

	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 21:50:40' prior: 50922522!
test12CannotCloseAClosedDoor

	| room room2 door key|

	room := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 	
		
	key := self correctKey.	
	door := Door in: room at: 1@1  and: room2  at: 1@1  thatOpensWith: key.
		
	self 
		shouldDo:  [ door closeWith: self correctKey ]
		failingAndRaising: 	Door doorAlreadyClosed.
	
	

	

	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 21:50:46' prior: 50922537!
test12CannotCloseAClosedDoor

	| room anotherRoom door key|

	room := Room ofWidth: 10 andHeight: 10.
	anotherRoom := Room ofWidth: 10 andHeight: 10. 	
		
	key := self correctKey.	
	door := Door in: room at: 1@1  and: anotherRoom  at: 1@1  thatOpensWith: key.
		
	self 
		shouldDo:  [ door closeWith: self correctKey ]
		failingAndRaising: 	Door doorAlreadyClosed.
	
	

	

	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 21:50:53' prior: 50920556!
test13DoorCanBeClosedWithAKey

	| room room2 door key newKey|

	room := Room ofWidth: 10 andHeight: 10.
	room2 := Room ofWidth: 10 andHeight: 10. 	
		
	key := self correctKey.	
	door := Door in: room at: 1@1  and: room2  at: 1@1  thatOpensWith: key.
	door openWith: key.

	newKey := self wrongKey.
	door closeWith: newKey.
	
	self assert: door isClosed.
	
	door openWith: newKey.
	
	self deny: door isClosed	.
	
		
	

	

	
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 21:51:00' prior: 50922567!
test13DoorCanBeClosedWithAKey

	| room anotherRoom door key newKey|

	room := Room ofWidth: 10 andHeight: 10.
	anotherRoom := Room ofWidth: 10 andHeight: 10. 	
		
	key := self correctKey.	
	door := Door in: room at: 1@1  and: anotherRoom  at: 1@1  thatOpensWith: key.
	door openWith: key.

	newKey := self wrongKey.
	door closeWith: newKey.
	
	self assert: door isClosed.
	
	door openWith: newKey.
	
	self deny: door isClosed	.
	
		
	

	

	
	! !
!Door methodsFor: 'use' stamp: 'FG 12/17/2020 21:52:03'!
otherSideFrom: aRoom 

	^ state useDoor: self from: aRoom.! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 21:52:03' prior: 50920415!
test03DoorLeadFromOneRoomToTheOther

	| room anotherRoom door key |
	
	room := Room ofWidth: 10 andHeight: 10.
	anotherRoom := Room ofWidth: 10 andHeight: 10. 
		
	key := self correctKey.
	door := Door in: room at: 1@1 and: anotherRoom at: 0@1 thatOpensWith: key.
	door openWith: key.	
	
	self assert: (door otherSideFrom: room) equals: anotherRoom.
	self assert: (door otherSideFrom: anotherRoom) equals: room. ! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 21:52:03' prior: 50922309!
test06CannotUseAClosedDoor

	| room anotherRoom door |
	
	room := Room ofWidth: 10 andHeight: 10.
	anotherRoom := Room ofWidth: 10 andHeight: 10. 
		
	door := Door in: room at: 1@1 and: anotherRoom at: 0@1 thatOpensWith: self correctKey.	
	
	self 
		shouldDo: [ door otherSideFrom: room] 
		failingAndRaising: (Door cannotUseClosedDoor).
	! !
!DoorTest methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 21:52:03' prior: 50920431!
test04CannotMoveFromARoomWhichDoesntHasTheDoor

	| room door |
	
	room := Room ofWidth: 10 andHeight: 10.
	
	door := self openedDoor.
	
	self 
		shouldDo: [ door otherSideFrom: room] 
		failingAndRaising: Door cannotMoveFromARoomWithoutThisDoor
! !
!PlayableCharacter methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 21:52:03' prior: 50922238!
moveTo: aNewPosition
	
	|newRoom|
	
	(((room isEmptyAt: aNewPosition) not) and:[(room at: aNewPosition) isKindOf: Door])
	ifTrue:[
		newRoom := 	(room at: aNewPosition) otherSideFrom: room.
		room moveAt: self position to: newRoom at: ((newRoom positionOf: (room at: aNewPosition)) + heading forwardPoint).
	]
	ifFalse:[
		room moveFrom: self position to: aNewPosition.
	] ! !

!methodRemoval: Door #useFrom: stamp: 'FG 12/17/2020 21:52:04'!
useFrom: aRoom 

	^ state useDoor: self from: aRoom.!
!Door methodsFor: 'use - private' stamp: 'FG 12/17/2020 21:52:24'!
otherSideOfClosedDoor

	self error: Door cannotUseClosedDoor .! !
!ClosedDoor methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 21:52:24' prior: 50921436 overrides: 50921403!
useDoor: aDoor from: aRoom

	aDoor otherSideOfClosedDoor.! !

!methodRemoval: Door #useClosedDoor stamp: 'FG 12/17/2020 21:52:24'!
useClosedDoor

	self error: Door cannotUseClosedDoor .!
!Door methodsFor: 'use - private' stamp: 'FG 12/17/2020 21:52:54'!
otherSideOfOpenDoorFrom: aRoom 

	(aRoom = firstRoom) ifTrue: [^ secondRoom].
	(aRoom = secondRoom) ifTrue: [^ firstRoom].
	self error: Door cannotMoveFromARoomWithoutThisDoor.! !
!OpenDoor methodsFor: 'as yet unclassified' stamp: 'FG 12/17/2020 21:52:54' prior: 50921469 overrides: 50921403!
useDoor: aDoor from: aRoom
	^ aDoor otherSideOfOpenDoorFrom: aRoom. ! !

!methodRemoval: Door #useOpenDoorFrom: stamp: 'FG 12/17/2020 21:52:54'!
useOpenDoorFrom: aRoom 

	(aRoom = firstRoom) ifTrue: [^ secondRoom].
	(aRoom = secondRoom) ifTrue: [^ firstRoom].
	self error: Door cannotMoveFromARoomWithoutThisDoor.!

!testRun: #DoorTest #test01DoorShouldBeInDifferentRooms stamp: 'FG 12/17/2020 21:53:17'!
PASSED!

!testRun: #DoorTest #test02DoorIsInBothRooms stamp: 'FG 12/17/2020 21:53:17'!
PASSED!

!testRun: #DoorTest #test03DoorLeadFromOneRoomToTheOther stamp: 'FG 12/17/2020 21:53:17'!
PASSED!

!testRun: #DoorTest #test04CannotMoveFromARoomWhichDoesntHasTheDoor stamp: 'FG 12/17/2020 21:53:17'!
PASSED!

!testRun: #DoorTest #test05DoorStartsClosed stamp: 'FG 12/17/2020 21:53:17'!
PASSED!

!testRun: #DoorTest #test06CannotUseAClosedDoor stamp: 'FG 12/17/2020 21:53:17'!
PASSED!

!testRun: #DoorTest #test07CannotOpenDoorWithWrongKey stamp: 'FG 12/17/2020 21:53:17'!
PASSED!

!testRun: #DoorTest #test08DoorOpensWithTheCorrectKey stamp: 'FG 12/17/2020 21:53:17'!
PASSED!

!testRun: #DoorTest #test09CannotOpenAnAlreadyOpenDoor stamp: 'FG 12/17/2020 21:53:17'!
PASSED!

!testRun: #DoorTest #test10ADoorCannotBeLockedWithAnyObjectThatIsNotAKey stamp: 'FG 12/17/2020 21:53:17'!
PASSED!

!testRun: #DoorTest #test11CannotCloseDoorWithANonKeyObject stamp: 'FG 12/17/2020 21:53:17'!
PASSED!

!testRun: #DoorTest #test12CannotCloseAClosedDoor stamp: 'FG 12/17/2020 21:53:17'!
PASSED!

!testRun: #DoorTest #test13DoorCanBeClosedWithAKey stamp: 'FG 12/17/2020 21:53:17'!
PASSED!

----QUIT----(17 December 2020 21:53:29) CuisUniversity-4384.image priorSource: 18827113!