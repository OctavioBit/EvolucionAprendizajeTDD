----End fileIn of /home/cmarta/Workspace/FCEyN/IS1/docentes/20-TusLibros/Iteracion1/TusLibros-18.st----!

TestCase subclass: #CashierTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classDefinition: #CashierTest category: 'TusLibros' stamp: 'CM 11/25/2020 18:38:28'!
TestCase subclass: #CashierTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classDefinition: #Cashier category: 'TusLibros' stamp: 'CM 11/25/2020 18:39:57'!
Object subclass: #Cashier
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!CashierTest methodsFor: 'no messages' stamp: 'CM 11/25/2020 18:39:49'!
test01CanNotCheckoutAnEmptyCart
	
	| cart creditCard cashier |
	
	cart := self createCart.
	creditCard := self createValidCreditCard.

	cashier := Cashier new.
	
	self should: [
			cashier checkout: cart chargingOn: creditCard
		]  raise: Error withMessageText: Cashier cartCannotBeEmptyErrorDescription.
	! !
!CashierTest methodsFor: 'support' stamp: 'CM 11/25/2020 18:40:23'!
createCart
	
	^Cart acceptingItemsOf: self defaultCatalog! !

!methodRemoval: CashierTest #createCart stamp: 'CM 11/25/2020 18:40:35'!
createCart
	
	^Cart acceptingItemsOf: self defaultCatalog!
!CashierTest methodsFor: 'support' stamp: 'CM 11/25/2020 18:41:12'!
createCart
	
	^Cart acceptingItemsOf: self defaultCatalog! !
!CashierTest methodsFor: 'support' stamp: 'CM 11/25/2020 18:41:20'!
defaultCatalog
	
	^ Array with: self itemSellByTheStore! !
!CashierTest methodsFor: 'support' stamp: 'CM 11/25/2020 18:41:27'!
itemNotSellByTheStore
	
	^'invalidBook'! !
!CashierTest methodsFor: 'support' stamp: 'CM 11/25/2020 18:41:35'!
itemSellByTheStore
	
	^ 'validBook'! !

!methodRemoval: CashierTest #itemNotSellByTheStore stamp: 'CM 11/25/2020 18:41:38'!
itemNotSellByTheStore
	
	^'invalidBook'!
!CashierTest methodsFor: 'support' stamp: 'CM 11/25/2020 18:41:54'!
createValidCreditCard
	
	^''! !
!Cashier methodsFor: 'no messages' stamp: 'CM 11/25/2020 18:43:31'!
checkout: aCart chargingOn: aTarjeta

	aCart isEmpty ifTrue: [ self error: self class cartCannotBeEmptyErrorDescription. ]
	
	
	! !
!Cashier class methodsFor: 'error messages' stamp: 'CM 11/25/2020 18:44:13'!
cartCannotBeEmptyErrorDescription

	^ 'Can not checkout an empty cart'.! !

!testRun: #CashierTest #test01CanNotCheckoutAnEmptyCart stamp: 'CM 11/25/2020 18:44:19'!
PASSED!
!CashierTest methodsFor: 'tests' stamp: 'CM 11/25/2020 18:45:59'!
test02AmountChargedCorrelatesToCartTotalPrice
	
	| cart cashier receiptAmount creditCard |
	
	cart := self createCart.
	cart add: 2 of: self itemSellByTheStore.
	creditCard := self createValidCreditCard.
	
	cashier := Cashier new.
	
	receiptAmount := cashier checkout: cart chargingOn: creditCard.
	
	self assert: receiptAmount equals: self itemSellByTheStorePrice * 2.
	
	
		! !
!CashierTest methodsFor: 'support' stamp: 'CM 11/25/2020 18:47:41'!
itemSellByTheStorePrice

	^ 3.! !
!Cashier methodsFor: 'as yet unclassified' stamp: 'CM 11/25/2020 18:48:27' prior: 50868018!
checkout: aCart chargingOn: aTarjeta

	| totalToDebit |
	aCart isEmpty ifTrue: [ self error: self class cartCannotBeEmptyErrorDescription ].
	
	totalToDebit := aCart totalProductsPrice.
	
	^ totalToDebit.
	
	
	! !
!Cashier methodsFor: 'as yet unclassified' stamp: 'CM 11/25/2020 18:48:36' prior: 50868051!
checkout: aCart chargingOn: aTarjeta

	| totalToDebit |
	
	aCart isEmpty ifTrue: [ self error: self class cartCannotBeEmptyErrorDescription ].
	
	totalToDebit := aCart totalProductsPrice.
	
	^ totalToDebit.
	
	
	! !
!CartTest methodsFor: 'tests' stamp: 'CM 11/25/2020 18:49:22'!
test09EmptyCartIsFreeFromCharge

	| cart |
	
	cart := self createCart.
	
	self assert: cart totalProductsPrice equals: 0! !
!Cart methodsFor: 'queries' stamp: 'CM 11/25/2020 18:49:51'!
totalProductsPrice

	^ 0.! !

!testRun: #CartTest #test01NewCartsAreCreatedEmpty stamp: 'CM 11/25/2020 18:49:53'!
PASSED!

!testRun: #CartTest #test02CanNotAddItemsThatDoNotBelongToStore stamp: 'CM 11/25/2020 18:49:53'!
PASSED!

!testRun: #CartTest #test03AfterAddingAnItemTheCartIsNotEmptyAnymore stamp: 'CM 11/25/2020 18:49:53'!
PASSED!

!testRun: #CartTest #test04CanNotAddNonPositiveNumberOfItems stamp: 'CM 11/25/2020 18:49:53'!
PASSED!

!testRun: #CartTest #test05CanNotAddMoreThanOneItemNotSellByTheStore stamp: 'CM 11/25/2020 18:49:53'!
PASSED!

!testRun: #CartTest #test06CartRemembersAddedItems stamp: 'CM 11/25/2020 18:49:53'!
PASSED!

!testRun: #CartTest #test07CartDoesNotHoldNotAddedItems stamp: 'CM 11/25/2020 18:49:53'!
PASSED!

!testRun: #CartTest #test08CartRemembersTheNumberOfAddedItems stamp: 'CM 11/25/2020 18:49:53'!
PASSED!

!testRun: #CartTest #test09EmptyCartIsFreeFromCharge stamp: 'CM 11/25/2020 18:49:53'!
PASSED!
!CartTest methodsFor: 'tests' stamp: 'CM 11/25/2020 18:50:23'!
test10AfterAddingAnItemTheCartTotalPriceIsUpdatedByItsValue

	| cart |
	
	cart := self createCart.
	cart add: self itemSellByTheStore.
	
	self assert: cart totalProductsPrice equals: self itemSellByTheStorePrice.! !
!CartTest methodsFor: 'support' stamp: 'CM 11/25/2020 18:50:37'!
itemSellByTheStorePrice
	
	^ 3.! !

!testRun: #CartTest #test01NewCartsAreCreatedEmpty stamp: 'CM 11/25/2020 18:50:40'!
PASSED!

!testRun: #CartTest #test02CanNotAddItemsThatDoNotBelongToStore stamp: 'CM 11/25/2020 18:50:40'!
PASSED!

!testRun: #CartTest #test03AfterAddingAnItemTheCartIsNotEmptyAnymore stamp: 'CM 11/25/2020 18:50:40'!
PASSED!

!testRun: #CartTest #test04CanNotAddNonPositiveNumberOfItems stamp: 'CM 11/25/2020 18:50:40'!
PASSED!

!testRun: #CartTest #test05CanNotAddMoreThanOneItemNotSellByTheStore stamp: 'CM 11/25/2020 18:50:40'!
PASSED!

!testRun: #CartTest #test06CartRemembersAddedItems stamp: 'CM 11/25/2020 18:50:40'!
PASSED!

!testRun: #CartTest #test07CartDoesNotHoldNotAddedItems stamp: 'CM 11/25/2020 18:50:40'!
PASSED!

!testRun: #CartTest #test08CartRemembersTheNumberOfAddedItems stamp: 'CM 11/25/2020 18:50:40'!
PASSED!

!testRun: #CartTest #test09EmptyCartIsFreeFromCharge stamp: 'CM 11/25/2020 18:50:40'!
PASSED!

!testRun: #CartTest #test10AfterAddingAnItemTheCartTotalPriceIsUpdatedByItsValue stamp: 'CM 11/25/2020 18:50:40'!
FAILURE!

!testRun: #CartTest #test10AfterAddingAnItemTheCartTotalPriceIsUpdatedByItsValue stamp: 'CM 11/25/2020 18:50:40'!
FAILURE!
!Cart methodsFor: 'queries' stamp: 'CM 11/25/2020 18:51:19' prior: 50868076!
totalProductsPrice

	^ items sum: [ :item | catalog at: item ] ifEmpty: [ 0 ].! !
!CartTest methodsFor: 'support' stamp: 'CM 11/25/2020 18:51:52' prior: 50867942!
defaultCatalog
		
	| catalog |
	
	catalog := Dictionary new.
	catalog add: self itemSellByTheStore -> self itemSellByTheStorePrice.
	
	^ catalog.
	! !

!testRun: #CartTest #test01NewCartsAreCreatedEmpty stamp: 'CM 11/25/2020 18:52:20'!
PASSED!

!testRun: #CartTest #test02CanNotAddItemsThatDoNotBelongToStore stamp: 'CM 11/25/2020 18:52:20'!
PASSED!

!testRun: #CartTest #test03AfterAddingAnItemTheCartIsNotEmptyAnymore stamp: 'CM 11/25/2020 18:52:20'!
ERROR!

!testRun: #CartTest #test04CanNotAddNonPositiveNumberOfItems stamp: 'CM 11/25/2020 18:52:20'!
PASSED!

!testRun: #CartTest #test05CanNotAddMoreThanOneItemNotSellByTheStore stamp: 'CM 11/25/2020 18:52:20'!
PASSED!

!testRun: #CartTest #test06CartRemembersAddedItems stamp: 'CM 11/25/2020 18:52:20'!
ERROR!

!testRun: #CartTest #test07CartDoesNotHoldNotAddedItems stamp: 'CM 11/25/2020 18:52:20'!
PASSED!

!testRun: #CartTest #test08CartRemembersTheNumberOfAddedItems stamp: 'CM 11/25/2020 18:52:20'!
ERROR!

!testRun: #CartTest #test09EmptyCartIsFreeFromCharge stamp: 'CM 11/25/2020 18:52:20'!
PASSED!

!testRun: #CartTest #test10AfterAddingAnItemTheCartTotalPriceIsUpdatedByItsValue stamp: 'CM 11/25/2020 18:52:20'!
ERROR!
!Cart methodsFor: 'assertions' stamp: 'CM 11/25/2020 18:52:45' prior: 50867790!
assertIsValidItem: anItem

	(catalog includesKey: anItem) ifFalse: [ self error: self invalidItemErrorMessage ]! !

!testRun: #CartTest #test01NewCartsAreCreatedEmpty stamp: 'CM 11/25/2020 18:52:48'!
PASSED!

!testRun: #CartTest #test02CanNotAddItemsThatDoNotBelongToStore stamp: 'CM 11/25/2020 18:52:48'!
PASSED!

!testRun: #CartTest #test03AfterAddingAnItemTheCartIsNotEmptyAnymore stamp: 'CM 11/25/2020 18:52:48'!
PASSED!

!testRun: #CartTest #test04CanNotAddNonPositiveNumberOfItems stamp: 'CM 11/25/2020 18:52:48'!
PASSED!

!testRun: #CartTest #test05CanNotAddMoreThanOneItemNotSellByTheStore stamp: 'CM 11/25/2020 18:52:48'!
PASSED!

!testRun: #CartTest #test06CartRemembersAddedItems stamp: 'CM 11/25/2020 18:52:48'!
PASSED!

!testRun: #CartTest #test07CartDoesNotHoldNotAddedItems stamp: 'CM 11/25/2020 18:52:48'!
PASSED!

!testRun: #CartTest #test08CartRemembersTheNumberOfAddedItems stamp: 'CM 11/25/2020 18:52:48'!
PASSED!

!testRun: #CartTest #test09EmptyCartIsFreeFromCharge stamp: 'CM 11/25/2020 18:52:48'!
PASSED!

!testRun: #CartTest #test10AfterAddingAnItemTheCartTotalPriceIsUpdatedByItsValue stamp: 'CM 11/25/2020 18:52:48'!
PASSED!

!testRun: #CashierTest #test01CanNotCheckoutAnEmptyCart stamp: 'CM 11/25/2020 18:52:51'!
PASSED!

!testRun: #CashierTest #test02AmountChargedCorrelatesToCartTotalPrice stamp: 'CM 11/25/2020 18:52:51'!
ERROR!

!testRun: #CashierTest #test02AmountChargedCorrelatesToCartTotalPrice stamp: 'CM 11/25/2020 18:52:51'!
ERROR!
!CashierTest methodsFor: 'support' stamp: 'CM 11/25/2020 18:53:02' prior: 50867998!
defaultCatalog
		
	| catalog |
	
	catalog := Dictionary new.
	catalog add: self itemSellByTheStore -> self itemSellByTheStorePrice.
	
	^ catalog.
	! !

!testRun: #CashierTest #test01CanNotCheckoutAnEmptyCart stamp: 'CM 11/25/2020 18:53:05'!
PASSED!

!testRun: #CashierTest #test02AmountChargedCorrelatesToCartTotalPrice stamp: 'CM 11/25/2020 18:53:05'!
PASSED!
!CashierTest methodsFor: 'tests' stamp: 'CM 11/25/2020 18:53:56'!
test03CanNotChargeOnAnExpiredCreditCard
	
	| cart cashier expiredCreditCard |
	
	cart := self createCart.
	cart add: self itemSellByTheStore.
	expiredCreditCard := self createExpiredCreditCard.
	
	cashier := Cashier new.
	
	self should: [
			cashier checkout: cart chargingOn: expiredCreditCard.
		] raise: Error withMessageText: Cashier cannotChargeOnAnExpiredCreditCardErrorDescription .
	! !
!Cashier class methodsFor: 'error messages' stamp: 'CM 11/25/2020 18:54:49'!
cannotChargeOnAnExpiredCreditCardErrorDescription

	^ 'Can not charge on an expired credit card'.! !
!Cashier methodsFor: 'as yet unclassified' stamp: 'CM 11/25/2020 18:55:46' prior: 50868061!
checkout: aCart chargingOn: aTarjeta

	| totalToDebit |
	
	aCart isEmpty ifTrue: [ self error: self class cartCannotBeEmptyErrorDescription ].
	(aTarjeta isExpired) ifTrue: [ self error: self class cannotChargeOnAnExpiredCreditCardErrorDescription ].
	
	totalToDebit := aCart totalProductsPrice.
	
	^ totalToDebit.
	
	
	! !

!testRun: #CashierTest #test01CanNotCheckoutAnEmptyCart stamp: 'CM 11/25/2020 18:55:53'!
PASSED!

!testRun: #CashierTest #test02AmountChargedCorrelatesToCartTotalPrice stamp: 'CM 11/25/2020 18:55:53'!
ERROR!

!testRun: #CashierTest #test03CanNotChargeOnAnExpiredCreditCard stamp: 'CM 11/25/2020 18:55:53'!
ERROR!

!testRun: #CashierTest #test02AmountChargedCorrelatesToCartTotalPrice stamp: 'CM 11/25/2020 18:55:59'!
ERROR!

!testRun: #CashierTest #test02AmountChargedCorrelatesToCartTotalPrice stamp: 'CM 11/25/2020 18:56:02'!
ERROR!
!CashierTest methodsFor: 'support' stamp: 'CM 11/25/2020 18:56:25'!
createExpiredCreditCard
	
	^ ''! !

!classDefinition: #CreditCard category: 'TusLibros' stamp: 'CM 11/25/2020 18:56:58'!
Object subclass: #CreditCard
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!CashierTest methodsFor: 'support' stamp: 'CM 11/25/2020 18:56:54' prior: 50868014!
createValidCreditCard
	
	^ CreditCard expiringOn: Date today month.! !
!CashierTest methodsFor: 'support' stamp: 'CM 11/25/2020 18:57:15' prior: 50868317!
createExpiredCreditCard
	
	^ CreditCard expiringOn: Date today month previous.! !
!CreditCard class methodsFor: 'class initialization' stamp: 'CM 11/25/2020 18:57:56'!
expiringOn: aMonth
	
	^ self new initializeExpiringOn: aMonth.! !

!classDefinition: #CreditCard category: 'TusLibros' stamp: 'CM 11/25/2020 18:58:16'!
Object subclass: #CreditCard
	instanceVariableNames: 'expirationDate'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!CreditCard methodsFor: 'no messages' stamp: 'CM 11/25/2020 18:58:14'!
initializeExpiringOn: aMonth

	expirationDate := aMonth.! !

TestCase subclass: #CreditCardTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classDefinition: #CreditCardTest category: 'TusLibros' stamp: 'CM 11/25/2020 18:58:26'!
TestCase subclass: #CreditCardTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!CreditCardTest methodsFor: 'no messages' stamp: 'CM 11/25/2020 18:59:06'!
test01CreditCardIsExpiredWhenExpirationDateIsPassed

	| creditCard |
	
	creditCard := self createExpiredCreditCard.
	
	self assert: creditCard isExpired.! !
!CreditCardTest methodsFor: 'support' stamp: 'CM 11/25/2020 18:59:34'!
createExpiredCreditCard
	
	^ CreditCard expiringOn: Date today month previous.! !
!CreditCardTest methodsFor: 'support' stamp: 'CM 11/25/2020 18:59:56'!
createValidCreditCard
	
	^ CreditCard expiringOn: Date today month.! !
!CreditCard methodsFor: 'testing' stamp: 'CM 11/25/2020 19:00:50'!
isExpired
	
	^ true.! !

!testRun: #CreditCardTest #test01CreditCardIsExpiredWhenExpirationDateIsPassed stamp: 'CM 11/25/2020 19:01:07'!
PASSED!
!CreditCardTest methodsFor: 'tests' stamp: 'CM 11/25/2020 19:01:48'!
test02CreditCardIsValidWhenExpirationDateHasNotYetArrived

	| creditCard |
	
	creditCard := self createValidCreditCard.
	
	self deny: creditCard isExpired.! !

!testRun: #CreditCardTest #test01CreditCardIsExpiredWhenExpirationDateIsPassed stamp: 'CM 11/25/2020 19:01:59'!
PASSED!

!testRun: #CreditCardTest #test02CreditCardIsValidWhenExpirationDateHasNotYetArrived stamp: 'CM 11/25/2020 19:01:59'!
FAILURE!

!testRun: #CreditCardTest #test02CreditCardIsValidWhenExpirationDateHasNotYetArrived stamp: 'CM 11/25/2020 19:01:59'!
FAILURE!
!CreditCard methodsFor: 'testing' stamp: 'CM 11/25/2020 19:02:30' prior: 50868385!
isExpired
	
	^ Date today start > expirationDate start.! !

!testRun: #CreditCardTest #test01CreditCardIsExpiredWhenExpirationDateIsPassed stamp: 'CM 11/25/2020 19:02:34'!
PASSED!

!testRun: #CreditCardTest #test02CreditCardIsValidWhenExpirationDateHasNotYetArrived stamp: 'CM 11/25/2020 19:02:34'!
FAILURE!

!testRun: #CreditCardTest #test02CreditCardIsValidWhenExpirationDateHasNotYetArrived stamp: 'CM 11/25/2020 19:02:34'!
FAILURE!
!CreditCard methodsFor: 'testing' stamp: 'CM 11/25/2020 19:02:40' prior: 50868412!
isExpired
	
	^ Date today start > expirationDate end.! !

!testRun: #CreditCardTest #test01CreditCardIsExpiredWhenExpirationDateIsPassed stamp: 'CM 11/25/2020 19:02:43'!
PASSED!

!testRun: #CreditCardTest #test02CreditCardIsValidWhenExpirationDateHasNotYetArrived stamp: 'CM 11/25/2020 19:02:43'!
PASSED!
!CreditCard methodsFor: 'testing' stamp: 'CM 11/25/2020 19:03:16'!
isExpiredBy: aDate
	
	^ aDate start > expirationDate end.! !
!CreditCard methodsFor: 'testing' stamp: 'CM 11/25/2020 19:03:29' prior: 50868429!
isExpired
	
	^ self isExpiredBy: Date today.! !

!testRun: #CreditCardTest #test01CreditCardIsExpiredWhenExpirationDateIsPassed stamp: 'CM 11/25/2020 19:03:31'!
PASSED!

!testRun: #CreditCardTest #test02CreditCardIsValidWhenExpirationDateHasNotYetArrived stamp: 'CM 11/25/2020 19:03:31'!
PASSED!

!testRun: #CashierTest #test01CanNotCheckoutAnEmptyCart stamp: 'CM 11/25/2020 19:03:34'!
PASSED!

!testRun: #CashierTest #test02AmountChargedCorrelatesToCartTotalPrice stamp: 'CM 11/25/2020 19:03:34'!
PASSED!

!testRun: #CashierTest #test03CanNotChargeOnAnExpiredCreditCard stamp: 'CM 11/25/2020 19:03:34'!
PASSED!
!CashierTest methodsFor: 'tests' stamp: 'CM 11/25/2020 19:09:18'!
test04SuccessfulCheckoutRegistersSaleOnSalesBook
	
	| cart cashier receiptAmount salesBook creditCard merchantProcessor |
	
	cart := self createCart.
	cart add: self itemSellByTheStore.
	creditCard := self createValidCreditCard.
	merchantProcessor := self createMerchantProcessorDouble.
	salesBook := self createSalesBook.

	cashier := Cashier billingOn: merchantProcessor 
				      registeringSalesOn: salesBook.

	receiptAmount := cashier checkout: cart chargingOn: creditCard.
	
	self assert: salesBook size equals: 1.
	self assert: salesBook first equals: receiptAmount.
! !
!CashierTest methodsFor: 'support' stamp: 'CM 11/25/2020 19:09:40'!
createSalesBook
	
	^ OrderedCollection new.! !

!classDefinition: 'Cashier class' category: 'TusLibros' stamp: 'CM 11/25/2020 19:10:42'!
Cashier class
	instanceVariableNames: 'salesBook'!

!classDefinition: 'Cashier class' category: 'TusLibros' stamp: 'CM 11/25/2020 19:10:43'!
Cashier class
	instanceVariableNames: 'salesBook merchantProcesor'!
!Cashier class methodsFor: 'class initialization' stamp: 'CM 11/25/2020 19:10:41'!
initializeBillingOn: aMerchantProcesor registeringSalesOn: aSalesBook
	
	salesBook := aSalesBook.
	merchantProcesor := aMerchantProcesor! !
!Cashier class methodsFor: 'class initialization' stamp: 'CM 11/25/2020 19:11:40'!
billingOn: aMerchantProcesor registeringSalesOn: aSalesBook
	
	^ self new initializeBillingOn: aMerchantProcesor registeringSalesOn: aSalesBook.! !

Cashier class
	instanceVariableNames: ''!

!classDefinition: 'Cashier class' category: 'TusLibros' stamp: 'CM 11/25/2020 19:11:46'!
Cashier class
	instanceVariableNames: ''!

!methodRemoval: Cashier class #initializeBillingOn:registeringSalesOn: stamp: 'CM 11/25/2020 19:11:57'!
initializeBillingOn: aMerchantProcesor registeringSalesOn: aSalesBook
	
	salesBook := aSalesBook.
	merchantProcesor := aMerchantProcesor!

!classDefinition: #Cashier category: 'TusLibros' stamp: 'CM 11/25/2020 19:12:06'!
Object subclass: #Cashier
	instanceVariableNames: 'salesBook'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classDefinition: #Cashier category: 'TusLibros' stamp: 'CM 11/25/2020 19:12:07'!
Object subclass: #Cashier
	instanceVariableNames: 'salesBook merchantProcesor'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!Cashier methodsFor: 'as yet unclassified' stamp: 'CM 11/25/2020 19:12:03'!
initializeBillingOn: aMerchantProcesor registeringSalesOn: aSalesBook
	
	salesBook := aSalesBook.
	merchantProcesor := aMerchantProcesor! !
!Cashier methodsFor: 'as yet unclassified' stamp: 'CM 11/25/2020 19:12:44' prior: 50868288!
checkout: aCart chargingOn: aTarjeta

	| totalToDebit |
	
	aCart isEmpty ifTrue: [ self error: self class cartCannotBeEmptyErrorDescription ].
	(aTarjeta isExpired) ifTrue: [ self error: self class cannotChargeOnAnExpiredCreditCardErrorDescription ].
	
	totalToDebit := aCart totalProductsPrice.
	
	salesBook add: totalToDebit .
	^ totalToDebit.
	
	
	! !

Object subclass: #TestDouble
	instanceVariableNames: 'allowedMessages'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classDefinition: #TestDouble category: 'TusLibros' stamp: 'CM 11/25/2020 19:13:05'!
Object subclass: #TestDouble
	instanceVariableNames: 'allowedMessages'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!TestDouble methodsFor: 'no messages' stamp: 'CM 11/25/2020 19:13:43'!
allowToReceive: aMessageSelector andRun: aBlock

	allowedMessages at: aMessageSelector put: aBlock.
	
	! !
!TestDouble methodsFor: 'initialization' stamp: 'CM 11/25/2020 19:14:09' overrides: 16896425!
initialize

	allowedMessages := Dictionary new.
	
	! !
!TestDouble methodsFor: 'initialization' stamp: 'CM 11/25/2020 19:15:01' overrides: 16881366!
doesNotUnderstand: aMessage 

	^ (allowedMessages at: aMessage selector 
					ifAbsent: [ super doesNotUnderstand: aMessage. ]
	).
	! !

TestCase subclass: #TestDoubleTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classDefinition: #TestDoubleTest category: 'TusLibros' stamp: 'CM 11/25/2020 19:15:20'!
TestCase subclass: #TestDoubleTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!TestDoubleTest methodsFor: 'no messages' stamp: 'CM 11/25/2020 19:16:19'!
test01

	| double executed |
	
	double := TestDouble new.
	
	executed := false.
	
	double allowToReceive: #myMethod andRun: [ executed := true ].
	
	self assert: executed.! !

!testRun: #TestDoubleTest #test01 stamp: 'CM 11/25/2020 19:16:22'!
FAILURE!

!testRun: #TestDoubleTest #test01 stamp: 'CM 11/25/2020 19:16:22'!
FAILURE!

!testRun: #TestDoubleTest #test01 stamp: 'CM 11/25/2020 19:16:29'!
FAILURE!

!testRun: #TestDoubleTest #test01 stamp: 'CM 11/25/2020 19:16:29'!
FAILURE!
!TestDoubleTest methodsFor: 'as yet unclassified' stamp: 'CM 11/25/2020 19:16:48' prior: 50868608!
test01

	| double executed |
	
	double := TestDouble new.
	
	executed := false.
	
	double allowToReceive: #myMethod andRun: [ executed := true ].
	
	double myMethod.
	self assert: executed.! !

!testRun: #TestDoubleTest #test01 stamp: 'CM 11/25/2020 19:16:52'!
FAILURE!

!testRun: #TestDoubleTest #test01 stamp: 'CM 11/25/2020 19:16:52'!
FAILURE!
!TestDouble methodsFor: 'as yet unclassified' stamp: 'CM 11/25/2020 19:18:01' prior: 50868590 overrides: 16881366!
doesNotUnderstand: aMessage 

	| blockToRun |

	blockToRun := (allowedMessages at: aMessage selector 
					ifAbsent: [ ^ super doesNotUnderstand: aMessage. ]
	).
	
	^ blockToRun value.
	! !

!testRun: #TestDoubleTest #test01 stamp: 'CM 11/25/2020 19:18:03'!
PASSED!

!testRun: #TestDoubleTest #test01 stamp: 'CM 11/25/2020 19:24:30'!
PASSED!
!TestDoubleTest methodsFor: 'as yet unclassified' stamp: 'CM 11/25/2020 19:27:24'!
test02

	| double |
	
	double := TestDouble new.
	
	self should: [ double myMethod ] raise: Error.
		! !

!testRun: #TestDoubleTest #test02 stamp: 'CM 11/25/2020 19:27:29'!
PASSED!
!TestDoubleTest methodsFor: 'as yet unclassified' stamp: 'CM 11/25/2020 19:28:03' prior: 50868656!
test02

	| double |
	
	double := TestDouble new.
	
	self should: [ double myMethod ] raise: MessageNotUnderstood.
		! !

!testRun: #TestDoubleTest #test02 stamp: 'CM 11/25/2020 19:28:06'!
PASSED!
!TestDoubleTest methodsFor: 'as yet unclassified' stamp: 'CM 11/25/2020 19:28:40'!
test01DoubleShouldExecuteBlockWhenAnAllowedMessageIsSent

	| double executed |
	
	double := TestDouble new.
	
	executed := false.
	
	double allowToReceive: #myMethod andRun: [ executed := true ].
	
	double myMethod.
	self assert: executed.! !

!methodRemoval: TestDoubleTest #test01DoubleShouldExecuteBlockWhenAnAllowedMessageIsSent stamp: 'CM 11/25/2020 19:28:51'!
test01DoubleShouldExecuteBlockWhenAnAllowedMessageIsSent

	| double executed |
	
	double := TestDouble new.
	
	executed := false.
	
	double allowToReceive: #myMethod andRun: [ executed := true ].
	
	double myMethod.
	self assert: executed.!
!TestDoubleTest methodsFor: 'as yet unclassified' stamp: 'CM 11/25/2020 19:29:08'!
test01DoubleShouldExecuteBlockWhenAnAllowedMessageIsSent

	| double executed |
	
	double := TestDouble new.
	
	executed := false.
	
	double allowToReceive: #myMethod andRun: [ executed := true ].
	
	double myMethod.
	self assert: executed.! !

!methodRemoval: TestDoubleTest #test01 stamp: 'CM 11/25/2020 19:29:08'!
test01

	| double executed |
	
	double := TestDouble new.
	
	executed := false.
	
	double allowToReceive: #myMethod andRun: [ executed := true ].
	
	double myMethod.
	self assert: executed.!
!TestDoubleTest methodsFor: 'as yet unclassified' stamp: 'CM 11/25/2020 19:29:51'!
test02DoubleShouldRaiseErrorWhenMessagereceivedHasNotBeenAllowed

	| double |
	
	double := TestDouble new.
	
	self should: [ double myMethod ] raise: MessageNotUnderstood.
		! !

!methodRemoval: TestDoubleTest #test02 stamp: 'CM 11/25/2020 19:29:51'!
test02

	| double |
	
	double := TestDouble new.
	
	self should: [ double myMethod ] raise: MessageNotUnderstood.
		!
!TestDoubleTest methodsFor: 'as yet unclassified' stamp: 'CM 11/25/2020 19:30:00'!
test02DoubleShouldRaiseErrorWhenMessageReceivedHasNotBeenAllowed

	| double |
	
	double := TestDouble new.
	
	self should: [ double myMethod ] raise: MessageNotUnderstood.
		! !

!methodRemoval: TestDoubleTest #test02DoubleShouldRaiseErrorWhenMessagereceivedHasNotBeenAllowed stamp: 'CM 11/25/2020 19:30:00'!
test02DoubleShouldRaiseErrorWhenMessagereceivedHasNotBeenAllowed

	| double |
	
	double := TestDouble new.
	
	self should: [ double myMethod ] raise: MessageNotUnderstood.
		!
!CashierTest methodsFor: 'support' stamp: 'CM 11/25/2020 19:31:21'!
createMerchantProcessorDouble

	| merchantProcesor |
	
	merchantProcesor := TestDouble new.
	merchantProcesor allowToReceive: #debit:from: andRun: [ :amount :creditCard | ].
	
	^ merchantProcesor.
! !
!Cashier methodsFor: 'as yet unclassified' stamp: 'CM 11/25/2020 19:31:55' prior: 50868553!
checkout: aCart chargingOn: aTarjeta

	| totalToDebit |
	
	aCart isEmpty ifTrue: [ self error: self class cartCannotBeEmptyErrorDescription ].
	(aTarjeta isExpired) ifTrue: [ self error: self class cannotChargeOnAnExpiredCreditCardErrorDescription ].
	
	totalToDebit := aCart totalProductsPrice.
	
	merchantProcesor debit: totalToDebit from: aTarjeta.
	
	salesBook add: totalToDebit .
	^ totalToDebit.
	
	
	! !

!testRun: #CashierTest #test01CanNotCheckoutAnEmptyCart stamp: 'CM 11/25/2020 19:31:57'!
PASSED!

!testRun: #CashierTest #test02AmountChargedCorrelatesToCartTotalPrice stamp: 'CM 11/25/2020 19:31:57'!
ERROR!

!testRun: #CashierTest #test03CanNotChargeOnAnExpiredCreditCard stamp: 'CM 11/25/2020 19:31:57'!
PASSED!

!testRun: #CashierTest #test04SuccessfulCheckoutRegistersSaleOnSalesBook stamp: 'CM 11/25/2020 19:31:57'!
ERROR!

!testRun: #CashierTest #test02AmountChargedCorrelatesToCartTotalPrice stamp: 'CM 11/25/2020 19:32:01'!
ERROR!
!CashierTest methodsFor: 'tests' stamp: 'CM 11/25/2020 19:32:25' prior: 50868266!
test03CanNotChargeOnAnExpiredCreditCard
	
	| cart cashier expiredCreditCard merchantProcessor salesBook |
	
	cart := self createCart.
	cart add: self itemSellByTheStore.
	expiredCreditCard := self createExpiredCreditCard.
	
	merchantProcessor := self createMerchantProcessorDouble.
	salesBook := self createSalesBook.

	cashier := Cashier billingOn: merchantProcessor 
				      registeringSalesOn: salesBook.

	self should: [
			cashier checkout: cart chargingOn: expiredCreditCard.
		] raise: Error withMessageText: Cashier cannotChargeOnAnExpiredCreditCardErrorDescription .
	! !
!CashierTest methodsFor: 'tests' stamp: 'CM 11/25/2020 19:32:33' prior: 50868033!
test02AmountChargedCorrelatesToCartTotalPrice
	
	| cart cashier receiptAmount creditCard merchantProcessor salesBook |
	
	cart := self createCart.
	cart add: 2 of: self itemSellByTheStore.
	creditCard := self createValidCreditCard.
	
	merchantProcessor := self createMerchantProcessorDouble.
	salesBook := self createSalesBook.

	cashier := Cashier billingOn: merchantProcessor 
				      registeringSalesOn: salesBook.

	
	receiptAmount := cashier checkout: cart chargingOn: creditCard.
	
	self assert: receiptAmount equals: self itemSellByTheStorePrice * 2.
	
	
		! !
!CashierTest methodsFor: 'tests' stamp: 'CM 11/25/2020 19:32:39' prior: 50867972!
test01CanNotCheckoutAnEmptyCart
	
	| cart creditCard cashier merchantProcessor salesBook |
	
	cart := self createCart.
	creditCard := self createValidCreditCard.

	merchantProcessor := self createMerchantProcessorDouble.
	salesBook := self createSalesBook.

	cashier := Cashier billingOn: merchantProcessor 
				      registeringSalesOn: salesBook.

	
	self should: [
			cashier checkout: cart chargingOn: creditCard
		]  raise: Error withMessageText: Cashier cartCannotBeEmptyErrorDescription.
	! !

!testRun: #CashierTest #test01CanNotCheckoutAnEmptyCart stamp: 'CM 11/25/2020 19:32:44'!
PASSED!

!testRun: #CashierTest #test02AmountChargedCorrelatesToCartTotalPrice stamp: 'CM 11/25/2020 19:32:44'!
ERROR!

!testRun: #CashierTest #test03CanNotChargeOnAnExpiredCreditCard stamp: 'CM 11/25/2020 19:32:44'!
PASSED!

!testRun: #CashierTest #test04SuccessfulCheckoutRegistersSaleOnSalesBook stamp: 'CM 11/25/2020 19:32:44'!
ERROR!

!testRun: #CashierTest #test02AmountChargedCorrelatesToCartTotalPrice stamp: 'CM 11/25/2020 19:32:46'!
ERROR!
!TestDoubleTest methodsFor: 'as yet unclassified' stamp: 'CM 11/25/2020 19:34:03'!
test03DoubleShouldExecuteBlockWithSameArgments

	| double executed |
	
	double := TestDouble new.
	
	executed := false.
	
	double allowToReceive: #myMethod andRun: [ :arg | executed := arg ].
	
	double myMethod: true.
	self assert: executed.! !

!testRun: #TestDoubleTest #test03DoubleShouldExecuteBlockWithSameArgments stamp: 'CM 11/25/2020 19:34:08'!
ERROR!

!testRun: #TestDoubleTest #test03DoubleShouldExecuteBlockWithSameArgments stamp: 'CM 11/25/2020 19:34:08'!
ERROR!
!TestDoubleTest methodsFor: 'as yet unclassified' stamp: 'CM 11/25/2020 19:34:15' prior: 50868869!
test03DoubleShouldExecuteBlockWithSameArgments

	| double executed |
	
	double := TestDouble new.
	
	executed := false.
	
	double allowToReceive: #myMethod: andRun: [ :arg | executed := arg ].
	
	double myMethod: true.
	self assert: executed.! !

!testRun: #TestDoubleTest #test03DoubleShouldExecuteBlockWithSameArgments stamp: 'CM 11/25/2020 19:34:17'!
ERROR!

!testRun: #TestDoubleTest #test03DoubleShouldExecuteBlockWithSameArgments stamp: 'CM 11/25/2020 19:34:17'!
ERROR!
!TestDouble methodsFor: 'as yet unclassified' stamp: 'CM 11/25/2020 19:34:42' prior: 50868642 overrides: 16881366!
doesNotUnderstand: aMessage 

	| blockToRun |

	blockToRun := (allowedMessages at: aMessage selector 
					ifAbsent: [ ^ super doesNotUnderstand: aMessage. ]
	).
	
	^ blockToRun valueWithArguments: aMessage arguments.
	! !

!testRun: #TestDoubleTest #test01DoubleShouldExecuteBlockWhenAnAllowedMessageIsSent stamp: 'CM 11/25/2020 19:34:44'!
PASSED!

!testRun: #TestDoubleTest #test02DoubleShouldRaiseErrorWhenMessageReceivedHasNotBeenAllowed stamp: 'CM 11/25/2020 19:34:44'!
PASSED!

!testRun: #TestDoubleTest #test03DoubleShouldExecuteBlockWithSameArgments stamp: 'CM 11/25/2020 19:34:44'!
PASSED!

!testRun: #CashierTest #test01CanNotCheckoutAnEmptyCart stamp: 'CM 11/25/2020 19:34:47'!
PASSED!

!testRun: #CashierTest #test02AmountChargedCorrelatesToCartTotalPrice stamp: 'CM 11/25/2020 19:34:47'!
PASSED!

!testRun: #CashierTest #test03CanNotChargeOnAnExpiredCreditCard stamp: 'CM 11/25/2020 19:34:47'!
PASSED!

!testRun: #CashierTest #test04SuccessfulCheckoutRegistersSaleOnSalesBook stamp: 'CM 11/25/2020 19:34:47'!
PASSED!
!CashierTest methodsFor: 'tests' stamp: 'CM 11/25/2020 19:35:38'!
test05CanNotProcessDebitWhenMerchantProcessorIsDown
	
	| cart cashier salesBook creditCard merchantProcessor |
	
	cart := self createCart.
	cart add: self itemSellByTheStore.
	creditCard := self createValidCreditCard.
	merchantProcessor := self createMerchantProcessorDoubleWithDebitBehaviour: [ :amount :card | self error: Cashier paymentCannotBeProcessedErrorDescription ].
	salesBook := self createSalesBook.
	
	cashier := Cashier billingOn: merchantProcessor registeringSalesOn: salesBook.
	
	self should: [
			cashier checkout: cart chargingOn: creditCard
		] raise: Error withExceptionDo: [ :error | 
			self assert: (salesBook isEmpty).
			self assert: error messageText equals: Cashier paymentCannotBeProcessedErrorDescription.
		]

	! !
!Cashier class methodsFor: 'error messages' stamp: 'CM 11/25/2020 19:36:08'!
paymentCannotBeProcessedErrorDescription

	^ 'Payment cannot be processed'.! !
!CashierTest methodsFor: 'support' stamp: 'CM 11/25/2020 19:36:54'!
createMerchantProcessorDoubleWithDebitBehaviour: aBlock

	| merchantProcesor |
	
	merchantProcesor := TestDouble new.
	merchantProcesor allowToReceive: #debit:from: andRun: aBlock.
	
	^ merchantProcesor.
! !
!CashierTest methodsFor: 'support' stamp: 'CM 11/25/2020 19:37:08' prior: 50868748!
createMerchantProcessorDouble

	^ self createMerchantProcessorDoubleWithDebitBehaviour: [ :amount :creditCard | ].
	! !

!testRun: #CashierTest #test01CanNotCheckoutAnEmptyCart stamp: 'CM 11/25/2020 19:37:10'!
PASSED!

!testRun: #CashierTest #test02AmountChargedCorrelatesToCartTotalPrice stamp: 'CM 11/25/2020 19:37:10'!
PASSED!

!testRun: #CashierTest #test03CanNotChargeOnAnExpiredCreditCard stamp: 'CM 11/25/2020 19:37:10'!
PASSED!

!testRun: #CashierTest #test04SuccessfulCheckoutRegistersSaleOnSalesBook stamp: 'CM 11/25/2020 19:37:10'!
PASSED!

!testRun: #CashierTest #test05CanNotProcessDebitWhenMerchantProcessorIsDown stamp: 'CM 11/25/2020 19:37:10'!
PASSED!
!CashierTest methodsFor: 'tests' stamp: 'CM 11/25/2020 19:40:04'!
test06CashierOnlyChargesOneTimeWithRightAmountAndCorrectCard
	
	| cart cashier salesBook creditCard merchantProcessor chargedAmount chargedCreditCard receiptAmount |
	
	cart := self createCart.
	cart add: self itemSellByTheStore.
	creditCard := self createValidCreditCard.
	
	merchantProcessor := self createMerchantProcessorDoubleWithDebitBehaviour: [ :amountToCharge :creditCardToCharge | 
		chargedAmount  := amountToCharge.
		chargedCreditCard  := creditCardToCharge.
	].
	salesBook := self createSalesBook.

	cashier := Cashier billingOn: merchantProcessor 
				      registeringSalesOn: salesBook.

	receiptAmount := cashier checkout: cart chargingOn: creditCard.
		
	self assert: (		merchantProcessor timesReceived: #debit:from: ) equals: 1.
	self assert: chargedAmount equals: receiptAmount.
	self assert: chargedCreditCard equals: creditCard.
	! !
!TestDoubleTest methodsFor: 'as yet unclassified' stamp: 'CM 11/25/2020 19:40:57'!
test04WhenAllowedMethodIsNotCalledTimesReceivedIsZero
	| double |
	
	double := TestDouble new.
	double allowToReceive: #myMethod andRun: [ ].
	
	self assert: 0 equals: (double timesReceived: #myMethod).! !
!TestDouble methodsFor: 'as yet unclassified' stamp: 'CM 11/25/2020 19:41:15'!
timesReceived: aMessageSelector

	^ 0.
	
	! !

!testRun: #TestDoubleTest #test01DoubleShouldExecuteBlockWhenAnAllowedMessageIsSent stamp: 'CM 11/25/2020 19:41:17'!
PASSED!

!testRun: #TestDoubleTest #test02DoubleShouldRaiseErrorWhenMessageReceivedHasNotBeenAllowed stamp: 'CM 11/25/2020 19:41:17'!
PASSED!

!testRun: #TestDoubleTest #test03DoubleShouldExecuteBlockWithSameArgments stamp: 'CM 11/25/2020 19:41:17'!
PASSED!

!testRun: #TestDoubleTest #test04WhenAllowedMethodIsNotCalledTimesReceivedIsZero stamp: 'CM 11/25/2020 19:41:17'!
PASSED!
!TestDoubleTest methodsFor: 'as yet unclassified' stamp: 'CM 11/25/2020 19:42:34'!
test05TimesReceivedIs1WhenMessageIsSentOnce
	| double |
	
	double := TestDouble new.
	double allowToReceive: #myMethod andRun: [ ].
	double myMethod.
	
	self assert: 1 equals: (double timesReceived: #myMethod).! !
!TestDoubleTest methodsFor: 'as yet unclassified' stamp: 'CM 11/25/2020 19:43:02'!
test04WhenAllowedMessageIsNotSentTimesReceivedIsZero
	| double |
	
	double := TestDouble new.
	double allowToReceive: #myMethod andRun: [ ].
	
	self assert: 0 equals: (double timesReceived: #myMethod).! !

!methodRemoval: TestDoubleTest #test04WhenAllowedMethodIsNotCalledTimesReceivedIsZero stamp: 'CM 11/25/2020 19:43:02'!
test04WhenAllowedMethodIsNotCalledTimesReceivedIsZero
	| double |
	
	double := TestDouble new.
	double allowToReceive: #myMethod andRun: [ ].
	
	self assert: 0 equals: (double timesReceived: #myMethod).!

!classDefinition: #TestDouble category: 'TusLibros' stamp: 'CM 11/25/2020 19:43:40'!
Object subclass: #TestDouble
	instanceVariableNames: 'allowedMessages receivedMessages'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!TestDouble methodsFor: 'initialization' stamp: 'CM 11/25/2020 19:43:39' prior: 50868585 overrides: 16896425!
initialize

	allowedMessages := Dictionary new.
	receivedMessages := Dictionary new.
	! !
!TestDouble methodsFor: 'as yet unclassified' stamp: 'CM 11/25/2020 19:43:56' prior: 50869044!
timesReceived: aMessageSelector

	^ receivedMessages at: aMessageSelector ifAbsent: [ 0 ].

	
	! !
!TestDouble methodsFor: 'as yet unclassified' stamp: 'CM 11/25/2020 19:44:18'!
incrementTimesReceived: aMessageSelector

	receivedMessages at: aMessageSelector put: 1.	! !
!TestDouble methodsFor: 'as yet unclassified' stamp: 'CM 11/25/2020 19:44:33' prior: 50868906 overrides: 16881366!
doesNotUnderstand: aMessage 

	| blockToRun |

	blockToRun := (allowedMessages at: aMessage selector 
					ifAbsent: [ ^ super doesNotUnderstand: aMessage. ]
	).
	
	self incrementTimesReceived: aMessage selector.
	^ blockToRun valueWithArguments: aMessage arguments.
	! !

!testRun: #TestDoubleTest #test01DoubleShouldExecuteBlockWhenAnAllowedMessageIsSent stamp: 'CM 11/25/2020 19:44:35'!
PASSED!

!testRun: #TestDoubleTest #test02DoubleShouldRaiseErrorWhenMessageReceivedHasNotBeenAllowed stamp: 'CM 11/25/2020 19:44:35'!
PASSED!

!testRun: #TestDoubleTest #test03DoubleShouldExecuteBlockWithSameArgments stamp: 'CM 11/25/2020 19:44:35'!
PASSED!

!testRun: #TestDoubleTest #test04WhenAllowedMessageIsNotSentTimesReceivedIsZero stamp: 'CM 11/25/2020 19:44:35'!
PASSED!

!testRun: #TestDoubleTest #test05TimesReceivedIs1WhenMessageIsSentOnce stamp: 'CM 11/25/2020 19:44:35'!
PASSED!
!TestDoubleTest methodsFor: 'as yet unclassified' stamp: 'CM 11/25/2020 19:45:03'!
test05TimesReceivedEqualsTheAmountOfTimesTheMessageWasSent
	| double |
	
	double := TestDouble new.
	double allowToReceive: #myMethod andRun: [ ].
	double myMethod.
	double myMethod.
	
	self assert: 2 equals: (double timesReceived: #myMethod).! !
!TestDoubleTest methodsFor: 'as yet unclassified' stamp: 'CM 11/25/2020 19:45:13'!
test06TimesReceivedEqualsTheAmountOfTimesTheMessageWasSent
	| double |
	
	double := TestDouble new.
	double allowToReceive: #myMethod andRun: [ ].
	double myMethod.
	double myMethod.
	
	self assert: 2 equals: (double timesReceived: #myMethod).! !

!methodRemoval: TestDoubleTest #test05TimesReceivedEqualsTheAmountOfTimesTheMessageWasSent stamp: 'CM 11/25/2020 19:45:13'!
test05TimesReceivedEqualsTheAmountOfTimesTheMessageWasSent
	| double |
	
	double := TestDouble new.
	double allowToReceive: #myMethod andRun: [ ].
	double myMethod.
	double myMethod.
	
	self assert: 2 equals: (double timesReceived: #myMethod).!
!TestDouble methodsFor: 'as yet unclassified' stamp: 'CM 11/25/2020 19:45:41' prior: 50869114!
incrementTimesReceived: aMessageSelector

	receivedMessages at: aMessageSelector put: (self timesReceived: aMessageSelector) + 1.	! !

!testRun: #TestDoubleTest #test01DoubleShouldExecuteBlockWhenAnAllowedMessageIsSent stamp: 'CM 11/25/2020 19:45:44'!
PASSED!

!testRun: #TestDoubleTest #test02DoubleShouldRaiseErrorWhenMessageReceivedHasNotBeenAllowed stamp: 'CM 11/25/2020 19:45:44'!
PASSED!

!testRun: #TestDoubleTest #test03DoubleShouldExecuteBlockWithSameArgments stamp: 'CM 11/25/2020 19:45:44'!
PASSED!

!testRun: #TestDoubleTest #test04WhenAllowedMessageIsNotSentTimesReceivedIsZero stamp: 'CM 11/25/2020 19:45:44'!
PASSED!

!testRun: #TestDoubleTest #test05TimesReceivedIs1WhenMessageIsSentOnce stamp: 'CM 11/25/2020 19:45:44'!
PASSED!

!testRun: #TestDoubleTest #test06TimesReceivedEqualsTheAmountOfTimesTheMessageWasSent stamp: 'CM 11/25/2020 19:45:44'!
PASSED!

!testRun: #CashierTest #test01CanNotCheckoutAnEmptyCart stamp: 'CM 11/25/2020 19:45:47'!
PASSED!

!testRun: #CashierTest #test02AmountChargedCorrelatesToCartTotalPrice stamp: 'CM 11/25/2020 19:45:47'!
PASSED!

!testRun: #CashierTest #test03CanNotChargeOnAnExpiredCreditCard stamp: 'CM 11/25/2020 19:45:47'!
PASSED!

!testRun: #CashierTest #test04SuccessfulCheckoutRegistersSaleOnSalesBook stamp: 'CM 11/25/2020 19:45:47'!
PASSED!

!testRun: #CashierTest #test05CanNotProcessDebitWhenMerchantProcessorIsDown stamp: 'CM 11/25/2020 19:45:47'!
PASSED!

!testRun: #CashierTest #test06CashierOnlyChargesOneTimeWithRightAmountAndCorrectCard stamp: 'CM 11/25/2020 19:45:47'!
PASSED!

TestCase subclass: #TusLibrosTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classDefinition: #TusLibrosTest category: 'TusLibros' stamp: 'CM 11/25/2020 19:46:14'!
TestCase subclass: #TusLibrosTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

TusLibrosTest subclass: #CreditCardTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classDefinition: #CreditCardTest category: 'TusLibros' stamp: 'CM 11/25/2020 19:46:26'!
TusLibrosTest subclass: #CreditCardTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

TusLibrosTest subclass: #CashierTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classDefinition: #CashierTest category: 'TusLibros' stamp: 'CM 11/25/2020 19:46:34'!
TusLibrosTest subclass: #CashierTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

TusLibrosTest subclass: #CartTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classDefinition: #CartTest category: 'TusLibros' stamp: 'CM 11/25/2020 19:46:44'!
TusLibrosTest subclass: #CartTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!TusLibrosTest methodsFor: 'support' stamp: 'CM 11/25/2020 19:47:11'!
createCart
	
	^Cart acceptingItemsOf: self defaultCatalog! !

!methodRemoval: CartTest #createCart stamp: 'CM 11/25/2020 19:47:11'!
createCart
	
	^Cart acceptingItemsOf: self defaultCatalog!
!TusLibrosTest methodsFor: 'support' stamp: 'CM 11/25/2020 19:47:48'!
defaultCatalog
		
	| catalog |
	
	catalog := Dictionary new.
	catalog add: self itemSellByTheStore -> self itemSellByTheStorePrice.
	
	^ catalog.
	! !

!methodRemoval: CartTest #defaultCatalog stamp: 'CM 11/25/2020 19:47:48'!
defaultCatalog
		
	| catalog |
	
	catalog := Dictionary new.
	catalog add: self itemSellByTheStore -> self itemSellByTheStorePrice.
	
	^ catalog.
	!
!TusLibrosTest methodsFor: 'support' stamp: 'CM 11/25/2020 19:57:06'!
itemSellByTheStore
	
	^ 'validBook'! !

!methodRemoval: CartTest #itemSellByTheStore stamp: 'CM 11/25/2020 19:57:06'!
itemSellByTheStore
	
	^ 'validBook'!
!TusLibrosTest methodsFor: 'support' stamp: 'CM 11/25/2020 19:57:13'!
itemSellByTheStorePrice
	
	^ 3.! !

!methodRemoval: CartTest #itemSellByTheStorePrice stamp: 'CM 11/25/2020 19:57:13'!
itemSellByTheStorePrice
	
	^ 3.!

!methodRemoval: CashierTest #createCart stamp: 'CM 11/25/2020 19:57:18'!
createCart
	
	^Cart acceptingItemsOf: self defaultCatalog!

!methodRemoval: CashierTest #defaultCatalog stamp: 'CM 11/25/2020 19:57:26'!
defaultCatalog
		
	| catalog |
	
	catalog := Dictionary new.
	catalog add: self itemSellByTheStore -> self itemSellByTheStorePrice.
	
	^ catalog.
	!

!methodRemoval: CashierTest #itemSellByTheStorePrice stamp: 'CM 11/25/2020 19:57:28'!
itemSellByTheStorePrice

	^ 3.!

!methodRemoval: CashierTest #itemSellByTheStore stamp: 'CM 11/25/2020 19:57:30'!
itemSellByTheStore
	
	^ 'validBook'!
!TusLibrosTest methodsFor: 'support' stamp: 'CM 11/25/2020 19:57:41'!
createValidCreditCard
	
	^ CreditCard expiringOn: Date today month.! !

!methodRemoval: CreditCardTest #createValidCreditCard stamp: 'CM 11/25/2020 19:57:41'!
createValidCreditCard
	
	^ CreditCard expiringOn: Date today month.!
!TusLibrosTest methodsFor: 'support' stamp: 'CM 11/25/2020 19:57:47'!
createExpiredCreditCard
	
	^ CreditCard expiringOn: Date today month previous.! !

!methodRemoval: CreditCardTest #createExpiredCreditCard stamp: 'CM 11/25/2020 19:57:47'!
createExpiredCreditCard
	
	^ CreditCard expiringOn: Date today month previous.!

!methodRemoval: CashierTest #createValidCreditCard stamp: 'CM 11/25/2020 19:57:57'!
createValidCreditCard
	
	^ CreditCard expiringOn: Date today month.!

!methodRemoval: CashierTest #createExpiredCreditCard stamp: 'CM 11/25/2020 19:57:59'!
createExpiredCreditCard
	
	^ CreditCard expiringOn: Date today month previous.!

!testRun: #CartTest #test01NewCartsAreCreatedEmpty stamp: 'CM 11/25/2020 19:58:08'!
PASSED!

!testRun: #CartTest #test02CanNotAddItemsThatDoNotBelongToStore stamp: 'CM 11/25/2020 19:58:08'!
PASSED!

!testRun: #CartTest #test03AfterAddingAnItemTheCartIsNotEmptyAnymore stamp: 'CM 11/25/2020 19:58:08'!
PASSED!

!testRun: #CartTest #test04CanNotAddNonPositiveNumberOfItems stamp: 'CM 11/25/2020 19:58:08'!
PASSED!

!testRun: #CartTest #test05CanNotAddMoreThanOneItemNotSellByTheStore stamp: 'CM 11/25/2020 19:58:08'!
PASSED!

!testRun: #CartTest #test06CartRemembersAddedItems stamp: 'CM 11/25/2020 19:58:08'!
PASSED!

!testRun: #CartTest #test07CartDoesNotHoldNotAddedItems stamp: 'CM 11/25/2020 19:58:08'!
PASSED!

!testRun: #CartTest #test08CartRemembersTheNumberOfAddedItems stamp: 'CM 11/25/2020 19:58:08'!
PASSED!

!testRun: #CartTest #test09EmptyCartIsFreeFromCharge stamp: 'CM 11/25/2020 19:58:08'!
PASSED!

!testRun: #CartTest #test10AfterAddingAnItemTheCartTotalPriceIsUpdatedByItsValue stamp: 'CM 11/25/2020 19:58:08'!
PASSED!

!testRun: #CashierTest #test01CanNotCheckoutAnEmptyCart stamp: 'CM 11/25/2020 19:58:08'!
PASSED!

!testRun: #CashierTest #test02AmountChargedCorrelatesToCartTotalPrice stamp: 'CM 11/25/2020 19:58:08'!
PASSED!

!testRun: #CashierTest #test03CanNotChargeOnAnExpiredCreditCard stamp: 'CM 11/25/2020 19:58:08'!
PASSED!

!testRun: #CashierTest #test04SuccessfulCheckoutRegistersSaleOnSalesBook stamp: 'CM 11/25/2020 19:58:08'!
PASSED!

!testRun: #CashierTest #test05CanNotProcessDebitWhenMerchantProcessorIsDown stamp: 'CM 11/25/2020 19:58:08'!
PASSED!

!testRun: #CashierTest #test06CashierOnlyChargesOneTimeWithRightAmountAndCorrectCard stamp: 'CM 11/25/2020 19:58:08'!
PASSED!

!testRun: #CreditCardTest #test01CreditCardIsExpiredWhenExpirationDateIsPassed stamp: 'CM 11/25/2020 19:58:08'!
PASSED!

!testRun: #CreditCardTest #test02CreditCardIsValidWhenExpirationDateHasNotYetArrived stamp: 'CM 11/25/2020 19:58:08'!
PASSED!

!testRun: #TestDoubleTest #test01DoubleShouldExecuteBlockWhenAnAllowedMessageIsSent stamp: 'CM 11/25/2020 19:58:08'!
PASSED!

!testRun: #TestDoubleTest #test02DoubleShouldRaiseErrorWhenMessageReceivedHasNotBeenAllowed stamp: 'CM 11/25/2020 19:58:08'!
PASSED!

!testRun: #TestDoubleTest #test03DoubleShouldExecuteBlockWithSameArgments stamp: 'CM 11/25/2020 19:58:08'!
PASSED!

!testRun: #TestDoubleTest #test04WhenAllowedMessageIsNotSentTimesReceivedIsZero stamp: 'CM 11/25/2020 19:58:08'!
PASSED!

!testRun: #TestDoubleTest #test05TimesReceivedIs1WhenMessageIsSentOnce stamp: 'CM 11/25/2020 19:58:08'!
PASSED!

!testRun: #TestDoubleTest #test06TimesReceivedEqualsTheAmountOfTimesTheMessageWasSent stamp: 'CM 11/25/2020 19:58:08'!
PASSED!
!Cashier methodsFor: 'chckout' stamp: 'CM 11/25/2020 20:20:26' prior: 50868758!
checkout: aCart chargingOn: aCreditCard

	| totalToDebit |
	
	aCart isEmpty ifTrue: [ self error: self class cartCannotBeEmptyErrorDescription ].
	(aCreditCard isExpired) ifTrue: [ self error: self class cannotChargeOnAnExpiredCreditCardErrorDescription ].
	
	totalToDebit := aCart totalProductsPrice.
	
	merchantProcesor debit: totalToDebit from: aCreditCard.
	
	salesBook add: totalToDebit .
	^ totalToDebit.
	
	
	! !
!Cashier methodsFor: 'chckout' stamp: 'CM 11/25/2020 20:20:50'!
assertIsNotEmpty: aCart

	^ aCart isEmpty ifTrue: [ self error: self class cartCannotBeEmptyErrorDescription ]! !
!Cashier methodsFor: 'chckout' stamp: 'CM 11/25/2020 20:20:50' prior: 50869453!
checkout: aCart chargingOn: aCreditCard

	| totalToDebit |
	
	self assertIsNotEmpty: aCart.
	(aCreditCard isExpired) ifTrue: [ self error: self class cannotChargeOnAnExpiredCreditCardErrorDescription ].
	
	totalToDebit := aCart totalProductsPrice.
	
	merchantProcesor debit: totalToDebit from: aCreditCard.
	
	salesBook add: totalToDebit .
	^ totalToDebit.
	
	
	! !
!Cashier methodsFor: 'chckout' stamp: 'CM 11/25/2020 20:21:08'!
assertIsNotExpired: aCreditCard

	^ (aCreditCard isExpired) ifTrue: [ self error: self class cannotChargeOnAnExpiredCreditCardErrorDescription ]! !
!Cashier methodsFor: 'chckout' stamp: 'CM 11/25/2020 20:21:08' prior: 50869476!
checkout: aCart chargingOn: aCreditCard

	| totalToDebit |
	
	self assertIsNotEmpty: aCart.
	self assertIsNotExpired: aCreditCard.
	
	totalToDebit := aCart totalProductsPrice.
	
	merchantProcesor debit: totalToDebit from: aCreditCard.
	
	salesBook add: totalToDebit .
	^ totalToDebit.
	
	
	! !
!Cashier methodsFor: 'chckout' stamp: 'CM 11/25/2020 20:23:59' prior: 50869498!
checkout: aCart chargingOn: aCreditCard

	| totalToDebit |
	
	self assertIsNotEmpty: aCart.
	self assertIsNotExpired: aCreditCard.
	
	totalToDebit := aCart totalProductsPrice.
	
	merchantProcesor debit: totalToDebit from: aCreditCard.
	
	salesBook add: totalToDebit .
	^ totalToDebit.! !
!Cashier methodsFor: 'chckout' stamp: 'CM 11/25/2020 20:24:08'!
registerSale: totalToDebit

	^ salesBook add: totalToDebit! !
!Cashier methodsFor: 'chckout' stamp: 'CM 11/25/2020 20:24:08' prior: 50869510!
checkout: aCart chargingOn: aCreditCard

	| totalToDebit |
	
	self assertIsNotEmpty: aCart.
	self assertIsNotExpired: aCreditCard.
	
	totalToDebit := aCart totalProductsPrice.
	
	merchantProcesor debit: totalToDebit from: aCreditCard.
	
	self registerSale: totalToDebit .
	^ totalToDebit.! !
!CashierTest methodsFor: 'tests' stamp: 'CM 11/25/2020 20:27:46' prior: 50868833!
test01CanNotCheckoutAnEmptyCart
	
	| cart creditCard cashier merchantProcessor salesBook |
	
	cart := self createCart.
	creditCard := self createValidCreditCard.

	merchantProcessor := self createMerchantProcessorDouble.
	salesBook := self createSalesBook.

	cashier := Cashier billingOn: merchantProcessor 
				      registeringSalesOn: salesBook.
	
	self should: [
			cashier checkout: cart chargingOn: creditCard
		]  raise: Error withMessageText: Cashier cartCannotBeEmptyErrorDescription.
	! !
!CashierTest methodsFor: 'tests' stamp: 'CM 11/25/2020 20:27:55' prior: 50868812!
test02AmountChargedCorrelatesToCartTotalPrice
	
	| cart cashier receiptAmount creditCard merchantProcessor salesBook |
	
	cart := self createCart.
	cart add: 2 of: self itemSellByTheStore.
	creditCard := self createValidCreditCard.
	
	merchantProcessor := self createMerchantProcessorDouble.
	salesBook := self createSalesBook.

	cashier := Cashier billingOn: merchantProcessor 
				      registeringSalesOn: salesBook.

	receiptAmount := cashier checkout: cart chargingOn: creditCard.
	
	self assert: receiptAmount equals: self itemSellByTheStorePrice * 2.
	
	
		! !

----SNAPSHOT----(25 November 2020 20:29:05) CuisUniversity-4384.image priorSource: 17155564!